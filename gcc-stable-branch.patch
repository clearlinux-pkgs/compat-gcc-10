Alex Coplan (9):
      aarch64: Fix SVE ACLE builtins with LTO [PR99216]
      arm: Fix PCS for SFmode -> SImode libcalls [PR99748]
      arm: Various MVE vec_duplicate fixes [PR99647]
      early-remat.c: Fix new/delete mismatch [PR100230]
      aarch64: Avoid duplicating bti j insns for jump tables [PR99988]
      arm: Fix ICEs with compare-and-swap and -march=armv8-m.base [PR99977]
      arm: Fix wrong code with MVE V2DImode loads and stores [PR99960]
      arm: Avoid emitting bogus CFA adjusts for CMSE nonsecure calls [PR99725]
      arm: Fix ICE with CMSE nonsecure calls on Armv8.1-M [PR100333]

Andre Vieira (1):
      arm: Fix testisms introduced with fix for pr target/95646

Andreas Larsson (1):
      sparc: Print out bit names for LEON and LEON3 with -mdebug

Andrew Pinski (1):
      [GCC 10 branch] tree-optimization: [PR102622]: wrong code due to signed one bit integer and "a?-1:0"

Antony Polukhin (1):
      libstdc++: Optimize std::seed_seq construction

Avi Kivity (1):
      libstdc++: add missing typename for dependent type in ranges::elements_view [PR100900]

Bill Schmidt (3):
      rs6000: Don't let swaps pass break multiply low-part (PR101129)
      rs6000: Add int128 target check to pr101129.c (PR101531)
      rs6000: Fix vec_cpsgn parameter order (PR101985)

Bin Cheng (1):
      tree-optimization/98736 - use programing order preserved RPO in ldist

Christophe Lyon (3):
      arm: Fix __arm_vctp16q return type in arm_mve.h
      arm: Fix typos for reorder assembler architecture directives [PR101723]
      arm: Fix pr69245.c testcase for reorder assembler architecture directives [PR101723]

Daniel Cederman (5):
      sparc: Treat more instructions as load or store in errata workarounds
      sparc: Skip all empty assembly statements
      sparc: Prevent atomic instructions in beginning of functions for UT700
      sparc: Add NOP in stack_protect_setsi if sparc_fix_b2bst enabled
      sparc: Add scheduling information for LEON5

David Edelsohn (1):
      aix: Alias -m64 to -maix64 and -m32 to -maix32.

Diane Meirowitz (1):
      doc: improve -fsanitize=undefined description

Eric Botcazou (24):
      Fix thinko in libcpp preparation patch for modules
      Further increase the limit on the size of accepted Ada files
      Fix another -freorder-blocks-and-partition glitch with Windows SEH
      Fix PR target/100402
      Fix gnat.dg spurious failures on PowerPC64 LE
      Fix incorrect SLOC on instruction
      Always translate Is_Pure flag into pure in C sense
      Fix internal error on locally derived bit-packed array type
      Change EH pointer encodings to PC relative on Windows
      Missing piece in earlier change
      [Ada] Fix bogus error for bit-packed array with volatile component
      Give more informative error message for by-reference types
      Remove superfluous call to UI_Is_In_Int_Range
      Fix internal error on pointer-to-pointer binding in LTO mode
      Fix inaccurate bounds in debug info for vector array types
      Do not issue size error for too large array type
      Fix PR rtl-optimization/102306
      Fix no_fsanitize_address effective target
      Fix PR c++/64697 at -O1 or above
      Fix ICE with stack checking emulation at -O2
      Fix PR target/102588
      Update documentation of %X spec
      Fix -freorder-blocks-and-partition glitch with Windows SEH (continued)
      Properly enable -freorder-blocks-and-partition on 64-bit Windows

Fran√ßois Dumont (3):
      libstdc++: Fix [multi]map/[multi]set move constructors noexcept qualification
      libstdc++: Fix unordered containers move constructors noexcept qualification
      libstdc++: [_GLIBCXX_DEBUG] Fix management of __dp_sign_max_size [PR 99402]

GCC Administrator (276):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Geng Qi (1):
      RISC-V: For '-march' and '-mabi' options, add 'Negative' property mentions itself.

H.J. Lu (1):
      x86: Document -fcf-protection requires i686 or newer

Hafiz Abid Qadeer (1):
      [OpenACC] Fix an ICE where a loop with GT condition is collapsed.

Harald Anlauf (44):
      PR fortran/63797 - Bogus ambiguous reference to 'sqrt'
      PR fortran/100154 - ICE in gfc_conv_procedure_call, at fortran/trans-expr.c:6131
      PR fortran/100274 - ICE in gfc_conv_procedure_call, at fortran/trans-expr.c:6131
      PR fortran/98411 - Pointless warning for static variables
      Fortran - ICE in inline_matmul_assign
      Fortran - ICE in gfc_check_do_variable, at fortran/parse.c:4446
      Fortran - ICE in gfc_conv_expr_present initializing non-dummy class variable
      Fortran: reject FORMAT tag of unknown type.
      Fortran: extend check for array arguments and reject CLASS array elements.
      Fortran: ICE, OOM while calculating sizes of derived type array components
      Fortran: fix pointless warning for static variables
      Fortran - out of bounds in array constructor with implied do loop
      Fortran - improve error recovery determining array element from constructor
      Fortran - (large) arrays in the main shall be static
      Fortran - fix handling of optional allocatable DT arguments with INTENT(OUT)
      Fortran - fix handling of substring start and end indices
      Fortran: fix error recovery for invalid constructor
      Fortran - ensure simplification of bounds of array-valued named constants
      Fortran - improve checking for intrinsics allowed in constant expressions
      Fortran: resolve expressions during SIZE simplification
      Fortran: fix order of checks for the SHAPE intrinsic
      Fortran: handle initialization of derived type parameter arrays from scalar
      Fortran: fix simplification of array-valued parameter expressions
      Fortran: error recovery on rank mismatch of array and its initializer
      Fortran: validate shape of arrays in constructors against declarations
      Fortran: error recovery on initializing invalid derived type array component
      Fortran: avoid NULL pointer dereferences
      Fortran: fix lookup for gfortran builtin math intrinsics used by DEC extensions
      Fortran: do not attempt simplification of [LU]BOUND for pointer/allocatable
      Fortran: perform array subscript checks only for valid INTEGER bounds
      Fortran: improve check of arguments to the RESHAPE intrinsic
      Fortran: generate error message for negative elements in SHAPE array
      Fortran: improve expansion of constant array expressions within constructors
      Fortran: prevent NULL pointer dereference in check of passed do-loop variable
      Fortran: fix checking of elemental functions of type CLASS
      Fortran: dimensions of an array have to be non-negative
      Fortran: reject BOZ type argument to SIZEOF().
      Fortran: improve checking of array specifications
      Fortran: catch failed simplification of bad stride expression
      Fortran: NULL() is not interoperable
      Fortran: BOZ literal constants are not interoperable
      Fortran: PACK intrinsic should not try to read from zero-sized array
      Fortran: fix check for pointer dummy arguments with INTENT(IN)
      Fortran: fix passing return value to class(*) dummy argument

Iain Buclaw (19):
      d: Fix ICE in when formating a string with '%' or '`' characters (PR98457)
      d: Fix ICE in gimplify_var_or_parm_decl, at gimplify.c:2755 (PR100882)
      d: Respect explicit align(N) type alignment (PR100935)
      d: TypeInfo error when using slice copy on Structs (PR100964)
      d: Fix ICE in TypeInfoDeclaration, at dmd/declaration.c (PR100967)
      d: foreach over a tuple doesn't work on 16-bit targets (PR100999)
      d: Change in DotTemplateExp type semantics leading to regression (PR101619)
      d: Compile-time reflection for supported built-ins (PR101127)
      d: __FUNCTION__ doesn't work in core.stdc.stdio functions without cast (PR101441)
      d: fix ICE at convert_expr(tree_node*, Type*, Type*) (PR101490)
      d: Wrong evaluation order of binary expressions (PR101640)
      d: Ensure casting from bool results in either 0 or 1 (PR96435)
      d: gdc driver ignores -static-libstdc++ when automatically linking libstdc++ library
      d: Use HOST_WIDE_INT for type size temporaries.
      libphobos: Don't call __gthread_key_delete in the emutls destroy function.
      libphobos: Increase size of defaultStackPages on OSX X86_64 targets.
      libphobos: Push all callee-save registers on the stack before GC scan
      d: Align methods to MINIMUM_METHOD_BOUNDARY.
      libphobos: Fix definition of stat_t for MIPS64 (PR103604)

Iain Sandoe (4):
      coroutines: Fix a typo in rewriting the function.
      coroutines: Factor code. Match original source location in helpers [NFC].
      coroutines: Adjust outlined function names [PR95520].
      Darwin, D: Fix bootstrap when target does not support -Bstatic/dynamic.

Ian Lance Taylor (1):
      compiler: correct condition for calling memclrHasPointers

Jakub Jelinek (19):
      rs6000: Fix up libgcc ABI when built with --with-long-double-format=ieee [PR97653]
      dse: Fix up hard reg conflict checking in replace_read [PR99863]
      c++: Don't cache constexpr functions which are passed pointers to heap or static vars being constructed [PR99859]
      rtlanal: Another fix for VOIDmode MEMs [PR98601]
      expand: Fix up LTO ICE with COMPOUND_LITERAL_EXPR [PR99849]
      c: Avoid clobbering TREE_TYPE (error_mark_node) [PR99990]
      combine: Don't fold away side-effects in simplify_and_const_int_1 [PR99830]
      combine: Fix up expand_compound_operation [PR99905]
      c++: Fix up handling of structured bindings in extract_locals_r [PR99833]
      vectorizer: Remove dead scalar .COND_* calls from vectorized loops [PR99767]
      c++: Fix empty base stores in cxx_eval_store_expression [PR100111]
      intl: Add --enable-host-shared support [PR100096]
      sanitizer: Fix asan against glibc 2.34 [PR100114]
      cprop: Fix -fcompare-debug bug in constprop_register [PR100148]
      vmsdbgout: Remove useless register keywords
      cfgcleanup: Fix -fcompare-debug issue in outgoing_edges_match [PR100254]
      aarch64: Fix ICE in aarch64_add_offset_1_temporaries [PR100302]
      nvptx: Fix up nvptx build against latest libstdc++ [PR100375]
      libcpp: Fix up pragma preprocessing [PR100450]

Jan Hubicka (1):
      Fix looping flag discovery in ipa-pure-const

Jason Merrill (20):
      c++: lambda pack init-capture within generic lambda
      c++: NRV in lambda in template [PR91217]
      c++: PMF template parm and noexcept [PR90664]
      c++: array new initialized from a call [PR99643]
      c++: constexpr if and nested generic lambda [PR99201]
      c++: lambda in DMI in class template [PR95870]
      c++: -Wunused, constant, and generic lambda [PR96311]
      c++: C++17 constexpr static data member linkage [PR99901]
      c++: access checking in aggregate initialization [PR96673]
      c++: using overloaded with local decl [PR92918]
      c++: base template friend [PR52625]
      c++: friend with redundant qualification [PR41723]
      c++: deduction guide using alias [PR99180]
      c++: constexpr, inheritance, and local class [PR91933]
      c++: alias template equivalence and cv-quals [PR100032]
      c++: generic lambda in template fn with DMI [PR100054]
      c++: constexpr and volatile member function [PR80456]
      c++: designated init with anonymous union [PR100489]
      c++: 'this' adjustment for devirtualized call
      c++: constexpr and array[0] [PR101029]

John David Anglin (5):
      Add support for 32-bit hppa targets in muldi3 expander
      Fix TARGET_SOFT_FLOAT patterns in pa.md
      Consistently use "rG" constraint for copy instruction in move patterns
      Don't use 'G' constraint in integer move patterns
      Fix warnings building linux-atomic.c and fptr.c on hppa64-linux

Jonathan Wakely (98):
      libstdc++: Fix Doxygen warning about ambiguous file name
      maintainer-scripts: Disable multilib when generating libstdc++ docs
      libstdc++: Fix doxygen markup for group close commands
      libstdc++: Fix Doxygen warnings
      libstdc++: Change URL for PSTL
      libstdc++: Fix filesystem::path construction from COW string [PR 99805]
      libstdc++: Fix tests using wrong allocator type
      libstdc++: Fix more doxygen markup for group close commands
      libstdc++: Remove spurious line break in doxygen comment
      libstdc++: Fix even more doxygen markup for group close commands
      libstdc++: Fix invalid constexpr function in C++11 mode [PR 99985]
      libstdc++: Fix bootstrap error due to inconsistent noexcept-specifier [PR 99983]
      libstdc++: Fix std::indirectly_readable ambiguity [LWG 3446]
      libstdc++: Implement LWG 3404 for C++20 subrange [PR 100044]
      libstdc++: Fix <bit> to work freestanding [PR 100060]
      libstdc++: Fix declarations of memalign etc. for freestanding [PR 97570]
      libstdc++: Disable test for non-gthreads targets [PR 100180]
      libstdc++: Define __cpp_lib_constexpr_string macro
      libstdc++: Add missing 'inline' specifiers to net::ip functions [PR 100259]
      libstdc++: Fix inconsistent feature test macro
      libstdc++: Fix find_type helper to work consistently
      libstdc++: Fix filesystem::path constraints for volatile [PR 100630]
      gcc-changelog: Remove use of non-strict mode
      doc: Update description of __GXX_EXPERIMENTAL_CXX0X__
      libstdc++: Fix installation of python hooks [PR 99453]
      libstdc++: Change [range.iter.op] functions to function objects [PR 100768]
      libstdc++: Fix return value of std::ranges::advance [PR 100833]
      libstdc++: Fix std::any constraints [PR101034]
      libstdc++: Fix constraint on std::optional assignment [PR 100982]
      libstdc++: Adjust expected errors in tests when compiled as C++20
      libstdc++: Simplify constexpr checks in std::char_traits [PR 91488]
      libstdc++: Implement proposed resolution to LWG 3548
      libstdc++: Fix missing members in std::allocator<void>
      libstdc++: Reject std::make_shared<T[]> [PR 99006]
      libstdc++: Do not use deduced return type for std::visit [PR 100384]
      libstdc++: Fix undefined behaviour in testsuite
      libstdc++: Fix null dereference in pb_ds containers
      libstdc++: Fix undefined behaviour in std::string
      libstdc++: Fix null dereferences in std::promise
      libstdc++: Remove unused helpers for std::variant
      libstdc++: Replace incorrect static assertion in std::reduce [PR95833]
      libstdc++: Constrain std::as_writable_bytes [PR101411]
      libstdc++: Simplify basic_string_view::ends_with [PR 101361]
      libstdc++: Constrain three-way comparison for std::optional [PR 98842]
      libstdc++: Move atomic functions to libsupc++ [PR 96657]
      libstdc++: Fix common_reference for non-reference results [PR100894]
      libstdc++: Change [cmp.alg] assertions to constraints
      libstdc++: Implement LWG 3465 for std::compare_partial_order_fallback [PR101056]
      libstdc++: Add more tests for filesystem::create_directory [PR101510]
      libstdc++: Fix create_directories to resolve symlinks [PR101510]
      libstdc++: Fix test that fails randomly [PR101866]
      libstdc++: Document P1739R4 status [PR100139]
      libstdc++: Add default template argument to basic_istream_view
      c++: Fix docs on assignment of virtual bases [PR60318]
      libstdc++: Fix std::match_results::end() for failed matches [PR102667]
      libstdc++: Add test for std::cmp_greater
      libstdc++: Add missing header to test
      libstdc++: Add missing constraint to std::span deduction guide [PR102280]
      libstdc++: Rename tests with incorrect extension
      libstdc++: Fix inefficiency in filesystem::absolute [PR99876]
      libstdc++: Remove non-deducible parameter for std::advance overload
      libstdc++: std::system_category should know meaning of zero [PR102425]
      libstdc++: Add pretty printer for std::error_code and std::error_condition
      libstdc++: Install GDB pretty printers for debug library
      libstdc++: Ensure std::span and std::string_view are trivially copyable (P2251R1)
      libstdc++: Move test that depends on wchar_t I/O to wchar_t sub-directory
      libstdc++: Fix test that fails for C++20
      libstdc++: Fix some problems in PSTL tests
      libstdc++: Implement LWG 3422 for std::seed_seq
      libstdc++: Clear up directories created by tests
      libstdc++: Skip filesystem tests that depend on permissions [PR90787]
      libstdc++: Ensure test is compiled as C++17
      libstdc++: Rename file with the wrong extension
      libstdc++: Fix range access for empty std::valarray [PR103022]
      libstdc++: Remove [[nodiscard]] from <valarray>
      libstdc++: Fix circular dependency for bitmap_allocator [PR103381]
      libstdc++: Do not use memset in constexpr calls to ranges::fill_n [PR101608]
      libstdc++: Add missing header to <bits/stl_iterator.h>
      libstdc++: Skip failing std::array test for debug mode
      libstdc++: Fix tests that fail in C++98 mode
      libstdc++: Fix test that fails for C++98 mode
      libstdc++: Add additional overload of std::lerp [PR101870]
      libstdc++: Improve std::forward static assert message
      libstdc++: Value-initialize objects held by EBO helpers [PR 100863]
      libstdc++: fix is_default_constructible for hash containers [PR 100863]
      libstdc++: Make allocator equality comparable in tests
      libstdc++: Add missing 'constexpr' to std::tuple [PR102270]
      libstdc++: Constrain std::make_any [PR102894]
      libstdc++: Don't check always-true condition [PR101965]
      libstdc++: Use std::addressof in ranges::uninitialized_xxx [PR101571]
      libstdc++: Fix pretty printing of std::unique_ptr [PR103086]
      libstdc++: Add another testcase for std::unique_ptr printer [PR103086]
      libstdc++: Fix std::allocator<void> for versioned namespace
      libstdc++: Fix std::error_code pretty printer for versioned namespace
      libstdc++: Make Asan detection work for Clang [PR103453]
      libstdc++: Initialize member in std::match_results [PR103549]
      libstdc++: Fix example preprocessor command in FAQ [PR103877]
      libstdc++: Fix std::char_traits<C>::move for constexpr

Jos√© Rui Faustino de Sousa (1):
      Fortran: Fix double function call with -fcheck=pointer [PR]

Kewen Lin (4):
      ipa-fnsummary: Remove inconsistent bp_pack_value
      vect: Don't update inits for simd_lane_access DRs [PR102789]
      rs6000/doc: Rename future cpu with power10
      rs6000: Remove builtin mask check from builtin_decl [PR102347]

Marek Polacek (13):
      c++: ICE when late parsing noexcept/NSDMI [PR98333]
      c++: ICE with delayed noexcept and attribute used [PR97966]
      c++: Fix bogus -Wvolatile warning in C++20 [PR98947]
      c++: Pointer-to-member fn conversion with noexcept [PR99374]
      c++: ICE with -Wshadow and enumerator in template [PR99120]
      c++: const_cast of null pointer in constant expr [PR99176]
      c++: -Wconversion vs value-dependent expressions [PR99331]
      c++: GC collects live data when synthesizing operator== [PR99831]
      c++: GC during late parsing collects live data [PR91416]
      c++: Fix two issues with auto function parameter [PR99806]
      c++: ICE with real-to-int conversion in template [PR97973]
      c++: Use FOR_EACH_VEC_ELT instead of range-based for loop.
      c++: Fix noexcept with unevaluated operand [PR101087]

Marius Hillenbrand (1):
      IBM Z: Fix vector intrinsics vec_double and vec_floate

Martin Jambor (3):
      ipa-sra: Fix thinko when overriding safe_to_import_accesses (PR 101066)
      sra: Fix corner case of total scalarization with virtual inheritance (PR 102505)
      ipa-sra: Check also ECF_LOOPING_CONST_OR_PURE when evaluating calls

Martin Liska (10):
      Sync gcc-changelog scripts.
      gcc-changelog: sync scripts.
      contrib: add git-commit-mklog wrapper
      Add mklog.py.
      sanitizer: cherry pick 414482751452e54710f16bae58458c66298aaf69
      coverage: handle function beginning
      coroutines: init struct members to NULL
      gcc-changelog: sync from master
      jit: Initialize function::m_blocks in ctor
      i386: Fix emissing of __builtin_cpu_supports.

Martin Sebor (2):
      PR middle-end/100571 - bogus -Wstringop-overflow with VLA of elements larger than byte
      Backport from GCC 11 [PR99295].

Martin Storsj√∂ (1):
      mh-mingw: Set __USE_MINGW_ACCESS in missed C++ flags variables

Michael Meissner (1):
      Backport fix for PR target/98952

Patrick Palka (32):
      c++: Fix deduction with reference NTTP [PR83476]
      c++: Fix tsubsting CLASS_PLACEHOLDER_TEMPLATE [PR95434]
      c++: ICE in dependent_type_p with constrained auto [PR97052]
      libstdc++: Don't initialize from *this inside some views [PR97600]
      libstdc++: Fix elements_view::operator* and operator[] [LWG 3502]
      libstdc++: Simplify copy-pasted algorithms in <ranges>
      libstdc++: Fix split_view::_OuterIter::operator++ [LWG 3505]
      c++: alias_ctad_tweaks and constrained dguide [PR95486]
      c++: std::is_constant_evaluated inside constraint [PR97051]
      libstdc++: Fix up lambda in join_view::_Iterator::operator++ [PR100290]
      libstdc++: Implement P2259R1 changes [PR95983]
      libstdc++: Implement proposed resolution for LWG 3532
      libstdc++: Implement LWG 3517/3520 for join_view/transform_view
      c++: tsubst_function_decl and excess arg levels [PR100102]
      libstdc++: Implement missing P0896R4 changes to reverse_iterator [PR100639]
      libstdc++: Fix miscellaneous issues with elements_view::_Sentinel [PR100631]
      libstdc++: Fix access issue in elements_view::_Sentinel [PR100631]
      libstdc++: Implement LWG 3391 changes to move/counted_iterator::base()
      libstdc++: Implement LWG 3533 changes to foo_view::iterator::base()
      libstdc++: Fix access issue in iota_view::_Sentinel [PR100690]
      libstdc++: Avoid hard error in ranges::unique_copy [PR100770]
      libstdc++: Implement LWG 3490 change to drop_while_view::begin()
      libstdc++: Implement LWG 3557 change to convertible_to
      libstdc++: Reduce ranges::minmax/minmax_element comparison complexity
      libstdc++: Implement LWG 3546 changes to common_iterator
      libstdc++: Implement LWG 3553 changes to split_view
      libstdc++: Implement LWG 3555 changes to transform/elements_view
      libstdc++: Define split_view::_InnerIter::base as per P2210
      libstdc++: Add missing std::move to join_view::iterator ctor [PR101483]
      libstdc++: Fix up implementation of LWG 3533 [PR101589]
      libstdc++: Add missing std::move to ranges::copy/move/reverse_copy [PR101599]
      libstdc++: Fix various bugs in ranges_algo.h [PR100187, ...]

Paul Thomas (11):
      Fortran: Fix for class defined operators [PR99125].
      Fortran: Allow pointer deferred length associate selectors. [PR93794]
      Fortran: Fix ICE due to elemental procedure pointers [PR93924/5].
      Fortran: Fix ICE on wrong code [PR99818].
      Fortran: Assumed and explicit size class arrays [PR46691/99819].
      Fortran: Fix host associated PDT entity initialization
      Fortran: Fix ICE due to elemental procedure pointers [PR98472].
      Fortran: Improve resolution of associate variables. [PR93701].
      Fortran: Fix some select rank issues [PR97694 and 97723].
      Fortran: Fix for class functions as associated target [PR98565].
      Fortran: Correct missing structure constructor comps. [PR97612].

Peter Bergner (7):
      rs6000: MMA test case ICEs using -O3 [PR99842]
      rs6000: Add new __builtin_vsx_build_pair and __builtin_mma_build_acc built-ins
      rs6000: MMA builtin usage ICEs when used in a #pragma omp parallel and using -fopenmp [PR100777]
      rs6000: Small GCC10 change required for the lxvp built-ins backport
      rs6000: Add MMA __builtin_vsx_lxvp and __builtin_vsx_stxvp built-ins
      rs6000: Harden mma_init_builtins
      rs6000: Fix ICE expanding lxvp and stxvp gimple built-ins [PR101849]

Philippe Blain (1):
      libstdc++: Install libstdc++*-gdb.py more robustly [PR 99453]

Piotr Kubaj (1):
      gcc/configure: Check for powerpc64le*-*-freebsd*

Richard Biener (34):
      Increment BASE-VER after release
      testsuite/100176 - fix struct-layout-1_generate.c compile
      middle-end/98726 - fix VECTOR_CST element access
      remove write-only array in rev_post_order_and_mark_dfs_back_seme
      Compute RPO with adjacent SCC members, expose toplevel SCC extents
      tree-optimization/99880 - avoid vectorizing irrelevant PHI backedge defs
      tree-optimization/99954 - fix loop distribution memcpy classification
      tree-optimization/100053 - fix predication in VN
      tree-optimization/96513 - rewrite hybrid SLP detection
      c++/98032 - add testcase
      tree-optimization/100278 - handle mismatched code in TBAA adjust of PRE
      tree-optimization/98786 - fix issue with phiopt and abnormals
      tree-optimization/100566 - fix another predication issue in VN
      Update mpfr version to 3.1.6
      rtl-optimization/80960 - avoid creating garbage RTL in DSE
      tree-optimization/100492 - avoid irreducible regions in loop distribution
      middle-end/100509 - avoid folding constant to aggregate type
      ipa/100513 - fix SSA_NAME_DEF_STMT corruption in IPA param manip
      ipa/100791 - copy fntype when processing __builtin_va_arg_pack
      tree-optimization/100934 - properly mark irreducible regions for DOM
      ipa/97565 - fix IPA PTA body availability check
      middle-end/101009 - fix distance vector recording
      tree-optimization/101105 - fix runtime alias test optimization
      tree-optimization/101173 - fix interchange dependence checking
      middle-end/101291 - set loop copy of versioned loop
      tree-optimization/101394 - fix PRE full redundancy wrt abnormals
      middle-end/101824 - properly handle volatiles in nested fn lowering
      tree-optimization/101868 - avoid PRE of trapping mems across calls
      tree-optimization/101925 - fix VN with reverse storage order
      tree-optimization/102046 - fix SLP build from scalars with patterns
      tree-optimization/100253 - fix bogus aligned vectorized loads/stores
      middle-end/100672 - fix bogus right shift folding
      ipa/102714 - IPA SRA eliding volatile
      tree-optimization/97953 - fix bougs range recorded by EVRP

Richard Earnshaw (12):
      arm: fix UB due to missing mode check [PR100311]
      arm: correctly handle inequality comparisons against max constants [PR100563]
      arm: Remove use of opts_set in arm_configure_build_target [PR100767]
      arm: ensure the arch_name is always set for the build target
      arm: Don't reconfigure globals in arm_configure_build_target
      arm: reorder assembler architecture directives [PR101723]
      arm: Fix general issues with patterns for VLLDM and VLSTM
      arm: testsuite: improve detection of CMSE hardware.
      arm: Add command-line option for enabling CVE-2021-35465 mitigation [PR102035]
      arm: add erratum mitigation to __gnu_cmse_nonsecure_call [PR102035]
      arm: fix vlldm erratum for Armv8.1-m [PR102035]
      arm: Add tests for VLLDM mitigation [PR102035]

Richard Sandiford (11):
      data-ref: Tighten index-based alias checks [PR99726]
      gimple-fold: Recompute ADDR_EXPR flags after folding a TMR [PR98268]
      aarch64: Tweak post-RA handling of CONST_INT moves [PR98136]
      Handle CONST_POLY_INTs in CONST_VECTORs [PR97141, PR98726]
      aarch64: Handle more SVE vector constants [PR99246]
      aarch64: Fix target alignment for SVE [PR98119]
      Check for matching CONST_VECTOR encodings [PR99929]
      lra: Avoid cycling on certain subreg reloads [PR96796]
      aarch64: Fix address mode for vec_concat pattern [PR100305]
      aarch64: Add -mtune=neoverse-512tvb
      libgcc: Add missing runtime exception notices

Roman Zhuykov (1):
      modulo-sched: skip loops with strange register defs [PR100225]

Segher Boessenkool (4):
      rs6000: Fix cpu selection w/ isel (PR100108)
      combine: Don't create REG_UNUSED notes if the reg already died (PR99927)
      rs6000: Don't use r12 for CR save on ELFv2 (PR102107)
      rs6000: Fix ELFv2 r12 use in epilogue

Srinath Parvathaneni (5):
      arm: Do not clobber callee saved registers with CMSE.
      arm: Remove duplicate definitions from arm_mve.h (pr100419).
      arm: Fix the mve multilib for the broken cmse support (pr99939).
      arm: Fix polymorphic variants failing with undefined reference to `__ARM_undef` error.
      arm: Fix multilib mapping for CDE extensions [PR100856].

Stefan Schulze Frielinghaus (2):
      PR rtl-optimization/100263: Ensure register can change mode
      IBM Z: Fix load-and-test peephole2 condition

Tamar Christina (2):
      SVE: Fix wrong sve predicate split (PR100048)
      libsanitizer: Remove cyclades from libsanitizer

Thomas Koenig (1):
      Do not replace variable op variable in I/O implied DO loop replacement.

Thomas Schwinge (5):
      Add 'libgomp.oacc-c-c++-common/static-variable-1.c' [PR84991, PR84992, PR90779]
      Restore 'gcc.dg/pr78213.c' testing
      libstdc++: Avoid illegal argument to verbose in dg-test callback, continued
      Fix up 'gcc.dg/pr78213.c' for '--enable-checking=release' etc.
      Fix 'OMP_CLAUSE_TILE' operands handling in 'gcc/tree.c:walk_tree_1'

Tobias Burnus (3):
      Fortran: Fix fndecl with -fcoarray=lib [PR99817]
      OpenACC: Fix integer-type issue with collapse/tile [PR97880]
      Fortran/OpenMP: Fix var-list expr parsing with array/dt

Uros Bizjak (5):
      i386: Fix atomic FP peepholes [PR100182]
      i386: Change abs<MMXMODEI:mode>2 to an expander.
      i386: Prevent unwanted combine from LZCNT to BSR [PR101175]
      i386: Remove atomic_storedi_fpu and atomic_loaddi_fpu peepholes [PR100182]
      i386: Fix ICE in ix86_print_opreand_address [PR 102761]

Vladimir N. Makarov (4):
      [PR97969] LRA: Transform pattern `plus (plus (hard reg, const),	pseudo)` after elimination
      [PR98722] LRA: Check that target has no 3-op add insn to transform 2 plus expression.
      [PR98777] LRA: Use preliminary created pseudo for in LRA elimination subpass
      [PR102842] Consider all outputs in generation of matching reloads

Xi Ruoyao (1):
      mips: Fix up mips_atomic_assign_expand_fenv [PR94780]

Xionghu Luo (1):
      rs6000: Expand fmod and remainder when built with fast-math [PR97142]

YiFei Zhu (2):
      bpf: align function entry point to 64 bits
      bpf: allow BSS symbols to be global symbols

konglin1 (2):
      i386: Fix _mm512_fpclass_ps_mask in O0 [PR 101471]
      i386: Fix wrong optimization for consecutive masked scatters [PR 101472]

diff --git a/config/ChangeLog b/config/ChangeLog
index 4eccf8839f1..39ae1c5c28c 100644
--- a/config/ChangeLog
+++ b/config/ChangeLog
@@ -1,3 +1,11 @@
+2021-12-16  Martin Storsj√∂  <martin@martin.st>
+
+	Backported from master:
+	2021-04-13  Martin Storsj√∂  <martin@martin.st>
+
+	* mh-mingw: Set __USE_MINGW_ACCESS in missed C++ flags
+	variables
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/config/mh-mingw b/config/mh-mingw
index a795096f038..e91367a7112 100644
--- a/config/mh-mingw
+++ b/config/mh-mingw
@@ -1,7 +1,9 @@
 # Add -D__USE_MINGW_ACCESS to enable the built compiler to work on Windows
 # Vista (see PR33281 for details).
 BOOT_CFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
+BOOT_CXXFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
 CFLAGS += -D__USE_MINGW_ACCESS
+CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE1_CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE2_CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE3_CXXFLAGS += -D__USE_MINGW_ACCESS
diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index cfcc8b12b53..da635e2e5fb 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,56 @@
+2021-11-08  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_check_commit.py: Sync from master.
+	* gcc-changelog/git_commit.py: Likewise.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_update_version.py: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* mklog.py: New file.
+	* test_mklog.py: New file.
+
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* git-commit-mklog.py: New file.
+
+2021-05-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	* gcc-changelog/git_email.py: Remove use of non-strict mode.
+
+2021-05-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-17  Richard Biener  <rguenther@suse.de>
+
+	* download_prerequisites: Update mpfr version to 3.1.6.
+	* prerequisites.md5: Update.
+	* prerequisites.sha512: Likewise.
+
+2021-05-14  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_check_commit.py: Sync from master.
+	* gcc-changelog/git_commit.py: Likewise.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_repository.py: Likewise.
+	* gcc-changelog/git_update_version.py: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
+2021-04-14  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: Sync with master.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_update_version.py: Likewise.
+	* gcc-changelog/setup.cfg: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/contrib/download_prerequisites b/contrib/download_prerequisites
index aa0356e6266..39291470918 100755
--- a/contrib/download_prerequisites
+++ b/contrib/download_prerequisites
@@ -28,7 +28,7 @@ version='(unversioned)'
 # `contrib/prerequisites.md5` with the new checksums.
 
 gmp='gmp-6.1.0.tar.bz2'
-mpfr='mpfr-3.1.4.tar.bz2'
+mpfr='mpfr-3.1.6.tar.bz2'
 mpc='mpc-1.0.3.tar.gz'
 isl='isl-0.18.tar.bz2'
 
diff --git a/contrib/gcc-changelog/git_check_commit.py b/contrib/gcc-changelog/git_check_commit.py
index 935425ef813..d6aff3cef91 100755
--- a/contrib/gcc-changelog/git_check_commit.py
+++ b/contrib/gcc-changelog/git_check_commit.py
@@ -23,19 +23,18 @@ from git_repository import parse_git_revisions
 parser = argparse.ArgumentParser(description='Check git ChangeLog format '
                                  'of a commit')
 parser.add_argument('revisions', default='HEAD', nargs='?',
-                    help='Git revisions (e.g. hash~5..hash or just hash)')
+                    help='Git revisions (e.g. hash~5..hash or just hash) - '
+                    'if not specified: HEAD')
 parser.add_argument('-g', '--git-path', default='.',
                     help='Path to git repository')
 parser.add_argument('-p', '--print-changelog', action='store_true',
                     help='Print final changelog entires')
-parser.add_argument('-n', '--non-strict-mode', action='store_true',
-                    help='Use non-strict mode (allow changes in ChangeLog and '
-                    'other automatically updated files).')
+parser.add_argument('-v', '--verbose', action='store_true',
+                    help='Print verbose information')
 args = parser.parse_args()
 
 retval = 0
-for git_commit in parse_git_revisions(args.git_path, args.revisions,
-                                      not args.non_strict_mode):
+for git_commit in parse_git_revisions(args.git_path, args.revisions):
     res = 'OK' if git_commit.success else 'FAILED'
     print('Checking %s: %s' % (git_commit.original_info.hexsha, res))
     if git_commit.success:
@@ -44,6 +43,8 @@ for git_commit in parse_git_revisions(args.git_path, args.revisions,
     else:
         for error in git_commit.errors:
             print('ERR: %s' % error)
+            if args.verbose and error.details:
+                print(error.details)
         retval = 1
 
 exit(retval)
diff --git a/contrib/gcc-changelog/git_commit.py b/contrib/gcc-changelog/git_commit.py
index ee1973371be..27a1d59b211 100755
--- a/contrib/gcc-changelog/git_commit.py
+++ b/contrib/gcc-changelog/git_commit.py
@@ -19,8 +19,9 @@
 import difflib
 import os
 import re
+import sys
 
-changelog_locations = {
+default_changelog_locations = {
     'c++tools',
     'config',
     'contrib',
@@ -133,6 +134,7 @@ ignored_prefixes = {
     'gcc/go/gofrontend/',
     'gcc/testsuite/gdc.test/',
     'gcc/testsuite/go.test/test/',
+    'libffi/',
     'libgo/',
     'libphobos/libdruntime/',
     'libphobos/src/',
@@ -155,7 +157,9 @@ author_line_regex = \
         re.compile(r'^(?P<datetime>\d{4}-\d{2}-\d{2})\ {2}(?P<name>.*  <.*>)')
 additional_author_regex = re.compile(r'^\t(?P<spaces>\ *)?(?P<name>.*  <.*>)')
 changelog_regex = re.compile(r'^(?:[fF]or +)?([a-z0-9+-/]*)ChangeLog:?')
-pr_regex = re.compile(r'\tPR (?P<component>[a-z+-]+\/)?([0-9]+)$')
+subject_pr_regex = re.compile(r'(^|\W)PR\s+(?P<component>[a-zA-Z+-]+)/(?P<pr>\d{4,7})')
+subject_pr2_regex = re.compile(r'[(\[]PR\s*(?P<pr>\d{4,7})[)\]]')
+pr_regex = re.compile(r'\tPR (?P<component>[a-z+-]+\/)?(?P<pr>[0-9]+)$')
 dr_regex = re.compile(r'\tDR ([0-9]+)$')
 star_prefix_regex = re.compile(r'\t\*(?P<spaces>\ *)(?P<content>.*)')
 end_of_location_regex = re.compile(r'[\[<(:]')
@@ -193,14 +197,15 @@ def decode_path(path):
 
 
 class Error:
-    def __init__(self, message, line=None):
+    def __init__(self, message, line=None, details=None):
         self.message = message
         self.line = line
+        self.details = details
 
     def __repr__(self):
         s = self.message
         if self.line:
-            s += ':"%s"' % self.line
+            s += ': "%s"' % self.line
         return s
 
 
@@ -214,6 +219,7 @@ class ChangeLogEntry:
         self.lines = []
         self.files = []
         self.file_patterns = []
+        self.parentheses_stack = []
 
     def parse_file_names(self):
         # Whether the content currently processed is between a star prefix the
@@ -223,8 +229,14 @@ class ChangeLogEntry:
         for line in self.lines:
             # If this line matches the star prefix, start the location
             # processing on the information that follows the star.
+            # Note that we need to skip macro names that can be in form of:
+            #
+            # * config/i386/i386.md (*fix_trunc<mode>_i387_1,
+            # *add<mode>3_ne, *add<mode>3_eq_0, *add<mode>3_ne_0,
+            # *fist<mode>2_<rounding>_1, *<code><mode>3_1):
+            #
             m = star_prefix_regex.match(line)
-            if m:
+            if m and len(m.group('spaces')) == 1:
                 in_location = True
                 line = m.group('content')
 
@@ -280,7 +292,7 @@ class GitInfo:
 
 
 class GitCommit:
-    def __init__(self, info, strict=True, commit_to_info_hook=None):
+    def __init__(self, info, commit_to_info_hook=None, ref_name=None):
         self.original_info = info
         self.info = info
         self.message = None
@@ -290,14 +302,19 @@ class GitCommit:
         self.top_level_authors = []
         self.co_authors = []
         self.top_level_prs = []
+        self.subject_prs = set()
         self.cherry_pick_commit = None
         self.revert_commit = None
         self.commit_to_info_hook = commit_to_info_hook
+        self.init_changelog_locations(ref_name)
 
         # Skip Update copyright years commits
         if self.info.lines and self.info.lines[0] == 'Update copyright years.':
             return
 
+        if self.info.lines and len(self.info.lines) > 1 and self.info.lines[1]:
+            self.errors.append(Error('Expected empty second line in commit message', info.lines[0]))
+
         # Identify first if the commit is a Revert commit
         for line in self.info.lines:
             m = revert_regex.match(line)
@@ -307,18 +324,36 @@ class GitCommit:
         if self.revert_commit:
             self.info = self.commit_to_info_hook(self.revert_commit)
 
+        # The following happens for get_email.py:
+        if not self.info:
+            return
+
+        self.check_commit_email()
+
+        # Extract PR numbers form the subject line
+        # Match either [PRnnnn] / (PRnnnn) or PR component/nnnn
+        if self.info.lines and not self.revert_commit:
+            self.subject_prs = {m.group('pr') for m in subject_pr2_regex.finditer(info.lines[0])}
+            for m in subject_pr_regex.finditer(info.lines[0]):
+                if not m.group('component') in bug_components:
+                    self.errors.append(Error('invalid PR component in subject', info.lines[0]))
+                self.subject_prs.add(m.group('pr'))
+
+        # Allow complete deletion of ChangeLog files in a commit
         project_files = [f for f in self.info.modified_files
-                         if self.is_changelog_filename(f[0])
+                         if (self.is_changelog_filename(f[0], allow_suffix=True) and f[1] != 'D')
                          or f[0] in misc_files]
         ignored_files = [f for f in self.info.modified_files
                          if self.in_ignored_location(f[0])]
         if len(project_files) == len(self.info.modified_files):
             # All modified files are only MISC files
             return
-        elif project_files and strict:
-            self.errors.append(Error('ChangeLog, DATESTAMP, BASE-VER and '
-                                     'DEV-PHASE updates should be done '
-                                     'separately from normal commits'))
+        elif project_files:
+            err = 'ChangeLog, DATESTAMP, BASE-VER and DEV-PHASE updates ' \
+                  'should be done separately from normal commits\n' \
+                  '(note: ChangeLog entries will be automatically ' \
+                  'added by a cron job)'
+            self.errors.append(Error(err))
             return
 
         all_are_ignored = (len(project_files) + len(ignored_files)
@@ -328,11 +363,15 @@ class GitCommit:
             self.parse_changelog()
             self.parse_file_names()
             self.check_for_empty_description()
+            self.check_for_broken_parentheses()
             self.deduce_changelog_locations()
             self.check_file_patterns()
             if not self.errors:
                 self.check_mentioned_files()
                 self.check_for_correct_changelog()
+        if self.subject_prs:
+            self.errors.append(Error('PR %s in subject but not in changelog' %
+                                     ', '.join(self.subject_prs), self.info.lines[0]))
 
     @property
     def success(self):
@@ -343,18 +382,23 @@ class GitCommit:
         return [x[0] for x in self.info.modified_files if x[1] == 'A']
 
     @classmethod
-    def is_changelog_filename(cls, path):
-        return path.endswith('/ChangeLog') or path == 'ChangeLog'
-
-    @classmethod
-    def find_changelog_location(cls, name):
+    def is_changelog_filename(cls, path, allow_suffix=False):
+        basename = os.path.basename(path)
+        if basename == 'ChangeLog':
+            return True
+        elif allow_suffix and basename.startswith('ChangeLog'):
+            return True
+        else:
+            return False
+
+    def find_changelog_location(self, name):
         if name.startswith('\t'):
             name = name[1:]
         if name.endswith(':'):
             name = name[:-1]
         if name.endswith('/'):
             name = name[:-1]
-        return name if name in changelog_locations else None
+        return name if name in self.changelog_locations else None
 
     @classmethod
     def format_git_author(cls, author):
@@ -374,6 +418,17 @@ class GitCommit:
                 modified_files.append((parts[2], 'A'))
         return modified_files
 
+    def init_changelog_locations(self, ref_name):
+        self.changelog_locations = list(default_changelog_locations)
+        if ref_name:
+            version = sys.maxsize
+            if 'releases/gcc-' in ref_name:
+                version = int(ref_name.split('-')[-1])
+            if version >= 12:
+                # HSA and BRIG were removed in GCC 12
+                self.changelog_locations.remove('gcc/brig')
+                self.changelog_locations.remove('libhsail-rt')
+
     def parse_lines(self, all_are_ignored):
         body = self.info.lines
 
@@ -382,7 +437,8 @@ class GitCommit:
                 continue
             if (changelog_regex.match(b) or self.find_changelog_location(b)
                     or star_prefix_regex.match(b) or pr_regex.match(b)
-                    or dr_regex.match(b) or author_line_regex.match(b)):
+                    or dr_regex.match(b) or author_line_regex.match(b)
+                    or b.lower().startswith(CO_AUTHORED_BY_PREFIX)):
                 self.changes = body[i:]
                 return
         if not all_are_ignored:
@@ -400,8 +456,10 @@ class GitCommit:
             if line != line.rstrip():
                 self.errors.append(Error('trailing whitespace', line))
             if len(line.replace('\t', ' ' * TAB_WIDTH)) > LINE_LIMIT:
-                self.errors.append(Error('line exceeds %d character limit'
-                                         % LINE_LIMIT, line))
+                # support long filenames
+                if not line.startswith('\t* ') or not line.endswith(':') or ' ' in line[3:-1]:
+                    self.errors.append(Error('line exceeds %d character limit'
+                                             % LINE_LIMIT, line))
             m = changelog_regex.match(line)
             if m:
                 last_entry = ChangeLogEntry(m.group(1).rstrip('/'),
@@ -428,7 +486,9 @@ class GitCommit:
                     else:
                         author_tuple = (m.group('name'), None)
                 elif pr_regex.match(line):
-                    component = pr_regex.match(line).group('component')
+                    m = pr_regex.match(line)
+                    component = m.group('component')
+                    pr = m.group('pr')
                     if not component:
                         self.errors.append(Error('missing PR component', line))
                         continue
@@ -437,6 +497,8 @@ class GitCommit:
                         continue
                     else:
                         pr_line = line.lstrip()
+                    if pr in self.subject_prs:
+                        self.subject_prs.remove(pr)
                 elif dr_regex.match(line):
                     pr_line = line.lstrip()
 
@@ -490,7 +552,8 @@ class GitCommit:
                 else:
                     m = star_prefix_regex.match(line)
                     if m:
-                        if len(m.group('spaces')) != 1:
+                        if (len(m.group('spaces')) != 1 and
+                                not last_entry.parentheses_stack):
                             msg = 'one space should follow asterisk'
                             self.errors.append(Error(msg, line))
                         else:
@@ -502,6 +565,7 @@ class GitCommit:
                                         msg = f'empty group "{needle}" found'
                                         self.errors.append(Error(msg, line))
                             last_entry.lines.append(line)
+                            self.process_parentheses(last_entry, line)
                     else:
                         if last_entry.is_empty:
                             msg = 'first line should start with a tab, ' \
@@ -509,6 +573,18 @@ class GitCommit:
                             self.errors.append(Error(msg, line))
                         else:
                             last_entry.lines.append(line)
+                            self.process_parentheses(last_entry, line)
+
+    def process_parentheses(self, last_entry, line):
+        for c in line:
+            if c == '(':
+                last_entry.parentheses_stack.append(line)
+            elif c == ')':
+                if not last_entry.parentheses_stack:
+                    msg = 'bad wrapping of parenthesis'
+                    self.errors.append(Error(msg, line))
+                else:
+                    del last_entry.parentheses_stack[-1]
 
     def parse_file_names(self):
         for entry in self.changelog_entries:
@@ -532,6 +608,12 @@ class GitCommit:
                     msg = 'missing description of a change'
                     self.errors.append(Error(msg, line))
 
+    def check_for_broken_parentheses(self):
+        for entry in self.changelog_entries:
+            if entry.parentheses_stack:
+                msg = 'bad parentheses wrapping'
+                self.errors.append(Error(msg, entry.parentheses_stack[-1]))
+
     def get_file_changelog_location(self, changelog_file):
         for file in self.info.modified_files:
             if file[0] == changelog_file:
@@ -549,7 +631,7 @@ class GitCommit:
                 for file in entry.files:
                     location = self.get_file_changelog_location(file)
                     if (location == ''
-                       or (location and location in changelog_locations)):
+                       or (location and location in self.changelog_locations)):
                         if changelog and changelog != location:
                             msg = 'could not deduce ChangeLog file, ' \
                                   'not unique location'
@@ -569,11 +651,10 @@ class GitCommit:
                 return True
         return False
 
-    @classmethod
-    def get_changelog_by_path(cls, path):
+    def get_changelog_by_path(self, path):
         components = path.split('/')
         while components:
-            if '/'.join(components) in changelog_locations:
+            if '/'.join(components) in self.changelog_locations:
                 break
             components = components[:-1]
         return '/'.join(components)
@@ -592,7 +673,12 @@ class GitCommit:
             assert not entry.folder.endswith('/')
             for file in entry.files:
                 if not self.is_changelog_filename(file):
-                    mentioned_files.add(os.path.join(entry.folder, file))
+                    item = os.path.join(entry.folder, file)
+                    if item in mentioned_files:
+                        msg = 'same file specified multiple times'
+                        self.errors.append(Error(msg, file))
+                    else:
+                        mentioned_files.add(item)
             for pattern in entry.file_patterns:
                 mentioned_patterns.append(os.path.join(entry.folder, pattern))
 
@@ -602,9 +688,11 @@ class GitCommit:
         for file in sorted(mentioned_files - changed_files):
             msg = 'unchanged file mentioned in a ChangeLog'
             candidates = difflib.get_close_matches(file, changed_files, 1)
+            details = None
             if candidates:
                 msg += f' (did you mean "{candidates[0]}"?)'
-            self.errors.append(Error(msg, file))
+                details = '\n'.join(difflib.Differ().compare([file], [candidates[0]])).rstrip()
+            self.errors.append(Error(msg, file, details))
         for file in sorted(changed_files - mentioned_files):
             if not self.in_ignored_location(file):
                 if file in self.new_files:
@@ -721,3 +809,12 @@ class GitCommit:
         print('Errors:')
         for error in self.errors:
             print(error)
+
+    def check_commit_email(self):
+        # Parse 'Martin Liska  <mliska@suse.cz>'
+        email = self.info.author.split(' ')[-1].strip('<>')
+
+        # Verify that all characters are ASCII
+        # TODO: Python 3.7 provides a nicer function: isascii
+        if len(email) != len(email.encode()):
+            self.errors.append(Error(f'non-ASCII characters in git commit email address ({email})'))
diff --git a/contrib/gcc-changelog/git_email.py b/contrib/gcc-changelog/git_email.py
index 00ad00458f4..87b419cae5d 100755
--- a/contrib/gcc-changelog/git_email.py
+++ b/contrib/gcc-changelog/git_email.py
@@ -17,6 +17,7 @@
 # <http://www.gnu.org/licenses/>.  */
 
 import os
+import re
 import sys
 from itertools import takewhile
 
@@ -28,16 +29,20 @@ from unidiff import PatchSet, PatchedFile
 
 DATE_PREFIX = 'Date: '
 FROM_PREFIX = 'From: '
+SUBJECT_PREFIX = 'Subject: '
+subject_patch_regex = re.compile(r'^\[PATCH( \d+/\d+)?\] ')
 unidiff_supports_renaming = hasattr(PatchedFile(), 'is_rename')
 
 
 class GitEmail(GitCommit):
-    def __init__(self, filename, strict=False):
+    def __init__(self, filename):
         self.filename = filename
         diff = PatchSet.from_filename(filename)
         date = None
         author = None
+        subject = ''
 
+        subject_last = False
         with open(self.filename, 'r') as f:
             lines = f.read().splitlines()
         lines = list(takewhile(lambda line: line != '---', lines))
@@ -46,8 +51,21 @@ class GitEmail(GitCommit):
                 date = parse(line[len(DATE_PREFIX):])
             elif line.startswith(FROM_PREFIX):
                 author = GitCommit.format_git_author(line[len(FROM_PREFIX):])
+            elif line.startswith(SUBJECT_PREFIX):
+                subject = line[len(SUBJECT_PREFIX):]
+                subject_last = True
+            elif subject_last and line.startswith(' '):
+                subject += line
+            elif line == '':
+                break
+            else:
+                subject_last = False
+
+        if subject:
+            subject = subject_patch_regex.sub('', subject)
         header = list(takewhile(lambda line: line != '', lines))
-        body = lines[len(header) + 1:]
+        # Note: commit message consists of email subject, empty line, email body
+        message = [subject] + lines[len(header):]
 
         modified_files = []
         for f in diff:
@@ -66,16 +84,29 @@ class GitEmail(GitCommit):
                 t = 'A'
             else:
                 t = 'M'
-            modified_files.append((target, t))
-        git_info = GitInfo(None, date, author, body, modified_files)
-        super().__init__(git_info, strict=strict,
+            modified_files.append((target if t != 'D' else source, t))
+        git_info = GitInfo(None, date, author, message, modified_files)
+        super().__init__(git_info,
                          commit_to_info_hook=lambda x: None)
 
 
-# With zero arguments, process every patch file in the ./patches directory.
-# With one argument, process the named patch file.
-# Patch files must be in 'git format-patch' format.
+def show_help():
+    print("""usage: git_email.py [--help] [patch file ...]
+
+Check git ChangeLog format of a patch
+
+With zero arguments, process every patch file in the
+./patches directory.
+With one argument, process the named patch file.
+
+Patch files must be in 'git format-patch' format.""")
+    sys.exit(0)
+
+
 if __name__ == '__main__':
+    if len(sys.argv) == 2 and (sys.argv[1] == '-h' or sys.argv[1] == '--help'):
+        show_help()
+
     if len(sys.argv) == 1:
         allfiles = []
         for root, _dirs, files in os.walk('patches'):
@@ -97,7 +128,7 @@ if __name__ == '__main__':
         print()
         print('Successfully parsed: %d/%d' % (success, len(allfiles)))
     else:
-        email = GitEmail(sys.argv[1], False)
+        email = GitEmail(sys.argv[1])
         if email.success:
             print('OK')
             email.print_output()
diff --git a/contrib/gcc-changelog/git_repository.py b/contrib/gcc-changelog/git_repository.py
index a0e293d756d..2d688826ff8 100755
--- a/contrib/gcc-changelog/git_repository.py
+++ b/contrib/gcc-changelog/git_repository.py
@@ -29,7 +29,7 @@ except ImportError:
 from git_commit import GitCommit, GitInfo, decode_path
 
 
-def parse_git_revisions(repo_path, revisions, strict=True):
+def parse_git_revisions(repo_path, revisions, ref_name=None):
     repo = Repo(repo_path)
 
     def commit_to_info(commit):
@@ -72,7 +72,8 @@ def parse_git_revisions(repo_path, revisions, strict=True):
         commits = [repo.commit(revisions)]
 
     for commit in commits:
-        git_commit = GitCommit(commit_to_info(commit.hexsha), strict=strict,
-                               commit_to_info_hook=commit_to_info)
+        git_commit = GitCommit(commit_to_info(commit.hexsha),
+                               commit_to_info_hook=commit_to_info,
+                               ref_name=ref_name)
         parsed_commits.append(git_commit)
     return parsed_commits
diff --git a/contrib/gcc-changelog/git_update_version.py b/contrib/gcc-changelog/git_update_version.py
index d2cadb8811c..1837c1a8d7f 100755
--- a/contrib/gcc-changelog/git_update_version.py
+++ b/contrib/gcc-changelog/git_update_version.py
@@ -26,6 +26,12 @@ from git_repository import parse_git_revisions
 
 current_timestamp = datetime.datetime.now().strftime('%Y%m%d\n')
 
+# Skip the following commits, they cannot be correctly processed
+IGNORED_COMMITS = (
+        'c2be82058fb40f3ae891c68d185ff53e07f14f45',
+        '04a040d907a83af54e0a98bdba5bfabc0ef4f700',
+        '2e96b5f14e4025691b57d2301d71aa6092ed44bc')
+
 
 def read_timestamp(path):
     with open(path) as f:
@@ -54,7 +60,8 @@ def prepend_to_changelog_files(repo, folder, git_commit, add_to_git):
             repo.git.add(full_path)
 
 
-active_refs = ['master', 'releases/gcc-8', 'releases/gcc-9', 'releases/gcc-10']
+active_refs = ['master', 'releases/gcc-9', 'releases/gcc-10',
+               'releases/gcc-11']
 
 parser = argparse.ArgumentParser(description='Update DATESTAMP and generate '
                                  'ChangeLog entries')
@@ -74,7 +81,7 @@ repo = Repo(args.git_path)
 origin = repo.remotes['origin']
 
 
-def update_current_branch():
+def update_current_branch(ref_name):
     commit = repo.head.commit
     commit_count = 1
     while commit:
@@ -97,7 +104,8 @@ def update_current_branch():
         if len(head.parents) == 2:
             head = head.parents[1]
         commits = parse_git_revisions(args.git_path, '%s..%s'
-                                      % (commit.hexsha, head.hexsha))
+                                      % (commit.hexsha, head.hexsha), ref_name)
+        commits = [c for c in commits if c.info.hexsha not in IGNORED_COMMITS]
         for git_commit in reversed(commits):
             prepend_to_changelog_files(repo, args.git_path, git_commit,
                                        not args.dry_mode)
@@ -140,6 +148,6 @@ else:
             branch.checkout()
             origin.pull(rebase=True)
             print('branch pulled and checked out')
-            update_current_branch()
+            update_current_branch(name)
             assert not repo.index.diff(None)
             print('branch is done\n', flush=True)
diff --git a/contrib/gcc-changelog/setup.cfg b/contrib/gcc-changelog/setup.cfg
index 9e4a0f6479c..efc313f6d52 100644
--- a/contrib/gcc-changelog/setup.cfg
+++ b/contrib/gcc-changelog/setup.cfg
@@ -1,2 +1,5 @@
+[flake8]
+max-line-length = 120
+
 [tool:pytest]
 addopts = -vv --flake8
diff --git a/contrib/gcc-changelog/test_email.py b/contrib/gcc-changelog/test_email.py
index 5db56caef9e..a4796dbbe94 100755
--- a/contrib/gcc-changelog/test_email.py
+++ b/contrib/gcc-changelog/test_email.py
@@ -62,17 +62,17 @@ class TestGccChangelog(unittest.TestCase):
             assert t.endswith('.patch')
             os.remove(t)
 
-    def get_git_email(self, filename, strict=False):
+    def get_git_email(self, filename):
         with tempfile.NamedTemporaryFile(mode='w+', suffix='.patch',
                                          delete=False) as f:
             f.write('\n'.join(self.patches[filename]))
             self.temps.append(f.name)
-        return GitEmail(f.name, strict)
+        return GitEmail(f.name)
 
-    def from_patch_glob(self, name, strict=False):
+    def from_patch_glob(self, name):
         files = [f for f in self.patches.keys() if f.startswith(name)]
         assert len(files) == 1
-        return self.get_git_email(files[0], strict)
+        return self.get_git_email(files[0])
 
     def test_simple_patch_format(self):
         email = self.get_git_email('0577-aarch64-Add-an-and.patch')
@@ -247,7 +247,7 @@ class TestGccChangelog(unittest.TestCase):
         assert email.changelog_entries[1].prs == []
 
     def test_multiple_prs_not_added(self):
-        email = self.from_patch_glob('0001-Add-patch_are')
+        email = self.from_patch_glob('0002-Add-patch_are')
         assert not email.errors
         assert email.changelog_entries[0].prs == ['PR target/93492']
         assert email.changelog_entries[1].prs == ['PR target/12345']
@@ -255,18 +255,17 @@ class TestGccChangelog(unittest.TestCase):
         assert email.changelog_entries[2].folder == 'gcc/testsuite'
 
     def test_strict_mode(self):
-        email = self.from_patch_glob('0001-Add-patch_are',
-                                     True)
+        email = self.from_patch_glob('0001-Add-patch_are')
         msg = 'ChangeLog, DATESTAMP, BASE-VER and DEV-PHASE updates should ' \
               'be done separately from normal commits'
-        assert email.errors[0].message == msg
+        assert email.errors[0].message.startswith(msg)
 
     def test_strict_mode_normal_patch(self):
-        email = self.get_git_email('0001-Just-test-it.patch', True)
+        email = self.get_git_email('0001-Just-test-it.patch')
         assert not email.errors
 
     def test_strict_mode_datestamp_only(self):
-        email = self.get_git_email('0002-Bump-date.patch', True)
+        email = self.get_git_email('0002-Bump-date.patch')
         assert not email.errors
 
     def test_wrong_changelog_entry(self):
@@ -404,3 +403,46 @@ class TestGccChangelog(unittest.TestCase):
         email = self.from_patch_glob('0001-Add-horse2.patch')
         assert not email.errors
         assert email.changelog_entries[0].files == ['kon√≠ƒçek.txt']
+
+    def test_modification_of_old_changelog(self):
+        email = self.from_patch_glob('0001-fix-old-ChangeLog.patch')
+        assert not email.errors
+
+    def test_multiline_parentheses(self):
+        email = self.from_patch_glob('0001-Add-macro.patch')
+        assert not email.errors
+
+    def test_multiline_bad_parentheses(self):
+        email = self.from_patch_glob('0002-Wrong-macro-changelog.patch')
+        assert email.errors[0].message == 'bad parentheses wrapping'
+        assert email.errors[0].line == '	* config/i386/i386.md (*fix_trunc<mode>_i387_1,'
+
+    def test_changelog_removal(self):
+        email = self.from_patch_glob('0001-ChangeLog-removal.patch')
+        assert not email.errors
+
+    def test_long_filenames(self):
+        email = self.from_patch_glob('0001-long-filenames')
+        assert not email.errors
+
+    def test_multi_same_file(self):
+        email = self.from_patch_glob('0001-OpenMP-Fix-SIMT')
+        assert email.errors[0].message == 'same file specified multiple times'
+
+    def test_pr_only_in_subject(self):
+        email = self.from_patch_glob('0001-rs6000-Support-doubleword')
+        assert (email.errors[0].message ==
+                'PR 100085 in subject but not in changelog')
+
+    def test_wrong_pr_comp_in_subject(self):
+        email = self.from_patch_glob('pr-wrong-comp.patch')
+        assert email.errors[0].message == 'invalid PR component in subject'
+
+    def test_copyright_years(self):
+        email = self.from_patch_glob('copyright-years.patch')
+        assert not email.errors
+
+    def test_non_ascii_email(self):
+        email = self.from_patch_glob('non-ascii-email.patch')
+        assert (email.errors[0].message ==
+                'non-ASCII characters in git commit email address (jbglaw@≈Çug-owl.de)')
diff --git a/contrib/gcc-changelog/test_patches.txt b/contrib/gcc-changelog/test_patches.txt
index ffd13682d5c..98a0d3f1ee0 100644
--- a/contrib/gcc-changelog/test_patches.txt
+++ b/contrib/gcc-changelog/test_patches.txt
@@ -68,13 +68,6 @@ xxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>
  create mode 100644 gcc/testsuite/gcc.target/arc/uncached-7.c
  create mode 100644 gcc/testsuite/gcc.target/arc/uncached-8.c
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 91dfcd71a4b..2cc61d68cf3 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/config/arc/arc.c b/gcc/config/arc/arc.c
 index 22475f2732e..e1a865f02e6 100644
 --- a/gcc/config/arc/arc.c
@@ -88,13 +81,6 @@ index cf7aa8d83c9..46cb254ed28 100644
 +++ b/gcc/config/arc/arc.md
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 16ddef07516..991934272e0 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/gcc.target/arc/arc.exp b/gcc/testsuite/gcc.target/arc/arc.exp
 index 8d1844edd22..501d4589c53 100644
@@ -199,20 +185,6 @@ without any data fields.
  4 files changed, 36 insertions(+)
  create mode 100644 gcc/testsuite/g++.dg/tree-ssa/pr93667.C
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 77c2a9ad810..6b53f9a2f07 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 9b4fe11a6f6..8033fa0a3bb 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr93667.C b/gcc/testsuite/g++.dg/tree-ssa/pr93667.C
 new file mode 100644
 index 00000000000..d875f53d9ec
@@ -275,20 +247,6 @@ Subject: [PATCH 0413/2034] SRA: Total scalarization after access propagation
  5 files changed, 537 insertions(+), 184 deletions(-)
  create mode 100644 gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 16247a59304..61da54df346 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 05518848829..38758207989 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/testsuite/gcc.dg/guality/pr59776.c b/gcc/testsuite/gcc.dg/guality/pr59776.c
 index 382abb622bb..6c1c8165b70 100644
 --- a/gcc/testsuite/gcc.dg/guality/pr59776.c
@@ -333,26 +291,12 @@ Subject: [PATCH 0334/2034] Do not generate a unique fnname for resolver.
  gcc/testsuite/gcc.target/i386/pr81213.c |  4 ++--
  4 files changed, 19 insertions(+), 17 deletions(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 45075840824..59806baa757 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/config/i386/i386-features.c b/gcc/config/i386/i386-features.c
 index e580b26b995..b49e6f8d408 100644
 --- a/gcc/config/i386/i386-features.c
 +++ b/gcc/config/i386/i386-features.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 2de060843d9..22a37dd1ab2 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/gcc.target/i386/pr81213.c b/gcc/testsuite/gcc.target/i386/pr81213.c
 index 13e15d5fef0..89c47529861 100644
@@ -396,26 +340,12 @@ Co-Authored-By: Jakub Jelinek <jakub@redhat.com>
  8 files changed, 142 insertions(+), 22 deletions(-)
  create mode 100644 gcc/testsuite/g++.dg/pr94314-4.C
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 74dbeeb44c6..9e499ec9c86 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
 index c73b8f810f0..8f541a28b6e 100644
 --- a/gcc/cgraphclones.c
 +++ b/gcc/cgraphclones.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 756f1d759e6..94d2312022d 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/g++.dg/pr94314-2.C b/gcc/testsuite/g++.dg/pr94314-2.C
 index 36b93ed6d4d..998ce601767 100644
@@ -492,13 +422,6 @@ https://gcc.gnu.org/ml/gcc-patches/2020-01/msg00809.html
  3 files changed, 24 insertions(+), 5 deletions(-)
  create mode 100644 gcc/testsuite/g++.dg/template/pr90916.C
 
-diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
-index 004ce0fdcdf..3cc7c48b490 100644
---- a/gcc/cp/ChangeLog
-+++ b/gcc/cp/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
 index fa82ecad233..4fdc74f9ca8 100644
 --- a/gcc/cp/pt.c
@@ -539,13 +462,6 @@ not broken, but this is both safer and satisfies static analysis.
  libgomp/plugin/plugin-gcn.c | 8 ++++++++
  2 files changed, 17 insertions(+)
 
-diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
-index c524abbbfb6..ee1764d4ae3 100644
---- a/libgomp/ChangeLog
-+++ b/libgomp/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/libgomp/plugin/plugin-gcn.c b/libgomp/plugin/plugin-gcn.c
 index dc72c90962c..4c6a4c03b6e 100644
 --- a/libgomp/plugin/plugin-gcn.c
@@ -578,13 +494,6 @@ ChangeLog:
  gcc/tree-into-ssa.c | 59 ++++++++++++++++++++++++++++++++++++---------
  2 files changed, 55 insertions(+), 12 deletions(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 8c17e5992d2..262f0d6506f 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/tree-into-ssa.c b/gcc/tree-into-ssa.c
 index c27bf2ce121..6528acac31a 100644
 --- a/gcc/tree-into-ssa.c
@@ -683,26 +592,12 @@ just the C-family ones that defined a forwarding macro.
  17 files changed, 146 insertions(+), 95 deletions(-)
  create mode 100644 gcc/testsuite/g++.dg/cpp/pr80005.C
 
-diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
-index 09ba2c8b40f..fdddb98a74d 100644
---- a/gcc/c-family/ChangeLog
-+++ b/gcc/c-family/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
 index a6308921dc9..70a12055e27 100644
 --- a/gcc/c-family/c-cppbuiltin.c
 +++ b/gcc/c-family/c-cppbuiltin.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index a526e32ac89..67d5f2e9e28 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/g++.dg/cpp/pr80005.C b/gcc/testsuite/g++.dg/cpp/pr80005.C
 new file mode 100644
@@ -731,13 +626,6 @@ index dd15cd6af3c..82fd602f9f1 100644
 +++ b/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C
 @@ -1 +1,2 @@
 
-+
-diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
-index 3249b93fe88..27a841bbdce 100644
---- a/libcpp/ChangeLog
-+++ b/libcpp/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/libcpp/directives.c b/libcpp/directives.c
 index 983206a5838..10735c8c668 100644
@@ -825,13 +713,6 @@ Subject: [PATCH 0004/2034] tree-opt: Fix bootstrap failure in
  gcc/tree-ssa-forwprop.c | 6 +++---
  2 files changed, 12 insertions(+), 3 deletions(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index a195863212e..f7df07343d1 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
 index aac31d02b6c..56c470f6ecf 100644
 --- a/gcc/tree-ssa-forwprop.c
@@ -898,13 +779,6 @@ Subject: [PATCH 0735/2034] PR 87488: Add --with-diagnostics-urls configuration
  gcc/pretty-print.h     |   5 +-
  11 files changed, 328 insertions(+), 26 deletions(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index e6eb6ab4c21..22f990a3088 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/config.in b/gcc/config.in
 index 48292861842..01fb18dbbb5 100644
 --- a/gcc/config.in
@@ -1000,13 +874,6 @@ gcc/ChangeLog
  gcc/cfgloopanal.c | 5 ++++-
  2 files changed, 9 insertions(+), 1 deletion(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 07e5bebe909..f3301b16464 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/cfgloopanal.c b/gcc/cfgloopanal.c
 index 392b1c337c4..0b33e8272a7 100644
 --- a/gcc/cfgloopanal.c
@@ -1073,13 +940,6 @@ Subject: [PATCH 0735/2034] PR 87488: Add --with-diagnostics-urls configuration
  gcc/pretty-print.h     |   5 +-
  11 files changed, 328 insertions(+), 26 deletions(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index e6eb6ab4c21..22f990a3088 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/config.in b/gcc/config.in
 index 48292861842..01fb18dbbb5 100644
 --- a/gcc/config.in
@@ -1187,26 +1047,12 @@ co-authored-by: John Miller2 <jm2@example.com>
  8 files changed, 142 insertions(+), 22 deletions(-)
  create mode 100644 gcc/testsuite/g++.dg/pr94314-4.C
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 74dbeeb44c6..9e499ec9c86 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
 index c73b8f810f0..8f541a28b6e 100644
 --- a/gcc/cgraphclones.c
 +++ b/gcc/cgraphclones.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 756f1d759e6..94d2312022d 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/g++.dg/pr94314-2.C b/gcc/testsuite/g++.dg/pr94314-2.C
 index 36b93ed6d4d..998ce601767 100644
@@ -1299,26 +1145,12 @@ if it isn't a REG or SUBREG of REG.
  4 files changed, 51 insertions(+), 19 deletions(-)
  create mode 100644 gcc/testsuite/gcc.dg/pr94291.c
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index a1ab9fb4ef3..12803e90b0a 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/combine.c b/gcc/combine.c
 index 58366a6d331..cff76cd3303 100644
 --- a/gcc/combine.c
 +++ b/gcc/combine.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 71b5a14bcbe..3cbf891d58d 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/gcc.dg/pr94291.c b/gcc/testsuite/gcc.dg/pr94291.c
 new file mode 100644
@@ -1389,13 +1221,6 @@ index e85a8e8813e..fb776ba5a0e 100644
 +++ b/gcc/ChangeLog
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
-index c429b49e68c..69ea1fdc4f3 100644
---- a/gcc/c-family/ChangeLog
-+++ b/gcc/c-family/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
 index ac936d5bbbb..a101312c581 100644
@@ -1432,10 +1257,122 @@ index c212a1a57dc..3dccef39701 100644
 @@ -1 +1,2 @@
 
 +
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 176aa117904..185f9ea725e 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+new file mode 100644
+index 00000000000..f60bf46cfe3
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+new file mode 100644
+index 00000000000..90f88c78be7
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+new file mode 100644
+index 00000000000..4490e5c15ca
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/varasm.c b/gcc/varasm.c
+index 271a67abf56..f062e48071f 100644
+--- a/gcc/varasm.c
++++ b/gcc/varasm.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.2
+
+=== 0002-Add-patch_area_size-and-patch_area_entry-to-crtl.patch ===
+From 6607bdd99994c834f92fce924abdaea3405f62dc Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 1 May 2020 21:03:10 -0700
+Subject: [PATCH] Add patch_area_size and patch_area_entry to crtl
+
+Currently patchable area is at the wrong place.  It is placed immediately
+after function label and before .cfi_startproc.  A backend should be able
+to add a pseudo patchable area instruction durectly into RTL.  This patch
+adds patch_area_size and patch_area_entry to crtl so that the patchable
+area info is available in RTL passes.
+
+It also limits patch_area_size and patch_area_entry to 65535, which is
+a reasonable maximum size for patchable area.
+
+gcc/
+
+	PR target/93492
+	* cfgexpand.c (pass_expand::execute): Set crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* emit-rtl.h (rtl_data): Add patch_area_size and patch_area_entry.
+	* opts.c (common_handle_option): Limit
+	function_entry_patch_area_size and function_entry_patch_area_start
+	to USHRT_MAX.  Fix a typo in error message.
+	* varasm.c (assemble_start_function): Use crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* doc/invoke.texi: Document the maximum value for
+	-fpatchable-function-entry.
+
+gcc/c-family/
+
+	PR target/12345
+	* c-attribs.c (handle_patchable_function_entry_attribute): Limit
+	value to USHRT_MAX (65535).
+
+---
+ gcc/ChangeLog                                 | 14 ++++++++
+ gcc/c-family/ChangeLog                        |  6 ++++
+ gcc/c-family/c-attribs.c                      |  9 +++++
+ gcc/cfgexpand.c                               | 33 +++++++++++++++++++
+ gcc/doc/invoke.texi                           |  1 +
+ gcc/emit-rtl.h                                |  6 ++++
+ gcc/opts.c                                    |  4 ++-
+ gcc/testsuite/ChangeLog                       |  7 ++++
+ .../patchable_function_entry-error-1.c        |  9 +++++
+ .../patchable_function_entry-error-2.c        |  9 +++++
+ .../patchable_function_entry-error-3.c        | 17 ++++++++++
+ gcc/varasm.c                                  | 30 ++---------------
+ 12 files changed, 116 insertions(+), 29 deletions(-)
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+
+diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
+index ac936d5bbbb..a101312c581 100644
+--- a/gcc/c-family/c-attribs.c
++++ b/gcc/c-family/c-attribs.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
+index a7ec77d5c85..86efa22bf60 100644
+--- a/gcc/cfgexpand.c
++++ b/gcc/cfgexpand.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
+index 527d362533a..767d1f07801 100644
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
+index a878efe3cf7..3d6565c8a30 100644
+--- a/gcc/emit-rtl.h
++++ b/gcc/emit-rtl.h
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/opts.c b/gcc/opts.c
+index c212a1a57dc..3dccef39701 100644
+--- a/gcc/opts.c
++++ b/gcc/opts.c
 @@ -1 +1,2 @@
 
 +
@@ -1497,13 +1434,6 @@ gcc/cp/ChangeLog
  3 files changed, 40 insertions(+), 18 deletions(-)
  create mode 100644 gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C
 
-diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
-index 640e4948130..4b6691a77f0 100644
---- a/gcc/cp/ChangeLog
-+++ b/gcc/cp/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
 index 7bf249cee5c..2fe7b66707c 100644
 --- a/gcc/cp/pt.c
@@ -1531,6 +1461,7 @@ Subject: [PATCH 0030/2034] 	PR c++/92746 - ICE with noexcept of function
 Another place that needs to specially handle Concepts TS function-style
 concepts.
 
+	PR c++/92746
 	* except.c (check_noexcept_r): Handle concept-check.
 ---
  gcc/cp/ChangeLog                            | 3 +++
@@ -1539,13 +1470,6 @@ concepts.
  3 files changed, 11 insertions(+)
  create mode 100644 gcc/testsuite/g++.dg/concepts/fn-concept3.C
 
-diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
-index 59646c70fa4..4729e3d331d 100644
---- a/gcc/cp/ChangeLog
-+++ b/gcc/cp/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/cp/except.c b/gcc/cp/except.c
 index e073bd4d2bc..55b4b6af442 100644
 --- a/gcc/cp/except.c
@@ -1573,13 +1497,6 @@ Subject: [PATCH 0129/2034] Add PR number to change log
  gcc/ChangeLog | 1 +
  1 file changed, 1 insertion(+)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 6c6d586ca75..49ca5f92dec 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 -- 
 2.26.1
 
@@ -1616,13 +1533,6 @@ gcc/testsuite/
  6 files changed, 132 insertions(+)
  create mode 100644 gcc/testsuite/gcc.target/aarch64/movk_2.c
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index efbbbf08225..cea8ffee99c 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
 index 24cc65a383a..d29975a8921 100644
 --- a/gcc/config/aarch64/aarch64-protos.h
@@ -1643,13 +1553,6 @@ index 90eebce85c0..9c1f17d0f85 100644
 +++ b/gcc/config/aarch64/aarch64.md
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 601bc336290..cdb26581b9c 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/gcc.target/aarch64/movk_2.c b/gcc/testsuite/gcc.target/aarch64/movk_2.c
 new file mode 100644
@@ -1836,26 +1739,12 @@ already).
  gcc/testsuite/g++.dg/tree-ssa/pr27830.C |  2 ++
  4 files changed, 47 insertions(+), 5 deletions(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 06f7eda0033..93c3076eb86 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/config/rs6000/rs6000-call.c b/gcc/config/rs6000/rs6000-call.c
 index e08621ace27..a9ae7ab70ca 100644
 --- a/gcc/config/rs6000/rs6000-call.c
 +++ b/gcc/config/rs6000/rs6000-call.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 684e408c1a5..245c1512c76 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr27830.C b/gcc/testsuite/g++.dg/tree-ssa/pr27830.C
 index 01c7fc18783..551ebc428cd 100644
@@ -1968,13 +1857,6 @@ index c212a1a57dc..3dccef39701 100644
 +++ b/gcc/opts.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 176aa117904..185f9ea725e 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
 new file mode 100644
@@ -2082,13 +1964,6 @@ Subject: [PATCH 0004/2034] tree-opt: Fix bootstrap failure in
  gcc/tree-ssa-forwprop.c | 6 +++---
  2 files changed, 12 insertions(+), 3 deletions(-)
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index a195863212e..f7df07343d1 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
 index aac31d02b6c..56c470f6ecf 100644
 --- a/gcc/tree-ssa-forwprop.c
@@ -2103,7 +1978,7 @@ index aac31d02b6c..56c470f6ecf 100644
 From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
 From: Jason Merrill <jason@redhat.com>
 Date: Thu, 16 Jan 2020 16:55:39 -0500
-Subject: [PATCH 0121/2034] PR c++/93286 - ICE with __is_constructible and
+Subject: [PATCH 0121/2034] PR c++/12345 - ICE with __is_constructible and
  variadic template.
 
 Here we had been recursing in tsubst_copy_and_build if type2 was a TREE_LIST
@@ -2125,13 +2000,6 @@ gcc/testsuite/ChangeLog:
  3 files changed, 89 insertions(+), 7 deletions(-)
  create mode 100644 gcc/testsuite/g++.dg/ext/is_constructible4.C
 
-diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
-index 3ca5d7a11b4..c37e461bcc5 100644
---- a/gcc/cp/ChangeLog
-+++ b/gcc/cp/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
 index 9bb8cc13e5f..872f8ff8f52 100644
 --- a/gcc/cp/pt.c
@@ -2210,26 +2078,12 @@ Subject: [PATCH 0043/2034] Compare TREE_ADDRESSABLE and TYPE_MODE when ODR
  create mode 100644 gcc/testsuite/g++.dg/lto/odr-8_0.C
  create mode 100644 gcc/testsuite/g++.dg/lto/odr-8_1.C
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 38165123654..33ca91a6467 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/ipa-devirt.c b/gcc/ipa-devirt.c
 index f0031957375..b609a77701d 100644
 --- a/gcc/ipa-devirt.c
 +++ b/gcc/ipa-devirt.c
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 8e3b9105188..dc42601794b 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/g++.dg/lto/odr-8_0.C b/gcc/testsuite/g++.dg/lto/odr-8_0.C
 new file mode 100644
@@ -2302,13 +2156,6 @@ gcc/testsuite/ChangeLog:
  create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c
  create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c
 
-diff --git a/gcc/ChangeLog b/gcc/ChangeLog
-index 9a949980699..49dcecb6777 100644
---- a/gcc/ChangeLog
-+++ b/gcc/ChangeLog
-@@ -1 +1,2 @@
-
-+
 diff --git a/gcc/config/aarch64/aarch64-builtins.c b/gcc/config/aarch64/aarch64-builtins.c
 index f0e0461b7f0..f50c4857e1c 100644
 --- a/gcc/config/aarch64/aarch64-builtins.c
@@ -2343,13 +2190,6 @@ index b9843b83c5f..83720d9802a 100644
 +++ b/gcc/config/aarch64/iterators.md
 @@ -1 +1,2 @@
 
-+
-diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
-index 0d8aa6063a7..8b01aa06a40 100644
---- a/gcc/testsuite/ChangeLog
-+++ b/gcc/testsuite/ChangeLog
-@@ -1 +1,2 @@
-
 +
 diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c
 new file mode 100755
@@ -3398,4 +3238,254 @@ index 00000000000..56c67f58752
 -- 
 2.29.2
 
+=== 0001-fix-old-ChangeLog.patch ===
+From fd498465b2801203089616be9a0e3c1f4fc065a0 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Wed, 13 Jan 2021 11:45:37 +0100
+Subject: [PATCH] Fix a changelog.
+
+---
+ gcc/ChangeLog-2020 | 1 +
+ 1 file changed, 1 insertion(+)
+
+-- 
+2.29.2
+=== 0001-Add-macro.patch ===
+From 9b7eedc932fe594547fb060b36dfd9e4178c4f9b Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Wed, 13 Jan 2021 16:26:45 +0100
+Subject: [PATCH 1/2] Add macro.
 
+gcc/ChangeLog:
+
+	* config/i386/i386.md (*fix_trunc<mode>_i387_1, *add<mode>3_eq,
+	*add<mode>3_ne, *add<mode>3_eq_0, *add<mode>3_ne_0, *add<mode>3_eq,
+	*fist<mode>2_<rounding>_1, *<code><mode>3_1, *<code>di3_doubleword):
+	Use ix86_pre_reload_split instead of can_create_pseudo_p in condition.
+	* config/i386/sse.md
+	(*fix_trunc<mode>_i387_1, *add<mode>3_eq,
+	*add<mode>3_ne, *add<mode>3_eq_0, *add<mode>3_ne_0, *add<mode>3_eq,
+	*fist<mode>2_<rounding>_1): This should also work.
+---
+ gcc/config/i386/i386.md | 1 +
+ gcc/config/i386/sse.md  | 1 +
+ 2 files changed, 2 insertions(+)
+
+diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
+index b60784a2908..ac63591b33f 100644
+--- a/gcc/config/i386/i386.md
++++ b/gcc/config/i386/i386.md
+@@ -1 +1,2 @@
+ 
++
+
+diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
+index 7f03fc491c3..0e17997db26 100644
+--- a/gcc/config/i386/sse.md
++++ b/gcc/config/i386/sse.md
+@@ -1 +1,2 @@
+ 
++
+
+-- 
+2.29.2
+
+=== 0002-Wrong-macro-changelog.patch ===
+From 3542802111d4c6752ac7233ef96655b7fb78aae4 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Wed, 13 Jan 2021 16:54:58 +0100
+Subject: [PATCH 2/2] Wrong macro changelog
+
+gcc/ChangeLog:
+
+	* config/i386/i386.md (*fix_trunc<mode>_i387_1,
+	(foo): Change it.
+---
+ gcc/config/i386/i386.md | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
+index ac63591b33f..ff4d61764e7 100644
+--- a/gcc/config/i386/i386.md
++++ b/gcc/config/i386/i386.md
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.29.2
+
+=== 0001-ChangeLog-removal.patch ===
+From b39fadf9df1a9510afcab0a391182da7dc68de24 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Fri, 12 Mar 2021 09:10:55 +0100
+Subject: [PATCH] Test ChangeLog removal.
+
+gcc/ChangeLog:
+
+	* ipa-icf.c (make_pass_ipa_icf): Add line.
+---
+diff --git a/gcc/analyzer/ChangeLog b/gcc/analyzer/ChangeLog
+deleted file mode 100644
+index 94e87f6bcde..00000000000
+--- a/gcc/analyzer/ChangeLog
++++ /dev/null
+@@ -1,1 +0,0 @@
+- foo
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
+index 5dd33a75c3a..c4ce432cb98 100644
+--- a/gcc/ipa-icf.c
++++ b/gcc/ipa-icf.c
+@@ -3655,3 +3655,4 @@ make_pass_ipa_icf (gcc::context *ctxt)
+ {
+   return new ipa_icf::pass_ipa_icf (ctxt);
+ }
++
+-- 
+2.30.1
+
+=== 0001-long-filenames ===
+From 0a5b3f87bdac5e61f9a626c795d30f9e93198585 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 12 Apr 2021 13:10:14 +0200
+Subject: [PATCH] libstdc++: Fix some tests that fail in C++20 mode
+
+The linear_congruential_engine negative tests fail with a different
+error in C++20 mode, because double is no longer an invalid type for
+NTTP. Adjust the expected errors.
+
+libstdc++-v3/ChangeLog:
+
+	* testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc:
+	Adjust expected error for C++20 mode.
+	* testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc:
+	Likewise.
+---
+ .../linear_congruential_engine/requirements/non_uint_neg.cc   | 4 +++-
+ .../random/linear_congruential/requirements/non_uint_neg.cc   | 3 ++-
+ 2 files changed, 5 insertions(+), 2 deletions(-)
+
+diff --git a/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc b/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc
+index e04e8ca6972..a36d63c6c7b 100644
+--- a/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc
++++ b/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc
+@@ -1 +1,2 @@
+ 
++
+diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc
+index 5ad82db1def..53b15f32516 100644
+--- a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc
++++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc
+@@ -1 +1,2 @@
+ 
++
+
+=== 0001-OpenMP-Fix-SIMT ===
+From 33b647956caa977d1ae489f9baed9cef70b4f382 Mon Sep 17 00:00:00 2001
+From: Tobias Burnus <tobias@codesourcery.com>
+Date: Fri, 7 May 2021 12:11:51 +0200
+Subject: [PATCH] OpenMP: Fix SIMT for complex/float reduction with && and ||
+
+libgomp/ChangeLog:
+
+	* testsuite/libgomp.c-c++-common/reduction-5.c: New test, testing
+	complex/floating-point || + && reduction with 'omp target'.
+	* testsuite/libgomp.c-c++-common/reduction-5.c: Likewise.
+---
+diff --git a/libgomp/testsuite/libgomp.c-c++-common/reduction-5.c b/libgomp/testsuite/libgomp.c-c++-common/reduction-5.c
+new file mode 100644
+index 00000000000..21540512e23
+--- /dev/null
++++ b/libgomp/testsuite/libgomp.c-c++-common/reduction-5.c
+@@ -0,0 +1,1 @@
++
+diff --git a/libgomp/testsuite/libgomp.c-c++-common/reduction-6.c b/libgomp/testsuite/libgomp.c-c++-common/reduction-6.c
+new file mode 100644
+index 00000000000..21540512e23
+--- /dev/null
++++ b/libgomp/testsuite/libgomp.c-c++-common/reduction-6.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+=== 0001-rs6000-Support-doubleword ===
+From f700e4b0ee3ef53b48975cf89be26b9177e3a3f3 Mon Sep 17 00:00:00 2001
+From: Xionghu Luo <luoxhu@linux.ibm.com>
+Date: Tue, 8 Jun 2021 21:48:12 -0500
+Subject: [PATCH] rs6000: Support doubleword swaps removal in rot64 load store
+ [PR100085]
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.target/powerpc/pr100085.c: New test.
+---
+diff --git a/gcc/testsuite/gcc.target/powerpc/pr100085.c b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+new file mode 100644
+index 00000000000..7d8b147b127
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+=== pr-wrong-comp.patch ===
+From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
+From: Jason Merrill <jason@redhat.com>
+Date: Thu, 16 Jan 2020 16:55:39 -0500
+Subject: [PATCH 0121/2034] PR some/93286 - ICE with __is_constructible and
+ variadic template.
+
+gcc/testsuite/ChangeLog:
+
+	PR c++/93286
+	* gcc.target/powerpc/pr100085.c: New test.
+---
+diff --git a/gcc/testsuite/gcc.target/powerpc/pr100085.c b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+new file mode 100644
+index 00000000000..7d8b147b127
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+==== copyright-years.patch ===
+From 99dee82307f1e163e150c9c810452979994047ce Mon Sep 17 00:00:00 2001
+From: Jakub Jelinek <jakub@redhat.com>
+Date: Mon, 4 Jan 2021 10:26:59 +0100
+Subject: [PATCH] Update copyright years.
+
+---
+diff --git a/lto-plugin/lto-plugin.c b/lto-plugin/lto-plugin.c
+new file mode 100644
+index 6f67552d075..32478f070e8 100644
+--- a/lto-plugin/lto-plugin.c
++++ b/lto-plugin/lto-plugin.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+
+=== non-ascii-email.patch ===
+From f42e95a830ab48e59389065ce79a013a519646f1 Mon Sep 17 00:00:00 2001
+From: Jan-Benedict Glaw <jbglaw@≈Çug-owl.de>
+Date: Mon, 13 Sep 2021 12:08:25 +0200
+Subject: [PATCH] Fix multi-statment macro
+
+INIT_CUMULATIVE_ARGS() expands to multiple statements, which will break right
+after an `if` statement. Wrap it into a block.
+
+gcc/ChangeLog:
+
+	* config/alpha/vms.h (INIT_CUMULATIVE_ARGS): Wrap multi-statment
+	define into a block.
+---
+ gcc/config/alpha/vms.h | 10 +++++++---
+ 1 file changed, 7 insertions(+), 3 deletions(-)
+
+diff --git a/gcc/config/alpha/vms.h b/gcc/config/alpha/vms.h
+index 2a9917cde62..0033b0004b3 100644
+--- a/gcc/config/alpha/vms.h
++++ b/gcc/config/alpha/vms.h
+@@ -0,0 +1,1 @@
++
+-- 
diff --git a/contrib/git-commit-mklog.py b/contrib/git-commit-mklog.py
new file mode 100755
index 00000000000..9c59fb97809
--- /dev/null
+++ b/contrib/git-commit-mklog.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+#
+# The script is wrapper for git commit-mklog alias where it parses
+# -b/--pr-numbers argument and passes it via environment variable
+# to mklog.py script.
+
+import argparse
+import os
+import subprocess
+
+if __name__ == '__main__':
+    children_args = []
+    myenv = os.environ.copy()
+
+    parser = argparse.ArgumentParser(description='git-commit-mklog wrapped')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    args, unknown_args = parser.parse_known_args()
+
+    myenv['GCC_FORCE_MKLOG'] = '1'
+    mklog_args = []
+    if args.pr_numbers:
+        mklog_args.append(f'-b {",".join(args.pr_numbers)}')
+    if args.fill_up_bug_titles:
+        mklog_args.append('-p')
+
+    if mklog_args:
+        myenv['GCC_MKLOG_ARGS'] = ' '.join(mklog_args)
+
+    commit_args = ' '.join(unknown_args)
+    subprocess.run(f'git commit {commit_args}', shell=True, env=myenv)
diff --git a/contrib/mklog.py b/contrib/mklog.py
new file mode 100755
index 00000000000..674c1dcd78b
--- /dev/null
+++ b/contrib/mklog.py
@@ -0,0 +1,356 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import argparse
+import datetime
+import os
+import re
+import subprocess
+import sys
+from itertools import takewhile
+
+import requests
+
+from unidiff import PatchSet
+
+pr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<pr>PR [a-z+-]+\/[0-9]+)')
+prnum_regex = re.compile(r'PR (?P<comp>[a-z+-]+)/(?P<num>[0-9]+)')
+dr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<dr>DR [0-9]+)')
+dg_regex = re.compile(r'{\s+dg-(error|warning)')
+pr_filename_regex = re.compile(r'(^|[\W_])[Pp][Rr](?P<pr>\d{4,})')
+identifier_regex = re.compile(r'^([a-zA-Z0-9_#].*)')
+comment_regex = re.compile(r'^\/\*')
+struct_regex = re.compile(r'^(class|struct|union|enum)\s+'
+                          r'(GTY\(.*\)\s+)?([a-zA-Z0-9_]+)')
+macro_regex = re.compile(r'#\s*(define|undef)\s+([a-zA-Z0-9_]+)')
+super_macro_regex = re.compile(r'^DEF[A-Z0-9_]+\s*\(([a-zA-Z0-9_]+)')
+fn_regex = re.compile(r'([a-zA-Z_][^()\s]*)\s*\([^*]')
+template_and_param_regex = re.compile(r'<[^<>]*>')
+md_def_regex = re.compile(r'\(define.*\s+"(.*)"')
+bugzilla_url = 'https://gcc.gnu.org/bugzilla/rest.cgi/bug?id=%s&' \
+               'include_fields=summary,component'
+
+function_extensions = {'.c', '.cpp', '.C', '.cc', '.h', '.inc', '.def', '.md'}
+
+# NB: Makefile.in isn't listed as it's not always generated.
+generated_files = {'aclocal.m4', 'config.h.in', 'configure'}
+
+help_message = """\
+Generate ChangeLog template for PATCH.
+PATCH must be generated using diff(1)'s -up or -cp options
+(or their equivalent in git).
+"""
+
+script_folder = os.path.realpath(__file__)
+root = os.path.dirname(os.path.dirname(script_folder))
+
+firstpr = ''
+
+
+def find_changelog(path):
+    folder = os.path.split(path)[0]
+    while True:
+        if os.path.exists(os.path.join(root, folder, 'ChangeLog')):
+            return folder
+        folder = os.path.dirname(folder)
+        if folder == '':
+            return folder
+    raise AssertionError()
+
+
+def extract_function_name(line):
+    if comment_regex.match(line):
+        return None
+    m = struct_regex.search(line)
+    if m:
+        # Struct declaration
+        return m.group(1) + ' ' + m.group(3)
+    m = macro_regex.search(line)
+    if m:
+        # Macro definition
+        return m.group(2)
+    m = super_macro_regex.search(line)
+    if m:
+        # Supermacro
+        return m.group(1)
+    m = fn_regex.search(line)
+    if m:
+        # Discard template and function parameters.
+        fn = m.group(1)
+        fn = re.sub(template_and_param_regex, '', fn)
+        return fn.rstrip()
+    return None
+
+
+def try_add_function(functions, line):
+    fn = extract_function_name(line)
+    if fn and fn not in functions:
+        functions.append(fn)
+    return bool(fn)
+
+
+def sort_changelog_files(changed_file):
+    return (changed_file.is_added_file, changed_file.is_removed_file)
+
+
+def get_pr_titles(prs):
+    output = []
+    for idx, pr in enumerate(prs):
+        pr_id = pr.split('/')[-1]
+        r = requests.get(bugzilla_url % pr_id)
+        bugs = r.json()['bugs']
+        if len(bugs) == 1:
+            prs[idx] = 'PR %s/%s' % (bugs[0]['component'], pr_id)
+            out = '%s - %s\n' % (prs[idx], bugs[0]['summary'])
+            if out not in output:
+                output.append(out)
+    if output:
+        output.append('')
+    return '\n'.join(output)
+
+
+def generate_changelog(data, no_functions=False, fill_pr_titles=False,
+                       additional_prs=None):
+    changelogs = {}
+    changelog_list = []
+    prs = []
+    out = ''
+    diff = PatchSet(data)
+    global firstpr
+
+    if additional_prs:
+        prs = [pr for pr in additional_prs if pr not in prs]
+    for file in diff:
+        # skip files that can't be parsed
+        if file.path == '/dev/null':
+            continue
+        changelog = find_changelog(file.path)
+        if changelog not in changelogs:
+            changelogs[changelog] = []
+            changelog_list.append(changelog)
+        changelogs[changelog].append(file)
+
+        # Extract PR entries from newly added tests
+        if 'testsuite' in file.path and file.is_added_file:
+            # Only search first ten lines as later lines may
+            # contains commented code which a note that it
+            # has not been tested due to a certain PR or DR.
+            this_file_prs = []
+            for line in list(file)[0][0:10]:
+                m = pr_regex.search(line.value)
+                if m:
+                    pr = m.group('pr')
+                    if pr not in prs:
+                        prs.append(pr)
+                        this_file_prs.append(pr.split('/')[-1])
+                else:
+                    m = dr_regex.search(line.value)
+                    if m:
+                        dr = m.group('dr')
+                        if dr not in prs:
+                            prs.append(dr)
+                            this_file_prs.append(dr.split('/')[-1])
+                    elif dg_regex.search(line.value):
+                        # Found dg-warning/dg-error line
+                        break
+            # PR number in the file name
+            fname = os.path.basename(file.path)
+            m = pr_filename_regex.search(fname)
+            if m:
+                pr = m.group('pr')
+                pr2 = 'PR ' + pr
+                if pr not in this_file_prs and pr2 not in prs:
+                    prs.append(pr2)
+
+    if prs:
+        firstpr = prs[0]
+
+    if fill_pr_titles:
+        out += get_pr_titles(prs)
+
+    # print list of PR entries before ChangeLog entries
+    if prs:
+        if not out:
+            out += '\n'
+        for pr in prs:
+            out += '\t%s\n' % pr
+        out += '\n'
+
+    # sort ChangeLog so that 'testsuite' is at the end
+    for changelog in sorted(changelog_list, key=lambda x: 'testsuite' in x):
+        files = changelogs[changelog]
+        out += '%s:\n' % os.path.join(changelog, 'ChangeLog')
+        out += '\n'
+        # new and deleted files should be at the end
+        for file in sorted(files, key=sort_changelog_files):
+            assert file.path.startswith(changelog)
+            in_tests = 'testsuite' in changelog or 'testsuite' in file.path
+            relative_path = file.path[len(changelog):].lstrip('/')
+            functions = []
+            if file.is_added_file:
+                msg = 'New test' if in_tests else 'New file'
+                out += '\t* %s: %s.\n' % (relative_path, msg)
+            elif file.is_removed_file:
+                out += '\t* %s: Removed.\n' % (relative_path)
+            elif hasattr(file, 'is_rename') and file.is_rename:
+                out += '\t* %s: Moved to...\n' % (relative_path)
+                new_path = file.target_file[2:]
+                # A file can be theoretically moved to a location that
+                # belongs to a different ChangeLog.  Let user fix it.
+                if new_path.startswith(changelog):
+                    new_path = new_path[len(changelog):].lstrip('/')
+                out += '\t* %s: ...here.\n' % (new_path)
+            elif os.path.basename(file.path) in generated_files:
+                out += '\t* %s: Regenerate.\n' % (relative_path)
+            else:
+                if not no_functions:
+                    for hunk in file:
+                        # Do not add function names for testsuite files
+                        extension = os.path.splitext(relative_path)[1]
+                        if not in_tests and extension in function_extensions:
+                            last_fn = None
+                            modified_visited = False
+                            success = False
+                            for line in hunk:
+                                m = identifier_regex.match(line.value)
+                                if line.is_added or line.is_removed:
+                                    # special-case definition in .md files
+                                    m2 = md_def_regex.match(line.value)
+                                    if extension == '.md' and m2:
+                                        fn = m2.group(1)
+                                        if fn not in functions:
+                                            functions.append(fn)
+                                            last_fn = None
+                                            success = True
+
+                                    if not line.value.strip():
+                                        continue
+                                    modified_visited = True
+                                    if m and try_add_function(functions,
+                                                              m.group(1)):
+                                        last_fn = None
+                                        success = True
+                                elif line.is_context:
+                                    if last_fn and modified_visited:
+                                        try_add_function(functions, last_fn)
+                                        last_fn = None
+                                        modified_visited = False
+                                        success = True
+                                    elif m:
+                                        last_fn = m.group(1)
+                                        modified_visited = False
+                            if not success:
+                                try_add_function(functions,
+                                                 hunk.section_header)
+                if functions:
+                    out += '\t* %s (%s):\n' % (relative_path, functions[0])
+                    for fn in functions[1:]:
+                        out += '\t(%s):\n' % fn
+                else:
+                    out += '\t* %s:\n' % relative_path
+        out += '\n'
+    return out
+
+
+def update_copyright(data):
+    current_timestamp = datetime.datetime.now().strftime('%Y-%m-%d')
+    username = subprocess.check_output('git config user.name', shell=True,
+                                       encoding='utf8').strip()
+    email = subprocess.check_output('git config user.email', shell=True,
+                                    encoding='utf8').strip()
+
+    changelogs = set()
+    diff = PatchSet(data)
+
+    for file in diff:
+        changelog = os.path.join(find_changelog(file.path), 'ChangeLog')
+        if changelog not in changelogs:
+            changelogs.add(changelog)
+            with open(changelog) as f:
+                content = f.read()
+            with open(changelog, 'w+') as f:
+                f.write(f'{current_timestamp}  {username}  <{email}>\n\n')
+                f.write('\tUpdate copyright years.\n\n')
+                f.write(content)
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description=help_message)
+    parser.add_argument('input', nargs='?',
+                        help='Patch file (or missing, read standard input)')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-s', '--no-functions', action='store_true',
+                        help='Do not generate function names in ChangeLogs')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    parser.add_argument('-d', '--directory',
+                        help='Root directory where to search for ChangeLog '
+                        'files')
+    parser.add_argument('-c', '--changelog',
+                        help='Append the ChangeLog to a git commit message '
+                             'file')
+    parser.add_argument('--update-copyright', action='store_true',
+                        help='Update copyright in ChangeLog files')
+    args = parser.parse_args()
+    if args.input == '-':
+        args.input = None
+    if args.directory:
+        root = args.directory
+
+    data = open(args.input) if args.input else sys.stdin
+    if args.update_copyright:
+        update_copyright(data)
+    else:
+        output = generate_changelog(data, args.no_functions,
+                                    args.fill_up_bug_titles, args.pr_numbers)
+        if args.changelog:
+            lines = open(args.changelog).read().split('\n')
+            start = list(takewhile(lambda l: not l.startswith('#'), lines))
+            end = lines[len(start):]
+            with open(args.changelog, 'w') as f:
+                if not start or not start[0]:
+                    # initial commit subject line 'component: [PRnnnnn]'
+                    m = prnum_regex.match(firstpr)
+                    if m:
+                        title = f'{m.group("comp")}: [PR{m.group("num")}]'
+                        start.insert(0, title)
+                if start:
+                    # append empty line
+                    if start[-1] != '':
+                        start.append('')
+                else:
+                    # append 2 empty lines
+                    start = 2 * ['']
+                f.write('\n'.join(start))
+                f.write('\n')
+                f.write(output)
+                f.write('\n'.join(end))
+        else:
+            print(output, end='')
diff --git a/contrib/prerequisites.md5 b/contrib/prerequisites.md5
index cc71e0f4de6..272f7a429b6 100644
--- a/contrib/prerequisites.md5
+++ b/contrib/prerequisites.md5
@@ -1,4 +1,4 @@
 86ee6e54ebfc4a90b643a65e402c4048  gmp-6.1.0.tar.bz2
-b8a2f6b0e68bef46e53da2ac439e1cf4  mpfr-3.1.4.tar.bz2
+320c28198def956aeacdb240b46b8969  mpfr-3.1.6.tar.bz2
 d6a1d5f8ddea3abd2cc3e98f58352d26  mpc-1.0.3.tar.gz
 11436d6b205e516635b666090b94ab32  isl-0.18.tar.bz2
diff --git a/contrib/prerequisites.sha512 b/contrib/prerequisites.sha512
index cf6b93b8d6b..71601457cfc 100644
--- a/contrib/prerequisites.sha512
+++ b/contrib/prerequisites.sha512
@@ -1,4 +1,4 @@
 3c82aeab9c1596d4da8afac2eec38e429e84f3211e1a572cf8fd2b546493c44c039b922a1133eaaa48bd7f3e11dbe795a384e21ed95cbe3ecc58d7ac02246117  gmp-6.1.0.tar.bz2
-51066066ff2c12ed2198605ecf68846b0c96b548adafa5b80e0c786d0df488411a5e8973358fce7192dc977ad4e68414cf14500e3c39746de62465eb145bb819  mpfr-3.1.4.tar.bz2
+0c310dd7956be527884f8059c195a5aca1042b089d0927ac6341e6310b1250a7059bc61aaaab4dfb76c6ab8b67e440878ca203f72674529bbcb46770ed9b6885  mpfr-3.1.6.tar.bz2
 0028b76df130720c1fad7de937a0d041224806ce5ef76589f19c7b49d956071a683e2f20d154c192a231e69756b19e48208f2889b0c13950ceb7b3cfaf059a43  mpc-1.0.3.tar.gz
 85d0b40f4dbf14cb99d17aa07048cdcab2dc3eb527d2fbb1e84c41b2de5f351025370e57448b63b2b8a8cf8a0843a089c3263f9baee1542d5c2e1cb37ed39d94  isl-0.18.tar.bz2
diff --git a/contrib/test_mklog.py b/contrib/test_mklog.py
new file mode 100755
index 00000000000..f5e9ecd577c
--- /dev/null
+++ b/contrib/test_mklog.py
@@ -0,0 +1,487 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import unittest
+
+from mklog import generate_changelog
+
+import unidiff
+
+unidiff_supports_renaming = hasattr(unidiff.PatchedFile(), 'is_rename')
+
+
+PATCH1 = '''\
+diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
+index 567c23380fe..e6209ede9d6 100644
+--- a/gcc/config/riscv/riscv.h
++++ b/gcc/config/riscv/riscv.h
+@@ -920,6 +920,7 @@ extern unsigned riscv_stack_boundary;
+ #define SHIFT_RS1 15
+ #define SHIFT_IMM 20
+ #define IMM_BITS 12
++#define C_S_BITS 5
+ #define C_SxSP_BITS 6
+ 
+ #define IMM_REACH (1LL << IMM_BITS)
+@@ -929,6 +930,10 @@ extern unsigned riscv_stack_boundary;
+ #define SWSP_REACH (4LL << C_SxSP_BITS)
+ #define SDSP_REACH (8LL << C_SxSP_BITS)
+ 
++/* This is the maximum value that can be represented in a compressed load/store
++   offset (an unsigned 5-bit value scaled by 4).  */
++#define CSW_MAX_OFFSET ((4LL << C_S_BITS) - 1) & ~3
++
+ /* Called from RISCV_REORG, this is defined in riscv-sr.c.  */
+ 
+ extern void riscv_remove_unneeded_save_restore_calls (void);
+
+'''
+
+EXPECTED1 = '''\
+gcc/ChangeLog:
+
+	* config/riscv/riscv.h (C_S_BITS):
+	(CSW_MAX_OFFSET):
+
+'''
+
+PATCH2 = '''\
+diff --git a/gcc/targhooks.h b/gcc/targhooks.h
+index 9704d23f1db..b572a36e8cf 100644
+--- a/gcc/targhooks.h
++++ b/gcc/targhooks.h
+@@ -120,7 +120,7 @@ extern bool default_empty_mask_is_expensive (unsigned);
+ extern void *default_init_cost (class loop *);
+ extern unsigned default_add_stmt_cost (class vec_info *, void *, int,
+ 				       enum vect_cost_for_stmt,
+-				       class _stmt_vec_info *, int,
++				       class _stmt_vec_info *, tree, int,
+ 				       enum vect_cost_model_location);
+ extern void default_finish_cost (void *, unsigned *, unsigned *, unsigned *);
+ extern void default_destroy_cost_data (void *);
+@@ -186,6 +186,7 @@ extern tree default_emutls_var_init (tree, tree, tree);
+ extern unsigned int default_hard_regno_nregs (unsigned int, machine_mode);
+ extern bool default_hard_regno_scratch_ok (unsigned int);
+ extern bool default_mode_dependent_address_p (const_rtx, addr_space_t);
++extern bool default_new_address_profitable_p (rtx, rtx_insn *, rtx);
+ extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);
+ extern bool default_target_option_pragma_parse (tree, tree);
+ extern bool default_target_can_inline_p (tree, tree);
+
+'''
+
+EXPECTED2 = '''\
+gcc/ChangeLog:
+
+	* targhooks.h (default_add_stmt_cost):
+	(default_new_address_profitable_p):
+
+'''
+
+PATCH3 = '''\
+diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
+index 2b1e33f94ae..7f47402f9b9 100644
+--- a/libcpp/include/cpplib.h
++++ b/libcpp/include/cpplib.h
+@@ -173,7 +173,7 @@ enum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_GNUC11, CLK_GNUC17, CLK_GNUC2X,
+ 	     CLK_STDC2X,
+ 	     CLK_GNUCXX, CLK_CXX98, CLK_GNUCXX11, CLK_CXX11,
+ 	     CLK_GNUCXX14, CLK_CXX14, CLK_GNUCXX17, CLK_CXX17,
+-	     CLK_GNUCXX2A, CLK_CXX2A, CLK_ASM};
++	     CLK_GNUCXX20, CLK_CXX20, CLK_ASM};
+ 
+ /* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */
+ struct GTY(()) cpp_string {
+@@ -484,7 +484,7 @@ struct cpp_options
+   /* Nonzero for C2X decimal floating-point constants.  */
+   unsigned char dfp_constants;
+ 
+-  /* Nonzero for C++2a __VA_OPT__ feature.  */
++  /* Nonzero for C++20 __VA_OPT__ feature.  */
+   unsigned char va_opt;
+ 
+   /* Nonzero for the '::' token.  */
+
+'''
+
+EXPECTED3 = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h (enum c_lang):
+	(struct cpp_options):
+
+'''
+
+EXPECTED3B = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h:
+
+'''
+
+PATCH4 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
+index aab79492357..f0df1002488 100644
+--- a/gcc/ipa-icf.c
++++ b/gcc/ipa-icf.c
+@@ -1,5 +1,7 @@
+ 
+ 
++
++
+ /* Interprocedural Identical Code Folding pass
+    Copyright (C) 2014-2020 Free Software Foundation, Inc.
+ 
+diff --git a/gcc/testsuite/gcc.dg/pr32374.c b/gcc/testsuite/gcc.dg/pr32374.c
+deleted file mode 100644
+index de15d559f5b..00000000000
+--- a/gcc/testsuite/gcc.dg/pr32374.c
++++ /dev/null
+@@ -1,20 +0,0 @@
+-/* { dg-do compile } */
+-/* { dg-options "-O2" } */
+-
+-extern int *stderr;
+-
+-void f (int *, const char *, ...);
+-
+-void g (const char *conf_name)
+-{
+-  typedef struct
+-  {
+-    const char *label;
+-    const int value;
+-  } Section;
+-
+-  const Section sections[2] = { {"", 0}, {"", 1} };
+-
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-}
+diff --git a/gcc/testsuite/gcc.dg/pr40209.c b/gcc/testsuite/gcc.dg/pr40209.c
+index 4e77df5c2e6..c23d69d1f1b 100644
+--- a/gcc/testsuite/gcc.dg/pr40209.c
++++ b/gcc/testsuite/gcc.dg/pr40209.c
+@@ -1,6 +1,8 @@
+ /* { dg-do compile } */
+ /* { dg-options "-O2 -fprofile-use -fopt-info -Wno-missing-profile" } */
+ 
++
++
+ void process(const char *s);
+ 
+ struct BaseHolder {
+diff --git a/gcc/testsuite/gcc.dg/pr50209.c b/gcc/testsuite/gcc.dg/pr50209.c
+new file mode 100644
+index 00000000000..b28b04f6431
+--- /dev/null
++++ b/gcc/testsuite/gcc.dg/pr50209.c
+@@ -0,0 +1,3 @@
++
++
++
+diff --git a/gcc/testsuite/gcc.dg/pr63567-1.c b/gcc/testsuite/gcc.dg/pr63567-1.c
+index 97da171563e..00c5ecc11fa 100644
+--- a/gcc/testsuite/gcc.dg/pr63567-1.c
++++ b/gcc/testsuite/gcc.dg/pr63567-1.c
+@@ -1,3 +1,4 @@
++
+ /* PR c/63567 */
+ /* { dg-do compile } */
+ /* { dg-options "" } */
+diff --git a/gcc/varasm.c b/gcc/varasm.c
+index f062e48071f..fd3c7ca8cf3 100644
+--- a/gcc/varasm.c
++++ b/gcc/varasm.c
+@@ -1,3 +1,5 @@
++
++
+ /* Output variables, constants and external declarations, for GNU compiler.
+    Copyright (C) 1987-2020 Free Software Foundation, Inc.
+ 
+diff --git a/libssp/gets-chk.c b/libssp/gets-chk.c
+index 4ad78c1f77b..6687b368038 100644
+--- a/libssp/gets-chk.c
++++ b/libssp/gets-chk.c
+@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ 
++
++
+ #include "config.h"
+ #include <ssp/ssp.h>
+ #include <stdarg.h>
+'''
+
+EXPECTED4 = '''\
+
+	PR 50209
+
+gcc/ChangeLog:
+
+	* ipa-icf.c:
+	* varasm.c:
+
+libssp/ChangeLog:
+
+	* gets-chk.c:
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.dg/pr40209.c:
+	* gcc.dg/pr63567-1.c:
+	* gcc.dg/pr32374.c: Removed.
+	* gcc.dg/pr50209.c: New test.
+
+'''
+
+PATCH5 = '''\
+diff --git a/gcc/testsuite/gcc.target/i386/pr95046-6.c b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+new file mode 100644
+index 00000000000..dcc8999c446
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+@@ -0,0 +1,44 @@
++/* PR target/95046 */
++/* { dg-do compile { target { ! ia32 } } } */
++/* { dg-options "-O3 -mavx512vl" } */
++
++
++double r[2];
++int s[2];
++unsigned int u[2];
++
++void
++test_float (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = s[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtdq2pd" } } */
++
++void
++test_ufloat (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = u[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtudq2pd" } } */
++
++void
++test_fix (void)
++{
++  for (int i = 0; i < 2; i++)
++    s[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2dqx" } } */
++
++void
++test_ufix (void)
++{
++  for (int i = 0; i < 2; i++)
++    u[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2udqx" } } */
+-- 
+2.26.2
+
+'''
+
+EXPECTED5 = '''\
+PR target/95046 - Vectorize V2SFmode operations
+
+	PR target/95046
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.target/i386/pr95046-6.c: New test.
+
+'''
+
+PATCH6 = '''\
+diff --git a/gcc/cgraph.h b/gcc/cgraph.h
+index 5ddeb65269b..cfae6e91da9 100644
+--- a/gcc/cgraph.h
++++ b/gcc/cgraph.h
+@@ -937,7 +937,8 @@ struct GTY((tag ("SYMTAB_FUNCTION"))) cgraph_node : public symtab_node
+       split_part (false), indirect_call_target (false), local (false),
+       versionable (false), can_change_signature (false),
+       redefined_extern_inline (false), tm_may_enter_irr (false),
+-      ipcp_clone (false), m_uid (uid), m_summary_id (-1)
++      ipcp_clone (false), declare_variant_alt (false),
++      calls_declare_variant_alt (false), m_uid (uid), m_summary_id (-1)
+   {}
+ 
+   /* Remove the node from cgraph and all inline clones inlined into it.
+
+'''
+
+EXPECTED6 = '''\
+gcc/ChangeLog:
+
+	* cgraph.h (struct cgraph_node):
+
+'''
+
+PATCH7 = '''\
+diff --git a/gcc/testsuite/g++.dg/DRs/dr2237.C b/gcc/testsuite/g++.dg/DRs/dr2237.C
+new file mode 100644
+index 00000000000..f3d6d11e61e
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/DRs/dr2237.C
+@@ -0,0 +1,18 @@
++// DR 2237 - Can a template-id name a constructor?
++
++template<class T>
++struct X {
++  X<T>(); // { dg-error "expected" "" { target c++20 } }
++  X(int); // OK, injected-class-name used
++  ~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
++
++// ill-formed since DR1435
++template<typename T> X<T>::X<T>() {} // { dg-error "names the constructor|as no template constructors" }
++template<typename T> X<T>::~X<T>() {} // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++
++struct Q {
++  // ill-formed since DR1435
++  template<typename T> friend X<T>::X<T>(); // { dg-error "names the constructor|as no template constructors" }
++  template<typename T> friend X<T>::~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
+'''
+
+EXPECTED7 = '''\
+
+	DR 2237
+
+gcc/testsuite/ChangeLog:
+
+	* g++.dg/DRs/dr2237.C: New test.
+
+'''
+
+PATCH8 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf2.c
+similarity index 100%
+rename from gcc/ipa-icf.c
+rename to gcc/ipa-icf2.c
+'''
+
+EXPECTED8 = '''\
+gcc/ChangeLog:
+
+	* ipa-icf.c: Moved to...
+	* ipa-icf2.c: ...here.
+
+'''
+
+PATCH9 = '''\
+diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
+index 2a260c1cfbd..7f03fc491c3 100644
+--- a/gcc/config/i386/sse.md
++++ b/gcc/config/i386/sse.md
+@@ -17611,6 +17611,23 @@ (define_insn "avx2_<code>v16qiv16hi2<mask_name>"
+    (set_attr "prefix" "maybe_evex")
+    (set_attr "mode" "OI")])
+ 
++(define_insn_and_split "*avx2_zero_extendv16qiv16hi2_1"
++  [(set (match_operand:V32QI 0 "register_operand" "=v")
++	(vec_select:V32QI
++	  (vec_concat:V64QI
++	    (match_operand:V32QI 1 "nonimmediate_operand" "vm")
++	    (match_operand:V32QI 2 "const0_operand" "C"))
++	  (match_parallel 3 "pmovzx_parallel"
++	    [(match_operand 4 "const_int_operand" "n")])))]
++  "TARGET_AVX2"
++  "#"
++  "&& reload_completed"
++  [(set (match_dup 0) (zero_extend:V16HI (match_dup 1)))]
++{
++  operands[0] = lowpart_subreg (V16HImode, operands[0], V32QImode);
++  operands[1] = lowpart_subreg (V16QImode, operands[1], V32QImode);
++})
++
+ (define_expand "<insn>v16qiv16hi2"
+   [(set (match_operand:V16HI 0 "register_operand")
+ 	(any_extend:V16HI
+'''
+
+EXPECTED9 = '''\
+gcc/ChangeLog:
+
+	* config/i386/sse.md (*avx2_zero_extendv16qiv16hi2_1):
+
+'''
+
+class TestMklog(unittest.TestCase):
+    def test_macro_definition(self):
+        changelog = generate_changelog(PATCH1)
+        assert changelog == EXPECTED1
+
+    def test_changed_argument(self):
+        changelog = generate_changelog(PATCH2)
+        assert changelog == EXPECTED2
+
+    def test_enum_and_struct(self):
+        changelog = generate_changelog(PATCH3)
+        assert changelog == EXPECTED3
+
+    def test_no_function(self):
+        changelog = generate_changelog(PATCH3, True)
+        assert changelog == EXPECTED3B
+
+    def test_sorting(self):
+        changelog = generate_changelog(PATCH4)
+        assert changelog == EXPECTED4
+
+    def test_pr_bugzilla_download(self):
+        changelog = generate_changelog(PATCH5, fill_pr_titles=True)
+        assert changelog == EXPECTED5
+
+    def test_gty_in_struct(self):
+        changelog = generate_changelog(PATCH6, fill_pr_titles=True)
+        assert changelog == EXPECTED6
+
+    def test_dr_detection_in_test_case(self):
+        changelog = generate_changelog(PATCH7)
+        assert changelog == EXPECTED7
+
+    @unittest.skipIf(not unidiff_supports_renaming,
+                     'Newer version of unidiff is needed (0.6.0+)')
+    def test_renaming(self):
+        changelog = generate_changelog(PATCH8)
+        assert changelog == EXPECTED8
+
+    def test_define_macro_parsing(self):
+        changelog = generate_changelog(PATCH9)
+        assert changelog == EXPECTED9
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 0719d810258..a9368325816 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-10.3.0
+10.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 3b1384e707f..26426efd7ef 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,1442 @@
+2022-01-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97953
+	* gimple-ssa-evrp-analyze.c
+	(evrp_range_analyzer::record_ranges_from_incoming_edge): Make
+	sure the condition post-dominates the SSA definition before
+	recording into SSA_NAME_RANGE_INFO.
+
+2022-01-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/103465
+	* coretypes.h (unwind_info_type): Swap UI_SEH and UI_TARGET.
+
+2021-12-16  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2021-12-15  Martin Liska  <mliska@suse.cz>
+
+	PR target/103661
+	* config/i386/i386-builtins.c (fold_builtin_cpu): Compare to 0
+	as API expects that non-zero values are returned (do that
+	it mask == 31).
+	For "avx512vbmi2" argument, we return now 1 << 31, which is a
+	negative integer value.
+
+2021-12-15  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-11-30  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/102347
+	* config/rs6000/rs6000-call.c (rs6000_builtin_decl): Remove builtin mask
+	check.
+
+2021-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-11-30  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/103267
+	* ipa-sra.c (scan_function): Also check ECF_LOOPING_CONST_OR_PURE flag.
+
+2021-11-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/103274
+	* config/i386/i386.c (ix86_output_call_insn): Beef up comment about
+	nops emitted with SEH.
+	* config/i386/winnt.c (i386_pe_seh_unwind_emit): When switching to
+	the cold section, emit a nop before the directive if the previous
+	active instruction is a call.
+
+2021-11-25  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-20  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/103052
+	* ipa-pure-const.c (propagate_pure_const): Fix merging of loping flag.
+
+2021-11-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101985
+	* config/rs6000/altivec.h (vec_cpsgn): Swap operand order.
+
+2021-11-22  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2021-11-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* config/s390/s390.md (define_peephole2): Variable insn points
+	to the first matched insn.  Use peep2_next_insn(1) to refer to
+	the second matched insn.
+
+2021-11-15  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-11-11  Kewen Lin  <linkw@linux.ibm.com>
+
+	* doc/invoke.texi: Change references to "future cpu" to "power10",
+	"-mcpu=future" to "-mcpu=power10".  Adjust words for float128.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/102714
+	* ipa-sra.c (ptr_parm_has_nonarg_uses): Fix volatileness
+	check.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100672
+	* fold-const.c (fold_negate_expr_1): Use element_precision.
+	(negate_expr_p): Likewise.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100253
+	* tree-vect-stmts.c (vectorizable_load): Do not assume
+	element alignment when DR_MISALIGNMENT is -1.
+	(vectorizable_store): Likewise.
+
+2021-11-08  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-10-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR tree-optimization/102789
+	* tree-vect-loop-manip.c (vect_update_inits_of_drs): Do not
+	update inits of simd_lane_access.
+
+2021-11-03  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/102842
+	* lra-constraints.c (match_reload): Ignore out in checking values
+	of outs.
+	(curr_insn_transform): Collect outputs before doing reloads of operands.
+
+2021-11-02  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-10-21  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/102505
+	* tree-sra.c (totally_scalarize_subtree): Check that the
+	encountered field fits within the acces we would like to put it
+	in.
+
+2021-10-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (%X): Remove obsolete reference to -Wl.
+
+2021-10-27  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/102761
+	* config/i386/i386.c (ix86_print_operand_address):
+	Error out for non-address_operand asm operands.
+
+2021-10-26  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	Backported from master:
+	2021-10-16  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	* configure.ac: Treat powerpc64*-*-freebsd* the same as
+	powerpc64-*-freebsd*.
+	* configure: Regenerate.
+
+2021-10-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md: Don't use 'G' constraint in integer move patterns.
+
+2021-10-21  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2021-10-21  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/98667
+	* doc/invoke.texi: Document -fcf-protection requires i686 or
+	new.
+
+2021-10-15  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md: Consistently use "rG" constraint for copy
+	instruction in move patterns.
+
+2021-10-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (cbranchsf4): Disable if TARGET_SOFT_FLOAT.
+	(cbranchdf4): Likewise.
+	Add missing move patterns for TARGET_SOFT_FLOAT.
+
+2021-10-13  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (muldi3): Add support for inlining 64-bit
+	multiplication on 32-bit PA 1.1 and 2.0 targets.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/102046
+	* tree-vect-slp.c (vect_build_slp_tree_2): Conservatively
+	update ->any_pattern when swapping operands.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101925
+	* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Set
+	reverse on COMPONENT_REF and ARRAY_REF according to
+	what reverse_storage_order_for_component_p does.
+	(vn_reference_eq): Compare reversed on reference ops.
+	(reverse_storage_order_for_component_p): New overload.
+	(vn_reference_lookup_3): Check reverse_storage_order_for_component_p
+	on the reference looked up.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101373
+	PR tree-optimization/101868
+	* tree-ssa-pre.c (prune_clobbered_mems): Also prune trapping
+	references when the BB may not return.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101824
+	* tree-nested.c (get_frame_field): Mark the COMPONENT_REF as
+	volatile in case the variable was.
+
+2021-10-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/102588
+	* config/sparc/sparc-modes.def (OI): New integer mode.
+
+2021-10-11  Diane Meirowitz  <diane.meirowitz@oracle.com>
+
+	Backported from master:
+	2021-10-11  Diane Meirowitz  <diane.meirowitz@oracle.com>
+
+	* doc/invoke.texi: Add link to UndefinedBehaviorSanitizer
+	documentation, mention UBSAN_OPTIONS, similar to what is done
+	for AddressSanitizer.
+
+2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/102622
+	* tree-ssa-phiopt.c (conditional_replacement): Set neg
+	to false for one bit signed types.
+
+2021-10-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* explow.c: Include langhooks.h.
+	(set_stack_check_libfunc): Build a proper function type.
+
+2021-10-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/64697
+	* config/i386/i386.c (legitimate_pic_address_disp_p): For PE-COFF do
+	not return true for external weak function symbols in medium model.
+
+2021-09-22  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-09-22  Kewen Lin  <linkw@linux.ibm.com>
+
+	* ipa-fnsummary.c (inline_read_section): Unpack a dummy bit
+	to keep consistent with the side of streaming out.
+
+2021-09-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2021-09-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102107
+	* config/rs6000/rs6000-logue.c (rs6000_emit_epilogue): For ELFv2 use
+	r11 instead of r12 for restoring CR.
+
+2021-09-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2021-09-03  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102107
+	* config/rs6000/rs6000-logue.c (rs6000_emit_prologue): On ELFv2 use r11
+	instead of r12 for CR save, in all cases.
+
+2021-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/102306
+	* combine.c (try_combine): Abort the combination if we are about to
+	duplicate volatile references.
+
+2021-09-16  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sparc-opts.h (enum sparc_processor_type): Add LEON5
+	* config/sparc/sparc.c (struct processor_costs): Add LEON5 costs
+	(leon5_adjust_cost): Increase cost of store with data dependency
+	on ALU instruction and FPU anti-dependencies.
+	(sparc_option_override): Add LEON5 costs
+	(sparc_adjust_cost): Add LEON5 cost adjustments
+	* config/sparc/sparc.h: Add LEON5
+	* config/sparc/sparc.md: Include LEON5 scheduling information
+	* config/sparc/sparc.opt: Add LEON5
+	* doc/invoke.texi: Add LEON5
+	* config/sparc/leon5.md: New file.
+
+2021-09-16  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sparc.md (stack_protect_setsi): Add NOP to prevent
+	sensitive sequence for B2BST errata workaround.
+
+2021-09-16  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sparc.c (sparc_do_work_around_errata): Do not begin
+	functions with atomic instruction in the UT700 errata workaround.
+
+2021-09-16  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sparc.c (next_active_non_empty_insn): New function
+	that returns next active non empty assembly instruction.
+	(sparc_do_work_around_errata): Use new function.
+
+2021-09-16  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sparc.c (store_insn_p): Add predicate for store
+	attributes.
+	(load_insn_p): Add predicate for load attributes.
+	(sparc_do_work_around_errata): Use new predicates.
+
+2021-09-16  Andreas Larsson  <andreas@gaisler.com>
+
+	* config/sparc/sparc.c (dump_target_flag_bits): Print bit names for
+	LEON and LEON3.
+
+2021-09-14  Xionghu Luo  <luoxhu@linux.ibm.com>
+
+	Backported from master:
+	2021-09-07  Xionghu Luo  <luoxhu@linux.ibm.com>
+
+	PR target/97142
+	* config/rs6000/rs6000.md (fmod<mode>3): New define_expand.
+	(remainder<mode>3): Likewise.
+
+2021-09-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/60318
+	* doc/trouble.texi (Copy Assignment): Fix description of
+	behaviour and fix code in example.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101394
+	* tree-ssa-pre.c (do_pre_regular_insertion): Avoid inserting
+	copies from abnormals for a full redundancy.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-05  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101291
+	* cfgloopmanip.c (loop_version): Set the loop copy of the
+	versioned loop to the new loop.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101173
+	PR tree-optimization/101280
+	* gimple-loop-interchange.cc
+	(tree_loop_interchange::valid_data_dependences): Properly
+	guard all dependence checks with DDR_REVERSED_P or its
+	inverse.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-24  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101105
+	* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):
+	Only ignore steps when they are equal or scalar order is preserved.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101009
+	* tree-data-ref.c (build_classic_dist_vector_1): Make sure
+	to set *init_b to true when we encounter a constant equal
+	index pair.
+	(compute_affine_dependence): Also dump the actual DR_REF.
+
+2021-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-08-19  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101849
+	* config/rs6000/rs6000-call.c (rs6000_gimple_fold_mma_builtin): Cast
+	pointer to __vector_pair *.
+
+2021-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-07-07  Peter Bergner  <bergner@linux.ibm.com>
+
+	* config/rs6000/rs6000-call.c (mma_init_builtins): Use VSX_BUILTIN_LXVP
+	and VSX_BUILTIN_STXVP.
+
+2021-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-07-02  Peter Bergner  <bergner@linux.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def (BU_MMA_PAIR_LD, BU_MMA_PAIR_ST):
+	New macros.
+	(__builtin_vsx_lxvp, __builtin_vsx_stxvp): New built-ins.
+	* config/rs6000/rs6000-call.c (rs6000_gimple_fold_mma_builtin): Expand
+	lxvp and stxvp built-ins.
+	(mma_init_builtins): Handle lxvp and stxvp built-ins.
+	(builtin_function_type): Likewise.
+	* doc/extend.texi (__builtin_vsx_lxvp, __builtin_mma_stxvp): Document.
+
+2021-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	* config/rs6000/rs6000-call.c (mma_init_builtins): Test for
+	MMA_BUILTIN_DISASSEMBLE_ACC and VSX_BUILTIN_DISASSEMBLE_PAIR.
+	(rs6000_gimple_fold_mma_builtin): Likewise.
+
+2021-08-31  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-31  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* tree.c (walk_tree_1) <OMP_CLAUSE_TILE>: Handle three operands.
+
+2021-08-27  konglin1  <lingling.kong@intel.com>
+
+	PR target/101472
+	* config/i386/sse.md: (<avx512>scattersi<mode>): Add mask operand to
+	UNSPEC_VSIBADDR.
+	(<avx512>scattersi<mode>): Likewise.
+	(*avx512f_scattersi<VI48F:mode>): Merge mask operand to set_dest.
+	(*avx512f_scatterdi<VI48F:mode>): Likewise
+
+2021-08-25  konglin1  <lingling.kong@intel.com>
+
+	PR target/101471
+	* config/i386/avx512dqintrin.h (_mm512_fpclass_ps_mask): Fix
+	macro define in O0.
+	(_mm512_mask_fpclass_ps_mask): Ditto.
+
+2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/102035
+	* config/arm/arm.md (attribute arch): Add fix_vlldm.
+	(arch_enabled): Use it.
+	* config/arm/vfp.md (lazy_store_multiple_insn): Add alternative to
+	use when erratum mitigation is needed.
+
+2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/102035
+	* config/arm/arm.opt (mfix-cmse-cve-2021-35465): New option.
+	* doc/invoke.texi (Arm Options): Document it.
+	* config/arm/arm-cpus.in (quirk_vlldm): New feature bit.
+	(ALL_QUIRKS): Add quirk_vlldm.
+	(cortex-m33): Add quirk_vlldm.
+	(cortex-m35p, cortex-m55): Likewise.
+	* config/arm/arm.c (arm_option_override): Enable fix_vlldm if
+	targetting an affected CPU and not explicitly controlled on
+	the command line.
+
+2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/vfp.md (lazy_store_multiple_insn): Rewrite as valid RTL.
+	(lazy_load_multiple_insn): Likewise.
+
+2021-08-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-23  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/97565
+	* tree-ssa-structalias.c (ipa_pta_execute): Check in_other_partition
+	in addition to has_gimple_body.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/101723
+	* config/arm/arm-cpus.in (generic-armv7-a): Add quirk to suppress
+	writing .cpu directive in asm output.
+	* config/arm/arm.c (arm_identify_fpu_from_isa): New variable.
+	(arm_last_printed_arch_string): Delete.
+	(arm_last-printed_fpu_string): Delete.
+	(arm_configure_build_target): If use of floating-point/SIMD is
+	disabled, remove all fp/simd related features from the target ISA.
+	(last_arm_targ_options): New variable.
+	(arm_print_asm_arch_directives): Add new parameters.  Change order
+	of emitted directives and handle all cases here.
+	(arm_file_start): Always call arm_print_asm_arch_directives, move
+	all generation of .arch/.arch_extension here.
+	(arm_file_end): Call arm_print_asm_arch.
+	(arm_declare_function_name): Call arm_print_asm_arch_directives
+	instead of printing .arch/.fpu directives directly.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm.c (arm_configure_build_target): Don't call
+	arm_option_reconfigure_globals.
+	(arm_option_restore): Call arm_option_reconfigure_globals after
+	reconfiguring the target.
+	* config/arm/arm-c.c (arm_pragma_target_parse): Likewise.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm.c (arm_configure_build_target): Ensure the target's
+	arch_name is always set.
+
+2021-08-23  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	Backported from master:
+	2021-08-23  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	* config/arm/arm_mve.h: Fix __arm_vctp16q return type.
+
+2021-08-19  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-05-27  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/100767
+	* config/arm/arm.c (arm_configure_build_target): Remove parameter
+	opts_set, directly check opts parameters for being non-null.
+	(arm_option_restore): Update call to arm_configure_build_target.
+	(arm_option_override): Likewise.
+	(arm_can_inline_p): Likewise.
+	(arm_valid_target_attribute_tree): Likewise.
+	* config/arm/arm-c.c (arm_pragma_target_parse): Likewise.
+	* config/arm/arm-protos.h (arm_configure_build_target): Adjust
+	prototype.
+
+2021-08-17  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-08-03  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* doc/invoke.texi: Document -mtune=neoverse-512tvb and
+	-mcpu=neoverse-512tvb.
+	* config/aarch64/aarch64-cores.def (neoverse-512tvb): New entry.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+
+2021-08-17  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-28  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/100305
+	* config/aarch64/constraints.md (Utq): Require the address to
+	be valid for both the element mode and for V2DImode.
+
+2021-08-13  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/100788
+	* coverage.c (coverage_begin_function): Update function
+	  beginning when #line macro is used.
+
+2021-07-31  Xi Ruoyao  <xry111@mengyan1223.wang>
+
+	Backported from master:
+	2021-07-30  Xi Ruoyao  <xry111@mengyan1223.wang>
+
+	PR target/94780
+	* config/mips/mips.c (mips_atomic_assign_expand_fenv): Use
+	  TARGET_EXPR instead of MODIFY_EXPR.
+
+2021-07-28  Martin Sebor  <msebor@redhat.com>
+
+	PR c/99295
+	* doc/extend.texi (attribute malloc): Reword and clarify nonaliasing
+	property.
+
+2021-07-20  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-07-08  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/101066
+	* ipa-sra.c (class isra_call_summary): New member
+	m_before_any_store, initialize it in the constructor.
+	(isra_call_summary::dump): Dump the new field.
+	(ipa_sra_call_summaries::duplicate): Copy it.
+	(process_scan_results): Set it.
+	(isra_write_edge_summary): Stream it.
+	(isra_read_edge_summary): Likewise.
+	(param_splitting_across_edge): Only override
+	safe_to_import_accesses if m_before_any_store is set.
+
+2021-07-20  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* config/i386/sync.md (define_peephole2 atomic_storedi_fpu):
+	Remove.
+	(define_peephole2 atomic_loaddi_fpu): Ditto.
+
+2021-07-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101129
+	* config/rs6000/rs6000-p8swap.c (has_part_mult): New.
+	(rs6000_analyze_swaps): Insns containing a subreg of a mult are
+	not swappable.
+
+2021-07-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/99927
+	* combine.c (distribute_notes) [REG_UNUSED]: If the register already
+	is dead, just drop it.
+
+2021-07-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/i386.c (asm_preferred_eh_data_format): Always use the
+	PIC encodings for PE-COFF targets.
+
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* config/i386/i386.md (bsr_rex64): Add zero-flag setting RTX.
+	(bsr): Ditto.
+	(*bsrhi): Remove.
+	(clz<mode>2): Update RTX pattern for additions.
+
+2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/100856
+	* common/config/arm/arm-common.c (arm_canon_arch_option_1): New function
+	derived from arm_canon_arch.
+	(arm_canon_arch_option): Call it.
+	(arm_canon_arch_multilib_option): New function.
+	* config/arm/arm-cpus.in (IGNORE_FOR_MULTILIB): New fgroup.
+	* config/arm/arm.h (arm_canon_arch_multilib_option): New prototype.
+	(CANON_ARCH_MULTILIB_SPEC_FUNCTION): New macro.
+	(MULTILIB_ARCH_CANONICAL_SPECS): New macro.
+	(DRIVER_SELF_SPECS): Add MULTILIB_ARCH_CANONICAL_SPECS.
+	* config/arm/arm.opt (mlibarch): New option.
+	* config/arm/t-rmprofile (MULTILIB_MATCHES): For armv8*-m, replace use
+	of march on RHS with mlibarch.
+
+2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2021-06-11  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/101016
+	* config/arm/arm_mve.h (__arm_vld1q): Change __ARM_mve_coerce(p0,
+	int8_t const *) to __ARM_mve_coerce1(p0, int8_t *) in the argument for
+	the polymorphic variants matching code.
+	(__arm_vld1q_z): Likewise.
+	(__arm_vld2q): Likewise.
+	(__arm_vld4q): Likewise.
+	(__arm_vldrbq_gather_offset): Likewise.
+	(__arm_vldrbq_gather_offset_z): Likewise.
+
+2021-06-18  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-06-14  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/100777
+	* config/rs6000/rs6000-call.c (rs6000_gimple_fold_mma_builtin): Use
+	create_tmp_reg_or_ssa_name().
+
+2021-06-18  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-06-10  Peter Bergner  <bergner@linux.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def (build_pair): New built-in.
+	(build_acc): Likewise.
+	* config/rs6000/rs6000-call.c (mma_expand_builtin): Swap assemble
+	source operands in little-endian mode.
+	(rs6000_gimple_fold_mma_builtin): Handle VSX_BUILTIN_BUILD_PAIR.
+	(mma_init_builtins): Likewise.
+	* config/rs6000/rs6000.c (rs6000_split_multireg_move): Handle endianness
+	ordering for the MMA assemble and build source operands.
+	* doc/extend.texi (__builtin_vsx_build_acc, __builtin_mma_build_pair):
+	Document.
+	(__builtin_mma_assemble_acc, __builtin_mma_assemble_pair): Remove
+	documentation.
+
+2021-06-18  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-05-31  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/99842
+	* config/rs6000/predicates.md(mma_assemble_input_operand): Allow
+	indexed form addresses.
+
+2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	Backported from master:
+	2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	PR target/100871
+	* config/s390/vecintrin.h (vec_doublee): Fix to use
+	  __builtin_s390_vflls.
+	(vec_floate): Fix to use __builtin_s390_vflrd.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100934
+	* tree-ssa-dom.c (pass_dominator::execute): Properly
+	mark irreducible regions.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-28  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/100791
+	* tree-inline.c (copy_bb): When processing __builtin_va_arg_pack
+	copy fntype from original call.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/100513
+	* ipa-param-manipulation.c
+	(ipa_param_body_adjustments::modify_call_stmt): Avoid
+	altering SSA_NAME_DEF_STMT by adjusting the calls LHS
+	via gimple_call_lhs_ptr.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100509
+	* gimple-fold.c (fold_gimple_assign): Only call
+	get_symbol_constant_value on register type symbols.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100492
+	* tree-loop-distribution.c (find_seed_stmts_for_distribution):
+	Find nothing when the loop contains an irreducible region.
+
+2021-06-04  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-19  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/100333
+	* config/arm/arm.md (nonsecure_call_internal): Always ensure
+	callee's address is in a register.
+
+2021-06-02  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	Backported from master:
+	2021-01-21  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/98777
+	* lra-int.h (lra_pmode_pseudo): New extern.
+	* lra.c (lra_pmode_pseudo): New global.
+	(lra): Set it up.
+	* lra-eliminations.c (eliminate_regs_in_insn): Use it.
+
+2021-06-02  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	Backported from master:
+	2021-01-20  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/98722
+	* lra-eliminations.c (eliminate_regs_in_insn): Check that target
+	has no 3-op add insn to transform insns containing two pluses.
+
+2021-06-02  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	Backported from master:
+	2021-01-12  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR target/97969
+	* lra-eliminations.c (eliminate_regs_in_insn): Add transformation
+	of pattern 'plus (plus (hard reg, const), pseudo)'.
+
+2021-06-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-02  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (abs<MMXMODEI:mode>2):
+	Change define_insn to define_expand.
+
+2021-06-01  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-11  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99725
+	* config/arm/arm.c (cmse_nonsecure_call_inline_register_clear):
+	Avoid emitting CFA adjusts on the sp if we have the fp.
+
+2021-05-25  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-10  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99960
+	* config/arm/mve.md (*mve_mov<mode>): Simplify output code. Use
+	vldrw.u32 and vstrw.32 for V2D[IF]mode loads and stores.
+
+2021-05-20  Alex Coplan  <alex.coplan@arm.com>
+	    Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/99977
+	* config/arm/arm.c (arm_split_compare_and_swap): Fix up codegen
+	with negative immediates: ensure we expand cbranchsi4_scratch
+	correctly and ensure we satisfy its constraints.
+	* config/arm/sync.md
+	(@atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1): Don't
+	attempt to tie two output operands together with constraints;
+	collapse two alternatives.
+	(@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1): Likewise.
+	* config/arm/thumb1.md (cbranchsi4_neg_late): New.
+
+2021-05-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/cpp.texi (Common Predefined Macros): Update documentation
+	for the __GXX_EXPERIMENTAL_CXX0X__ macro.
+
+2021-05-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/80960
+	* dse.c (check_mem_read_rtx): Call get_addr on the
+	offsetted address.
+
+2021-05-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100566
+	* tree-ssa-sccvn.c (dominated_by_p_w_unex): Properly handle
+	allow_back for all edge queries.
+
+2021-05-13  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2021-05-11  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+		    Joe Ramsay   <joe.ramsay@arm.com>
+
+	PR target/100419
+	* config/arm/arm_mve.h (__arm_vstrwq_scatter_offset): Fix wrong arguments.
+	(__arm_vcmpneq): Remove duplicate definition.
+	(__arm_vstrwq_scatter_offset_p): Likewise.
+	(__arm_vmaxq_x): Likewise.
+	(__arm_vmlsdavaq): Likewise.
+	(__arm_vmlsdavaxq): Likewise.
+	(__arm_vmlsdavq_p): Likewise.
+	(__arm_vmlsdavxq_p): Likewise.
+	(__arm_vrmlaldavhaq): Likewise.
+	(__arm_vstrbq_p): Likewise.
+	(__arm_vstrbq_scatter_offset): Likewise.
+	(__arm_vstrbq_scatter_offset_p): Likewise.
+	(__arm_vstrdq_scatter_offset): Likewise.
+	(__arm_vstrdq_scatter_offset_p): Likewise.
+	(__arm_vstrdq_scatter_shifted_offset): Likewise.
+	(__arm_vstrdq_scatter_shifted_offset_p): Likewise.
+
+2021-05-13  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/100563
+	* config/arm/arm.c (arm_canonicalize_comparison): Correctly
+	canonicalize DImode inequality comparisons against the
+	maximum integral value.
+
+2021-05-12  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/100571
+	* calls.c (maybe_warn_rdwr_sizes): Clear object size if it can't
+	be determined.
+
+2021-05-12  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-11  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99988
+	* config/aarch64/aarch64-bti-insert.c (aarch64_bti_j_insn_p): New.
+	(rest_of_insert_bti): Avoid inserting duplicate bti j insns for
+	jump table targets.
+
+2021-05-11  Geng Qi  <gengqi@linux.alibaba.com>
+
+	Backported from master:
+	2021-04-30  Geng Qi  <gengqi@linux.alibaba.com>
+
+	* config/riscv/riscv.opt (march=,mabi=): Negative itself.
+
+2021-05-10  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2021-04-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/100108
+	* config/rs6000/rs6000.c (rs6000_machine_from_flags): Do not consider
+	OPTION_MASK_ISEL.
+
+2021-05-06  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backported from master:
+	2021-04-30  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/100225
+	PR rtl-optimization/84878
+	* modulo-sched.c (sms_schedule): Use note_stores to skip loops
+	where we have an instruction which touches (writes) any hard
+	register from df->regular_block_artificial_uses set.
+	Allow not-single-set instruction only right before basic block
+	tail.
+
+2021-05-06  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backported from master:
+	2020-09-15  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm.c (arm_options_perform_arch_sanity_checks): Do not
+	check +D32 for CMSE if -mfloat-abi=soft
+
+2021-05-06  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2020-06-23  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	PR target/95646
+	* config/arm/arm.c: (cmse_nonsecure_entry_clear_before_return): Use
+	'callee_saved_reg_p' instead of 'calL_used_or_fixed_reg_p'.
+
+2021-05-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/100402
+	* config/i386/i386.c (ix86_compute_frame_layout): For a SEH target,
+	always return the establisher frame for __builtin_frame_address (0).
+
+2021-05-05  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2021-05-05  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	PR rtl-optimization/100263
+	* postreload.c (move2add_valid_value_p): Ensure register can
+	change mode.
+
+2021-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98786
+	* tree-ssa-phiopt.c (factor_out_conditional_conversion): Avoid
+	adding new uses of abnormals.
+
+2021-05-05  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100278
+	* tree-ssa-pre.c (compute_avail): Give up when we cannot
+	adjust TBAA beacuse of mismatching bases.
+
+2021-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/100375
+	* config/nvptx/nvptx.c (nvptx_sese_pseudo): Use NULL instead of 0
+	as first argument of pseudo_node_t constructors.
+
+2021-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/100302
+	* config/aarch64/aarch64.c (aarch64_add_offset_1_temporaries): Use
+	absu_hwi instead of abs_hwi.
+
+2021-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/100254
+	* cfgcleanup.c (outgoing_edges_match): Check REG_EH_REGION on
+	last1 and last2 insns rather than BB_END (bb1) and BB_END (bb2) insns.
+
+2021-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/100255
+	* vmsdbgout.c (ASM_OUTPUT_DEBUG_STRING, vmsdbgout_begin_block,
+	vmsdbgout_end_block, lookup_filename, vmsdbgout_source_line): Remove
+	register keywords.
+
+2021-05-04  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-04-23  Alex Coplan  <alex.coplan@arm.com>
+
+	PR rtl-optimization/100230
+	* early-remat.c (early_remat::sort_candidates): Use delete[]
+	instead of delete for array allocated with new[].
+
+2021-04-30  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backported from master:
+	2021-04-27  David Edelsohn  <dje.gcc@gmail.com>
+
+	* config/rs6000/aix.h (SUBTARGET_DRIVER_SELF_SPECS): New.
+	* config/rs6000/aix64.opt (m64): New.
+	(m32): New.
+
+2021-04-30  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96513
+	* tree-vect-slp.c (struct vdhs_data): New.
+	(vect_detect_hybrid_slp): New walker.
+	(vect_detect_hybrid_slp): Rewrite.
+
+2021-04-29  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-04-28  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/100311
+	* config/arm/arm.c (arm_hard_regno_mode_ok): Only allow VPR to be
+	used in HImode.
+
+2021-04-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-04-23  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* config/i386/sync.md (FILD_ATOMIC/FIST_ATOMIC FP load peephole2):
+	Copy operand 3 to operand 4.  Use sse_reg_operand
+	as operand 3 predicate.
+	(FILD_ATOMIC/FIST_ATOMIC FP load peephole2 with mem blockage): Ditto.
+	(LDX_ATOMIC/STX_ATOMIC FP load peephole2): Ditto.
+	(LDX_ATOMIC/LDX_ATOMIC FP load peephole2 with mem blockage): Ditto.
+	(FILD_ATOMIC/FIST_ATOMIC FP store peephole2):
+	Copy operand 1 to operand 0.
+	(FILD_ATOMIC/FIST_ATOMIC FP store peephole2 with mem blockage): Ditto.
+	(LDX_ATOMIC/STX_ATOMIC FP store peephole2): Ditto.
+	(LDX_ATOMIC/LDX_ATOMIC FP store peephole2 with mem blockage): Ditto.
+
+2021-04-26  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-04-08  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99647
+	* config/arm/iterators.md (MVE_vecs): New.
+	(V_elem): Also handle V2DF.
+	* config/arm/mve.md (*mve_mov<mode>): Rename to ...
+	(*mve_vdup<mode>): ... this. Remove second alternative since
+	vec_duplicate of const_int is not canonical RTL, and we don't
+	want to match symbol_refs.
+	(*mve_vec_duplicate<mode>): Delete (pattern is redundant).
+
+2021-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100053
+	* tree-ssa-sccvn.c (vn_nary_op_get_predicated_value): Do
+	not use optimistic dominance queries for backedges to validate
+	predicated values.
+	(dominated_by_p_w_unex): Add parameter to ignore executable
+	state on backedges.
+	(rpo_elim::eliminate_avail): Adjust.
+
+2021-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/99954
+	* tree-loop-distribution.c: Include tree-affine.h.
+	(generate_memcpy_builtin): Try using tree-affine to prove
+	non-overlap.
+	(loop_distribution::classify_builtin_ldst): Always classify
+	as PKIND_MEMMOVE.
+
+2021-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/99880
+	* tree-vect-loop.c (maybe_set_vectorized_backedge_value): Only
+	set vectorized defs of relevant PHIs.
+
+2021-04-24  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/96796
+	* lra-constraints.c (in_class_p): Add a default-false
+	allow_all_reload_class_changes_p parameter.  Do not treat
+	reload moves specially when the parameter is true.
+	(get_reload_reg): Try to narrow the class of an existing OP_OUT
+	reload if we're reloading a reload pseudo in a reload instruction.
+
+2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	Backported from master:
+	2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	* config/bpf/bpf.h (ASM_OUTPUT_ALIGNED_BSS): Use .type and .lcomm.
+
+2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	Backported from master:
+	2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	* config/bpf/bpf.h (FUNCTION_BOUNDARY): Set to 64.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/99929
+	* rtl.h (same_vector_encodings_p): New function.
+	* cse.c (exp_equiv_p): Check that CONST_VECTORs have the same encoding.
+	* cselib.c (rtx_equal_for_cselib_1): Likewise.
+	* jump.c (rtx_renumbered_equal_p): Likewise.
+	* lra-constraints.c (operands_match_p): Likewise.
+	* reload.c (operands_match_p): Likewise.
+	* rtl.c (rtx_equal_p_cb, rtx_equal_p): Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98119
+	* config/aarch64/aarch64.c
+	(aarch64_vectorize_preferred_vector_alignment): Query the size
+	of the provided SVE vector; do not assume that all SVE vectors
+	have the same size.
+
+2021-04-23  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2021-04-07  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/98736
+	* tree-loop-distribution.c
+	* (loop_distribution::bb_top_order_init):
+	Compute RPO with programing order preserved by calling function
+	rev_post_order_and_mark_dfs_back_seme.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-31  Richard Biener  <rguenther@suse.de>
+
+	* cfganal.h (rev_post_order_and_mark_dfs_back_seme): Adjust
+	prototype.
+	* cfganal.c (rpoamdbs_bb_data): New struct with pre BB data.
+	(tag_header): New helper.
+	(cmp_edge_dest_pre): Likewise.
+	(rev_post_order_and_mark_dfs_back_seme): Compute SCCs,
+	find SCC exits and perform a DFS walk with extra edges to
+	compute a RPO with adjacent SCC members when requesting an
+	iteration optimized order and populate the toplevel SCC array.
+	* tree-ssa-sccvn.c (do_rpo_vn): Remove ad-hoc computation
+	of max_rpo and fill it in from SCC extent info instead.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-20  Richard Biener  <rguenther@suse.de>
+
+	* cfganal.c (rev_post_order_and_mark_dfs_back_seme): Remove
+	write-only post array.
+
+2021-04-23  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-04-06  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99748
+	* config/arm/arm.c (arm_libcall_uses_aapcs_base): Also use base
+	PCS for [su]fix_optab.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/99249
+	* config/aarch64/aarch64.c (aarch64_expand_sve_const_vector_sel):
+	New function.
+	(aarch64_expand_sve_const_vector): Use it for nelts_per_pattern==2.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/97141
+	PR rtl-optimization/98726
+	* emit-rtl.c (valid_for_const_vector_p): Return true for
+	CONST_POLY_INT_P.
+	* rtx-vector-builder.h (rtx_vector_builder::step): Return a
+	poly_wide_int instead of a wide_int.
+	(rtx_vector_builder::apply_set): Take a poly_wide_int instead
+	of a wide_int.
+	* rtx-vector-builder.c (rtx_vector_builder::apply_set): Likewise.
+	* config/aarch64/aarch64.c (aarch64_legitimate_constant_p): Return
+	false for CONST_VECTORs that cannot be forced to memory.
+	* config/aarch64/aarch64-simd.md (mov<mode>): If a CONST_VECTOR
+	is too complex to force to memory, build it up from individual
+	elements instead.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-26  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/98726
+	* tree.h (vector_cst_int_elt): Remove.
+	* tree.c (vector_cst_int_elt): Use poly_wide_int for computations,
+	make static.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-30  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98136
+	* config/aarch64/aarch64.md (mov<mode>): Pass multi-instruction
+	CONST_INTs to aarch64_expand_mov_immediate when called after RA.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/98268
+	* gimple-fold.c (maybe_canonicalize_mem_ref_addr): Call
+	recompute_tree_invariant_for_addr_expr after successfully
+	folding a TARGET_MEM_REF that occurs inside an ADDR_EXPR.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/99726
+	* tree-data-ref.c (create_intersect_range_checks_index): Bail
+	out if there is more than one access function SCEV for the loop
+	being versioned.
+
+2021-04-22  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99216
+	* config/aarch64/aarch64-sve-builtins.cc
+	(function_builder::add_function): Add placeholder_p argument, use
+	placeholder decls if this is set.
+	(function_builder::add_unique_function): Instead of conditionally adding
+	direct overloads, unconditionally add either a direct overload or a
+	placeholder.
+	(function_builder::add_overloaded_function): Set placeholder_p if we're
+	using C++ overloads. Use the obstack for string storage instead
+	of relying on the tree nodes.
+	(function_builder::add_overloaded_functions): Don't return early for
+	m_direct_overloads: we need to add placeholders.
+	* config/aarch64/aarch64-sve-builtins.h
+	(function_builder::add_function): Add placeholder_p argument.
+	* lto-streamer.h (LTO_minor_version): Bump.
+
+2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/100148
+	* cprop.c (constprop_register): Use next_nondebug_insn instead of
+	NEXT_INSN.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/99767
+	* tree-vect-loop.c (vect_transform_loop): Don't remove just
+	dead scalar .MASK_LOAD calls, but also dead .COND_* calls - replace
+	them by their last argument.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99905
+	* combine.c (expand_compound_operation): If pos + len > modewidth,
+	perform the right shift by pos in inner_mode and then convert to mode,
+	instead of trying to simplify a shift of rtx with inner_mode by pos
+	as if it was a shift in mode.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/99830
+	* combine.c (simplify_and_const_int_1): Don't optimize varop
+	away if it has side-effects.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/99849
+	* expr.c (expand_expr_addr_expr_1): Test is_global_var rather than
+	just TREE_STATIC on COMPOUND_LITERAL_EXPR_DECLs.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/98601
+	* rtlanal.c (rtx_addr_can_trap_p_1): Allow in assert unknown size
+	not just for BLKmode, but also for VOIDmode.  For STRICT_ALIGNMENT
+	unaligned_mems handle VOIDmode like BLKmode.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99863
+	* dse.c (replace_read): Drop regs_live argument.  Instead of
+	regs_live, use store_insn->fixed_regs_live if non-NULL,
+	otherwise punt if insns sequence clobbers or sets any hard
+	registers.
+
+2021-04-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-11-27  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR c/97880
+	* omp-expand.c (expand_oacc_collapse_init, expand_oacc_collapse_vars):
+	Use now passed diff_type.
+	(expand_oacc_for): Take largest type for diff_type, taking tiling
+	and collapsing into account.
+
+2021-04-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/winnt.c (i386_pe_seh_cold_init): Properly deal with
+	frames larger than the SEH maximum frame size.
+
+2021-04-18  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	Backported from master:
+	2021-04-11  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	PR middle-end/98088
+	* omp-expand.c (expand_oacc_collapse_init): Update condition in
+	a gcc_assert.
+
+2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/100048
+	* config/aarch64/aarch64-sve.md (@aarch64_sve_trn1_conv<mode>): New.
+	* config/aarch64/aarch64.c (aarch64_expand_sve_const_pred_trn): Use new
+	TRN optab.
+	* config/aarch64/iterators.md (UNSPEC_TRN1_CONV): New.
+
+2021-04-08  Richard Biener  <rguenther@suse.de>
+
+	PR lto/99898
+	* lto-streamer.h (LTO_minor_version): Bump.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 86fd883487b..277fbcd6a15 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,64 @@
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (validate_size): Do not issue an error if the
+	old size has overflowed.
+
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity): For vector types, make
+	the representative array the debug type.
+
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (update_pointer_to): Set TYPE_CANONICAL on
+	pointer and reference types.
+
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (can_materialize_object_renaming_p): Do not
+	call UI_Is_In_Int_Range on the result of Normalized_First_Bit.
+
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <is_type>: Declare new
+	constant.  Adjust error message issued by validate_size in the case
+	of by-reference types.
+	(validate_size): Always use the error strings passed by the caller.
+
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* freeze.adb (Check_Strict_Alignment): Do not set the flag for
+	a bit-packed array type, even if it is a by-reference type.
+
+2021-07-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (finish_subprog_decl): Remove obsolete line.
+
+2021-05-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Process
+	the implementation type of a packed type implemented specially.
+
+2021-05-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_subprog_type): Always translate
+	the Is_Pure flag into the "pure" attribute of GNU C.
+
+2021-05-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (gnat_to_gnu) <N_Simple_Return_Statement>:
+	Put a SLOC on the assignment from the return value to the return
+	object in the copy-in/copy-out case.
+
+2021-04-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/misc.c (gnat_init): Set default range bits to 0.
+	* gcc-interface/trans.c (extract_encoding): Delete.
+	(decode_name): Likewise.
+	(File_Name_to_gnu): New function.
+	(gigi): Call it to translate file names.  Replace assertion on
+	1-1 mapping between files and line maps with conditional error.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/ada/freeze.adb b/gcc/ada/freeze.adb
index 0312ca704aa..458e1b4d3c2 100644
--- a/gcc/ada/freeze.adb
+++ b/gcc/ada/freeze.adb
@@ -1610,7 +1610,10 @@ package body Freeze is
       Comp  : Entity_Id;
 
    begin
-      if Is_By_Reference_Type (E) then
+      --  Bit-packed array types do not require strict alignment, even if they
+      --  are by-reference types, because they are accessed in a special way.
+
+      if Is_By_Reference_Type (E) and then not Is_Bit_Packed_Array (E) then
          Set_Strict_Alignment (E);
 
       elsif Is_Array_Type (E) then
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
index 300f7c04b0c..8b221bc1363 100644
--- a/gcc/ada/gcc-interface/decl.c
+++ b/gcc/ada/gcc-interface/decl.c
@@ -2322,11 +2322,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	      set_nonaliased_component_on_array_type (tem);
 	  }
 
-	/* If an alignment is specified, use it if valid.  But ignore it
-	   for the original type of packed array types.  If the alignment
-	   was requested with an explicit alignment clause, state so.  */
-	if (No (Packed_Array_Impl_Type (gnat_entity))
-	    && Known_Alignment (gnat_entity))
+	/* If this is a packed type implemented specially, then process the
+	   implementation type so it is elaborated in the proper scope.  */
+	if (Present (Packed_Array_Impl_Type (gnat_entity)))
+	  gnat_to_gnu_entity (Packed_Array_Impl_Type (gnat_entity), NULL_TREE,
+			      false);
+
+	/* Otherwise, if an alignment is specified, use it if valid and, if
+	   the alignment was requested with an explicit clause, state so.  */
+	else if (Known_Alignment (gnat_entity))
 	  {
 	    SET_TYPE_ALIGN (tem,
 			    validate_alignment (Alignment (gnat_entity),
@@ -4253,6 +4257,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
      handling alignment and possible padding.  */
   if (is_type && (!gnu_decl || this_made_decl))
     {
+      const bool is_by_ref = Is_By_Reference_Type (gnat_entity);
+
       gcc_assert (!TYPE_IS_DUMMY_P (gnu_type));
 
       /* Process the attributes, if not already done.  Note that the type is
@@ -4267,15 +4273,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	 non-constant).  */
       if (!gnu_size && kind != E_String_Literal_Subtype)
 	{
+	  const char *size_s = "size for %s too small{, minimum allowed is ^}";
+	  const char *type_s = is_by_ref ? "by-reference type &" : "&";
+
 	  if (Known_Esize (gnat_entity))
 	    gnu_size
 	      = validate_size (Esize (gnat_entity), gnu_type, gnat_entity,
-			       VAR_DECL, false, false, NULL, NULL);
+			       VAR_DECL, false, false, size_s, type_s);
 	  else
 	    gnu_size
 	      = validate_size (RM_Size (gnat_entity), gnu_type, gnat_entity,
 			       TYPE_DECL, false, Has_Size_Clause (gnat_entity),
-			       NULL, NULL);
+			       size_s, type_s);
 	}
 
       /* If a size was specified, see if we can make a new type of that size
@@ -4578,7 +4587,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	    TYPE_ALIGN_OK (gnu_type) = 1;
 
 	  /* Record whether the type is passed by reference.  */
-	  if (Is_By_Reference_Type (gnat_entity) && !VOID_TYPE_P (gnu_type))
+	  if (is_by_ref && !VOID_TYPE_P (gnu_type))
 	    TYPE_BY_REFERENCE_P (gnu_type) = 1;
 
 	  /* Record whether an alignment clause was specified.  */
@@ -4698,6 +4707,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
       else
 	gnu_decl = create_type_decl (gnu_entity_name, gnu_type, artificial_p,
 				     debug_info_p, gnat_entity);
+
+      /* For vector types, make the representative array the debug type.  */
+      if (VECTOR_TYPE_P (gnu_type))
+	{
+	  tree rep = TYPE_REPRESENTATIVE_ARRAY (gnu_type);
+	  TYPE_NAME (rep) = DECL_NAME (gnu_decl);
+	  SET_TYPE_DEBUG_TYPE (gnu_type, rep);
+	}
     }
 
   /* Otherwise, for a type reusing an existing DECL, back-annotate values.  */
@@ -5719,16 +5736,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,
   tree gnu_cico_return_type = NULL_TREE;
   tree gnu_cico_field_list = NULL_TREE;
   bool gnu_cico_only_integral_type = true;
-  /* The semantics of "pure" in Ada essentially matches that of "const"
-     or "pure" in GCC.  In particular, both properties are orthogonal
-     to the "nothrow" property if the EH circuitry is explicit in the
-     internal representation of the middle-end.  If we are to completely
-     hide the EH circuitry from it, we need to declare that calls to pure
-     Ada subprograms that can throw have side effects since they can
-     trigger an "abnormal" transfer of control flow; therefore, they can
-     be neither "const" nor "pure" in the GCC sense.  */
-  bool const_flag = (Back_End_Exceptions () && Is_Pure (gnat_subprog));
-  bool pure_flag = false;
+  /* Although the semantics of "pure" units in Ada essentially match those of
+     "const" in GNU C, the semantics of the Is_Pure flag in GNAT do not say
+     anything about access to global memory, that's why it needs to be mapped
+     to "pure" instead of "const" in GNU C.  The property is orthogonal to the
+     "nothrow" property only if the EH circuitry is explicit in the internal
+     representation of the middle-end: if we are to completely hide the EH
+     circuitry from it, we need to declare that calls to pure Ada subprograms
+     that can throw have side effects, since they can trigger an "abnormal"
+     transfer of control; therefore they cannot be "pure" in the GCC sense.  */
+  bool pure_flag = Is_Pure (gnat_subprog) && Back_End_Exceptions ();
   bool return_by_direct_ref_p = false;
   bool return_by_invisi_ref_p = false;
   bool return_unconstrained_p = false;
@@ -5881,14 +5898,14 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,
     }
 
   /* A procedure (something that doesn't return anything) shouldn't be
-     considered const since there would be no reason for calling such a
+     considered pure since there would be no reason for calling such a
      subprogram.  Note that procedures with Out (or In Out) parameters
      have already been converted into a function with a return type.
      Similarly, if the function returns an unconstrained type, then the
      function will allocate the return value on the secondary stack and
      thus calls to it cannot be CSE'ed, lest the stack be reclaimed.  */
   if (VOID_TYPE_P (gnu_return_type) || return_unconstrained_p)
-    const_flag = false;
+    pure_flag = false;
 
   /* Loop over the parameters and get their associated GCC tree.  While doing
      this, build a copy-in copy-out structure if we need one.  */
@@ -6011,18 +6028,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,
 	  save_gnu_tree (gnat_param, gnu_param, false);
 
 	  /* A pure function in the Ada sense which takes an access parameter
-	     may modify memory through it and thus need be considered neither
-	     const nor pure in the GCC sense.  Likewise it if takes a by-ref
-	     In Out or Out parameter.  But if it takes a by-ref In parameter,
-	     then it may only read memory through it and can be considered
-	     pure in the GCC sense.  */
-	  if ((const_flag || pure_flag)
-	      && (POINTER_TYPE_P (gnu_param_type)
+	     may modify memory through it and thus cannot be considered pure
+	     in the GCC sense, unless it's access-to-function.  Likewise it if
+	     takes a by-ref In Out or Out parameter.  But if it takes a by-ref
+	     In parameter, then it may only read memory through it and can be
+	     considered pure in the GCC sense.  */
+	  if (pure_flag
+	      && ((POINTER_TYPE_P (gnu_param_type)
+		   && TREE_CODE (TREE_TYPE (gnu_param_type)) != FUNCTION_TYPE)
 		  || TYPE_IS_FAT_POINTER_P (gnu_param_type)))
-	    {
-	      const_flag = false;
-	      pure_flag = DECL_POINTS_TO_READONLY_P (gnu_param);
-	    }
+	    pure_flag = DECL_POINTS_TO_READONLY_P (gnu_param);
 	}
 
       /* If the parameter uses the copy-in copy-out mechanism, allocate a field
@@ -6221,9 +6236,6 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,
 	    }
 	}
 
-      if (const_flag)
-	gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_CONST);
-
       if (pure_flag)
 	gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_RESTRICT);
 
@@ -9032,13 +9044,12 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,
   /* Issue an error either if the default size of the object isn't a constant
      or if the new size is smaller than it.  */
   if (TREE_CODE (old_size) != INTEGER_CST
-      || TREE_OVERFLOW (old_size)
-      || tree_int_cst_lt (size, old_size))
+      || (!TREE_OVERFLOW (old_size) && tree_int_cst_lt (size, old_size)))
     {
       char buf[128];
       const char *s;
 
-      if (kind == FIELD_DECL)
+      if (s1 && s2)
 	{
 	  snprintf (buf, sizeof (buf), s1, s2);
 	  s = buf;
@@ -9047,6 +9058,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,
 	s = "component size for& too small{, minimum allowed is ^}";
       else
 	s = "size for& too small{, minimum allowed is ^}";
+
       post_error_ne_tree (s, gnat_error_node, gnat_object, old_size);
 
       return NULL_TREE;
diff --git a/gcc/ada/gcc-interface/misc.c b/gcc/ada/gcc-interface/misc.c
index d68b37384ff..775ab190515 100644
--- a/gcc/ada/gcc-interface/misc.c
+++ b/gcc/ada/gcc-interface/misc.c
@@ -366,6 +366,9 @@ gnat_init (void)
   sbitsize_one_node = sbitsize_int (1);
   sbitsize_unit_node = sbitsize_int (BITS_PER_UNIT);
 
+  /* In Ada, we do not use location ranges.  */
+  line_table->default_range_bits = 0;
+
   /* Register our internal error function.  */
   global_dc->internal_error = &internal_error_function;
 
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
index 7ecf321c250..334324152f8 100644
--- a/gcc/ada/gcc-interface/trans.c
+++ b/gcc/ada/gcc-interface/trans.c
@@ -252,17 +252,27 @@ static tree build_raise_check (int, enum exception_info_kind);
 static tree create_init_temporary (const char *, tree, tree *, Node_Id);
 static bool maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk);
 
-/* Hooks for debug info back-ends, only supported and used in a restricted set
-   of configurations.  */
-static const char *extract_encoding (const char *) ATTRIBUTE_UNUSED;
-static const char *decode_name (const char *) ATTRIBUTE_UNUSED;
-
 /* This makes gigi's file_info_ptr visible in this translation unit,
    so that Sloc_to_locus can look it up when deciding whether to map
    decls to instances.  */
 
 static struct File_Info_Type *file_map;
 
+/* Return the string of the identifier allocated for the file name Id.  */
+
+static const char*
+File_Name_to_gnu (Name_Id Id)
+{
+  /* __gnat_to_canonical_file_spec translates file names from pragmas
+     Source_Reference that contain host style syntax not understood by GDB.  */
+  const char *name = __gnat_to_canonical_file_spec (Get_Name_String (Id));
+
+  /* Use the identifier table to make a permanent copy of the file name as
+     the name table gets reallocated after Gigi returns but before all the
+     debugging information is output.  */
+  return IDENTIFIER_POINTER (get_identifier (name));
+}
+
 /* This is the main program of the back-end.  It sets up all the table
    structures and then generates code.  */
 
@@ -316,23 +326,18 @@ gigi (Node_Id gnat_root,
 
   for (i = 0; i < number_file; i++)
     {
-      /* Use the identifier table to make a permanent copy of the filename as
-	 the name table gets reallocated after Gigi returns but before all the
-	 debugging information is output.  The __gnat_to_canonical_file_spec
-	 call translates filenames from pragmas Source_Reference that contain
-	 host style syntax not understood by gdb.  */
-      const char *filename
-	= IDENTIFIER_POINTER
-	   (get_identifier
-	    (__gnat_to_canonical_file_spec
-	     (Get_Name_String (file_info_ptr[i].File_Name))));
-
       /* We rely on the order isomorphism between files and line maps.  */
-      gcc_assert ((int) LINEMAPS_ORDINARY_USED (line_table) == i);
+      if ((int) LINEMAPS_ORDINARY_USED (line_table) != i)
+	{
+	  gcc_assert (i > 0);
+	  error ("%s contains too many lines",
+		 File_Name_to_gnu (file_info_ptr[i - 1].File_Name));
+	}
 
       /* We create the line map for a source file at once, with a fixed number
 	 of columns chosen to avoid jumping over the next power of 2.  */
-      linemap_add (line_table, LC_ENTER, 0, filename, 1);
+      linemap_add (line_table, LC_ENTER, 0,
+		   File_Name_to_gnu (file_info_ptr[i].File_Name), 1);
       linemap_line_start (line_table, file_info_ptr[i].Num_Source_Lines, 252);
       linemap_position_for_column (line_table, 252 - 1);
       linemap_add (line_table, LC_LEAVE, 0, NULL, 0);
@@ -8084,8 +8089,10 @@ gnat_to_gnu (Node_Id gnat_node)
 	if (gnu_return_label_stack->last ())
 	  {
 	    if (gnu_ret_val)
-	      add_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_ret_obj,
-					 gnu_ret_val));
+	      add_stmt_with_node (build_binary_op (MODIFY_EXPR,
+						   NULL_TREE, gnu_ret_obj,
+						   gnu_ret_val),
+				  gnat_node);
 
 	    gnu_result = build1 (GOTO_EXPR, void_type_node,
 				 gnu_return_label_stack->last ());
@@ -10976,28 +10983,7 @@ set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)
       return false;
     }
 }
-
-/* Return a colon-separated list of encodings contained in encoded Ada
-   name.  */
-
-static const char *
-extract_encoding (const char *name)
-{
-  char *encoding = (char *) ggc_alloc_atomic (strlen (name));
-  get_encoding (name, encoding);
-  return encoding;
-}
 
-/* Extract the Ada name from an encoded name.  */
-
-static const char *
-decode_name (const char *name)
-{
-  char *decoded = (char *) ggc_alloc_atomic (strlen (name) * 2 + 60);
-  __gnat_decode (name, decoded, 0);
-  return decoded;
-}
-
 /* Post an error message.  MSG is the error message, properly annotated.
    NODE is the node at which to post the error and the node to use for the
    '&' substitution.  */
diff --git a/gcc/ada/gcc-interface/utils.c b/gcc/ada/gcc-interface/utils.c
index 63a0ad9461e..db78c6e8eb3 100644
--- a/gcc/ada/gcc-interface/utils.c
+++ b/gcc/ada/gcc-interface/utils.c
@@ -3438,9 +3438,6 @@ finish_subprog_decl (tree decl, tree asm_name, tree type)
   DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);
   DECL_RESULT (decl) = result_decl;
 
-  /* Propagate the "const" property.  */
-  TREE_READONLY (decl) = TYPE_READONLY (type);
-
   /* Propagate the "pure" property.  */
   DECL_PURE_P (decl) = TYPE_RESTRICT (type);
 
@@ -4233,6 +4230,7 @@ update_pointer_to (tree old_type, tree new_type)
 	    TREE_TYPE (t) = new_type;
 	    if (TYPE_NULL_BOUNDS (t))
 	      TREE_TYPE (TREE_OPERAND (TYPE_NULL_BOUNDS (t), 0)) = new_type;
+	    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_POINTER_TO (new_type));
 	  }
 
       /* Chain REF and its variants at the end.  */
@@ -4249,7 +4247,10 @@ update_pointer_to (tree old_type, tree new_type)
       /* Now adjust them.  */
       for (; ref; ref = TYPE_NEXT_REF_TO (ref))
 	for (t = TYPE_MAIN_VARIANT (ref); t; t = TYPE_NEXT_VARIANT (t))
-	  TREE_TYPE (t) = new_type;
+	  {
+	    TREE_TYPE (t) = new_type;
+	    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_REFERENCE_TO (new_type));
+	  }
 
       TYPE_POINTER_TO (old_type) = NULL_TREE;
       TYPE_REFERENCE_TO (old_type) = NULL_TREE;
@@ -5762,8 +5763,7 @@ can_materialize_object_renaming_p (Node_Id expr)
 
 	    const Uint bitpos
 	      = Normalized_First_Bit (Entity (Selector_Name (expr)));
-	    if (!UI_Is_In_Int_Range (bitpos)
-		|| (bitpos != UI_No_Uint && bitpos != UI_From_Int (0)))
+	    if (bitpos != UI_No_Uint && bitpos != Uint_0)
 	      return false;
 
 	    expr = Prefix (expr);
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index ecd1741df24..8fd5fa92b1a 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,12 @@
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/99990
+	* c-decl.c (finish_decl): Don't overwrite TREE_TYPE of
+	error_mark_node.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index b3e05be0af8..8e24b522ee4 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -5320,7 +5320,7 @@ finish_decl (tree decl, location_t init_loc, tree init,
 	  gcc_unreachable ();
 	}
 
-      if (DECL_INITIAL (decl))
+      if (DECL_INITIAL (decl) && DECL_INITIAL (decl) != error_mark_node)
 	TREE_TYPE (DECL_INITIAL (decl)) = type;
 
       relayout_decl (decl);
diff --git a/gcc/calls.c b/gcc/calls.c
index 26894342c21..45c137cee1e 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -2112,6 +2112,11 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)
 	}
       else
 	{
+	  /* If the size cannot be determined clear it to keep it from
+	     being taken as real (and excessive).  */
+	  if (objsize && integer_all_onesp (objsize))
+	    objsize = NULL_TREE;
+
 	  /* For read-only and read-write attributes also set the source
 	     size.  */
 	  srcsize = objsize;
diff --git a/gcc/cfganal.c b/gcc/cfganal.c
index 395b810262a..24ae41bcac5 100644
--- a/gcc/cfganal.c
+++ b/gcc/cfganal.c
@@ -1060,113 +1060,389 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,
   return pre_order_num;
 }
 
-/* Unlike pre_and_rev_post_order_compute we fill rev_post_order backwards
-   so iterating in RPO order needs to start with rev_post_order[n - 1]
-   going to rev_post_order[0].  If FOR_ITERATION is true then try to
-   make CFG cycles fit into small contiguous regions of the RPO order.
-   When FOR_ITERATION is true this requires up-to-date loop structures.  */
+
+/* Per basic-block data for rev_post_order_and_mark_dfs_back_seme,
+   element of a sparsely populated array indexed by basic-block number.  */
+typedef auto_vec<int, 2> scc_exit_vec_t;
+struct rpoamdbs_bb_data {
+    int depth;
+    int bb_to_pre;
+    /* The basic-block index of the SCC entry of the block visited first
+       (the SCC leader).  */
+    int scc;
+    /* The index into the RPO array where the blocks SCC entries end
+       (only valid for the SCC leader).  */
+    int scc_end;
+    /* The indexes of the exits destinations of this SCC (only valid
+       for the SCC leader).  Initialized upon discovery of SCC leaders.  */
+    scc_exit_vec_t scc_exits;
+};
+
+/* Tag H as a header of B, weaving H and its loop header list into the
+   current loop header list of B.  */
+
+static void
+tag_header (int b, int h, rpoamdbs_bb_data *bb_data)
+{
+  if (h == -1 || b == h)
+    return;
+  int cur1 = b;
+  int cur2 = h;
+  while (bb_data[cur1].scc != -1)
+    {
+      int ih = bb_data[cur1].scc;
+      if (ih == cur2)
+	return;
+      if (bb_data[ih].depth < bb_data[cur2].depth)
+	{
+	  bb_data[cur1].scc = cur2;
+	  cur1 = cur2;
+	  cur2 = ih;
+	}
+      else
+	cur1 = ih;
+    }
+  bb_data[cur1].scc = cur2;
+}
+
+/* Comparator for a sort of two edges destinations E1 and E2 after their index
+   in the PRE array as specified by BB_TO_PRE.  */
+
+static int
+cmp_edge_dest_pre (const void *e1_, const void *e2_, void *data_)
+{
+  const int *e1 = (const int *)e1_;
+  const int *e2 = (const int *)e2_;
+  rpoamdbs_bb_data *bb_data = (rpoamdbs_bb_data *)data_;
+  return (bb_data[*e1].bb_to_pre - bb_data[*e2].bb_to_pre);
+}
+
+/* Compute the reverse completion number of a depth first search
+   on the SEME region denoted by the ENTRY edge and the EXIT_BBS set of
+   exit block indexes and store it in the array REV_POST_ORDER.
+   Also sets the EDGE_DFS_BACK edge flags according to this visitation
+   order.
+   Returns the number of nodes visited.
+
+   In case the function has unreachable blocks the number of nodes
+   visited does not include them.
+
+   If FOR_ITERATION is true then compute an RPO where SCCs form a
+   contiguous region in the RPO array.
+   *TOPLEVEL_SCC_EXTENTS if not NULL is filled with pairs of
+   *REV_POST_ORDER indexes denoting extents of the toplevel SCCs in
+   this region.  */
 
 int
 rev_post_order_and_mark_dfs_back_seme (struct function *fn, edge entry,
 				       bitmap exit_bbs, bool for_iteration,
-				       int *rev_post_order)
+				       int *rev_post_order,
+				       vec<std::pair<int, int> >
+					 *toplevel_scc_extents)
 {
-  int pre_order_num = 0;
   int rev_post_order_num = 0;
 
-  /* Allocate stack for back-tracking up CFG.  Worst case we need
-     O(n^2) edges but the following should suffice in practice without
-     a need to re-allocate.  */
-  auto_vec<edge, 20> stack (2 * n_basic_blocks_for_fn (fn));
-
-  int *pre = XNEWVEC (int, 2 * last_basic_block_for_fn (fn));
-  int *post = pre + last_basic_block_for_fn (fn);
-
   /* BB flag to track nodes that have been visited.  */
   auto_bb_flag visited (fn);
-  /* BB flag to track which nodes have post[] assigned to avoid
-     zeroing post.  */
-  auto_bb_flag post_assigned (fn);
-
-  /* Push the first edge on to the stack.  */
-  stack.quick_push (entry);
 
-  while (!stack.is_empty ())
-    {
-      basic_block src;
-      basic_block dest;
+  /* Lazily initialized per-BB data for the two DFS walks below.  */
+  rpoamdbs_bb_data *bb_data
+    = XNEWVEC (rpoamdbs_bb_data, last_basic_block_for_fn (fn));
 
-      /* Look at the edge on the top of the stack.  */
-      int idx = stack.length () - 1;
-      edge e = stack[idx];
-      src = e->src;
-      dest = e->dest;
-      e->flags &= ~EDGE_DFS_BACK;
+  /* First DFS walk, loop discovery according to
+      A New Algorithm for Identifying Loops in Decompilation
+     by Tao Wei, Jian Mao, Wei Zou and You Chen of the Institute of
+     Computer Science and Technology of the Peking University.  */
+  auto_vec<edge_iterator, 20> ei_stack (n_basic_blocks_for_fn (fn) + 1);
+  auto_bb_flag is_header (fn);
+  int depth = 1;
+  unsigned n_sccs = 0;
 
-      /* Check if the edge destination has been visited yet.  */
-      if (! bitmap_bit_p (exit_bbs, dest->index)
-	  && ! (dest->flags & visited))
+  basic_block dest = entry->dest;
+  edge_iterator ei;
+  int pre_num = 0;
+
+  /* DFS process DEST.  */
+find_loops:
+  bb_data[dest->index].bb_to_pre = pre_num++;
+  bb_data[dest->index].depth = depth;
+  bb_data[dest->index].scc = -1;
+  depth++;
+  gcc_assert ((dest->flags & (is_header|visited)) == 0);
+  dest->flags |= visited;
+  ei = ei_start (dest->succs);
+  while (!ei_end_p (ei))
+    {
+      ei_edge (ei)->flags &= ~EDGE_DFS_BACK;
+      if (bitmap_bit_p (exit_bbs, ei_edge (ei)->dest->index))
+	;
+      else if (!(ei_edge (ei)->dest->flags & visited))
 	{
-	  /* Mark that we have visited the destination.  */
-	  dest->flags |= visited;
-
-	  pre[dest->index] = pre_order_num++;
-
-	  if (EDGE_COUNT (dest->succs) > 0)
+	  ei_stack.quick_push (ei);
+	  dest = ei_edge (ei)->dest;
+	  /* DFS recurse on DEST.  */
+	  goto find_loops;
+
+ret_from_find_loops:
+	  /* Return point of DFS recursion.  */
+	  ei = ei_stack.pop ();
+	  dest = ei_edge (ei)->src;
+	  int header = bb_data[ei_edge (ei)->dest->index].scc;
+	  tag_header (dest->index, header, bb_data);
+	  depth = bb_data[dest->index].depth + 1;
+	}
+      else
+	{
+	  if (bb_data[ei_edge (ei)->dest->index].depth > 0) /* on the stack */
 	    {
-	      /* Since the DEST node has been visited for the first
-		 time, check its successors.  */
-	      /* Push the edge vector in reverse to match previous behavior.  */
-	      stack.reserve (EDGE_COUNT (dest->succs));
-	      for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)
-		stack.quick_push (EDGE_SUCC (dest, i));
-	      /* Generalize to handle more successors?  */
-	      if (for_iteration
-		  && EDGE_COUNT (dest->succs) == 2)
-		{
-		  edge &e1 = stack[stack.length () - 2];
-		  if (loop_exit_edge_p (e1->src->loop_father, e1))
-		    std::swap (e1, stack.last ());
-		}
+	      ei_edge (ei)->flags |= EDGE_DFS_BACK;
+	      n_sccs++;
+	      ei_edge (ei)->dest->flags |= is_header;
+	      ::new (&bb_data[ei_edge (ei)->dest->index].scc_exits)
+		auto_vec<int, 2> ();
+	      tag_header (dest->index, ei_edge (ei)->dest->index, bb_data);
 	    }
+	  else if (bb_data[ei_edge (ei)->dest->index].scc == -1)
+	    ;
 	  else
 	    {
-	      /* There are no successors for the DEST node so assign
-		 its reverse completion number.  */
-	      post[dest->index] = rev_post_order_num;
-	      dest->flags |= post_assigned;
-	      rev_post_order[rev_post_order_num] = dest->index;
-	      rev_post_order_num++;
+	      int header = bb_data[ei_edge (ei)->dest->index].scc;
+	      if (bb_data[header].depth > 0)
+		tag_header (dest->index, header, bb_data);
+	      else
+		{
+		  /* A re-entry into an existing loop.  */
+		  /* ???  Need to mark is_header?  */
+		  while (bb_data[header].scc != -1)
+		    {
+		      header = bb_data[header].scc;
+		      if (bb_data[header].depth > 0)
+			{
+			  tag_header (dest->index, header, bb_data);
+			  break;
+			}
+		    }
+		}
 	    }
 	}
-      else
-	{
-	  if (dest->flags & visited
-	      && src != entry->src
-	      && pre[src->index] >= pre[dest->index]
-	      && !(dest->flags & post_assigned))
-	    e->flags |= EDGE_DFS_BACK;
+      ei_next (&ei);
+    }
+  rev_post_order[rev_post_order_num++] = dest->index;
+  /* not on the stack anymore */
+  bb_data[dest->index].depth = -bb_data[dest->index].depth;
+  if (!ei_stack.is_empty ())
+    /* Return from DFS recursion.  */
+    goto ret_from_find_loops;
+
+  /* Optimize for no SCCs found or !for_iteration.  */
+  if (n_sccs == 0 || !for_iteration)
+    {
+      /* Clear the temporarily allocated flags.  */
+      for (int i = 0; i < rev_post_order_num; ++i)
+	BASIC_BLOCK_FOR_FN (fn, rev_post_order[i])->flags
+	  &= ~(is_header|visited);
+      /* And swap elements.  */
+      for (int i = 0; i < rev_post_order_num/2; ++i)
+	std::swap (rev_post_order[i], rev_post_order[rev_post_order_num-i-1]);
+      XDELETEVEC (bb_data);
+
+      return rev_post_order_num;
+    }
 
-	  if (idx != 0 && stack[idx - 1]->src != src)
+  /* Next find SCC exits, clear the visited flag and compute an upper bound
+     for the edge stack below.  */
+  unsigned edge_count = 0;
+  for (int i = 0; i < rev_post_order_num; ++i)
+    {
+      int bb = rev_post_order[i];
+      BASIC_BLOCK_FOR_FN (fn, bb)->flags &= ~visited;
+      edge e;
+      FOR_EACH_EDGE (e, ei, BASIC_BLOCK_FOR_FN (fn, bb)->succs)
+	{
+	  if (bitmap_bit_p (exit_bbs, e->dest->index))
+	    continue;
+	  edge_count++;
+	  /* if e is an exit from e->src, record it for
+	     bb_data[e->src].scc.  */
+	  int src_scc = e->src->index;
+	  if (!(e->src->flags & is_header))
+	    src_scc = bb_data[src_scc].scc;
+	  if (src_scc == -1)
+	    continue;
+	  int dest_scc = e->dest->index;
+	  if (!(e->dest->flags & is_header))
+	    dest_scc = bb_data[dest_scc].scc;
+	  if (src_scc == dest_scc)
+	    continue;
+	  /* When dest_scc is nested insde src_scc it's not an
+	     exit.  */
+	  int tem_dest_scc = dest_scc;
+	  unsigned dest_scc_depth = 0;
+	  while (tem_dest_scc != -1)
 	    {
-	      /* There are no more successors for the SRC node
-		 so assign its reverse completion number.  */
-	      post[src->index] = rev_post_order_num;
-	      src->flags |= post_assigned;
-	      rev_post_order[rev_post_order_num] = src->index;
-	      rev_post_order_num++;
+	      dest_scc_depth++;
+	      if ((tem_dest_scc = bb_data[tem_dest_scc].scc) == src_scc)
+		break;
+	    }
+	  if (tem_dest_scc != -1)
+	    continue;
+	  /* When src_scc is nested inside dest_scc record an
+	     exit from the outermost SCC this edge exits.  */
+	  int tem_src_scc = src_scc;
+	  unsigned src_scc_depth = 0;
+	  while (tem_src_scc != -1)
+	    {
+	      if (bb_data[tem_src_scc].scc == dest_scc)
+		{
+		  edge_count++;
+		  bb_data[tem_src_scc].scc_exits.safe_push (e->dest->index);
+		  break;
+		}
+	      tem_src_scc = bb_data[tem_src_scc].scc;
+	      src_scc_depth++;
+	    }
+	  /* Else find the outermost SCC this edge exits (exits
+	     from the inner SCCs are not important for the DFS
+	     walk adjustment).  Do so by computing the common
+	     ancestor SCC where the immediate child it to the source
+	     SCC is the exited SCC.  */
+	  if (tem_src_scc == -1)
+	    {
+	      edge_count++;
+	      while (src_scc_depth > dest_scc_depth)
+		{
+		  src_scc = bb_data[src_scc].scc;
+		  src_scc_depth--;
+		}
+	      while (dest_scc_depth > src_scc_depth)
+		{
+		  dest_scc = bb_data[dest_scc].scc;
+		  dest_scc_depth--;
+		}
+	      while (bb_data[src_scc].scc != bb_data[dest_scc].scc)
+		{
+		  src_scc = bb_data[src_scc].scc;
+		  dest_scc = bb_data[dest_scc].scc;
+		}
+	      bb_data[src_scc].scc_exits.safe_push (e->dest->index);
 	    }
-
-	  stack.pop ();
 	}
     }
 
-  XDELETEVEC (pre);
+  /* Now the second DFS walk to compute a RPO where the extent of SCCs
+     is minimized thus SCC members are adjacent in the RPO array.
+     This is done by performing a DFS walk computing RPO with first visiting
+     extra direct edges from SCC entry to its exits.
+     That simulates a DFS walk over the graph with SCCs collapsed and
+     walking the SCCs themselves only when all outgoing edges from the
+     SCCs have been visited.
+     SCC_END[scc-header-index] is the position in the RPO array of the
+     last member of the SCC.  */
+  auto_vec<std::pair<basic_block, basic_block>, 20> estack (edge_count + 1);
+  int idx = rev_post_order_num;
+  basic_block edest;
+  dest = entry->dest;
+
+  /* DFS process DEST.  */
+dfs_rpo:
+  gcc_checking_assert ((dest->flags & visited) == 0);
+  /* Verify we enter SCCs through the same header and SCC nesting appears
+     the same.  */
+  gcc_assert (bb_data[dest->index].scc == -1
+	      || (BASIC_BLOCK_FOR_FN (fn, bb_data[dest->index].scc)->flags
+		  & visited));
+  dest->flags |= visited;
+  bb_data[dest->index].scc_end = -1;
+  if ((dest->flags & is_header)
+      && !bb_data[dest->index].scc_exits.is_empty ())
+    {
+      /* Push the all SCC exits as outgoing edges from its header to
+	 be visited first.
+	 To process exits in the same relative order as in the first
+	 DFS walk sort them after their destination PRE order index.  */
+      gcc_sort_r (&bb_data[dest->index].scc_exits[0],
+		  bb_data[dest->index].scc_exits.length (),
+		  sizeof (int), cmp_edge_dest_pre, bb_data);
+      /* Process edges in reverse to match previous DFS walk order.  */
+      for (int i = bb_data[dest->index].scc_exits.length () - 1; i >= 0; --i)
+	estack.quick_push (std::make_pair
+	  (dest, BASIC_BLOCK_FOR_FN (fn, bb_data[dest->index].scc_exits[i])));
+    }
+  else
+    {
+      if (dest->flags & is_header)
+	bb_data[dest->index].scc_end = idx - 1;
+      /* Push the edge vector in reverse to match the iteration order
+	 from the DFS walk above.  */
+      for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)
+	if (!bitmap_bit_p (exit_bbs, EDGE_SUCC (dest, i)->dest->index))
+	  estack.quick_push (std::make_pair (dest,
+					     EDGE_SUCC (dest, i)->dest));
+    }
+  while (!estack.is_empty ()
+	 && estack.last ().first == dest)
+    {
+      edest = estack.last ().second;
+      if (!(edest->flags & visited))
+	{
+	  dest = edest;
+	  /* DFS recurse on DEST.  */
+	  goto dfs_rpo;
 
-  /* Clear the temporarily allocated flags.  */
+ret_from_dfs_rpo:
+	  /* Return point of DFS recursion.  */
+	  dest = estack.last ().first;
+	}
+      estack.pop ();
+      /* If we processed all SCC exits from DEST mark the SCC end
+	 since all RPO entries up to DEST itself will now belong
+	 to its SCC.  The special-case of no SCC exits is already
+	 dealt with above.  */
+      if (dest->flags & is_header
+	  /* When the last exit edge was processed mark the SCC end
+	     and push the regular edges.  */
+	  && bb_data[dest->index].scc_end == -1
+	  && (estack.is_empty ()
+	      || estack.last ().first != dest))
+	{
+	  bb_data[dest->index].scc_end = idx - 1;
+	  /* Push the edge vector in reverse to match the iteration order
+	     from the DFS walk above.  */
+	  for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)
+	    if (!bitmap_bit_p (exit_bbs, EDGE_SUCC (dest, i)->dest->index))
+	      estack.quick_push (std::make_pair (dest,
+						 EDGE_SUCC (dest, i)->dest));
+	}
+    }
+  rev_post_order[--idx] = dest->index;
+  if (!estack.is_empty ())
+    /* Return from DFS recursion.  */
+    goto ret_from_dfs_rpo;
+
+  /* Each SCC extends are from the position of the header inside
+     the RPO array up to RPO array index scc_end[header-index].  */
+  if (toplevel_scc_extents)
+    for (int i = 0; i < rev_post_order_num; i++)
+      {
+	basic_block bb = BASIC_BLOCK_FOR_FN (fn, rev_post_order[i]);
+	if (bb->flags & is_header)
+	  {
+	    toplevel_scc_extents->safe_push
+	      (std::make_pair (i, bb_data[bb->index].scc_end));
+	    i = bb_data[bb->index].scc_end;
+	  }
+      }
+
+  /* Clear the temporarily allocated flags and free memory.  */
   for (int i = 0; i < rev_post_order_num; ++i)
-    BASIC_BLOCK_FOR_FN (fn, rev_post_order[i])->flags
-      &= ~(post_assigned|visited);
+    {
+      basic_block bb = BASIC_BLOCK_FOR_FN (fn, rev_post_order[i]);
+      if (bb->flags & is_header)
+	bb_data[bb->index].scc_exits.~scc_exit_vec_t ();
+      bb->flags &= ~(visited|is_header);
+    }
+
+  XDELETEVEC (bb_data);
 
   return rev_post_order_num;
 }
diff --git a/gcc/cfganal.h b/gcc/cfganal.h
index 849e537eddb..06830b7f469 100644
--- a/gcc/cfganal.h
+++ b/gcc/cfganal.h
@@ -68,7 +68,8 @@ extern int pre_and_rev_post_order_compute_fn (struct function *,
 					      int *, int *, bool);
 extern int pre_and_rev_post_order_compute (int *, int *, bool);
 extern int rev_post_order_and_mark_dfs_back_seme (struct function *, edge,
-						  bitmap, bool, int *);
+						  bitmap, bool, int *,
+						  vec<std::pair<int, int> > *);
 extern int dfs_enumerate_from (basic_block, int,
 			       bool (*)(const_basic_block, const void *),
 			       basic_block *, int, const void *);
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 061a97fbef5..5168ba6e3f6 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -1885,8 +1885,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)
 
   /* Ensure the same EH region.  */
   {
-    rtx n1 = find_reg_note (BB_END (bb1), REG_EH_REGION, 0);
-    rtx n2 = find_reg_note (BB_END (bb2), REG_EH_REGION, 0);
+    rtx n1 = find_reg_note (last1, REG_EH_REGION, 0);
+    rtx n2 = find_reg_note (last2, REG_EH_REGION, 0);
 
     if (!n1 && n2)
       return false;
diff --git a/gcc/cfgloopmanip.c b/gcc/cfgloopmanip.c
index 73134a20e33..495e7a9e6b8 100644
--- a/gcc/cfgloopmanip.c
+++ b/gcc/cfgloopmanip.c
@@ -1734,6 +1734,7 @@ loop_version (class loop *loop,
 		   then_scale, else_scale);
 
   copy_loop_info (loop, nloop);
+  set_loop_copy (loop, nloop);
 
   /* loopify redirected latch_edge. Update its PENDING_STMTS.  */
   lv_flush_pending_stmts (latch_edge);
diff --git a/gcc/combine.c b/gcc/combine.c
index 35505cc5311..d7135f393de 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -3214,6 +3214,16 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
       return 0;
     }
 
+  /* We cannot safely duplicate volatile references in any case.  */
+
+  if ((added_sets_2 && volatile_refs_p (PATTERN (i2)))
+      || (added_sets_1 && volatile_refs_p (PATTERN (i1)))
+      || (added_sets_0 && volatile_refs_p (PATTERN (i0))))
+    {
+      undo_all ();
+      return 0;
+    }
+
   /* Count how many auto_inc expressions there were in the original insns;
      we need to have the same number in the resulting patterns.  */
 
@@ -7444,11 +7454,15 @@ expand_compound_operation (rtx x)
 				  mode, tem, modewidth - len);
     }
   else if (unsignedp && len < HOST_BITS_PER_WIDE_INT)
-    tem = simplify_and_const_int (NULL_RTX, mode,
-				  simplify_shift_const (NULL_RTX, LSHIFTRT,
-							mode, XEXP (x, 0),
-							pos),
-				  (HOST_WIDE_INT_1U << len) - 1);
+    {
+      tem = simplify_shift_const (NULL_RTX, LSHIFTRT, inner_mode,
+				  XEXP (x, 0), pos);
+      tem = gen_lowpart (mode, tem);
+      if (!tem || GET_CODE (tem) == CLOBBER)
+	return x;
+      tem = simplify_and_const_int (NULL_RTX, mode, tem,
+				    (HOST_WIDE_INT_1U << len) - 1);
+    }
   else
     /* Any other cases we can't handle.  */
     return x;
@@ -10170,7 +10184,7 @@ simplify_and_const_int_1 (scalar_int_mode mode, rtx varop,
   constop &= nonzero;
 
   /* If we don't have any bits left, return zero.  */
-  if (constop == 0)
+  if (constop == 0 && !side_effects_p (varop))
     return const0_rtx;
 
   /* If VAROP is a NEG of something known to be zero or 1 and CONSTOP is
@@ -14378,6 +14392,11 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,
 	     we keep notes from i2 or i1 if they will turn into REG_DEAD
 	     notes.  */
 
+	  /* If this register is set or clobbered between FROM_INSN and I3,
+	     we should not create a note for it.  */
+	  if (reg_set_between_p (XEXP (note, 0), from_insn, i3))
+	    break;
+
 	  /* If this register is set or clobbered in I3, put the note there
 	     unless there is one already.  */
 	  if (reg_set_p (XEXP (note, 0), PATTERN (i3)))
diff --git a/gcc/common/config/arm/arm-common.c b/gcc/common/config/arm/arm-common.c
index 78a779c9350..a4b3e86ad52 100644
--- a/gcc/common/config/arm/arm-common.c
+++ b/gcc/common/config/arm/arm-common.c
@@ -590,9 +590,15 @@ public:
    The options array consists of couplets of information where the
    first item in each couplet is the string describing which option
    name was selected (arch, cpu, fpu) and the second is the value
-   passed for that option.  */
-const char *
-arm_canon_arch_option (int argc, const char **argv)
+   passed for that option.
+
+   arch_for_multilib is boolean variable taking value true or false.
+   arch_for_multilib is false when the canonical representation is for -march
+   option and it is true when canonical representation is for -mlibarch option.
+   On passing arch_for_multilib true the canonical string generated will be
+   without the compiler options which are not required for multilib linking.  */
+static const char *
+arm_canon_arch_option_1 (int argc, const char **argv, bool arch_for_multilib)
 {
   const char *arch = NULL;
   const char *cpu = NULL;
@@ -657,8 +663,8 @@ arm_canon_arch_option (int argc, const char **argv)
   /* First build up a bitmap describing the target architecture.  */
   if (arch)
     {
-      selected_arch = arm_parse_arch_option_name (all_architectures,
-						  "-march", arch);
+      selected_arch = arm_parse_arch_option_name (all_architectures, "-march",
+						  arch, !arch_for_multilib);
 
       if (selected_arch == NULL)
 	return "";
@@ -666,6 +672,15 @@ arm_canon_arch_option (int argc, const char **argv)
       arm_initialize_isa (target_isa, selected_arch->common.isa_bits);
       arm_parse_option_features (target_isa, &selected_arch->common,
 				 strchr (arch, '+'));
+      if (arch_for_multilib)
+	{
+	  const enum isa_feature removable_bits[] = {ISA_IGNORE_FOR_MULTILIB,
+						     isa_nobit};
+	  sbitmap isa_bits = sbitmap_alloc (isa_num_bits);
+	  arm_initialize_isa (isa_bits, removable_bits);
+	  bitmap_and_compl (target_isa, target_isa, isa_bits);
+	}
+
       if (fpu && strcmp (fpu, "auto") != 0)
 	{
 	  /* We assume that architectures do not have any FPU bits
@@ -682,7 +697,8 @@ arm_canon_arch_option (int argc, const char **argv)
   else if (cpu)
     {
       const cpu_option *selected_cpu
-	= arm_parse_cpu_option_name (all_cores, "-mcpu", cpu);
+	= arm_parse_cpu_option_name (all_cores, "-mcpu", cpu,
+				     !arch_for_multilib);
 
       if (selected_cpu == NULL)
 	return "";
@@ -1032,3 +1048,22 @@ arm_asm_auto_mfpu (int argc, const char **argv)
 #define TARGET_EXCEPT_UNWIND_INFO  arm_except_unwind_info
 
 struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
+
+/* Returns a canonical representation of the -march option from the current
+   -march string (if given) and other options on the command line that might
+   affect the architecture.  */
+const char *
+arm_canon_arch_option (int argc, const char **argv)
+{
+  return arm_canon_arch_option_1 (argc, argv, false);
+}
+
+/* Returns a canonical representation of the -mlibarch option from the current
+   -march string (if given) and other options on the command line that might
+   affect the architecture after removing the compiler extension options which
+   are not required for multilib linking.  */
+const char *
+arm_canon_arch_multilib_option (int argc, const char **argv)
+{
+  return arm_canon_arch_option_1 (argc, argv, true);
+}
diff --git a/gcc/config/aarch64/aarch64-bti-insert.c b/gcc/config/aarch64/aarch64-bti-insert.c
index 98026695fdb..d0035c735a3 100644
--- a/gcc/config/aarch64/aarch64-bti-insert.c
+++ b/gcc/config/aarch64/aarch64-bti-insert.c
@@ -120,6 +120,17 @@ aarch64_pac_insn_p (rtx x)
   return false;
 }
 
+/* Check if INSN is a BTI J insn.  */
+static bool
+aarch64_bti_j_insn_p (rtx_insn *insn)
+{
+  if (!insn || !INSN_P (insn))
+    return false;
+
+  rtx pat = PATTERN (insn);
+  return GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == UNSPECV_BTI_J;
+}
+
 /* Insert the BTI instruction.  */
 /* This is implemented as a late RTL pass that runs before branch
    shortening and does the following.  */
@@ -165,6 +176,10 @@ rest_of_insert_bti (void)
 		  for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)
 		    {
 		      label = as_a <rtx_insn *> (XEXP (RTVEC_ELT (vec, j), 0));
+		      rtx_insn *next = next_nonnote_nondebug_insn (label);
+		      if (aarch64_bti_j_insn_p (next))
+			continue;
+
 		      bti_insn = gen_bti_j ();
 		      emit_insn_after (bti_insn, label);
 		    }
diff --git a/gcc/config/aarch64/aarch64-cores.def b/gcc/config/aarch64/aarch64-cores.def
index 9c290292479..fc60e2ae1ac 100644
--- a/gcc/config/aarch64/aarch64-cores.def
+++ b/gcc/config/aarch64/aarch64-cores.def
@@ -135,6 +135,7 @@ AARCH64_CORE("thunderx3t110",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_
 /* Arm ('A') cores.  */
 AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
 AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, INVALID_IMP, INVALID_CORE, -1)
 
 /* Qualcomm ('Q') cores. */
 AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
index 6049adc3f3b..e16bc784bb4 100644
--- a/gcc/config/aarch64/aarch64-simd.md
+++ b/gcc/config/aarch64/aarch64-simd.md
@@ -35,6 +35,17 @@
 		&& aarch64_mem_pair_operand (operands[0], DImode))
 	       || known_eq (GET_MODE_SIZE (<MODE>mode), 8))))
       operands[1] = force_reg (<MODE>mode, operands[1]);
+
+  /* If a constant is too complex to force to memory (e.g. because it
+     contains CONST_POLY_INTs), build it up from individual elements instead.
+     We should only need to do this before RA; aarch64_legitimate_constant_p
+     should ensure that we don't try to rematerialize the constant later.  */
+  if (GET_CODE (operands[1]) == CONST_VECTOR
+      && targetm.cannot_force_const_mem (<MODE>mode, operands[1]))
+    {
+      aarch64_expand_vector_init (operands[0], operands[1]);
+      DONE;
+    }
   "
 )
 
diff --git a/gcc/config/aarch64/aarch64-sve-builtins.cc b/gcc/config/aarch64/aarch64-sve-builtins.cc
index d534ca923d9..336a1db662b 100644
--- a/gcc/config/aarch64/aarch64-sve-builtins.cc
+++ b/gcc/config/aarch64/aarch64-sve-builtins.cc
@@ -995,12 +995,29 @@ registered_function &
 function_builder::add_function (const function_instance &instance,
 				const char *name, tree fntype, tree attrs,
 				uint64_t required_extensions,
-				bool overloaded_p)
+				bool overloaded_p,
+				bool placeholder_p)
 {
   unsigned int code = vec_safe_length (registered_functions);
   code = (code << AARCH64_BUILTIN_SHIFT) | AARCH64_BUILTIN_SVE;
-  tree decl = simulate_builtin_function_decl (input_location, name, fntype,
-					      code, NULL, attrs);
+
+  /* We need to be able to generate placeholders to enusre that we have a
+     consistent numbering scheme for function codes between the C and C++
+     frontends, so that everything ties up in LTO.
+
+     Currently, tree-streamer-in.c:unpack_ts_function_decl_value_fields
+     validates that tree nodes returned by TARGET_BUILTIN_DECL are non-NULL and
+     some node other than error_mark_node. This is a holdover from when builtin
+     decls were streamed by code rather than by value.
+
+     Ultimately, we should be able to remove this validation of BUILT_IN_MD
+     nodes and remove the target hook. For now, however, we need to appease the
+     validation and return a non-NULL, non-error_mark_node node, so we
+     arbitrarily choose integer_zero_node.  */
+  tree decl = placeholder_p
+    ? integer_zero_node
+    : simulate_builtin_function_decl (input_location, name, fntype,
+				      code, NULL, attrs);
 
   registered_function &rfn = *ggc_alloc <registered_function> ();
   rfn.instance = instance;
@@ -1032,7 +1049,7 @@ function_builder::add_unique_function (const function_instance &instance,
 					   argument_types.address ());
   tree attrs = get_attributes (instance);
   registered_function &rfn = add_function (instance, name, fntype, attrs,
-					   required_extensions, false);
+					   required_extensions, false, false);
 
   /* Enter the function into the hash table.  */
   hashval_t hash = instance.hash ();
@@ -1043,16 +1060,14 @@ function_builder::add_unique_function (const function_instance &instance,
 
   /* Also add the function under its overloaded alias, if we want
      a separate decl for each instance of an overloaded function.  */
-  if (m_direct_overloads || force_direct_overloads)
+  char *overload_name = get_name (instance, true);
+  if (strcmp (name, overload_name) != 0)
     {
-      char *overload_name = get_name (instance, true);
-      if (strcmp (name, overload_name) != 0)
-	{
-	  /* Attribute lists shouldn't be shared.  */
-	  tree attrs = get_attributes (instance);
-	  add_function (instance, overload_name, fntype, attrs,
-			required_extensions, false);
-	}
+      /* Attribute lists shouldn't be shared.  */
+      tree attrs = get_attributes (instance);
+      bool placeholder_p = !(m_direct_overloads || force_direct_overloads);
+      add_function (instance, overload_name, fntype, attrs,
+		    required_extensions, false, placeholder_p);
     }
 
   obstack_free (&m_string_obstack, name);
@@ -1073,18 +1088,19 @@ function_builder::add_overloaded_function (const function_instance &instance,
 {
   char *name = get_name (instance, true);
   if (registered_function **map_value = m_overload_names.get (name))
-    gcc_assert ((*map_value)->instance == instance
-		&& ((*map_value)->required_extensions
-		    & ~required_extensions) == 0);
+    {
+      gcc_assert ((*map_value)->instance == instance
+		  && ((*map_value)->required_extensions
+		      & ~required_extensions) == 0);
+      obstack_free (&m_string_obstack, name);
+    }
   else
     {
       registered_function &rfn
 	= add_function (instance, name, m_overload_type, NULL_TREE,
-			required_extensions, true);
-      const char *permanent_name = IDENTIFIER_POINTER (DECL_NAME (rfn.decl));
-      m_overload_names.put (permanent_name, &rfn);
+			required_extensions, true, m_direct_overloads);
+      m_overload_names.put (name, &rfn);
     }
-  obstack_free (&m_string_obstack, name);
 }
 
 /* If we are using manual overload resolution, add one function decl
@@ -1094,9 +1110,6 @@ void
 function_builder::add_overloaded_functions (const function_group_info &group,
 					    mode_suffix_index mode)
 {
-  if (m_direct_overloads)
-    return;
-
   unsigned int explicit_type0 = (*group.shape)->explicit_type_suffix_p (0);
   unsigned int explicit_type1 = (*group.shape)->explicit_type_suffix_p (1);
   for (unsigned int pi = 0; group.preds[pi] != NUM_PREDS; ++pi)
diff --git a/gcc/config/aarch64/aarch64-sve-builtins.h b/gcc/config/aarch64/aarch64-sve-builtins.h
index 526d9f55e7b..5ffc58cab0a 100644
--- a/gcc/config/aarch64/aarch64-sve-builtins.h
+++ b/gcc/config/aarch64/aarch64-sve-builtins.h
@@ -337,7 +337,8 @@ private:
   tree get_attributes (const function_instance &);
 
   registered_function &add_function (const function_instance &,
-				     const char *, tree, tree, uint64_t, bool);
+				     const char *, tree, tree,
+				     uint64_t, bool, bool);
 
   /* The function type to use for functions that are resolved by
      function_resolver.  */
diff --git a/gcc/config/aarch64/aarch64-sve.md b/gcc/config/aarch64/aarch64-sve.md
index d17a7770690..bd51323e57d 100644
--- a/gcc/config/aarch64/aarch64-sve.md
+++ b/gcc/config/aarch64/aarch64-sve.md
@@ -8455,6 +8455,20 @@
   "<perm_insn>\t%0.<Vetype>, %1.<Vetype>, %2.<Vetype>"
 )
 
+;; Special purpose permute used by the predicate generation instructions.
+;; Unlike the normal permute patterns, these instructions operate on VNx16BI
+;; regardless of the element size, so that all input and output bits are
+;; well-defined.  Operand 3 then indicates the size of the permute.
+(define_insn "@aarch64_sve_trn1_conv<mode>"
+  [(set (match_operand:VNx16BI 0 "register_operand" "=Upa")
+	(unspec:VNx16BI [(match_operand:VNx16BI 1 "register_operand" "Upa")
+			 (match_operand:VNx16BI 2 "register_operand" "Upa")
+			 (match_operand:PRED_ALL 3 "aarch64_simd_imm_zero")]
+			UNSPEC_TRN1_CONV))]
+  "TARGET_SVE"
+  "trn1\t%0.<PRED_ALL:Vetype>, %1.<PRED_ALL:Vetype>, %2.<PRED_ALL:Vetype>"
+)
+
 ;; =========================================================================
 ;; == Conversions
 ;; =========================================================================
diff --git a/gcc/config/aarch64/aarch64-tune.md b/gcc/config/aarch64/aarch64-tune.md
index 7fda2294b8a..aa68d67bdf4 100644
--- a/gcc/config/aarch64/aarch64-tune.md
+++ b/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa65,cortexa65ae,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
+	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa65,cortexa65ae,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 9b400c49ac6..1e08f4caa11 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -4322,7 +4322,7 @@ aarch64_mov128_immediate (rtx imm)
 static unsigned int
 aarch64_add_offset_1_temporaries (HOST_WIDE_INT offset)
 {
-  return abs_hwi (offset) < 0x1000000 ? 0 : 1;
+  return absu_hwi (offset) < 0x1000000 ? 0 : 1;
 }
 
 /* A subroutine of aarch64_add_offset.  Set DEST to SRC + OFFSET for
@@ -4752,6 +4752,56 @@ aarch64_expand_sve_ld1rq (rtx dest, rtx src)
   return true;
 }
 
+/* SRC is an SVE CONST_VECTOR that contains N "foreground" values followed
+   by N "background" values.  Try to move it into TARGET using:
+
+      PTRUE PRED.<T>, VL<N>
+      MOV TRUE.<T>, #<foreground>
+      MOV FALSE.<T>, #<background>
+      SEL TARGET.<T>, PRED.<T>, TRUE.<T>, FALSE.<T>
+
+   The PTRUE is always a single instruction but the MOVs might need a
+   longer sequence.  If the background value is zero (as it often is),
+   the sequence can sometimes collapse to a PTRUE followed by a
+   zero-predicated move.
+
+   Return the target on success, otherwise return null.  */
+
+static rtx
+aarch64_expand_sve_const_vector_sel (rtx target, rtx src)
+{
+  gcc_assert (CONST_VECTOR_NELTS_PER_PATTERN (src) == 2);
+
+  /* Make sure that the PTRUE is valid.  */
+  machine_mode mode = GET_MODE (src);
+  machine_mode pred_mode = aarch64_sve_pred_mode (mode);
+  unsigned int npatterns = CONST_VECTOR_NPATTERNS (src);
+  if (aarch64_svpattern_for_vl (pred_mode, npatterns)
+      == AARCH64_NUM_SVPATTERNS)
+    return NULL_RTX;
+
+  rtx_vector_builder pred_builder (pred_mode, npatterns, 2);
+  rtx_vector_builder true_builder (mode, npatterns, 1);
+  rtx_vector_builder false_builder (mode, npatterns, 1);
+  for (unsigned int i = 0; i < npatterns; ++i)
+    {
+      true_builder.quick_push (CONST_VECTOR_ENCODED_ELT (src, i));
+      pred_builder.quick_push (CONST1_RTX (BImode));
+    }
+  for (unsigned int i = 0; i < npatterns; ++i)
+    {
+      false_builder.quick_push (CONST_VECTOR_ENCODED_ELT (src, i + npatterns));
+      pred_builder.quick_push (CONST0_RTX (BImode));
+    }
+  expand_operand ops[4];
+  create_output_operand (&ops[0], target, mode);
+  create_input_operand (&ops[1], true_builder.build (), mode);
+  create_input_operand (&ops[2], false_builder.build (), mode);
+  create_input_operand (&ops[3], pred_builder.build (), pred_mode);
+  expand_insn (code_for_vcond_mask (mode, mode), 4, ops);
+  return target;
+}
+
 /* Return a register containing CONST_VECTOR SRC, given that SRC has an
    SVE data mode and isn't a legitimate constant.  Use TARGET for the
    result if convenient.
@@ -4886,6 +4936,10 @@ aarch64_expand_sve_const_vector (rtx target, rtx src)
   if (GET_MODE_NUNITS (mode).is_constant ())
     return NULL_RTX;
 
+  if (nelts_per_pattern == 2)
+    if (rtx res = aarch64_expand_sve_const_vector_sel (target, src))
+      return res;
+
   /* Expand each pattern individually.  */
   gcc_assert (npatterns > 1);
   rtx_vector_builder builder;
@@ -5067,12 +5121,12 @@ aarch64_expand_sve_const_pred_trn (rtx target, rtx_vector_builder &builder,
 	}
     }
 
-  /* Emit the TRN1 itself.  */
+  /* Emit the TRN1 itself.  We emit a TRN that operates on VNx16BI
+     operands but permutes them as though they had mode MODE.  */
   machine_mode mode = aarch64_sve_pred_mode (permute_size).require ();
-  target = aarch64_target_reg (target, mode);
-  emit_insn (gen_aarch64_sve (UNSPEC_TRN1, mode, target,
-			      gen_lowpart (mode, a),
-			      gen_lowpart (mode, b)));
+  target = aarch64_target_reg (target, GET_MODE (a));
+  rtx type_reg = CONST0_RTX (mode);
+  emit_insn (gen_aarch64_sve_trn1_conv (mode, target, a, b, type_reg));
   return target;
 }
 
@@ -16271,10 +16325,22 @@ aarch64_legitimate_constant_p (machine_mode mode, rtx x)
 {
   /* Support CSE and rematerialization of common constants.  */
   if (CONST_INT_P (x)
-      || (CONST_DOUBLE_P (x) && GET_MODE_CLASS (mode) == MODE_FLOAT)
-      || GET_CODE (x) == CONST_VECTOR)
+      || (CONST_DOUBLE_P (x) && GET_MODE_CLASS (mode) == MODE_FLOAT))
     return true;
 
+  /* Only accept variable-length vector constants if they can be
+     handled directly.
+
+     ??? It would be possible (but complex) to handle rematerialization
+     of other constants via secondary reloads.  */
+  if (!GET_MODE_SIZE (mode).is_constant ())
+    return aarch64_simd_valid_immediate (x, NULL);
+
+  /* Otherwise, accept any CONST_VECTOR that, if all else fails, can at
+     least be forced to memory and loaded from there.  */
+  if (GET_CODE (x) == CONST_VECTOR)
+    return !targetm.cannot_force_const_mem (mode, x);
+
   /* Do not allow vector struct mode constants for Advanced SIMD.
      We could support 0 and -1 easily, but they need support in
      aarch64-simd.md.  */
@@ -16282,14 +16348,6 @@ aarch64_legitimate_constant_p (machine_mode mode, rtx x)
   if (vec_flags == (VEC_ADVSIMD | VEC_STRUCT))
     return false;
 
-  /* Only accept variable-length vector constants if they can be
-     handled directly.
-
-     ??? It would be possible to handle rematerialization of other
-     constants via secondary reloads.  */
-  if (vec_flags & VEC_ANY_SVE)
-    return aarch64_simd_valid_immediate (x, NULL);
-
   if (GET_CODE (x) == HIGH)
     x = XEXP (x, 0);
 
@@ -18621,10 +18679,11 @@ aarch64_vectorize_preferred_vector_alignment (const_tree type)
 {
   if (aarch64_sve_data_mode_p (TYPE_MODE (type)))
     {
-      /* If the length of the vector is fixed, try to align to that length,
-	 otherwise don't try to align at all.  */
+      /* If the length of the vector is a fixed power of 2, try to align
+	 to that length, otherwise don't try to align at all.  */
       HOST_WIDE_INT result;
-      if (!BITS_PER_SVE_VECTOR.is_constant (&result))
+      if (!GET_MODE_BITSIZE (TYPE_MODE (type)).is_constant (&result)
+	  || !pow2p_hwi (result))
 	result = TYPE_ALIGN (TREE_TYPE (type));
       return result;
     }
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 58445dea941..552aed3ce89 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -1229,10 +1229,19 @@
     if (GET_CODE (operands[0]) == MEM && operands[1] != const0_rtx)
       operands[1] = force_reg (<MODE>mode, operands[1]);
 
-    /* FIXME: RR we still need to fix up what we are doing with
-       symbol_refs and other types of constants.  */
-    if (CONSTANT_P (operands[1])
-        && !CONST_INT_P (operands[1]))
+    /* Lower moves of symbolic constants into individual instructions.
+       Doing this now is sometimes necessary for correctness, since some
+       sequences require temporary pseudo registers.  Lowering now is also
+       often better for optimization, since more RTL passes get the
+       chance to optimize the individual instructions.
+
+       When called after RA, also split multi-instruction moves into
+       smaller pieces now, since we can't be sure that sure that there
+       will be a following split pass.  */
+    if (CONST_INT_P (operands[1])
+	? (reload_completed
+	   && !aarch64_mov_imm_operand (operands[1], <MODE>mode))
+	: CONSTANT_P (operands[1]))
      {
        aarch64_expand_mov_immediate (operands[0], operands[1]);
        DONE;
diff --git a/gcc/config/aarch64/constraints.md b/gcc/config/aarch64/constraints.md
index 8cc6f508881..98c1f41c490 100644
--- a/gcc/config/aarch64/constraints.md
+++ b/gcc/config/aarch64/constraints.md
@@ -327,6 +327,8 @@
   "@internal
    An address valid for loading or storing a 128-bit AdvSIMD register"
   (and (match_code "mem")
+       (match_test "aarch64_legitimate_address_p (GET_MODE (op),
+						  XEXP (op, 0), 1)")
        (match_test "aarch64_legitimate_address_p (V2DImode,
 						  XEXP (op, 0), 1)")))
 
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index 0a7145281fa..ff5b23d71b1 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -633,6 +633,7 @@
     UNSPEC_UZP2Q	; Used in aarch64-sve.md.
     UNSPEC_ZIP1Q	; Used in aarch64-sve.md.
     UNSPEC_ZIP2Q	; Used in aarch64-sve.md.
+    UNSPEC_TRN1_CONV	; Used in aarch64-sve.md.
     UNSPEC_COND_CMPEQ_WIDE ; Used in aarch64-sve.md.
     UNSPEC_COND_CMPGE_WIDE ; Used in aarch64-sve.md.
     UNSPEC_COND_CMPGT_WIDE ; Used in aarch64-sve.md.
diff --git a/gcc/config/arm/arm-c.c b/gcc/config/arm/arm-c.c
index 7468a20bd98..36b12215243 100644
--- a/gcc/config/arm/arm-c.c
+++ b/gcc/config/arm/arm-c.c
@@ -408,8 +408,8 @@ arm_pragma_target_parse (tree args, tree pop_target)
        target_option_current_node, but not handle_pragma_target.  */
       target_option_current_node = cur_tree;
       arm_configure_build_target (&arm_active_target,
-				  TREE_TARGET_OPTION (cur_tree),
-				  &global_options_set, false);
+				  TREE_TARGET_OPTION (cur_tree), false);
+      arm_option_reconfigure_globals ();
     }
 
   /* Update macros if target_node changes. The global state will be restored
diff --git a/gcc/config/arm/arm-cpus.in b/gcc/config/arm/arm-cpus.in
index db0b93f6bb7..65c6a4d2d02 100644
--- a/gcc/config/arm/arm-cpus.in
+++ b/gcc/config/arm/arm-cpus.in
@@ -186,6 +186,9 @@ define feature quirk_armv6kz
 # Cortex-M3 LDRD quirk.
 define feature quirk_cm3_ldrd
 
+# v8-m/v8.1-m VLLDM errata.
+define feature quirk_vlldm
+
 # Don't use .cpu assembly directive
 define feature quirk_no_asmcpu
 
@@ -322,7 +325,9 @@ define implied vfp_base MVE MVE_FP ALL_FP
 # architectures.
 # xscale isn't really a 'quirk', but it isn't an architecture either and we
 # need to ignore it for matching purposes.
-define fgroup ALL_QUIRKS   quirk_no_volatile_ce quirk_armv6kz quirk_cm3_ldrd xscale quirk_no_asmcpu
+define fgroup ALL_QUIRKS   quirk_no_volatile_ce quirk_armv6kz quirk_cm3_ldrd quirk_vlldm xscale quirk_no_asmcpu
+
+define fgroup IGNORE_FOR_MULTILIB cdecp0 cdecp1 cdecp2 cdecp3 cdecp4 cdecp5 cdecp6 cdecp7
 
 # Architecture entries
 # format:
@@ -1078,6 +1083,7 @@ begin cpu generic-armv7-a
  cname genericv7a
  tune flags LDSCHED
  architecture armv7-a+fp
+ isa quirk_no_asmcpu
  option mp add mp
  option sec add sec
  option vfpv3-d16 add VFPv3 FP_DBL
@@ -1524,6 +1530,7 @@ begin cpu cortex-m33
  architecture armv8-m.main+dsp+fp
  option nofp remove ALL_FP
  option nodsp remove armv7em
+ isa quirk_vlldm
  costs v7m
 end cpu cortex-m33
 
@@ -1533,6 +1540,7 @@ begin cpu cortex-m35p
  architecture armv8-m.main+dsp+fp
  option nofp remove ALL_FP
  option nodsp remove armv7em
+ isa quirk_vlldm
  costs v7m
 end cpu cortex-m35p
 
@@ -1544,7 +1552,7 @@ begin cpu cortex-m55
  option nomve remove mve mve_float
  option nofp remove ALL_FP mve_float
  option nodsp remove MVE mve_float
- isa quirk_no_asmcpu
+ isa quirk_no_asmcpu quirk_vlldm
  costs v7m
  vendor 41
 end cpu cortex-m55
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index bbbf67180f6..fac68cee8da 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -241,8 +241,7 @@ extern bool arm_change_mode_p (tree);
 extern tree arm_valid_target_attribute_tree (tree, struct gcc_options *,
 					     struct gcc_options *);
 extern void arm_configure_build_target (struct arm_build_target *,
-					struct cl_target_option *,
-					struct gcc_options *, bool);
+					struct cl_target_option *, bool);
 extern void arm_option_reconfigure_globals (void);
 extern void arm_options_perform_arch_sanity_checks (void);
 extern void arm_pr_long_calls (struct cpp_reader *);
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index db37e2b8e71..f02d3d30b05 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -77,10 +77,6 @@
 typedef struct minipool_node    Mnode;
 typedef struct minipool_fixup   Mfix;
 
-/* The last .arch and .fpu assembly strings that we printed.  */
-static std::string arm_last_printed_arch_string;
-static std::string arm_last_printed_fpu_string;
-
 void (*arm_lang_output_object_attributes_hook)(void);
 
 struct four_ints
@@ -332,6 +328,7 @@ static HOST_WIDE_INT arm_constant_alignment (const_tree, HOST_WIDE_INT);
 static rtx_insn * thumb1_md_asm_adjust (vec<rtx> &, vec<rtx> &,
 					vec<const char *> &, vec<rtx> &,
 					HARD_REG_SET &);
+static const char *arm_identify_fpu_from_isa (sbitmap);
 
 /* Table of machine attributes.  */
 static const struct attribute_spec arm_attribute_table[] =
@@ -3036,7 +3033,7 @@ arm_override_options_after_change (void)
 {
   arm_configure_build_target (&arm_active_target,
 			      TREE_TARGET_OPTION (target_option_default_node),
-			      &global_options_set, false);
+			      false);
 
   arm_override_options_after_change_1 (&global_options);
 }
@@ -3057,8 +3054,8 @@ arm_option_restore (struct gcc_options *opts, struct cl_target_option *ptr)
   opts->x_arm_arch_string = ptr->x_arm_arch_string;
   opts->x_arm_cpu_string = ptr->x_arm_cpu_string;
   opts->x_arm_tune_string = ptr->x_arm_tune_string;
-  arm_configure_build_target (&arm_active_target, ptr, &global_options_set,
-			      false);
+  arm_configure_build_target (&arm_active_target, ptr, false);
+  arm_option_reconfigure_globals ();
 }
 
 /* Reset options between modes that the user has specified.  */
@@ -3181,7 +3178,6 @@ static sbitmap isa_quirkbits;
 void
 arm_configure_build_target (struct arm_build_target *target,
 			    struct cl_target_option *opts,
-			    struct gcc_options *opts_set,
 			    bool warn_compatible)
 {
   const cpu_option *arm_selected_tune = NULL;
@@ -3196,7 +3192,7 @@ arm_configure_build_target (struct arm_build_target *target,
   target->core_name = NULL;
   target->arch_name = NULL;
 
-  if (opts_set->x_arm_arch_string)
+  if (opts->x_arm_arch_string)
     {
       arm_selected_arch = arm_parse_arch_option_name (all_architectures,
 						      "-march",
@@ -3204,7 +3200,7 @@ arm_configure_build_target (struct arm_build_target *target,
       arch_opts = strchr (opts->x_arm_arch_string, '+');
     }
 
-  if (opts_set->x_arm_cpu_string)
+  if (opts->x_arm_cpu_string)
     {
       arm_selected_cpu = arm_parse_cpu_option_name (all_cores, "-mcpu",
 						    opts->x_arm_cpu_string);
@@ -3214,7 +3210,7 @@ arm_configure_build_target (struct arm_build_target *target,
 	 options for tuning.  */
     }
 
-  if (opts_set->x_arm_tune_string)
+  if (opts->x_arm_tune_string)
     {
       arm_selected_tune = arm_parse_cpu_option_name (all_cores, "-mtune",
 						     opts->x_arm_tune_string);
@@ -3407,6 +3403,11 @@ arm_configure_build_target (struct arm_build_target *target,
       bitmap_ior (target->isa, target->isa, fpu_bits);
     }
 
+  /* If we have the soft-float ABI, clear any feature bits relating to use of
+     floating-point operations.  They'll just confuse things later on.  */
+  if (arm_float_abi == ARM_FLOAT_ABI_SOFT)
+    bitmap_and_compl (target->isa, target->isa, isa_all_fpbits);
+
   /* There may be implied bits which we still need to enable. These are
      non-named features which are needed to complete other sets of features,
      but cannot be enabled from arm-cpus.in due to being shared between
@@ -3429,6 +3430,8 @@ arm_configure_build_target (struct arm_build_target *target,
   const cpu_tune *tune_data = &all_tunes[arm_selected_tune - all_cores];
 
   /* Finish initializing the target structure.  */
+  if (!target->arch_name)
+    target->arch_name = arm_selected_arch->common.name;
   target->arch_pp_name = arm_selected_arch->arch;
   target->base_arch = arm_selected_arch->base_arch;
   target->profile = arm_selected_arch->profile;
@@ -3436,7 +3439,6 @@ arm_configure_build_target (struct arm_build_target *target,
   target->tune_flags = tune_data->tune_flags;
   target->tune = tune_data->tune;
   target->tune_core = tune_data->scheduler;
-  arm_option_reconfigure_globals ();
 }
 
 /* Fix up any incompatible options that the user has specified.  */
@@ -3473,8 +3475,7 @@ arm_option_override (void)
     }
 
   cl_target_option_save (&opts, &global_options);
-  arm_configure_build_target (&arm_active_target, &opts, &global_options_set,
-			      true);
+  arm_configure_build_target (&arm_active_target, &opts, true);
 
 #ifdef SUBTARGET_OVERRIDE_OPTIONS
   SUBTARGET_OVERRIDE_OPTIONS;
@@ -3610,6 +3611,15 @@ arm_option_override (void)
 	fix_cm3_ldrd = 0;
     }
 
+  /* Enable fix_vlldm by default if required.  */
+  if (fix_vlldm == 2)
+    {
+      if (bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_vlldm))
+	fix_vlldm = 1;
+      else
+	fix_vlldm = 0;
+    }
+
   /* Hot/Cold partitioning is not currently supported, since we can't
      handle literal pool placement in that case.  */
   if (flag_reorder_blocks_and_partition)
@@ -3850,7 +3860,7 @@ arm_options_perform_arch_sanity_checks (void)
 
   /* We don't clear D16-D31 VFP registers for cmse_nonsecure_call functions
      and ARMv8-M Baseline and Mainline do not allow such configuration.  */
-  if (use_cmse && LAST_VFP_REGNUM > LAST_LO_VFP_REGNUM)
+  if (use_cmse && TARGET_HARD_FLOAT && LAST_VFP_REGNUM > LAST_LO_VFP_REGNUM)
     error ("ARMv8-M Security Extensions incompatible with selected FPU");
 
 
@@ -5567,9 +5577,20 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
 			return;
 		      *op1 = GEN_INT (i + 1);
 		      *code = *code == GT ? GE : LT;
-		      return;
 		    }
-		  break;
+		  else
+		    {
+		      /* GT maxval is always false, LE maxval is always true.
+			 We can't fold that away here as we must make a
+			 comparison, but we can fold them to comparisons
+			 with the same result that can be handled:
+			   op0 GT maxval -> op0 LT minval
+			   op0 LE maxval -> op0 GE minval
+			 where minval = (-maxval - 1).  */
+		      *op1 = GEN_INT (-maxval - 1);
+		      *code = *code == GT ? LT : GE;
+		    }
+		  return;
 
 		case GTU:
 		case LEU:
@@ -5582,9 +5603,19 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
 			return;
 		      *op1 = GEN_INT (i + 1);
 		      *code = *code == GTU ? GEU : LTU;
-		      return;
 		    }
-		  break;
+		  else
+		    {
+		      /* GTU ~0 is always false, LEU ~0 is always true.
+			 We can't fold that away here as we must make a
+			 comparison, but we can fold them to comparisons
+			 with the same result that can be handled:
+			   op0 GTU ~0 -> op0 LTU 0
+			   op0 LEU ~0 -> op0 GEU 0.  */
+		      *op1 = const0_rtx;
+		      *code = *code == GTU ? LTU : GEU;
+		    }
+		  return;
 
 		default:
 		  gcc_unreachable ();
@@ -5786,6 +5817,10 @@ arm_libcall_uses_aapcs_base (const_rtx libcall)
 		   convert_optab_libfunc (sfix_optab, DImode, SFmode));
       add_libcall (libcall_htab,
 		   convert_optab_libfunc (ufix_optab, DImode, SFmode));
+      add_libcall (libcall_htab,
+		   convert_optab_libfunc (sfix_optab, SImode, SFmode));
+      add_libcall (libcall_htab,
+		   convert_optab_libfunc (ufix_optab, SImode, SFmode));
 
       /* Values from double-precision helper functions are returned in core
 	 registers if the selected core only supports single-precision
@@ -18740,10 +18775,14 @@ cmse_nonsecure_call_inline_register_clear (void)
 		  imm = gen_int_mode (- lazy_store_stack_frame_size, SImode);
 		  add_insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
 						    stack_pointer_rtx, imm));
-		  arm_add_cfa_adjust_cfa_note (add_insn,
-					       - lazy_store_stack_frame_size,
-					       stack_pointer_rtx,
-					       stack_pointer_rtx);
+		  /* If we have the frame pointer, then it will be the
+		     CFA reg.  Otherwise, the stack pointer is the CFA
+		     reg, so we need to emit a CFA adjust.  */
+		  if (!frame_pointer_needed)
+		    arm_add_cfa_adjust_cfa_note (add_insn,
+						 - lazy_store_stack_frame_size,
+						 stack_pointer_rtx,
+						 stack_pointer_rtx);
 		  emit_insn (gen_lazy_store_multiple_insn (stack_pointer_rtx));
 		}
 	      /* Save VFP callee-saved registers.  */
@@ -18781,10 +18820,11 @@ cmse_nonsecure_call_inline_register_clear (void)
 		  rtx_insn *add_insn =
 		    emit_insn (gen_addsi3 (stack_pointer_rtx,
 					   stack_pointer_rtx, imm));
-		  arm_add_cfa_adjust_cfa_note (add_insn,
-					       lazy_store_stack_frame_size,
-					       stack_pointer_rtx,
-					       stack_pointer_rtx);
+		  if (!frame_pointer_needed)
+		    arm_add_cfa_adjust_cfa_note (add_insn,
+						 lazy_store_stack_frame_size,
+						 stack_pointer_rtx,
+						 stack_pointer_rtx);
 		}
 	      /* Restore VFP callee-saved registers.  */
 	      else
@@ -25242,7 +25282,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)
     return false;
 
   if (IS_VPR_REGNUM (regno))
-    return true;
+    return mode == HImode;
 
   if (TARGET_THUMB1)
     /* For the Thumb we only allow values bigger than SImode in
@@ -27007,7 +27047,7 @@ cmse_nonsecure_entry_clear_before_return (void)
 	continue;
       if (IN_RANGE (regno, IP_REGNUM, PC_REGNUM))
 	continue;
-      if (call_used_or_fixed_reg_p (regno)
+      if (!callee_saved_reg_p (regno)
 	  && (!IN_RANGE (regno, FIRST_VFP_REGNUM, LAST_VFP_REGNUM)
 	      || TARGET_HARD_FLOAT))
 	bitmap_set_bit (to_clear_bitmap, regno);
@@ -28040,20 +28080,65 @@ arm_print_tune_info (void)
 	       (int) current_tune->sched_autopref);
 }
 
+/* The last set of target options used to emit .arch directives, etc.  This
+   could be a function-local static if it were not required to expose it as a
+   root to the garbage collector.  */
+static GTY(()) cl_target_option *last_asm_targ_options = NULL;
+
 /* Print .arch and .arch_extension directives corresponding to the
    current architecture configuration.  */
 static void
-arm_print_asm_arch_directives ()
+arm_print_asm_arch_directives (FILE *stream, cl_target_option *targ_options)
 {
+  arm_build_target build_target;
+  /* If the target options haven't changed since the last time we were called
+     there is nothing to do.  This should be sufficient to suppress the
+     majority of redundant work.  */
+  if (last_asm_targ_options == targ_options)
+    return;
+
+  last_asm_targ_options = targ_options;
+
+  build_target.isa = sbitmap_alloc (isa_num_bits);
+  arm_configure_build_target (&build_target, targ_options, false);
+
+  if (build_target.core_name
+      && !bitmap_bit_p (build_target.isa, isa_bit_quirk_no_asmcpu))
+    {
+      const char* truncated_name
+	= arm_rewrite_selected_cpu (build_target.core_name);
+      asm_fprintf (stream, "\t.cpu %s\n", truncated_name);
+    }
+
   const arch_option *arch
     = arm_parse_arch_option_name (all_architectures, "-march",
-				  arm_active_target.arch_name);
+				  build_target.arch_name);
   auto_sbitmap opt_bits (isa_num_bits);
 
   gcc_assert (arch);
 
-  asm_fprintf (asm_out_file, "\t.arch %s\n", arm_active_target.arch_name);
-  arm_last_printed_arch_string = arm_active_target.arch_name;
+  if (strcmp (build_target.arch_name, "armv7ve") == 0)
+    {
+      /* Keep backward compatability for assemblers which don't support
+	 armv7ve.  Fortunately, none of the following extensions are reset
+	 by a .fpu directive.  */
+      asm_fprintf (stream, "\t.arch armv7-a\n");
+      asm_fprintf (stream, "\t.arch_extension virt\n");
+      asm_fprintf (stream, "\t.arch_extension idiv\n");
+      asm_fprintf (stream, "\t.arch_extension sec\n");
+      asm_fprintf (stream, "\t.arch_extension mp\n");
+    }
+  else
+    asm_fprintf (stream, "\t.arch %s\n", build_target.arch_name);
+
+  /* The .fpu directive will reset any architecture extensions from the
+     assembler that relate to the fp/vector extensions.  So put this out before
+     any .arch_extension directives.  */
+  const char *fpu_name = (TARGET_SOFT_FLOAT
+			  ? "softvfp"
+			  : arm_identify_fpu_from_isa (build_target.isa));
+  asm_fprintf (stream, "\t.fpu %s\n", fpu_name);
+
   if (!arch->common.extensions)
     return;
 
@@ -28079,13 +28164,12 @@ arm_print_asm_arch_directives ()
 		  && !TARGET_HAVE_MVE_FLOAT))
 	    continue;
 
-	  /* If every feature bit of this option is set in the target
-	     ISA specification, print out the option name.  However,
-	     don't print anything if all the bits are part of the
-	     FPU specification.  */
-	  if (bitmap_subset_p (opt_bits, arm_active_target.isa)
+	  /* If every feature bit of this option is set in the target ISA
+	     specification, print out the option name.  However, don't print
+	     anything if all the bits are part of the FPU specification.  */
+	  if (bitmap_subset_p (opt_bits, build_target.isa)
 	      && !bitmap_subset_p (opt_bits, isa_all_fpubits_internal))
-	    asm_fprintf (asm_out_file, "\t.arch_extension %s\n", opt->name);
+	    asm_fprintf (stream, "\t.arch_extension %s\n", opt->name);
 	}
     }
 }
@@ -28095,46 +28179,23 @@ arm_file_start (void)
 {
   int val;
 
+  arm_print_asm_arch_directives
+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));
+
   if (TARGET_BPABI)
     {
-      /* We don't have a specified CPU.  Use the architecture to
-	 generate the tags.
-
-	 Note: it might be better to do this unconditionally, then the
-	 assembler would not need to know about all new CPU names as
-	 they are added.  */
-      if (!arm_active_target.core_name)
-	{
-	  /* armv7ve doesn't support any extensions.  */
-	  if (strcmp (arm_active_target.arch_name, "armv7ve") == 0)
-	    {
-	      /* Keep backward compatability for assemblers
-		 which don't support armv7ve.  */
-	      asm_fprintf (asm_out_file, "\t.arch armv7-a\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension virt\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension idiv\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension sec\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension mp\n");
-	      arm_last_printed_arch_string = "armv7ve";
-	    }
-	  else
-	    arm_print_asm_arch_directives ();
-	}
-      else if (strncmp (arm_active_target.core_name, "generic", 7) == 0)
-	{
-	  asm_fprintf (asm_out_file, "\t.arch %s\n",
-		       arm_active_target.core_name + 8);
-	  arm_last_printed_arch_string = arm_active_target.core_name + 8;
-	}
-      else
+      /* If we have a named cpu, but we the assembler does not support that
+	 name via .cpu, put out a cpu name attribute; but don't do this if the
+	 name starts with the fictitious prefix, 'generic'.  */
+      if (arm_active_target.core_name
+	  && bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu)
+	  && strncmp (arm_active_target.core_name, "generic", 7) != 0)
 	{
 	  const char* truncated_name
 	    = arm_rewrite_selected_cpu (arm_active_target.core_name);
 	  if (bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu))
 	    asm_fprintf (asm_out_file, "\t.eabi_attribute 5, \"%s\"\n",
 			 truncated_name);
-	  else
-	    asm_fprintf (asm_out_file, "\t.cpu %s\n", truncated_name);
 	}
 
       if (print_tune_info)
@@ -28202,6 +28263,13 @@ arm_file_end (void)
 {
   int regno;
 
+  /* Just in case the last function output in the assembler had non-default
+     architecture directives, we force the assembler state back to the default
+     set, so that any 'calculated' build attributes are based on the default
+     options rather than the special options for that function.  */
+  arm_print_asm_arch_directives
+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));
+
   if (NEED_INDICATE_EXEC_STACK)
     /* Add .note.GNU-stack.  */
     file_end_indicate_exec_stack ();
@@ -30470,13 +30538,31 @@ arm_split_compare_and_swap (rtx operands[])
     }
   else
     {
-      emit_move_insn (neg_bval, const1_rtx);
       cond = gen_rtx_NE (VOIDmode, rval, oldval);
       if (thumb1_cmpneg_operand (oldval, SImode))
-	emit_unlikely_jump (gen_cbranchsi4_scratch (neg_bval, rval, oldval,
-						    label2, cond));
+	{
+	  rtx src = rval;
+	  if (!satisfies_constraint_L (oldval))
+	    {
+	      gcc_assert (satisfies_constraint_J (oldval));
+
+	      /* For such immediates, ADDS needs the source and destination regs
+		 to be the same.
+
+		 Normally this would be handled by RA, but this is all happening
+		 after RA.  */
+	      emit_move_insn (neg_bval, rval);
+	      src = neg_bval;
+	    }
+
+	  emit_unlikely_jump (gen_cbranchsi4_neg_late (neg_bval, src, oldval,
+						       label2, cond));
+	}
       else
-	emit_unlikely_jump (gen_cbranchsi4_insn (cond, rval, oldval, label2));
+	{
+	  emit_move_insn (neg_bval, const1_rtx);
+	  emit_unlikely_jump (gen_cbranchsi4_insn (cond, rval, oldval, label2));
+	}
     }
 
   arm_emit_store_exclusive (mode, neg_bval, mem, newval, use_release);
@@ -32397,10 +32483,8 @@ arm_can_inline_p (tree caller, tree callee)
   caller_target.isa = sbitmap_alloc (isa_num_bits);
   callee_target.isa = sbitmap_alloc (isa_num_bits);
 
-  arm_configure_build_target (&caller_target, caller_opts, &global_options_set,
-			      false);
-  arm_configure_build_target (&callee_target, callee_opts, &global_options_set,
-			      false);
+  arm_configure_build_target (&caller_target, caller_opts, false);
+  arm_configure_build_target (&callee_target, callee_opts, false);
   if (!bitmap_subset_p (callee_target.isa, caller_target.isa))
     can_inline = false;
 
@@ -32536,7 +32620,7 @@ arm_valid_target_attribute_tree (tree args, struct gcc_options *opts,
     return NULL_TREE;
 
   cl_target_option_save (&cl_opts, opts);
-  arm_configure_build_target (&arm_active_target, &cl_opts, opts_set, false);
+  arm_configure_build_target (&arm_active_target, &cl_opts, false);
   arm_option_check_internal (opts);
   /* Do any overrides, such as global options arch=xxx.
      We do this since arm_active_target was overridden.  */
@@ -32680,58 +32764,7 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)
     targ_options = TREE_TARGET_OPTION (target_option_current_node);
   gcc_assert (targ_options);
 
-  /* Only update the assembler .arch string if it is distinct from the last
-     such string we printed. arch_to_print is set conditionally in case
-     targ_options->x_arm_arch_string is NULL which can be the case
-     when cc1 is invoked directly without passing -march option.  */
-  std::string arch_to_print;
-  if (targ_options->x_arm_arch_string)
-    arch_to_print = targ_options->x_arm_arch_string;
-
-  if (arch_to_print != arm_last_printed_arch_string)
-    {
-      std::string arch_name
-	= arch_to_print.substr (0, arch_to_print.find ("+"));
-      asm_fprintf (asm_out_file, "\t.arch %s\n", arch_name.c_str ());
-      const arch_option *arch
-	= arm_parse_arch_option_name (all_architectures, "-march",
-				      targ_options->x_arm_arch_string);
-      auto_sbitmap opt_bits (isa_num_bits);
-
-      gcc_assert (arch);
-      if (arch->common.extensions)
-	{
-	  for (const struct cpu_arch_extension *opt = arch->common.extensions;
-	       opt->name != NULL;
-	       opt++)
-	    {
-	      if (!opt->remove)
-		{
-		  arm_initialize_isa (opt_bits, opt->isa_bits);
-		  /* For the cases "-march=armv8.1-m.main+mve -mfloat-abi=soft"
-		     and "-march=armv8.1-m.main+mve.fp -mfloat-abi=soft" MVE and
-		     MVE with floating point instructions is disabled.  So the
-		     following check restricts the printing of ".arch_extension
-		     mve" and ".arch_extension fp" (for mve.fp) in the assembly
-		     file.    MVE needs this special behaviour because the
-		     feature bit "mve" and "mve_float" are not part of
-		     "fpu bits", so they are not cleared when -mfloat-abi=soft
-		     (i.e nofp) but the marco TARGET_HAVE_MVE and
-		     TARGET_HAVE_MVE_FLOAT are disabled.  */
-		  if ((bitmap_bit_p (opt_bits, isa_bit_mve) && !TARGET_HAVE_MVE)
-		      || (bitmap_bit_p (opt_bits, isa_bit_mve_float)
-			  && !TARGET_HAVE_MVE_FLOAT))
-		    continue;
-		  if (bitmap_subset_p (opt_bits, arm_active_target.isa)
-		      && !bitmap_subset_p (opt_bits, isa_all_fpubits_internal))
-		    asm_fprintf (asm_out_file, "\t.arch_extension %s\n",
-				 opt->name);
-		}
-	     }
-	}
-
-      arm_last_printed_arch_string = arch_to_print;
-    }
+  arm_print_asm_arch_directives (stream, targ_options);
 
   fprintf (stream, "\t.syntax unified\n");
 
@@ -32749,17 +32782,6 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)
   else
     fprintf (stream, "\t.arm\n");
 
-  std::string fpu_to_print
-    = TARGET_SOFT_FLOAT
-	? "softvfp" : arm_identify_fpu_from_isa (arm_active_target.isa);
-
-  if (!(!strcmp (fpu_to_print.c_str (), "softvfp") && TARGET_VFP_BASE)
-      && (fpu_to_print != arm_last_printed_arch_string))
-    {
-      asm_fprintf (asm_out_file, "\t.fpu %s\n", fpu_to_print.c_str ());
-      arm_last_printed_fpu_string = fpu_to_print;
-    }
-
   if (TARGET_POKE_FUNCTION_NAME)
     arm_poke_function_name (stream, (const char *) name);
 }
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 30e1d6dc994..2922dfe677c 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -2357,10 +2357,14 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);
 #endif
 
 const char *arm_canon_arch_option (int argc, const char **argv);
+const char *arm_canon_arch_multilib_option (int argc, const char **argv);
 
 #define CANON_ARCH_SPEC_FUNCTION		\
   { "canon_arch", arm_canon_arch_option },
 
+#define CANON_ARCH_MULTILIB_SPEC_FUNCTION		\
+  { "canon_arch_multilib", arm_canon_arch_multilib_option },
+
 const char *arm_be8_option (int argc, const char **argv);
 #define BE8_SPEC_FUNCTION			\
   { "be8_linkopt", arm_be8_option },
@@ -2369,6 +2373,7 @@ const char *arm_be8_option (int argc, const char **argv);
   MCPU_MTUNE_NATIVE_FUNCTIONS			\
   ASM_CPU_SPEC_FUNCTIONS			\
   CANON_ARCH_SPEC_FUNCTION			\
+  CANON_ARCH_MULTILIB_SPEC_FUNCTION		\
   TARGET_MODE_SPEC_FUNCTIONS			\
   BE8_SPEC_FUNCTION
 
@@ -2389,12 +2394,22 @@ const char *arm_be8_option (int argc, const char **argv);
   "                     %{mfloat-abi=*: abi %*}"	\
   "                     %<march=*) "
 
+/* Generate a canonical string to represent the architecture selected ignoring
+   the options not required for multilib linking.  */
+#define MULTILIB_ARCH_CANONICAL_SPECS				\
+  "-mlibarch=%:canon_arch_multilib(%{mcpu=*: cpu %*} "		\
+  "				   %{march=*: arch %*} "	\
+  "				   %{mfpu=*: fpu %*} "		\
+  "				   %{mfloat-abi=*: abi %*}"	\
+  "				   %<mlibarch=*) "
+
 /* Complete set of specs for the driver.  Commas separate the
    individual rules so that any option suppression (%<opt...)is
    completed before starting subsequent rules.  */
 #define DRIVER_SELF_SPECS			\
   MCPU_MTUNE_NATIVE_SPECS,			\
   TARGET_MODE_SPECS,				\
+  MULTILIB_ARCH_CANONICAL_SPECS,		\
   ARCH_CANONICAL_SPECS
 
 #define TARGET_SUPPORTS_WIDE_INT 1
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 55ba92fe39a..650b0f7f6a4 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -132,9 +132,12 @@
 ; TARGET_32BIT, "t1" or "t2" to specify a specific Thumb mode.  "v6"
 ; for ARM or Thumb-2 with arm_arch6, and nov6 for ARM without
 ; arm_arch6.  "v6t2" for Thumb-2 with arm_arch6 and "v8mb" for ARMv8-M
-; Baseline.  This attribute is used to compute attribute "enabled",
+; Baseline.  "fix_vlldm" is for fixing the v8-m/v8.1-m VLLDM erratum.
+; This attribute is used to compute attribute "enabled",
 ; use type "any" to enable an alternative in all cases.
-(define_attr "arch" "any,a,t,32,t1,t2,v6,nov6,v6t2,v8mb,iwmmxt,iwmmxt2,armv6_or_vfpv3,neon,mve"
+(define_attr "arch" "any, a, t, 32, t1, t2, v6,nov6, v6t2, \
+		     v8mb, fix_vlldm, iwmmxt, iwmmxt2, armv6_or_vfpv3, \
+		     neon, mve"
   (const_string "any"))
 
 (define_attr "arch_enabled" "no,yes"
@@ -177,6 +180,10 @@
 	      (match_test "TARGET_THUMB1 && arm_arch8"))
 	 (const_string "yes")
 
+	 (and (eq_attr "arch" "fix_vlldm")
+	      (match_test "fix_vlldm"))
+	 (const_string "yes")
+
 	 (and (eq_attr "arch" "iwmmxt2")
 	      (match_test "TARGET_REALLY_IWMMXT2"))
 	 (const_string "yes")
@@ -8579,18 +8586,21 @@
 	      (use (match_operand 2 "" ""))
 	      (clobber (reg:SI LR_REGNUM))])]
   "use_cmse"
-  "
   {
+    rtx addr = XEXP (operands[0], 0);
+    rtx tmp = REG_P (addr) ? addr : force_reg (SImode, addr);
+
     if (!TARGET_HAVE_FPCXT_CMSE)
       {
-	rtx tmp =
-	  copy_to_suggested_reg (XEXP (operands[0], 0),
-				 gen_rtx_REG (SImode, R4_REGNUM),
-				 SImode);
-
-	operands[0] = replace_equiv_address (operands[0], tmp);
+	rtx r4 = gen_rtx_REG (SImode, R4_REGNUM);
+	emit_move_insn (r4, tmp);
+	tmp = r4;
       }
-  }")
+
+    if (tmp != addr)
+      operands[0] = replace_equiv_address (operands[0], tmp);
+  }
+)
 
 (define_insn "*call_reg_armv5"
   [(call (mem:SI (match_operand:SI 0 "s_register_operand" "r"))
diff --git a/gcc/config/arm/arm.opt b/gcc/config/arm/arm.opt
index cd3d8e1beac..976af5ce1c3 100644
--- a/gcc/config/arm/arm.opt
+++ b/gcc/config/arm/arm.opt
@@ -90,6 +90,12 @@ Specify the name of the target architecture.
 EnumValue
 Enum(arm_arch) String(native) Value(-1) DriverOnly
 
+; Set to the name of target architecture which is required for
+; multilib linking.  This option is undocumented becuase it
+; should not be used by the users.
+mlibarch=
+Target RejectNegative JoinedOrMissing NoDWARFRecord DriverOnly Undocumented
+
 marm
 Target Report RejectNegative Negative(mthumb) InverseMask(THUMB)
 Generate code in 32 bit ARM state.
@@ -271,6 +277,10 @@ Target Report Var(fix_cm3_ldrd) Init(2)
 Avoid overlapping destination and address registers on LDRD instructions
 that may trigger Cortex-M3 errata.
 
+mfix-cmse-cve-2021-35465
+Target Var(fix_vlldm) Init(2)
+Mitigate issues with VLLDM on some M-profile devices (CVE-2021-35465).
+
 munaligned-access
 Target Report Var(unaligned_access) Init(2) Save
 Enable unaligned word and halfword accesses to packed data.
diff --git a/gcc/config/arm/arm_mve.h b/gcc/config/arm/arm_mve.h
index 449219e90fc..a19006f5008 100644
--- a/gcc/config/arm/arm_mve.h
+++ b/gcc/config/arm/arm_mve.h
@@ -3524,7 +3524,7 @@ __arm_vaddlvq_u32 (uint32x4_t __a)
   return __builtin_mve_vaddlvq_uv4si (__a);
 }
 
-__extension__ extern __inline int64_t
+__extension__ extern __inline mve_pred16_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 __arm_vctp16q (uint32_t __a)
 {
@@ -37559,47 +37559,47 @@ extern void *__ARM_undef;
 
 #define __arm_vld1q(p0) (\
   _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_s8 (__ARM_mve_coerce(p0, int8_t const *)), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_s16 (__ARM_mve_coerce(p0, int16_t const *)), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_s32 (__ARM_mve_coerce(p0, int32_t const *)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_u8 (__ARM_mve_coerce(p0, uint8_t const *)), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_u16 (__ARM_mve_coerce(p0, uint16_t const *)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_u32 (__ARM_mve_coerce(p0, uint32_t const *)), \
-  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld1q_f16 (__ARM_mve_coerce(p0, float16_t const *)), \
-  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld1q_f32 (__ARM_mve_coerce(p0, float32_t const *))))
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_s8 (__ARM_mve_coerce1(p0, int8_t *)), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_s16 (__ARM_mve_coerce1(p0, int16_t *)), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_s32 (__ARM_mve_coerce1(p0, int32_t *)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_u8 (__ARM_mve_coerce1(p0, uint8_t *)), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_u16 (__ARM_mve_coerce1(p0, uint16_t *)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_u32 (__ARM_mve_coerce1(p0, uint32_t *)), \
+  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld1q_f16 (__ARM_mve_coerce1(p0, float16_t *)), \
+  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld1q_f32 (__ARM_mve_coerce1(p0, float32_t *))))
 
 #define __arm_vld1q_z(p0,p1) ( \
   _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_z_s8 (__ARM_mve_coerce(p0, int8_t const *), p1), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_z_s16 (__ARM_mve_coerce(p0, int16_t const *), p1), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_z_s32 (__ARM_mve_coerce(p0, int32_t const *), p1), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_z_u8 (__ARM_mve_coerce(p0, uint8_t const *), p1), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_z_u16 (__ARM_mve_coerce(p0, uint16_t const *), p1), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_z_u32 (__ARM_mve_coerce(p0, uint32_t const *), p1), \
-  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld1q_z_f16 (__ARM_mve_coerce(p0, float16_t const *), p1), \
-  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld1q_z_f32 (__ARM_mve_coerce(p0, float32_t const *), p1)))
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_z_s8 (__ARM_mve_coerce1(p0, int8_t *), p1), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_z_s16 (__ARM_mve_coerce1(p0, int16_t *), p1), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_z_s32 (__ARM_mve_coerce1(p0, int32_t *), p1), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_z_u8 (__ARM_mve_coerce1(p0, uint8_t *), p1), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_z_u16 (__ARM_mve_coerce1(p0, uint16_t *), p1), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_z_u32 (__ARM_mve_coerce1(p0, uint32_t *), p1), \
+  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld1q_z_f16 (__ARM_mve_coerce1(p0, float16_t *), p1), \
+  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld1q_z_f32 (__ARM_mve_coerce1(p0, float32_t *), p1)))
 
 #define __arm_vld2q(p0) ( \
   _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld2q_s8 (__ARM_mve_coerce(p0, int8_t const *)), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld2q_s16 (__ARM_mve_coerce(p0, int16_t const *)), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld2q_s32 (__ARM_mve_coerce(p0, int32_t const *)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld2q_u8 (__ARM_mve_coerce(p0, uint8_t const *)), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld2q_u16 (__ARM_mve_coerce(p0, uint16_t const *)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld2q_u32 (__ARM_mve_coerce(p0, uint32_t const *)), \
-  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld2q_f16 (__ARM_mve_coerce(p0, float16_t const *)), \
-  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld2q_f32 (__ARM_mve_coerce(p0, float32_t const *))))
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld2q_s8 (__ARM_mve_coerce1(p0, int8_t *)), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld2q_s16 (__ARM_mve_coerce1(p0, int16_t *)), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld2q_s32 (__ARM_mve_coerce1(p0, int32_t *)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld2q_u8 (__ARM_mve_coerce1(p0, uint8_t *)), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld2q_u16 (__ARM_mve_coerce1(p0, uint16_t *)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld2q_u32 (__ARM_mve_coerce1(p0, uint32_t *)), \
+  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld2q_f16 (__ARM_mve_coerce1(p0, float16_t *)), \
+  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld2q_f32 (__ARM_mve_coerce1(p0, float32_t *))))
 
 #define __arm_vld4q(p0) ( \
   _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld4q_s8 (__ARM_mve_coerce(p0, int8_t const *)), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld4q_s16 (__ARM_mve_coerce(p0, int16_t const *)), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld4q_s32 (__ARM_mve_coerce(p0, int32_t const *)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld4q_u8 (__ARM_mve_coerce(p0, uint8_t const *)), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld4q_u16 (__ARM_mve_coerce(p0, uint16_t const *)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld4q_u32 (__ARM_mve_coerce(p0, uint32_t const *)), \
-  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld4q_f16 (__ARM_mve_coerce(p0, float16_t const *)), \
-  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld4q_f32 (__ARM_mve_coerce(p0, float32_t const *))))
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld4q_s8 (__ARM_mve_coerce1(p0, int8_t *)), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld4q_s16 (__ARM_mve_coerce1(p0, int16_t *)), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld4q_s32 (__ARM_mve_coerce1(p0, int32_t *)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld4q_u8 (__ARM_mve_coerce1(p0, uint8_t *)), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld4q_u16 (__ARM_mve_coerce1(p0, uint16_t *)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld4q_u32 (__ARM_mve_coerce1(p0, uint32_t *)), \
+  int (*)[__ARM_mve_type_float16_t_ptr]: __arm_vld4q_f16 (__ARM_mve_coerce1(p0, float16_t *)), \
+  int (*)[__ARM_mve_type_float32_t_ptr]: __arm_vld4q_f32 (__ARM_mve_coerce1(p0, float32_t *))))
 
 #define __arm_vldrhq_gather_offset(p0,p1) ({ __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)])0, \
@@ -37802,33 +37802,19 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_base_p_u32(p0, p1, __ARM_mve_coerce(__p2, uint32x4_t), p3), \
   int (*)[__ARM_mve_type_float32x4_t]: __arm_vstrwq_scatter_base_p_f32(p0, p1, __ARM_mve_coerce(__p2, float32x4_t), p3));})
 
-#define __arm_vstrwq_scatter_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t)), \
-  int (*)[__ARM_mve_type_float32_t_ptr][__ARM_mve_type_float32x4_t]: __arm_vstrwq_scatter_offset_f32 (__ARM_mve_coerce(p0, float32_t *), __p1, __ARM_mve_coerce(__p2, float32x4_t)));})
-
-#define __arm_vstrwq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vstrwq_scatter_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_p_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_p_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t), p3), \
-  int (*)[__ARM_mve_type_float32_t_ptr][__ARM_mve_type_float32x4_t]: __arm_vstrwq_scatter_offset_p_f32 (__ARM_mve_coerce(p0, float32_t *), __p1, __ARM_mve_coerce(__p2, float32x4_t), p3));})
-
-#define __arm_vstrwq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_p_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_p_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t), p3), \
-  int (*)[__ARM_mve_type_float32_t_ptr][__ARM_mve_type_float32x4_t]: __arm_vstrwq_scatter_offset_p_f32 (__ARM_mve_coerce(p0, float32_t *), __p1, __ARM_mve_coerce(__p2, float32x4_t), p3));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_s32 (__ARM_mve_coerce(__p0, int32_t *), p1, __ARM_mve_coerce(__p2, int32x4_t)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_u32 (__ARM_mve_coerce(__p0, uint32_t *), p1, __ARM_mve_coerce(__p2, uint32x4_t)), \
+  int (*)[__ARM_mve_type_float32_t_ptr][__ARM_mve_type_float32x4_t]: __arm_vstrwq_scatter_offset_f32 (__ARM_mve_coerce(__p0, float32_t *), p1, __ARM_mve_coerce(__p2, float32x4_t)));})
 
-#define __arm_vstrwq_scatter_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vstrwq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t)), \
-  int (*)[__ARM_mve_type_float32_t_ptr][__ARM_mve_type_float32x4_t]: __arm_vstrwq_scatter_offset_f32 (__ARM_mve_coerce(p0, float32_t *), __p1, __ARM_mve_coerce(__p2, float32x4_t)));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_p_s32 (__ARM_mve_coerce(__p0, int32_t *), p1, __ARM_mve_coerce(__p2, int32x4_t), p3), \
+  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_p_u32 (__ARM_mve_coerce(__p0, uint32_t *), p1, __ARM_mve_coerce(__p2, uint32x4_t), p3), \
+  int (*)[__ARM_mve_type_float32_t_ptr][__ARM_mve_type_float32x4_t]: __arm_vstrwq_scatter_offset_p_f32 (__ARM_mve_coerce(__p0, float32_t *), p1, __ARM_mve_coerce(__p2, float32x4_t), p3));})
 
 #define __arm_vstrwq_scatter_shifted_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
@@ -38416,6 +38402,12 @@ extern void *__ARM_undef;
 #define __arm_vcmpneq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8_t)), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16_t)), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32_t)), \
+  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u8 (__ARM_mve_coerce(__p0, uint8x16_t), __ARM_mve_coerce(__p1, uint8_t)), \
+  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16_t)), \
+  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32_t)), \
   int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vcmpneq_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t)), \
   int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vcmpneq_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t)), \
   int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vcmpneq_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t)), \
@@ -38865,23 +38857,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_int_n]: __arm_vcmpeqq_n_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16_t)), \
   int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_int_n]: __arm_vcmpeqq_n_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32_t)));})
 
-#define __arm_vcmpneq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vcmpneq_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t)), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vcmpneq_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t)), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vcmpneq_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vcmpneq_u8 (__ARM_mve_coerce(__p0, uint8x16_t), __ARM_mve_coerce(__p1, uint8x16_t)), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vcmpneq_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16x8_t)), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vcmpneq_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32x4_t)), \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8_t)), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16_t)), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32_t)), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u8 (__ARM_mve_coerce(__p0, uint8x16_t), __ARM_mve_coerce(__p1, uint8_t)), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16_t)), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32_t)));})
-
-
 #define __arm_vqmovntq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
@@ -39030,22 +39005,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vcmpneq_m_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
   int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vcmpneq_m_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
 
-#define __arm_vcmpneq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vcmpneq_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t)), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vcmpneq_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t)), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vcmpneq_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vcmpneq_u8 (__ARM_mve_coerce(__p0, uint8x16_t), __ARM_mve_coerce(__p1, uint8x16_t)), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vcmpneq_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16x8_t)), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vcmpneq_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32x4_t)), \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8_t)), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16_t)), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32_t)), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u8 (__ARM_mve_coerce(__p0, uint8x16_t), __ARM_mve_coerce(__p1, uint8_t)), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16_t)), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_int_n]: __arm_vcmpneq_n_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32_t)));})
-
 #define __arm_vshlcq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)])0, \
   int (*)[__ARM_mve_type_int8x16_t]: __arm_vshlcq_s8 (__ARM_mve_coerce(__p0, int8x16_t), p1, p2), \
@@ -39361,52 +39320,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_int16x8_t]: __arm_vminaq_m_s16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
   int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_int32x4_t]: __arm_vminaq_m_s32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2));})
 
-#define __arm_vrmlaldavhaq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vcmpltq_m_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vcmpltq_m_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vcmpltq_m_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2), \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int_n]: __arm_vcmpltq_m_n_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int_n]: __arm_vcmpltq_m_n_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int_n]: __arm_vcmpltq_m_n_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32_t), p2));})
-
-#define __arm_vmlsdavxq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vcmpleq_m_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vcmpleq_m_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vcmpleq_m_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2), \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int_n]: __arm_vcmpleq_m_n_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int_n]: __arm_vcmpleq_m_n_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int_n]: __arm_vcmpleq_m_n_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32_t), p2));})
-
-#define __arm_vmlsdavq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vcmpgtq_m_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vcmpgtq_m_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vcmpgtq_m_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2), \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int_n]: __arm_vcmpgtq_m_n_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int_n]: __arm_vcmpgtq_m_n_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int_n]: __arm_vcmpgtq_m_n_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32_t), p2));})
-
-#define __arm_vmlsdavaxq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int16x8_t]: __arm_vshrntq_n_s16 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int32x4_t]: __arm_vshrntq_n_s32 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int32x4_t), p2), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint16x8_t]: __arm_vshrntq_n_u16 (__ARM_mve_coerce(__p0, uint8x16_t), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint32x4_t]: __arm_vshrntq_n_u32 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
-
-#define __arm_vmlsdavaq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int16x8_t]: __arm_vrshrntq_n_s16 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int32x4_t]: __arm_vrshrntq_n_s32 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int32x4_t), p2), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint16x8_t]: __arm_vrshrntq_n_u16 (__ARM_mve_coerce(__p0, uint8x16_t), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint32x4_t]: __arm_vrshrntq_n_u32 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
-
 #define __arm_vmovlbq_m(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
@@ -39705,26 +39618,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vmulq_m_u16 (__ARM_mve_coerce(__p0, uint16x8_t), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
   int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vmulq_m_u32 (__ARM_mve_coerce(__p0, uint32x4_t), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
 
-#define __arm_vstrbq(p0,p1) ({ __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int8x16_t]: __arm_vstrbq_s8 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, int8x16_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int16x8_t]: __arm_vstrbq_s16 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, int16x8_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrbq_s32 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_u8 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_u16 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_u32 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t)));})
-
-#define __arm_vstrbq_scatter_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_int8x16_t]: __arm_vstrbq_scatter_offset_s8 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, int8x16_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_int16x8_t]: __arm_vstrbq_scatter_offset_s16 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, int16x8_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_int32x4_t]: __arm_vstrbq_scatter_offset_s32 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_scatter_offset_u8 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_scatter_offset_u16 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_scatter_offset_u32 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t)));})
-
 #define __arm_vstrwq_scatter_base(p0,p1,p2) ({ __typeof(p2) __p2 = (p2); \
   _Generic( (int (*)[__ARM_mve_typeid(__p2)])0, \
   int (*)[__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_base_s32(p0, p1, __ARM_mve_coerce(__p2, int32x4_t)), \
@@ -39732,46 +39625,26 @@ extern void *__ARM_undef;
 
 #define __arm_vldrbq_gather_offset(p0,p1) ({ __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_s8 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint8x16_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_s16 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint16x8_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_s32 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint32x4_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_u8 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint8x16_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_u16 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint16x8_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_u32 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint32x4_t)));})
-
-#define __arm_vstrbq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int8x16_t]: __arm_vstrbq_p_s8 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, int8x16_t), p2), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int16x8_t]: __arm_vstrbq_p_s16 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrbq_p_s32 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, int32x4_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_p_u8 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_p_u16 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_p_u32 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
-
-#define __arm_vstrbq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_int8x16_t]: __arm_vstrbq_scatter_offset_p_s8 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_int16x8_t]: __arm_vstrbq_scatter_offset_p_s16 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_int32x4_t]: __arm_vstrbq_scatter_offset_p_s32 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_scatter_offset_p_u8 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_scatter_offset_p_u16 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_scatter_offset_p_u32 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_s8 (__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t)), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_s16 (__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t)), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_s32 (__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_u8 (__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_u16 (__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_u32 (__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t)));})
 
 #define __arm_vstrwq_scatter_base_p(p0,p1,p2,p3) ({ __typeof(p2) __p2 = (p2); \
   _Generic( (int (*)[__ARM_mve_typeid(__p2)])0, \
   int (*)[__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_base_p_s32 (p0, p1, __ARM_mve_coerce(__p2, int32x4_t), p3), \
   int (*)[__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_base_p_u32 (p0, p1, __ARM_mve_coerce(__p2, uint32x4_t), p3));})
 
-#define __arm_vld1q(p0) (_Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_s8 (__ARM_mve_coerce(p0, int8_t const *)), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_s16 (__ARM_mve_coerce(p0, int16_t const *)), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_s32 (__ARM_mve_coerce(p0, int32_t const *)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_u8 (__ARM_mve_coerce(p0, uint8_t const *)), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_u16 (__ARM_mve_coerce(p0, uint16_t const *)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_u32 (__ARM_mve_coerce(p0, uint32_t const *))))
+#define __arm_vld1q(p0) (\
+  _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_s8 (__ARM_mve_coerce1(p0, int8_t *)), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_s16 (__ARM_mve_coerce1(p0, int16_t *)), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_s32 (__ARM_mve_coerce1(p0, int32_t *)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_u8 (__ARM_mve_coerce1(p0, uint8_t *)), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_u16 (__ARM_mve_coerce1(p0, uint16_t *)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_u32 (__ARM_mve_coerce1(p0, uint32_t *))))
 
 #define __arm_vldrhq_gather_offset(p0,p1) ({ __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)])0, \
@@ -39915,34 +39788,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_base_s64 (p0, p1, __ARM_mve_coerce(__p2, int64x2_t)), \
   int (*)[__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_base_u64 (p0, p1, __ARM_mve_coerce(__p2, uint64x2_t)));})
 
-#define __arm_vstrdq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_offset_p_s64 (__ARM_mve_coerce(__p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t), p3), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_offset_p_u64 (__ARM_mve_coerce(__p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t), p3));})
-
-#define __arm_vstrdq_scatter_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_offset_s64 (__ARM_mve_coerce(__p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t)), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_offset_u64 (__ARM_mve_coerce(__p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t)));})
-
-#define __arm_vstrdq_scatter_shifted_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_shifted_offset_p_s64 (__ARM_mve_coerce(__p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t), p3), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_shifted_offset_p_u64 (__ARM_mve_coerce(__p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t), p3));})
-
-#define __arm_vstrdq_scatter_shifted_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_shifted_offset_s64 (__ARM_mve_coerce(__p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t)), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_shifted_offset_u64 (__ARM_mve_coerce(__p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t)));})
-
 #define __arm_vstrhq_scatter_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
   _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
@@ -39975,29 +39820,17 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint16_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vstrhq_scatter_shifted_offset_p_u16 (__ARM_mve_coerce(p0, uint16_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
   int (*)[__ARM_mve_type_uint16_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vstrhq_scatter_shifted_offset_p_u32 (__ARM_mve_coerce(p0, uint16_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
 
-#define __arm_vstrwq_scatter_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t)));})
-
-#define __arm_vstrwq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_p_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_p_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t)));})
-
-#define __arm_vstrwq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vstrwq_scatter_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_p_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_p_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t), p3));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_s32 (__ARM_mve_coerce(__p0, int32_t *), p1, __ARM_mve_coerce(__p2, int32x4_t)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_u32 (__ARM_mve_coerce(__p0, uint32_t *), p1, __ARM_mve_coerce(__p2, uint32x4_t)));})
 
-#define __arm_vstrwq_scatter_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vstrwq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_s32 (__ARM_mve_coerce(p0, int32_t *), __p1, __ARM_mve_coerce(__p2, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_u32 (__ARM_mve_coerce(p0, uint32_t *), __p1, __ARM_mve_coerce(__p2, uint32x4_t)));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int32_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrwq_scatter_offset_p_s32 (__ARM_mve_coerce(__p0, int32_t *), p1, __ARM_mve_coerce(__p2, int32x4_t), p3), \
+  int (*)[__ARM_mve_type_uint32_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrwq_scatter_offset_p_u32 (__ARM_mve_coerce(__p0, uint32_t *), p1, __ARM_mve_coerce(__p2, uint32x4_t), p3));})
 
 #define __arm_vstrwq_scatter_shifted_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
@@ -40154,32 +39987,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_veorq_x_u16 (__ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
   int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_veorq_x_u32 (__ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
 
-#define __arm_vmaxq_x(p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmulq_x_s8 (__ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmulq_x_s16 (__ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmulq_x_s32 (__ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int_n]: __arm_vmulq_x_n_s8 (__ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8_t), p3), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int_n]: __arm_vmulq_x_n_s16 (__ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16_t), p3), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int_n]: __arm_vmulq_x_n_s32 (__ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32_t), p3), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vmulq_x_u8 (__ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vmulq_x_u16 (__ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vmulq_x_u32 (__ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_int_n]: __arm_vmulq_x_n_u8 (__ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8_t), p3), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_int_n]: __arm_vmulq_x_n_u16 (__ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16_t), p3), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_int_n]: __arm_vmulq_x_n_u32 (__ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32_t), p3));})
-
-#define __arm_vminq_x(p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vminq_x_s8 (__ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vminq_x_s16 (__ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vminq_x_s32 (__ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vminq_x_u8 (__ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vminq_x_u16 (__ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vminq_x_u32 (__ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
-
 #define __arm_vmovlbq_x(p1,p2) ({ __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(__p1)])0, \
   int (*)[__ARM_mve_type_int8x16_t]: __arm_vmovlbq_x_s8 (__ARM_mve_coerce(__p1, int8x16_t), p2), \
@@ -40334,29 +40141,29 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint32x4_t]: __arm_vbrsrq_x_n_u32 (__ARM_mve_coerce(__p1, uint32x4_t), p2, p3));})
 
 #define __arm_vld1q_z(p0,p1) ( _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_z_s8 (__ARM_mve_coerce(p0, int8_t const *), p1), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_z_s16 (__ARM_mve_coerce(p0, int16_t const *), p1), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_z_s32 (__ARM_mve_coerce(p0, int32_t const *), p1), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_z_u8 (__ARM_mve_coerce(p0, uint8_t const *), p1), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_z_u16 (__ARM_mve_coerce(p0, uint16_t const *), p1), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_z_u32 (__ARM_mve_coerce(p0, uint32_t const *), p1)))
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld1q_z_s8 (__ARM_mve_coerce1(p0, int8_t *), p1), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld1q_z_s16 (__ARM_mve_coerce1(p0, int16_t *), p1), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld1q_z_s32 (__ARM_mve_coerce1(p0, int32_t *), p1), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld1q_z_u8 (__ARM_mve_coerce1(p0, uint8_t *), p1), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld1q_z_u16 (__ARM_mve_coerce1(p0, uint16_t *), p1), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld1q_z_u32 (__ARM_mve_coerce1(p0, uint32_t *), p1)))
 
 #define __arm_vld2q(p0) ( _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld2q_s8 (__ARM_mve_coerce(p0, int8_t const *)), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld2q_s16 (__ARM_mve_coerce(p0, int16_t const *)), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld2q_s32 (__ARM_mve_coerce(p0, int32_t const *)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld2q_u8 (__ARM_mve_coerce(p0, uint8_t const *)), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld2q_u16 (__ARM_mve_coerce(p0, uint16_t const *)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld2q_u32 (__ARM_mve_coerce(p0, uint32_t const *))))
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld2q_s8 (__ARM_mve_coerce1(p0, int8_t *)), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld2q_s16 (__ARM_mve_coerce1(p0, int16_t *)), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld2q_s32 (__ARM_mve_coerce1(p0, int32_t *)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld2q_u8 (__ARM_mve_coerce1(p0, uint8_t *)), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld2q_u16 (__ARM_mve_coerce1(p0, uint16_t *)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld2q_u32 (__ARM_mve_coerce1(p0, uint32_t *))))
 
 
 #define __arm_vld4q(p0) ( _Generic( (int (*)[__ARM_mve_typeid(p0)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld4q_s8 (__ARM_mve_coerce(p0, int8_t const *)), \
-  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld4q_s16 (__ARM_mve_coerce(p0, int16_t const *)), \
-  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld4q_s32 (__ARM_mve_coerce(p0, int32_t const *)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld4q_u8 (__ARM_mve_coerce(p0, uint8_t const *)), \
-  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld4q_u16 (__ARM_mve_coerce(p0, uint16_t const *)), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld4q_u32 (__ARM_mve_coerce(p0, uint32_t const *))))
+  int (*)[__ARM_mve_type_int8_t_ptr]: __arm_vld4q_s8 (__ARM_mve_coerce1(p0, int8_t *)), \
+  int (*)[__ARM_mve_type_int16_t_ptr]: __arm_vld4q_s16 (__ARM_mve_coerce1(p0, int16_t *)), \
+  int (*)[__ARM_mve_type_int32_t_ptr]: __arm_vld4q_s32 (__ARM_mve_coerce1(p0, int32_t *)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr]: __arm_vld4q_u8 (__ARM_mve_coerce1(p0, uint8_t *)), \
+  int (*)[__ARM_mve_type_uint16_t_ptr]: __arm_vld4q_u16 (__ARM_mve_coerce1(p0, uint16_t *)), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_vld4q_u32 (__ARM_mve_coerce1(p0, uint32_t *))))
 
 #define __arm_vgetq_lane(p0,p1) ({ __typeof(p0) __p0 = (p0); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)])0, \
@@ -40703,12 +40510,12 @@ extern void *__ARM_undef;
 
 #define __arm_vldrbq_gather_offset_z(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_z_s8 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint8x16_t), p2), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_z_s16 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_z_s32 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint32x4_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_z_u8 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint8x16_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_z_u16 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_z_u32 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_z_s8 (__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t), p2), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_z_s16 (__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_z_s32 (__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t), p2), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_z_u8 (__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), p2), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_z_u16 (__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_z_u32 (__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
 
 #define __arm_vqrdmlahq_m(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
@@ -41007,13 +40814,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsldavaxq_p_s16(__p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
   int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsldavaxq_p_s32(__p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3));})
 
-#define __arm_vrmlaldavhaq_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vrmlaldavhaq_p_s32 (__ARM_mve_coerce(__p0, int64_t), __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vrmlaldavhaq_p_u32 (__ARM_mve_coerce(__p0, uint64_t), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
-
 #define __arm_vrmlaldavhaxq_p(p0,p1,p2,p3) __arm_vrmlaldavhaxq_p_s32(p0,p1,p2,p3)
 
 #define __arm_vrmlsldavhaq_p(p0,p1,p2,p3) __arm_vrmlsldavhaq_p_s32(p0,p1,p2,p3)
@@ -41337,21 +41137,47 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vqrdmladhxq_m_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
   int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vqrdmladhxq_m_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3));})
 
-#define __arm_vmlsdavaxq_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
+#define __arm_vmlsdavaxq_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
+  __typeof(p2) __p2 = (p2); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaxq_p_s8 (p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaxq_p_s16 (p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaxq_p_s32 (p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3));})
+
+#define __arm_vmlsdavaq(p0,p1,p2) ({  __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
   _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaxq_p_s8 (__p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaxq_p_s16 (__p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaxq_p_s32 (__p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3));})
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaq_s8(p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t)), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaq_s16(p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t)), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaq_s32(p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t)));})
 
-#define __arm_vmlsdavaq_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
+#define __arm_vmlsdavaxq(p0,p1,p2) ({ __typeof(p2) __p2 = (p2); \
   __typeof(p1) __p1 = (p1); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaxq_s8(p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t)), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaxq_s16(p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t)), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaxq_s32(p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t)));})
+
+#define __arm_vmlsdavq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p1) __p1 = (p1); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavq_p_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t), p2), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavq_p_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavq_p_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2));})
+
+#define __arm_vmlsdavxq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p1) __p1 = (p1); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavxq_p_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t), p2), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavxq_p_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavxq_p_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2));})
+
+#define __arm_vmlsdavaq_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
   _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaq_p_s8(__p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaq_p_s16(__p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaq_p_s32(__p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3));})
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaq_p_s8(p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaq_p_s16(p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaq_p_s32(p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3));})
 
 #define __arm_vmladavaxq_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
@@ -41370,12 +41196,12 @@ extern void *__ARM_undef;
 
 #define __arm_vldrbq_gather_offset(p0,p1) ({ __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_s8 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint8x16_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_s16 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint16x8_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_s32 (__ARM_mve_coerce(p0, int8_t const *), __ARM_mve_coerce(__p1, uint32x4_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_u8 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint8x16_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_u16 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint16x8_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_u32 (__ARM_mve_coerce(p0, uint8_t const *), __ARM_mve_coerce(__p1, uint32x4_t)));})
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_s8(__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t)), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_s16(__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t)), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_s32(__ARM_mve_coerce1(p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vldrbq_gather_offset_u8(__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vldrbq_gather_offset_u16(__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vldrbq_gather_offset_u32(__ARM_mve_coerce1(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t)));})
 
 #define __arm_vidupq_m(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
  __typeof(p1) __p1 = (p1); \
@@ -41439,8 +41265,8 @@ extern void *__ARM_undef;
 
 #define __arm_viwdupq_u16(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)])0, \
-  int (*)[__ARM_mve_type_int_n]: __arm_viwdupq_n_u16 (__ARM_mve_coerce(__p0, uint32_t), p1, p2), \
-  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_viwdupq_wb_u16 (__ARM_mve_coerce(__p0, uint32_t *), p1, p2));})
+  int (*)[__ARM_mve_type_int_n]: __arm_viwdupq_n_u16 (__ARM_mve_coerce(__p0, uint32_t), p1, (const int) p2), \
+  int (*)[__ARM_mve_type_uint32_t_ptr]: __arm_viwdupq_wb_u16 (__ARM_mve_coerce(__p0, uint32_t *), p1, (const int) p2));})
 
 #define __arm_viwdupq_u32(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)])0, \
@@ -41622,16 +41448,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int16x8_t]: __arm_vmaxavq_p_s16 (__p0, __ARM_mve_coerce(__p1, int16x8_t), p2), \
   int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int32x4_t]: __arm_vmaxavq_p_s32 (__p0, __ARM_mve_coerce(__p1, int32x4_t), p2));})
 
-#define __arm_vmaxq_x(p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmaxq_x_s8 (__ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmaxq_x_s16 (__ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmaxq_x_s32 (__ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vmaxq_x_u8( __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
-  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vmaxq_x_u16( __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
-  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vmaxq_x_u32( __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
-
 #define __arm_vmaxvq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
@@ -41666,6 +41482,16 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int16x8_t]: __arm_vminavq_p_s16 (__p0, __ARM_mve_coerce(__p1, int16x8_t), p2), \
   int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int32x4_t]: __arm_vminavq_p_s32 (__p0, __ARM_mve_coerce(__p1, int32x4_t), p2));})
 
+#define __arm_vmaxq_x(p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
+  __typeof(p2) __p2 = (p2); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmaxq_x_s8 (__ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
+  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmaxq_x_s16 (__ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
+  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmaxq_x_s32 (__ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
+  int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vmaxq_x_u8 (__ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
+  int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vmaxq_x_u16 (__ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
+  int (*)[__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vmaxq_x_u32 (__ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
+
 #define __arm_vminq_x(p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
   _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
@@ -41804,22 +41630,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlaldavxq_p_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
   int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlaldavxq_p_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2));})
 
-#define __arm_vmlsdavaq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaq_s8(__p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t)), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaq_s16(__p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t)), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaq_s32(__p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t)));})
-
-#define __arm_vmlsdavaxq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavaxq_s8(__p0, __ARM_mve_coerce(__p1, int8x16_t), __ARM_mve_coerce(__p2, int8x16_t)), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavaxq_s16(__p0, __ARM_mve_coerce(__p1, int16x8_t), __ARM_mve_coerce(__p2, int16x8_t)), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavaxq_s32(__p0, __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t)));})
-
 #define __arm_vmlsdavq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
@@ -41827,13 +41637,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavq_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t)), \
   int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavq_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t)));})
 
-#define __arm_vmlsdavq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavq_p_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavq_p_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavq_p_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2));})
-
 #define __arm_vmlsdavxq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
   _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
@@ -41841,13 +41644,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavxq_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t)), \
   int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavxq_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t)));})
 
-#define __arm_vmlsdavxq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8x16_t][__ARM_mve_type_int8x16_t]: __arm_vmlsdavxq_p_s8 (__ARM_mve_coerce(__p0, int8x16_t), __ARM_mve_coerce(__p1, int8x16_t), p2), \
-  int (*)[__ARM_mve_type_int16x8_t][__ARM_mve_type_int16x8_t]: __arm_vmlsdavxq_p_s16 (__ARM_mve_coerce(__p0, int16x8_t), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vmlsdavxq_p_s32 (__ARM_mve_coerce(__p0, int32x4_t), __ARM_mve_coerce(__p1, int32x4_t), p2));})
-
 #define __arm_vmlsldavaq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
@@ -41942,13 +41738,6 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vmulltq_poly_x_p8 (__ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
   int (*)[__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vmulltq_poly_x_p16 (__ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3));})
 
-#define __arm_vrmlaldavhaq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
-  __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vrmlaldavhaq_s32 (__ARM_mve_coerce(__p0, int64_t), __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t)), \
-  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vrmlaldavhaq_u32 (__ARM_mve_coerce(__p0, uint64_t), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t)));})
-
 #define __arm_vrmlaldavhaxq(p0,p1,p2) __arm_vrmlaldavhaxq_s32(p0,p1,p2)
 
 #define __arm_vrmlaldavhq(p0,p1) ({ __typeof(p0) __p0 = (p0); \
@@ -41988,35 +41777,15 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_u16 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t)), \
   int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_u32 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t)));})
 
-#define __arm_vstrbq_p(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int8x16_t]: __arm_vstrbq_p_s8 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, int8x16_t), p2), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int16x8_t]: __arm_vstrbq_p_s16 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, int16x8_t), p2), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrbq_p_s32 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, int32x4_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_p_u8 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_p_u16 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_p_u32 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
-
-#define __arm_vstrbq_scatter_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_int8x16_t]: __arm_vstrbq_scatter_offset_s8 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, int8x16_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_int16x8_t]: __arm_vstrbq_scatter_offset_s16 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, int16x8_t)), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_int32x4_t]: __arm_vstrbq_scatter_offset_s32 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, int32x4_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_scatter_offset_u8 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_scatter_offset_u16 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t)), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_scatter_offset_u32 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t)));})
-
-
-#define __arm_vstrbq_scatter_offset_p(p0,p1,p2,p3) ({__typeof(p1) __p1 = (p1); \
-  __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_int8x16_t]: __arm_vstrbq_scatter_offset_p_s8 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_int16x8_t]: __arm_vstrbq_scatter_offset_p_s16 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
-  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_int32x4_t]: __arm_vstrbq_scatter_offset_p_s32 (__ARM_mve_coerce(p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_scatter_offset_p_u8 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_scatter_offset_p_u16 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
-  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_scatter_offset_p_u32 (__ARM_mve_coerce(p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
+#define __arm_vstrbq_p(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p1) __p1 = (p1); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)])0, \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int8x16_t]: __arm_vstrbq_p_s8 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, int8x16_t), p2), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int16x8_t]: __arm_vstrbq_p_s16 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, int16x8_t), p2), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_int32x4_t]: __arm_vstrbq_p_s32 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, int32x4_t), p2), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_p_u8 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), p2), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_p_u16 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), p2), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_p_u32 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), p2));})
 
 #define __arm_vstrdq_scatter_base(p0,p1,p2) ({ __typeof(p2) __p2 = (p2); \
   _Generic( (int (*)[__ARM_mve_typeid(__p2)])0, \
@@ -42028,29 +41797,65 @@ extern void *__ARM_undef;
   int (*)[__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_base_p_s64 (p0, p1, __ARM_mve_coerce(__p2, int64x2_t), p3), \
   int (*)[__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_base_p_u64 (p0, p1, __ARM_mve_coerce(__p2, uint64x2_t), p3));})
 
-#define __arm_vstrdq_scatter_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vrmlaldavhaq(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_offset_s64 (__ARM_mve_coerce(p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t)), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_offset_u64 (__ARM_mve_coerce(p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t)));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vrmlaldavhaq_s32 (__ARM_mve_coerce(__p0, int64_t), __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t)), \
+  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vrmlaldavhaq_u32 (__ARM_mve_coerce(__p0, uint64_t), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t)));})
+
+#define __arm_vrmlaldavhaq_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p1) __p1 = (p1); \
+  __typeof(p2) __p2 = (p2); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_int32x4_t][__ARM_mve_type_int32x4_t]: __arm_vrmlaldavhaq_p_s32 (__ARM_mve_coerce(__p0, int64_t), __ARM_mve_coerce(__p1, int32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
+  int (*)[__ARM_mve_type_int_n][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vrmlaldavhaq_p_u32 (__ARM_mve_coerce(__p0, uint64_t), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
 
-#define __arm_vstrdq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vstrbq_scatter_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_offset_p_s64 (__ARM_mve_coerce(p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t), p3), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_offset_p_u64 (__ARM_mve_coerce(p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t), p3));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_int8x16_t]: __arm_vstrbq_scatter_offset_s8 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, int8x16_t)), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_int16x8_t]: __arm_vstrbq_scatter_offset_s16 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, int16x8_t)), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_int32x4_t]: __arm_vstrbq_scatter_offset_s32 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, int32x4_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_scatter_offset_u8 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_scatter_offset_u16 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t)), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_scatter_offset_u32 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t)));})
 
-#define __arm_vstrdq_scatter_shifted_offset(p0,p1,p2) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vstrbq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p1) __p1 = (p1); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_shifted_offset_s64 (__ARM_mve_coerce(p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t)), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_shifted_offset_u64 (__ARM_mve_coerce(p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t)));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p1)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_int8x16_t]: __arm_vstrbq_scatter_offset_p_s8 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, int8x16_t), p3), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_int16x8_t]: __arm_vstrbq_scatter_offset_p_s16 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, int16x8_t), p3), \
+  int (*)[__ARM_mve_type_int8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_int32x4_t]: __arm_vstrbq_scatter_offset_p_s32 (__ARM_mve_coerce(__p0, int8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, int32x4_t), p3), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint8x16_t][__ARM_mve_type_uint8x16_t]: __arm_vstrbq_scatter_offset_p_u8 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint8x16_t), __ARM_mve_coerce(__p2, uint8x16_t), p3), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint16x8_t][__ARM_mve_type_uint16x8_t]: __arm_vstrbq_scatter_offset_p_u16 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint16x8_t), __ARM_mve_coerce(__p2, uint16x8_t), p3), \
+  int (*)[__ARM_mve_type_uint8_t_ptr][__ARM_mve_type_uint32x4_t][__ARM_mve_type_uint32x4_t]: __arm_vstrbq_scatter_offset_p_u32 (__ARM_mve_coerce(__p0, uint8_t *), __ARM_mve_coerce(__p1, uint32x4_t), __ARM_mve_coerce(__p2, uint32x4_t), p3));})
 
-#define __arm_vstrdq_scatter_shifted_offset_p(p0,p1,p2,p3) ({ __typeof(p1) __p1 = (p1); \
+#define __arm_vstrdq_scatter_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
   __typeof(p2) __p2 = (p2); \
-  _Generic( (int (*)[__ARM_mve_typeid(p0)][__ARM_mve_typeid(__p2)])0, \
-  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_shifted_offset_p_s64 (__ARM_mve_coerce(p0, int64_t *), __p1, __ARM_mve_coerce(__p2, int64x2_t), p3), \
-  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_shifted_offset_p_u64 (__ARM_mve_coerce(p0, uint64_t *), __p1, __ARM_mve_coerce(__p2, uint64x2_t), p3));})
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_offset_p_s64 (__ARM_mve_coerce(__p0, int64_t *), p1, __ARM_mve_coerce(__p2, int64x2_t), p3), \
+  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_offset_p_u64 (__ARM_mve_coerce(__p0, uint64_t *), p1, __ARM_mve_coerce(__p2, uint64x2_t), p3));})
+
+#define __arm_vstrdq_scatter_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p2) __p2 = (p2); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_offset_s64 (__ARM_mve_coerce(__p0, int64_t *), p1, __ARM_mve_coerce(__p2, int64x2_t)), \
+  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_offset_u64 (__ARM_mve_coerce(__p0, uint64_t *), p1, __ARM_mve_coerce(__p2, uint64x2_t)));})
+
+#define __arm_vstrdq_scatter_shifted_offset_p(p0,p1,p2,p3) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p2) __p2 = (p2); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_shifted_offset_p_s64 (__ARM_mve_coerce(__p0, int64_t *), p1, __ARM_mve_coerce(__p2, int64x2_t), p3), \
+  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_shifted_offset_p_u64 (__ARM_mve_coerce(__p0, uint64_t *), p1, __ARM_mve_coerce(__p2, uint64x2_t), p3));})
+
+#define __arm_vstrdq_scatter_shifted_offset(p0,p1,p2) ({ __typeof(p0) __p0 = (p0); \
+  __typeof(p2) __p2 = (p2); \
+  _Generic( (int (*)[__ARM_mve_typeid(__p0)][__ARM_mve_typeid(__p2)])0, \
+  int (*)[__ARM_mve_type_int64_t_ptr][__ARM_mve_type_int64x2_t]: __arm_vstrdq_scatter_shifted_offset_s64 (__ARM_mve_coerce(__p0, int64_t *), p1, __ARM_mve_coerce(__p2, int64x2_t)), \
+  int (*)[__ARM_mve_type_uint64_t_ptr][__ARM_mve_type_uint64x2_t]: __arm_vstrdq_scatter_shifted_offset_u64 (__ARM_mve_coerce(__p0, uint64_t *), p1, __ARM_mve_coerce(__p2, uint64x2_t)));})
 
 #endif /* __cplusplus  */
 #endif /* __ARM_FEATURE_MVE  */
diff --git a/gcc/config/arm/iterators.md b/gcc/config/arm/iterators.md
index 846bae7b71f..21a938f71bf 100644
--- a/gcc/config/arm/iterators.md
+++ b/gcc/config/arm/iterators.md
@@ -269,6 +269,7 @@
 
 ;; MVE mode iterator.
 (define_mode_iterator MVE_types [V16QI V8HI V4SI V2DI TI V8HF V4SF V2DF])
+(define_mode_iterator MVE_vecs [V16QI V8HI V4SI V2DI V8HF V4SF V2DF])
 (define_mode_iterator MVE_VLD_ST [V16QI V8HI V4SI V8HF V4SF])
 (define_mode_iterator MVE_0 [V8HF V4SF])
 (define_mode_iterator MVE_1 [V16QI V8HI V4SI V2DI])
@@ -575,9 +576,10 @@
 			  (V4HI "HI") (V8HI "HI")
 			  (V4HF "HF") (V8HF "HF")
 			  (V4BF "BF") (V8BF "BF")
-                          (V2SI "SI") (V4SI "SI")
-                          (V2SF "SF") (V4SF "SF")
-                          (DI "DI")   (V2DI "DI")])
+			  (V2SI "SI") (V4SI "SI")
+			  (V2SF "SF") (V4SF "SF")
+			  (DI   "DI") (V2DI "DI")
+			  (V2DF "DF")])
 
 ;; As above but in lower case.
 (define_mode_attr V_elem_l [(V8QI "qi") (V16QI "qi")
diff --git a/gcc/config/arm/mve.md b/gcc/config/arm/mve.md
index 11c69443fb9..6d84cd47a9b 100644
--- a/gcc/config/arm/mve.md
+++ b/gcc/config/arm/mve.md
@@ -41,44 +41,19 @@
 
   if (which_alternative == 4 || which_alternative == 7)
     {
-      rtx ops[2];
-      int regno = (which_alternative == 7)
-		  ? REGNO (operands[1]) : REGNO (operands[0]);
-
-      ops[0] = operands[0];
-      ops[1] = operands[1];
-      if (<MODE>mode == V2DFmode || <MODE>mode == V2DImode)
-	{
-	  if (which_alternative == 7)
-	    {
-	      ops[1] = gen_rtx_REG (DImode, regno);
-	      output_asm_insn ("vstr.64\t%P1, %E0",ops);
-	    }
-	  else
-	    {
-	      ops[0] = gen_rtx_REG (DImode, regno);
-	      output_asm_insn ("vldr.64\t%P0, %E1",ops);
-	    }
-	}
-      else if (<MODE>mode == TImode)
+      if (<MODE>mode == V2DFmode || <MODE>mode == V2DImode || <MODE>mode == TImode)
 	{
 	  if (which_alternative == 7)
-	    output_asm_insn ("vstr.64\t%q1, %E0",ops);
+	    output_asm_insn ("vstrw.32\t%q1, %E0", operands);
 	  else
-	    output_asm_insn ("vldr.64\t%q0, %E1",ops);
+	    output_asm_insn ("vldrw.u32\t%q0, %E1",operands);
 	}
       else
 	{
 	  if (which_alternative == 7)
-	    {
-	      ops[1] = gen_rtx_REG (TImode, regno);
-	      output_asm_insn ("vstr<V_sz_elem1>.<V_sz_elem>\t%q1, %E0",ops);
-	    }
+	    output_asm_insn ("vstr<V_sz_elem1>.<V_sz_elem>\t%q1, %E0", operands);
 	  else
-	    {
-	      ops[0] = gen_rtx_REG (TImode, regno);
-	      output_asm_insn ("vldr<V_sz_elem1>.<V_sz_elem>\t%q0, %E1",ops);
-	    }
+	    output_asm_insn ("vldr<V_sz_elem1>.<V_sz_elem>\t%q0, %E1", operands);
 	}
       return "";
     }
@@ -104,18 +79,14 @@
    (set_attr "thumb2_pool_range" "*,*,*,*,1018,*,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,*,996,*,*,*,*")])
 
-(define_insn "*mve_mov<mode>"
-  [(set (match_operand:MVE_types 0 "s_register_operand" "=w,w")
-	(vec_duplicate:MVE_types
-	  (match_operand:SI 1 "nonmemory_operand" "r,i")))]
+(define_insn "*mve_vdup<mode>"
+  [(set (match_operand:MVE_vecs 0 "s_register_operand" "=w")
+	(vec_duplicate:MVE_vecs
+	  (match_operand:<V_elem> 1 "s_register_operand" "r")))]
   "TARGET_HAVE_MVE || TARGET_HAVE_MVE_FLOAT"
-{
-  if (which_alternative == 0)
-    return "vdup.<V_sz_elem>\t%q0, %1";
-  return "vmov.<V_sz_elem>\t%q0, %1";
-}
-  [(set_attr "length" "4,4")
-   (set_attr "type" "mve_move,mve_move")])
+  "vdup.<V_sz_elem>\t%q0, %1"
+  [(set_attr "length" "4")
+   (set_attr "type" "mve_move")])
 
 ;;
 ;; [vst4q])
@@ -10739,13 +10710,6 @@
  [(set_attr "type" "mve_move")
   (set_attr "length" "8")])
 
-(define_insn "*mve_vec_duplicate<mode>"
- [(set (match_operand:MVE_VLD_ST 0 "s_register_operand" "=w")
-       (vec_duplicate:MVE_VLD_ST (match_operand:<V_elem> 1 "general_operand" "r")))]
- "TARGET_HAVE_MVE || TARGET_HAVE_MVE_FLOAT"
- "vdup.<V_sz_elem>\t%q0, %1"
- [(set_attr "type" "mve_move")])
-
 ;; CDE instructions on MVE registers.
 
 (define_insn "arm_vcx1qv16qi"
diff --git a/gcc/config/arm/sync.md b/gcc/config/arm/sync.md
index 78498d052b2..0ec289a0abb 100644
--- a/gcc/config/arm/sync.md
+++ b/gcc/config/arm/sync.md
@@ -187,20 +187,20 @@
 ;; Constraints of this pattern must be at least as strict as those of the
 ;; cbranchsi operations in thumb1.md and aim to be as permissive.
 (define_insn_and_split "@atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1"
-  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l,&l")	;; bool out
+  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l")	;; bool out
 	(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))
-   (set (match_operand:SI 1 "s_register_operand" "=&r,&l,&0,&l*h")	;; val out
+   (set (match_operand:SI 1 "s_register_operand" "=&r,&l,&l*h")	;; val out
 	(zero_extend:SI
-	  (match_operand:NARROW 2 "mem_noofs_operand" "+Ua,Ua,Ua,Ua")))	;; memory
+	  (match_operand:NARROW 2 "mem_noofs_operand" "+Ua,Ua,Ua")))	;; memory
    (set (match_dup 2)
 	(unspec_volatile:NARROW
-	  [(match_operand:SI 3 "arm_add_operand" "rIL,lIL*h,J,*r")	;; expected
-	   (match_operand:NARROW 4 "s_register_operand" "r,r,r,r")	;; desired
+	  [(match_operand:SI 3 "arm_add_operand" "rIL,lILJ*h,*r")	;; expected
+	   (match_operand:NARROW 4 "s_register_operand" "r,r,r")	;; desired
 	   (match_operand:SI 5 "const_int_operand")		;; is_weak
 	   (match_operand:SI 6 "const_int_operand")		;; mod_s
 	   (match_operand:SI 7 "const_int_operand")]		;; mod_f
 	  VUNSPEC_ATOMIC_CAS))
-   (clobber (match_scratch:SI 8 "=&r,X,X,X"))]
+   (clobber (match_scratch:SI 8 "=&r,X,X"))]
   "<NARROW:sync_predtab>"
   "#"
   "&& reload_completed"
@@ -209,7 +209,7 @@
     arm_split_compare_and_swap (operands);
     DONE;
   }
-  [(set_attr "arch" "32,v8mb,v8mb,v8mb")])
+  [(set_attr "arch" "32,v8mb,v8mb")])
 
 (define_mode_attr cas_cmp_operand
   [(SI "arm_add_operand") (DI "cmpdi_operand")])
@@ -219,19 +219,19 @@
 ;; Constraints of this pattern must be at least as strict as those of the
 ;; cbranchsi operations in thumb1.md and aim to be as permissive.
 (define_insn_and_split "@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1"
-  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l,&l")	;; bool out
+  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l")	;; bool out
 	(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))
-   (set (match_operand:SIDI 1 "s_register_operand" "=&r,&l,&0,&l*h")	;; val out
-	(match_operand:SIDI 2 "mem_noofs_operand" "+Ua,Ua,Ua,Ua"))	;; memory
+   (set (match_operand:SIDI 1 "s_register_operand" "=&r,&l,&l*h")	;; val out
+	(match_operand:SIDI 2 "mem_noofs_operand" "+Ua,Ua,Ua"))	;; memory
    (set (match_dup 2)
 	(unspec_volatile:SIDI
-	  [(match_operand:SIDI 3 "<SIDI:cas_cmp_operand>" "<SIDI:cas_cmp_str>,lIL*h,J,*r") ;; expect
-	   (match_operand:SIDI 4 "s_register_operand" "r,r,r,r")	;; desired
+	  [(match_operand:SIDI 3 "<SIDI:cas_cmp_operand>" "<SIDI:cas_cmp_str>,lILJ*h,*r") ;; expect
+	   (match_operand:SIDI 4 "s_register_operand" "r,r,r")	;; desired
 	   (match_operand:SI 5 "const_int_operand")		;; is_weak
 	   (match_operand:SI 6 "const_int_operand")		;; mod_s
 	   (match_operand:SI 7 "const_int_operand")]		;; mod_f
 	  VUNSPEC_ATOMIC_CAS))
-   (clobber (match_scratch:SI 8 "=&r,X,X,X"))]
+   (clobber (match_scratch:SI 8 "=&r,X,X"))]
   "<SIDI:sync_predtab>"
   "#"
   "&& reload_completed"
@@ -240,7 +240,7 @@
     arm_split_compare_and_swap (operands);
     DONE;
   }
-  [(set_attr "arch" "32,v8mb,v8mb,v8mb")])
+  [(set_attr "arch" "32,v8mb,v8mb")])
 
 (define_insn_and_split "atomic_exchange<mode>"
   [(set (match_operand:QHSD 0 "s_register_operand" "=&r,&r")	;; output
diff --git a/gcc/config/arm/t-rmprofile b/gcc/config/arm/t-rmprofile
index 16e368f25cc..9f4d70b718a 100644
--- a/gcc/config/arm/t-rmprofile
+++ b/gcc/config/arm/t-rmprofile
@@ -53,10 +53,15 @@ MULTILIB_REQUIRED	+= mthumb/march=armv8.1-m.main+mve/mfloat-abi=hard
 # Arch Matches
 MULTILIB_MATCHES	+= march?armv6s-m=march?armv6-m
 
+# For all MULITIB_MATCHES for v8-m and above add mlibarch? on the right hand side
+# of = in the variant string instead of march?.  This is needed becuase all the
+# MULITIB_MATCHES variant strings are compared with mlibarch option for multilib
+# linking.
+
 # Map all v8-m.main+dsp FP variants down to the variant without DSP.
-MULTILIB_MATCHES	+= march?armv8-m.main=march?armv8-m.main+dsp \
+MULTILIB_MATCHES	+= march?armv8-m.main=mlibarch?armv8-m.main+dsp \
 			   $(foreach FP, +fp +fp.dp, \
-			     march?armv8-m.main$(FP)=march?armv8-m.main+dsp$(FP))
+			     march?armv8-m.main$(FP)=mlibarch?armv8-m.main+dsp$(FP))
 
 # For single-precision only fpv5, use the base fp libraries
 MULTILIB_MATCHES	+= march?armv7e-m+fp=march?armv7e-m+fpv5
@@ -65,10 +70,9 @@ MULTILIB_MATCHES	+= march?armv7e-m+fp=march?armv7e-m+fpv5
 MULTILIB_REUSE		+= $(foreach ARCH, armv6s-m armv7-m armv7e-m armv8-m\.base armv8-m\.main, \
 			     mthumb/march.$(ARCH)/mfloat-abi.soft=mthumb/march.$(ARCH)/mfloat-abi.softfp)
 
-
 # Map v8.1-M to v8-M.
-MULTILIB_MATCHES	+= march?armv8-m.main=march?armv8.1-m.main
-MULTILIB_MATCHES	+= march?armv8-m.main=march?armv8.1-m.main+dsp
+MULTILIB_MATCHES	+= march?armv8-m.main=mlibarch?armv8.1-m.main
+MULTILIB_MATCHES	+= march?armv8-m.main=mlibarch?armv8.1-m.main+dsp
 MULTILIB_REUSE		+= mthumb/march.armv8-m\.main/mfloat-abi.soft=mthumb/march.armv8\.1-m\.main+mve/mfloat-abi.soft
 MULTILIB_REUSE		+= mthumb/march.armv8-m\.main/mfloat-abi.soft=mthumb/march.armv8\.1-m\.main+mve/mfloat-abi.softfp
 
@@ -77,8 +81,15 @@ v8_1m_dp_variants = +fp.dp +dsp+fp.dp +fp.dp+mve +fp.dp+mve.fp
 
 # Map all v8.1-m.main FP sp variants down to v8-m.
 MULTILIB_MATCHES += $(foreach FP, $(v8_1m_sp_variants), \
-			     march?armv8-m.main+fp=march?armv8.1-m.main$(FP))
+			     march?armv8-m.main+fp=mlibarch?armv8.1-m.main$(FP))
 
 # Map all v8.1-m.main FP dp variants down to v8-m.
 MULTILIB_MATCHES += $(foreach FP, $(v8_1m_dp_variants), \
-			     march?armv8-m.main+fp.dp=march?armv8.1-m.main$(FP))
+			     march?armv8-m.main+fp.dp=mlibarch?armv8.1-m.main$(FP))
+
+# For all the MULTILIB_REQUIRED for v8-m and above, add MULTILIB_MATCHES which
+# maps mlibarch with march for multilib linking.
+MULTILIB_MATCHES	+= march?armv8-m.main=mlibarch?armv8-m.main
+MULTILIB_MATCHES	+= march?armv8-m.main+fp=mlibarch?armv8-m.main+fp
+MULTILIB_MATCHES	+= march?armv8-m.main+fp.dp=mlibarch?armv8-m.main+fp.dp
+MULTILIB_MATCHES	+= march?armv8.1-m.main+mve=mlibarch?armv8.1-m.main+mve
diff --git a/gcc/config/arm/thumb1.md b/gcc/config/arm/thumb1.md
index f0129db2c3e..46351d9f784 100644
--- a/gcc/config/arm/thumb1.md
+++ b/gcc/config/arm/thumb1.md
@@ -1242,6 +1242,21 @@
    (set_attr "type" "multiple")]
 )
 
+;; An expander which makes use of the cbranchsi4_scratch insn, but can
+;; be used safely after RA.
+(define_expand "cbranchsi4_neg_late"
+  [(parallel [
+     (set (pc) (if_then_else
+		(match_operator 4 "arm_comparison_operator"
+		 [(match_operand:SI 1 "s_register_operand")
+		  (match_operand:SI 2 "thumb1_cmpneg_operand")])
+		(label_ref (match_operand 3 "" ""))
+		(pc)))
+     (clobber (match_operand:SI 0 "s_register_operand"))
+  ])]
+  "TARGET_THUMB1"
+)
+
 ;; Changes to the constraints of this pattern must be propagated to those of
 ;; atomic compare_and_swap splitters in sync.md.  These must be at least as
 ;; strict as the constraints here and aim to be as permissive.
diff --git a/gcc/config/arm/vfp.md b/gcc/config/arm/vfp.md
index e6c287c1a85..63915478582 100644
--- a/gcc/config/arm/vfp.md
+++ b/gcc/config/arm/vfp.md
@@ -1703,12 +1703,15 @@
    (set_attr "type" "mov_reg")]
 )
 
+;; Both this and the next instruction are treated by GCC in the same
+;; way as a blockage pattern.  That's perhaps stronger than it needs
+;; to be, but we do not want accesses to the VFP register bank to be
+;; moved across either instruction.
+
 (define_insn "lazy_store_multiple_insn"
-  [(set (match_operand:SI 0 "s_register_operand" "+&rk")
-	(post_dec:SI (match_dup 0)))
-   (unspec_volatile [(const_int 0)
-		     (mem:SI (post_dec:SI (match_dup 0)))]
-		    VUNSPEC_VLSTM)]
+  [(unspec_volatile
+    [(mem:BLK (match_operand:SI 0 "s_register_operand" "rk"))]
+    VUNSPEC_VLSTM)]
   "use_cmse && reload_completed"
   "vlstm%?\\t%0"
   [(set_attr "predicable" "yes")
@@ -1716,14 +1719,16 @@
 )
 
 (define_insn "lazy_load_multiple_insn"
-  [(set (match_operand:SI 0 "s_register_operand" "+&rk")
-	(post_inc:SI (match_dup 0)))
-   (unspec_volatile:SI [(const_int 0)
-			(mem:SI (match_dup 0))]
-		       VUNSPEC_VLLDM)]
+  [(unspec_volatile
+    [(mem:BLK (match_operand:SI 0 "s_register_operand" "rk,rk"))]
+    VUNSPEC_VLLDM)]
   "use_cmse && reload_completed"
-  "vlldm%?\\t%0"
-  [(set_attr "predicable" "yes")
+  "@
+   vscclrm\\t{vpr}\;vlldm\\t%0
+   vlldm\\t%0"
+  [(set_attr "arch" "fix_vlldm,*")
+   (set_attr "predicable" "no")
+   (set_attr "length" "8,4")
    (set_attr "type" "load_4")]
 )
 
diff --git a/gcc/config/bpf/bpf.h b/gcc/config/bpf/bpf.h
index 359f389a134..88183e69564 100644
--- a/gcc/config/bpf/bpf.h
+++ b/gcc/config/bpf/bpf.h
@@ -57,8 +57,8 @@
    64-bit at any time.  */
 #define STACK_BOUNDARY 64
 
-/* Function entry points are aligned to 128 bits.  */
-#define FUNCTION_BOUNDARY 128
+/* Function entry points are aligned to 64 bits.  */
+#define FUNCTION_BOUNDARY 64
 
 /* Maximum alignment required by data of any type.  */
 #define BIGGEST_ALIGNMENT 64
@@ -422,9 +422,15 @@ enum reg_class
    Try to use asm_output_aligned_bss to implement this macro.  */
 
 #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)	\
-  do {								\
-    ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);		\
-  } while (0)
+  do									\
+    {									\
+      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");			\
+      fprintf ((FILE), "%s", "\t.lcomm\t");				\
+      assemble_name ((FILE), (NAME));					\
+      fprintf ((FILE), "," HOST_WIDE_INT_PRINT_UNSIGNED ",%u\n",	\
+	       (SIZE), (ALIGN) / BITS_PER_UNIT);			\
+    }									\
+  while (0)
 
 /*** Output and Generation of Labels.  */
 
diff --git a/gcc/config/i386/avx512dqintrin.h b/gcc/config/i386/avx512dqintrin.h
index d28dfab8e4e..bdc8f1dc0b1 100644
--- a/gcc/config/i386/avx512dqintrin.h
+++ b/gcc/config/i386/avx512dqintrin.h
@@ -2655,7 +2655,7 @@ _mm512_fpclass_ps_mask (__m512 __A, const int __imm)
 
 #define _mm512_mask_fpclass_ps_mask(u, x, c)				\
   ((__mmask16) __builtin_ia32_fpclassps512_mask ((__v16sf) (__m512) (x),\
-						 (int) (c),(__mmask8)(u)))
+						 (int) (c),(__mmask16)(u)))
 
 #define _mm512_fpclass_pd_mask(X, C)                                    \
   ((__mmask8) __builtin_ia32_fpclasspd512_mask ((__v8df) (__m512d) (X), \
@@ -2663,7 +2663,7 @@ _mm512_fpclass_ps_mask (__m512 __A, const int __imm)
 
 #define _mm512_fpclass_ps_mask(x, c)                                    \
   ((__mmask16) __builtin_ia32_fpclassps512_mask ((__v16sf) (__m512) (x),\
-						 (int) (c),(__mmask8)-1))
+						 (int) (c),(__mmask16)-1))
 
 #define _mm_reduce_sd(A, B, C)						\
   ((__m128d) __builtin_ia32_reducesd_mask ((__v2df)(__m128d)(A),	\
diff --git a/gcc/config/i386/i386-builtins.c b/gcc/config/i386/i386-builtins.c
index 6f6a8328ef1..c24cbd5de28 100644
--- a/gcc/config/i386/i386-builtins.c
+++ b/gcc/config/i386/i386-builtins.c
@@ -2323,7 +2323,11 @@ fold_builtin_cpu (tree fndecl, tree *args)
       /* Return __cpu_model.__cpu_features[0] & field_val  */
       final = build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,
 		      build_int_cstu (unsigned_type_node, field_val));
-      return build1 (CONVERT_EXPR, integer_type_node, final);
+      if (isa_names_table[i].feature == (INT_TYPE_SIZE - 1))
+	return build2 (NE_EXPR, integer_type_node, final,
+		       build_int_cst (unsigned_type_node, 0));
+      else
+	return build1 (CONVERT_EXPR, integer_type_node, final);
     }
   gcc_unreachable ();
 }
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 2f838840e96..44e4be58c39 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -6356,12 +6356,29 @@ ix86_compute_frame_layout (void)
 	 area, see the SEH code in config/i386/winnt.c for the rationale.  */
       frame->hard_frame_pointer_offset = frame->sse_reg_save_offset;
 
-      /* If we can leave the frame pointer where it is, do so.  Also, return
+      /* If we can leave the frame pointer where it is, do so; however return
 	 the establisher frame for __builtin_frame_address (0) or else if the
-	 frame overflows the SEH maximum frame size.  */
+	 frame overflows the SEH maximum frame size.
+
+	 Note that the value returned by __builtin_frame_address (0) is quite
+	 constrained, because setjmp is piggybacked on the SEH machinery with
+	 recent versions of MinGW:
+
+	  #    elif defined(__SEH__)
+	  #     if defined(__aarch64__) || defined(_ARM64_)
+	  #      define setjmp(BUF) _setjmp((BUF), __builtin_sponentry())
+	  #     elif (__MINGW_GCC_VERSION < 40702)
+	  #      define setjmp(BUF) _setjmp((BUF), mingw_getsp())
+	  #     else
+	  #      define setjmp(BUF) _setjmp((BUF), __builtin_frame_address (0))
+	  #     endif
+
+	 and the second argument passed to _setjmp, if not null, is forwarded
+	 to the TargetFrame parameter of RtlUnwindEx by longjmp (after it has
+	 built an ExceptionRecord on the fly describing the setjmp buffer).  */
       const HOST_WIDE_INT diff
 	= frame->stack_pointer_offset - frame->hard_frame_pointer_offset;
-      if (diff <= 255)
+      if (diff <= 255 && !crtl->accesses_prior_frames)
 	{
 	  /* The resulting diff will be a multiple of 16 lower than 255,
 	     i.e. at most 240 as required by the unwind data structure.  */
@@ -10318,24 +10335,19 @@ legitimate_pic_address_disp_p (rtx disp)
 	      if (is_imported_p (op0))
 		return true;
 
-	      if (SYMBOL_REF_FAR_ADDR_P (op0)
-		  || !SYMBOL_REF_LOCAL_P (op0))
+	      if (SYMBOL_REF_FAR_ADDR_P (op0) || !SYMBOL_REF_LOCAL_P (op0))
 		break;
 
-	      /* Function-symbols need to be resolved only for
-	         large-model.
-	         For the small-model we don't need to resolve anything
-	         here.  */
+	      /* Non-external-weak function symbols need to be resolved only
+		 for the large model.  Non-external symbols don't need to be
+		 resolved for large and medium models.  For the small model,
+		 we don't need to resolve anything here.  */
 	      if ((ix86_cmodel != CM_LARGE_PIC
-	           && SYMBOL_REF_FUNCTION_P (op0))
+		   && SYMBOL_REF_FUNCTION_P (op0)
+		   && !(SYMBOL_REF_EXTERNAL_P (op0) && SYMBOL_REF_WEAK (op0)))
+		  || !SYMBOL_REF_EXTERNAL_P (op0)
 		  || ix86_cmodel == CM_SMALL_PIC)
 		return true;
-	      /* Non-external symbols don't need to be resolved for
-	         large, and medium-model.  */
-	      if ((ix86_cmodel == CM_LARGE_PIC
-		   || ix86_cmodel == CM_MEDIUM_PIC)
-		  && !SYMBOL_REF_EXTERNAL_P (op0))
-		return true;
 	    }
 	  else if (!SYMBOL_REF_FAR_ADDR_P (op0)
 		   && (SYMBOL_REF_LOCAL_P (op0)
@@ -13465,7 +13477,10 @@ ix86_print_operand_address_as (FILE *file, rtx addr,
 static void
 ix86_print_operand_address (FILE *file, machine_mode /*mode*/, rtx addr)
 {
-  ix86_print_operand_address_as (file, addr, ADDR_SPACE_GENERIC, false);
+  if (this_is_asm_operands && ! address_operand (addr, VOIDmode))
+    output_operand_lossage ("invalid constraints for operand");
+  else
+    ix86_print_operand_address_as (file, addr, ADDR_SPACE_GENERIC, false);
 }
 
 /* Implementation of TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA.  */
@@ -15836,8 +15851,10 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)
 	    break;
 
 	  /* If we get to the epilogue note, prevent a catch region from
-	     being adjacent to the standard epilogue sequence.  If non-
-	     call-exceptions, we'll have done this during epilogue emission. */
+	     being adjacent to the standard epilogue sequence.  Note that,
+	     if non-call exceptions are enabled, we already did it during
+	     epilogue expansion, or else, if the insn can throw internally,
+	     we already did it during the reorg pass.  */
 	  if (NOTE_P (i) && NOTE_KIND (i) == NOTE_INSN_EPILOGUE_BEG
 	      && !flag_non_call_exceptions
 	      && !can_throw_internal (insn))
@@ -21333,10 +21350,12 @@ ix86_stack_protect_fail (void)
    After all, the relocation needed is the same as for the call insn.
    Whether or not a particular assembler allows us to enter such, I
    guess we'll have to see.  */
+
 int
 asm_preferred_eh_data_format (int code, int global)
 {
-  if (flag_pic)
+  /* PE-COFF is effectively always -fPIC because of the .reloc section.  */
+  if (flag_pic || TARGET_PECOFF)
     {
       int type = DW_EH_PE_sdata8;
       if (!TARGET_64BIT
@@ -21345,9 +21364,11 @@ asm_preferred_eh_data_format (int code, int global)
 	type = DW_EH_PE_sdata4;
       return (global ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | type;
     }
+
   if (ix86_cmodel == CM_SMALL
       || (ix86_cmodel == CM_MEDIUM && code))
     return DW_EH_PE_udata4;
+
   return DW_EH_PE_absptr;
 }
 
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index d447df2cfe4..670ff1d3682 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -13812,10 +13812,12 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "bsr_rex64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:DI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:DI 0 "register_operand" "=r")
 	(minus:DI (const_int 63)
-		  (clz:DI (match_operand:DI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:DI (match_dup 1))))]
   "TARGET_64BIT"
   "bsr{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13824,10 +13826,12 @@
    (set_attr "mode" "DI")])
 
 (define_insn "bsr"
-  [(set (match_operand:SI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
 	(minus:SI (const_int 31)
-		  (clz:SI (match_operand:SI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:SI (match_dup 1))))]
   ""
   "bsr{l}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13835,25 +13839,15 @@
    (set_attr "znver1_decode" "vector")
    (set_attr "mode" "SI")])
 
-(define_insn "*bsrhi"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(minus:HI (const_int 15)
-		  (clz:HI (match_operand:HI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
-  ""
-  "bsr{w}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")
-   (set_attr "prefix_0f" "1")
-   (set_attr "znver1_decode" "vector")
-   (set_attr "mode" "HI")])
-
 (define_expand "clz<mode>2"
   [(parallel
-     [(set (match_operand:SWI48 0 "register_operand")
+     [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SWI48 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+      (set (match_operand:SWI48 0 "register_operand")
 	   (minus:SWI48
 	     (match_dup 2)
-	     (clz:SWI48 (match_operand:SWI48 1 "nonimmediate_operand"))))
-      (clobber (reg:CC FLAGS_REG))])
+	     (clz:SWI48 (match_dup 1))))])
    (parallel
      [(set (match_dup 0) (xor:SWI48 (match_dup 0) (match_dup 2)))
       (clobber (reg:CC FLAGS_REG))])]
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index bf01e1d7426..b80da2e6c50 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -16927,7 +16927,7 @@
    (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI,TI")])
 
-(define_insn "abs<mode>2"
+(define_expand "abs<mode>2"
   [(set (match_operand:MMXMODEI 0 "register_operand")
 	(abs:MMXMODEI
 	  (match_operand:MMXMODEI 1 "register_operand")))]
@@ -21728,8 +21728,9 @@
   "TARGET_AVX512F"
 {
   operands[5]
-    = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, operands[0], operands[2],
-					operands[4]), UNSPEC_VSIBADDR);
+    = gen_rtx_UNSPEC (Pmode, gen_rtvec (4, operands[0], operands[2],
+					operands[4], operands[1]),
+					UNSPEC_VSIBADDR);
 })
 
 (define_insn "*avx512f_scattersi<VI48F:mode>"
@@ -21737,10 +21738,11 @@
 	  [(unspec:P
 	     [(match_operand:P 0 "vsib_address_operand" "Tv")
 	      (match_operand:<VEC_GATHER_IDXSI> 2 "register_operand" "v")
-	      (match_operand:SI 4 "const1248_operand" "n")]
+	      (match_operand:SI 4 "const1248_operand" "n")
+	      (match_operand:<avx512fmaskmode> 6 "register_operand" "1")]
 	     UNSPEC_VSIBADDR)])
 	(unspec:VI48F
-	  [(match_operand:<avx512fmaskmode> 6 "register_operand" "1")
+	  [(match_dup 6)
 	   (match_operand:VI48F 3 "register_operand" "v")]
 	  UNSPEC_SCATTER))
    (clobber (match_scratch:<avx512fmaskmode> 1 "=&Yk"))]
@@ -21766,8 +21768,9 @@
   "TARGET_AVX512F"
 {
   operands[5]
-    = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, operands[0], operands[2],
-					operands[4]), UNSPEC_VSIBADDR);
+    = gen_rtx_UNSPEC (Pmode, gen_rtvec (4, operands[0], operands[2],
+					operands[4], operands[1]),
+					UNSPEC_VSIBADDR);
 })
 
 (define_insn "*avx512f_scatterdi<VI48F:mode>"
@@ -21775,10 +21778,11 @@
 	  [(unspec:P
 	     [(match_operand:P 0 "vsib_address_operand" "Tv")
 	      (match_operand:<VEC_GATHER_IDXDI> 2 "register_operand" "v")
-	      (match_operand:SI 4 "const1248_operand" "n")]
+	      (match_operand:SI 4 "const1248_operand" "n")
+	      (match_operand:QI 6 "register_operand" "1")]
 	     UNSPEC_VSIBADDR)])
 	(unspec:VI48F
-	  [(match_operand:QI 6 "register_operand" "1")
+	  [(match_dup 6)
 	   (match_operand:<VEC_GATHER_SRCDI> 3 "register_operand" "v")]
 	  UNSPEC_SCATTER))
    (clobber (match_scratch:QI 1 "=&Yk"))]
diff --git a/gcc/config/i386/sync.md b/gcc/config/i386/sync.md
index 502d5673789..b8ce2b99877 100644
--- a/gcc/config/i386/sync.md
+++ b/gcc/config/i386/sync.md
@@ -212,78 +212,6 @@
   DONE;
 })
 
-(define_peephole2
-  [(set (match_operand:DF 0 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_FIST_ATOMIC))
-   (set (match_operand:DF 3 "any_fp_register_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(set (match_dup 3) (match_dup 5))]
-  "operands[5] = gen_lowpart (DFmode, operands[1]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_FIST_ATOMIC))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 3 "any_fp_register_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));
-  emit_insn (gen_memory_blockage ());
-  DONE;
-})
-
-(define_peephole2
-  [(set (match_operand:DF 0 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_STX_ATOMIC))
-   (set (match_operand:DF 3 "any_fp_register_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(set (match_dup 3) (match_dup 5))]
-  "operands[5] = gen_lowpart (DFmode, operands[1]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_STX_ATOMIC))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 3 "any_fp_register_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));
-  emit_insn (gen_memory_blockage ());
-  DONE;
-})
-
 (define_expand "atomic_store<mode>"
   [(set (match_operand:ATOMIC 0 "memory_operand")
 	(unspec:ATOMIC [(match_operand:ATOMIC 1 "nonimmediate_operand")
@@ -373,78 +301,6 @@
   DONE;
 })
 
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (match_operand:DF 2 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_FIST_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (3, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(set (match_dup 5) (match_dup 1))]
-  "operands[5] = gen_lowpart (DFmode, operands[4]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 2 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_FIST_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (4, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(const_int 0)]
-{
-  emit_insn (gen_memory_blockage ());
-  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);
-  DONE;
-})
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (match_operand:DF 2 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_STX_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (3, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(set (match_dup 5) (match_dup 1))]
-  "operands[5] = gen_lowpart (DFmode, operands[4]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 2 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_STX_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (4, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(const_int 0)]
-{
-  emit_insn (gen_memory_blockage ());
-  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);
-  DONE;
-})
-
 ;; ??? You'd think that we'd be able to perform this via FLOAT + FIX_TRUNC
 ;; operations.  But the fix_trunc patterns want way more setup than we want
 ;; to provide.  Note that the scratch is DFmode instead of XFmode in order
diff --git a/gcc/config/i386/winnt.c b/gcc/config/i386/winnt.c
index 201f69e74c4..92510efa985 100644
--- a/gcc/config/i386/winnt.c
+++ b/gcc/config/i386/winnt.c
@@ -921,15 +921,17 @@ i386_pe_seh_cold_init (FILE *f, const char *name)
 
   /* In the normal case, the frame pointer is near the bottom of the frame
      so we can do the full stack allocation and set it afterwards.  There
-     is an exception when the function accesses prior frames so, in this
-     case, we need to pre-allocate a small chunk before setting it.  */
-  if (crtl->accesses_prior_frames)
-    alloc_offset = seh->cfa_offset;
-  else
+     is an exception if the function overflows the SEH maximum frame size
+     or accesses prior frames so, in this case, we need to pre-allocate a
+     small chunk of stack before setting it.  */
+  offset = seh->sp_offset - INCOMING_FRAME_SP_OFFSET;
+  if (offset < SEH_MAX_FRAME_SIZE && !crtl->accesses_prior_frames)
     alloc_offset = seh->sp_offset;
+  else
+    alloc_offset = MIN (seh->cfa_offset + 240, seh->sp_offset);
 
   offset = alloc_offset - INCOMING_FRAME_SP_OFFSET;
-  if (offset > 0 && offset < SEH_MAX_FRAME_SIZE)
+  if (offset > 0)
     fprintf (f, "\t.seh_stackalloc\t" HOST_WIDE_INT_PRINT_DEC "\n", offset);
 
   for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
@@ -958,7 +960,7 @@ i386_pe_seh_cold_init (FILE *f, const char *name)
       fprintf (f, ", " HOST_WIDE_INT_PRINT_DEC "\n", offset);
     }
 
-  if (crtl->accesses_prior_frames)
+  if (alloc_offset != seh->sp_offset)
     {
       offset = seh->sp_offset - alloc_offset;
       if (offset > 0 && offset < SEH_MAX_FRAME_SIZE)
@@ -1242,9 +1244,9 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)
   seh = cfun->machine->seh;
   if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)
     {
-      /* See ix86_seh_fixup_eh_fallthru for the rationale.  */
+      /* See ix86_output_call_insn/seh_fixup_eh_fallthru for the rationale.  */
       rtx_insn *prev = prev_active_insn (insn);
-      if (prev && !insn_nothrow_p (prev))
+      if (prev && (CALL_P (prev) || !insn_nothrow_p (prev)))
 	fputs ("\tnop\n", asm_out_file);
       fputs ("\t.seh_endproc\n", asm_out_file);
       seh->in_cold_section = true;
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 513fc5fe295..c1bd2332eb8 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -22418,12 +22418,12 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   tree get_fcsr = mips_builtin_decls[MIPS_GET_FCSR];
   tree set_fcsr = mips_builtin_decls[MIPS_SET_FCSR];
   tree get_fcsr_hold_call = build_call_expr (get_fcsr, 0);
-  tree hold_assign_orig = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-				  fcsr_orig_var, get_fcsr_hold_call);
+  tree hold_assign_orig = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+				  fcsr_orig_var, get_fcsr_hold_call, NULL, NULL);
   tree hold_mod_val = build2 (BIT_AND_EXPR, MIPS_ATYPE_USI, fcsr_orig_var,
 			      build_int_cst (MIPS_ATYPE_USI, 0xfffff003));
-  tree hold_assign_mod = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-				 fcsr_mod_var, hold_mod_val);
+  tree hold_assign_mod = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+				 fcsr_mod_var, hold_mod_val, NULL, NULL);
   tree set_fcsr_hold_call = build_call_expr (set_fcsr, 1, fcsr_mod_var);
   tree hold_all = build2 (COMPOUND_EXPR, MIPS_ATYPE_USI,
 			  hold_assign_orig, hold_assign_mod);
@@ -22433,8 +22433,8 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   *clear = build_call_expr (set_fcsr, 1, fcsr_mod_var);
 
   tree get_fcsr_update_call = build_call_expr (get_fcsr, 0);
-  *update = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-		    exceptions_var, get_fcsr_update_call);
+  *update = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+		    exceptions_var, get_fcsr_update_call, NULL, NULL);
   tree set_fcsr_update_call = build_call_expr (set_fcsr, 1, fcsr_orig_var);
   *update = build2 (COMPOUND_EXPR, void_type_node, *update,
 		    set_fcsr_update_call);
diff --git a/gcc/config/nvptx/nvptx.c b/gcc/config/nvptx/nvptx.c
index e3e84dfd4e4..243bf9da51a 100644
--- a/gcc/config/nvptx/nvptx.c
+++ b/gcc/config/nvptx/nvptx.c
@@ -3571,9 +3571,9 @@ nvptx_sese_pseudo (basic_block me, bb_sese *sese, int depth, int dir,
   edge e;
   edge_iterator ei;
   int hi_back = depth;
-  pseudo_node_t node_back (0, depth);
+  pseudo_node_t node_back (NULL, depth);
   int hi_child = depth;
-  pseudo_node_t node_child (0, depth);
+  pseudo_node_t node_child (NULL, depth);
   basic_block child = NULL;
   unsigned num_children = 0;
   int usd = -dir * sese->dir;
@@ -3640,7 +3640,7 @@ nvptx_sese_pseudo (basic_block me, bb_sese *sese, int depth, int dir,
       else
 	{ /* Fallen off graph, backlink to entry node.  */
 	  hi_back = 0;
-	  node_back = pseudo_node_t (0, 0);
+	  node_back = pseudo_node_t (NULL, 0);
 	}
     }
 
@@ -3661,7 +3661,7 @@ nvptx_sese_pseudo (basic_block me, bb_sese *sese, int depth, int dir,
       else
 	{
 	  /* back edge to entry node */
-	  sese->push (pseudo_node_t (0, 0));
+	  sese->push (pseudo_node_t (NULL, 0));
 	}
     }
   
@@ -3670,7 +3670,7 @@ nvptx_sese_pseudo (basic_block me, bb_sese *sese, int depth, int dir,
   if (!sese->brackets.length () || !edges || !edges->length ())
     {
       hi_back = 0;
-      node_back = pseudo_node_t (0, 0);
+      node_back = pseudo_node_t (NULL, 0);
       sese->push (node_back);
     }
 
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 3a82fac85e3..1803c66cd21 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -1383,7 +1383,7 @@
                         (match_operand:SF 2 "reg_or_0_operand" "")])
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
-  ""
+  "! TARGET_SOFT_FLOAT"
   "
 {
   pa_emit_bcond_fp (operands);
@@ -1398,7 +1398,7 @@
                         (match_operand:DF 2 "reg_or_0_operand" "")])
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
-  ""
+  "! TARGET_SOFT_FLOAT"
   "
 {
   pa_emit_bcond_fp (operands);
@@ -2236,6 +2236,29 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:SI 0 "move_dest_operand"
+			  "=r,r,r,r,r,r,Q,!*q,!r")
+	(match_operand:SI 1 "move_src_operand"
+			  "A,r,J,N,K,RQ,rM,!rM,!*q"))]
+  "(register_operand (operands[0], SImode)
+    || reg_or_0_operand (operands[1], SImode))
+   && TARGET_SOFT_FLOAT
+   && TARGET_64BIT"
+  "@
+   ldw RT'%A1,%0
+   copy %1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   {zdepi|depwi,z} %Z1,%0
+   ldw%M1 %1,%0
+   stw%M0 %r1,%0
+   mtsar %r1
+   {mfctl|mfctl,w} %%sar,%0"
+  [(set_attr "type" "load,move,move,move,shift,load,store,move,move")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4,4,4,4")])
+
 (define_insn ""
   [(set (match_operand:SI 0 "indexed_memory_operand" "=R")
 	(match_operand:SI 1 "register_operand" "f"))]
@@ -4024,12 +4047,12 @@
   [(set (match_operand:DF 0 "move_dest_operand"
 			  "=!*r,*r,*r,*r,*r,Q,f,f,T")
 	(match_operand:DF 1 "move_src_operand"
-			  "!*r,J,N,K,RQ,*rG,fG,RT,f"))]
+			  "!*rG,J,N,K,RQ,*rG,fG,RT,f"))]
   "(register_operand (operands[0], DFmode)
     || reg_or_0_operand (operands[1], DFmode))
    && !TARGET_SOFT_FLOAT && TARGET_64BIT"
   "@
-   copy %1,%0
+   copy %r1,%0
    ldi %1,%0
    ldil L'%1,%0
    depdi,z %z1,%0
@@ -4042,6 +4065,25 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:DF 0 "move_dest_operand"
+			  "=!*r,*r,*r,*r,*r,Q")
+	(match_operand:DF 1 "move_src_operand"
+			  "!*rG,J,N,K,RQ,*rG"))]
+  "(register_operand (operands[0], DFmode)
+    || reg_or_0_operand (operands[1], DFmode))
+   && TARGET_SOFT_FLOAT && TARGET_64BIT"
+  "@
+   copy %r1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   depdi,z %z1,%0
+   ldd%M1 %1,%0
+   std%M0 %r1,%0"
+  [(set_attr "type" "move,move,move,shift,load,store")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4")])
+
 
 (define_expand "movdi"
   [(set (match_operand:DI 0 "general_operand" "")
@@ -4200,6 +4242,28 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:DI 0 "move_dest_operand"
+			  "=r,r,r,r,r,r,Q,!*q,!r")
+	(match_operand:DI 1 "move_src_operand"
+			  "A,r,J,N,K,RQ,rM,!rM,!*q"))]
+  "(register_operand (operands[0], DImode)
+    || reg_or_0_operand (operands[1], DImode))
+   && TARGET_SOFT_FLOAT && TARGET_64BIT"
+  "@
+   ldd RT'%A1,%0
+   copy %1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   depdi,z %z1,%0
+   ldd%M1 %1,%0
+   std%M0 %r1,%0
+   mtsar %r1
+   {mfctl|mfctl,w} %%sar,%0"
+  [(set_attr "type" "load,move,move,move,shift,load,store,move,move")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4,4,4,4")])
+
 (define_insn ""
   [(set (match_operand:DI 0 "indexed_memory_operand" "=R")
 	(match_operand:DI 1 "register_operand" "f"))]
@@ -4405,6 +4469,23 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:SF 0 "move_dest_operand"
+			  "=!*r,*r,Q")
+	(match_operand:SF 1 "reg_or_0_or_nonsymb_mem_operand"
+			  "!*rG,RQ,*rG"))]
+  "(register_operand (operands[0], SFmode)
+    || reg_or_0_operand (operands[1], SFmode))
+   && TARGET_SOFT_FLOAT
+   && TARGET_64BIT"
+  "@
+   copy %r1,%0
+   ldw%M1 %1,%0
+   stw%M0 %r1,%0"
+  [(set_attr "type" "move,load,store")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4")])
+
 (define_insn ""
   [(set (match_operand:SF 0 "indexed_memory_operand" "=R")
 	(match_operand:SF 1 "register_operand" "f"))]
@@ -5374,32 +5455,38 @@
   [(set (match_operand:DI 0 "register_operand" "")
         (mult:DI (match_operand:DI 1 "register_operand" "")
 		 (match_operand:DI 2 "register_operand" "")))]
-  "TARGET_64BIT && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT"
+  "! optimize_size
+   && TARGET_PA_11
+   && ! TARGET_DISABLE_FPREGS
+   && ! TARGET_SOFT_FLOAT"
   "
 {
   rtx low_product = gen_reg_rtx (DImode);
   rtx cross_product1 = gen_reg_rtx (DImode);
   rtx cross_product2 = gen_reg_rtx (DImode);
-  rtx cross_scratch = gen_reg_rtx (DImode);
-  rtx cross_product = gen_reg_rtx (DImode);
   rtx op1l, op1r, op2l, op2r;
-  rtx op1shifted, op2shifted;
-
-  op1shifted = gen_reg_rtx (DImode);
-  op2shifted = gen_reg_rtx (DImode);
-  op1l = gen_reg_rtx (SImode);
-  op1r = gen_reg_rtx (SImode);
-  op2l = gen_reg_rtx (SImode);
-  op2r = gen_reg_rtx (SImode);
-
-  emit_move_insn (op1shifted, gen_rtx_LSHIFTRT (DImode, operands[1],
-						GEN_INT (32)));
-  emit_move_insn (op2shifted, gen_rtx_LSHIFTRT (DImode, operands[2],
-						GEN_INT (32)));
-  op1r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[1], 4));
-  op2r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[2], 4));
-  op1l = force_reg (SImode, gen_rtx_SUBREG (SImode, op1shifted, 4));
-  op2l = force_reg (SImode, gen_rtx_SUBREG (SImode, op2shifted, 4));
+
+  if (TARGET_64BIT)
+    {
+      rtx op1shifted = gen_reg_rtx (DImode);
+      rtx op2shifted = gen_reg_rtx (DImode);
+
+      emit_move_insn (op1shifted, gen_rtx_LSHIFTRT (DImode, operands[1],
+						    GEN_INT (32)));
+      emit_move_insn (op2shifted, gen_rtx_LSHIFTRT (DImode, operands[2],
+						    GEN_INT (32)));
+      op1r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[1], 4));
+      op2r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[2], 4));
+      op1l = force_reg (SImode, gen_rtx_SUBREG (SImode, op1shifted, 4));
+      op2l = force_reg (SImode, gen_rtx_SUBREG (SImode, op2shifted, 4));
+    }
+  else
+    {
+      op1r = force_reg (SImode, gen_lowpart (SImode, operands[1]));
+      op2r = force_reg (SImode, gen_lowpart (SImode, operands[2]));
+      op1l = force_reg (SImode, gen_highpart (SImode, operands[1]));
+      op2l = force_reg (SImode, gen_highpart (SImode, operands[2]));
+    }
 
   /* Emit multiplies for the cross products.  */
   emit_insn (gen_umulsidi3 (cross_product1, op2r, op1l));
@@ -5408,13 +5495,35 @@
   /* Emit a multiply for the low sub-word.  */
   emit_insn (gen_umulsidi3 (low_product, copy_rtx (op2r), copy_rtx (op1r)));
 
-  /* Sum the cross products and shift them into proper position.  */
-  emit_insn (gen_adddi3 (cross_scratch, cross_product1, cross_product2));
-  emit_insn (gen_ashldi3 (cross_product, cross_scratch, GEN_INT (32)));
+  if (TARGET_64BIT)
+    {
+      rtx cross_scratch = gen_reg_rtx (DImode);
+      rtx cross_product = gen_reg_rtx (DImode);
 
-  /* Add the cross product to the low product and store the result
-     into the output operand .  */
-  emit_insn (gen_adddi3 (operands[0], cross_product, low_product));
+      /* Sum the cross products and shift them into proper position.  */
+      emit_insn (gen_adddi3 (cross_scratch, cross_product1, cross_product2));
+      emit_insn (gen_ashldi3 (cross_product, cross_scratch, GEN_INT (32)));
+
+      /* Add the cross product to the low product and store the result
+	 into the output operand .  */
+      emit_insn (gen_adddi3 (operands[0], cross_product, low_product));
+    }
+  else
+    {
+      rtx cross_scratch = gen_reg_rtx (SImode);
+
+      /* Sum cross products.  */
+      emit_move_insn (cross_scratch,
+		      gen_rtx_PLUS (SImode,
+				    gen_lowpart (SImode, cross_product1),
+				    gen_lowpart (SImode, cross_product2)));
+      emit_move_insn (gen_lowpart (SImode, operands[0]),
+		      gen_lowpart (SImode, low_product));
+      emit_move_insn (gen_highpart (SImode, operands[0]),
+		      gen_rtx_PLUS (SImode,
+				    gen_highpart (SImode, low_product),
+				    cross_scratch));
+    }
   DONE;
 }")
 
diff --git a/gcc/config/riscv/riscv.opt b/gcc/config/riscv/riscv.opt
index 29de246759e..e726a12fd45 100644
--- a/gcc/config/riscv/riscv.opt
+++ b/gcc/config/riscv/riscv.opt
@@ -30,7 +30,7 @@ Target Report Var(TARGET_PLT) Init(1)
 When generating -fpic code, allow the use of PLTs. Ignored for fno-pic.
 
 mabi=
-Target Report RejectNegative Joined Enum(abi_type) Var(riscv_abi) Init(ABI_ILP32)
+Target Report RejectNegative Joined Enum(abi_type) Var(riscv_abi) Init(ABI_ILP32) Negative(mabi=)
 Specify integer and floating-point calling convention.
 
 mpreferred-stack-boundary=
@@ -71,7 +71,7 @@ Target Report Mask(DIV)
 Use hardware instructions for integer division.
 
 march=
-Target Report RejectNegative Joined
+Target Report RejectNegative Joined Negative(march=)
 -march=	Generate code for given RISC-V ISA (e.g. RV64IM).  ISA strings must be
 lower-case.
 
diff --git a/gcc/config/rs6000/aix.h b/gcc/config/rs6000/aix.h
index edd6fdb0ec2..076b11728e2 100644
--- a/gcc/config/rs6000/aix.h
+++ b/gcc/config/rs6000/aix.h
@@ -280,3 +280,8 @@
 /* Use standard DWARF numbering for DWARF debugging information.  */
 #define RS6000_USE_DWARF_NUMBERING
 
+/* Replace -m64 with -maix64 and -m32 with -maix32.  */
+#undef SUBTARGET_DRIVER_SELF_SPECS
+#define SUBTARGET_DRIVER_SELF_SPECS	\
+"%{m64:-maix64} %<m64",			\
+"%{m32:-maix32} %<m32"
diff --git a/gcc/config/rs6000/aix64.opt b/gcc/config/rs6000/aix64.opt
index 48135ce5b17..6f693166159 100644
--- a/gcc/config/rs6000/aix64.opt
+++ b/gcc/config/rs6000/aix64.opt
@@ -53,3 +53,9 @@ Driver
 
 pthread
 Driver
+
+m64
+Driver
+
+m32
+Driver
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
index b40e750dc13..c03d7c9b149 100644
--- a/gcc/config/rs6000/altivec.h
+++ b/gcc/config/rs6000/altivec.h
@@ -129,7 +129,7 @@
 #define vec_vcfux __builtin_vec_vcfux
 #define vec_cts __builtin_vec_cts
 #define vec_ctu __builtin_vec_ctu
-#define vec_cpsgn __builtin_vec_copysign
+#define vec_cpsgn(x,y) __builtin_vec_copysign(y,x)
 #define vec_double __builtin_vec_double
 #define vec_doublee __builtin_vec_doublee
 #define vec_doubleo __builtin_vec_doubleo
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
index 956f7dd5b46..fad45a6e1ac 100644
--- a/gcc/config/rs6000/predicates.md
+++ b/gcc/config/rs6000/predicates.md
@@ -1129,7 +1129,8 @@
   (match_test "(mode == V16QImode
 		&& (vsx_register_operand (op, mode)
 		    || (MEM_P (op)
-			&& quad_address_p (XEXP (op, 0), mode, false))))"))
+			&& (indexed_or_indirect_address (XEXP (op, 0), mode)
+			    || quad_address_p (XEXP (op, 0), mode, false)))))"))
 
 ;; Return true if operand is an operator used in rotate-and-mask instructions.
 (define_predicate "rotate_mask_operator"
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index 1766d325bfb..b3ae6fea640 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -467,6 +467,25 @@
 		     | RS6000_BTC_SENARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
+#define BU_MMA_PAIR_LD(ENUM, NAME, ATTR)				\
+  RS6000_BUILTIN_M (VSX_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_vsx_" NAME,		/* NAME */	\
+		    RS6000_BTM_MMA,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_BINARY				\
+		     | RS6000_BTC_GIMPLE),				\
+		    CODE_FOR_nothing)			/* ICODE */
+
+#define BU_MMA_PAIR_ST(ENUM, NAME, ATTR)				\
+  RS6000_BUILTIN_M (VSX_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_vsx_" NAME,		/* NAME */	\
+		    RS6000_BTM_MMA,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_TERNARY				\
+		     | RS6000_BTC_VOID					\
+		     | RS6000_BTC_GIMPLE),				\
+		    CODE_FOR_nothing)			/* ICODE */
+
 /* ISA 2.05 (power6) convenience macros. */
 /* For functions that depend on the CMPB instruction */
 #define BU_P6_2(ENUM, NAME, ATTR, ICODE)				\
@@ -2771,6 +2790,9 @@ BU_SPECIAL_X (RS6000_BUILTIN_CFSTRING, "__builtin_cfstring", RS6000_BTM_ALWAYS,
 BU_P10V_VSX_1 (XVCVBF16SPN,	    "xvcvbf16spn",	MISC, vsx_xvcvbf16spn)
 BU_P10V_VSX_1 (XVCVSPBF16,	    "xvcvspbf16",	MISC, vsx_xvcvspbf16)
 
+BU_MMA_PAIR_LD (LXVP,	    "lxvp",		MISC)
+BU_MMA_PAIR_ST (STXVP,	    "stxvp",		PAIR)
+
 BU_MMA_1 (XXMFACC,	    "xxmfacc",		QUAD, mma_xxmfacc)
 BU_MMA_1 (XXMTACC,	    "xxmtacc",		QUAD, mma_xxmtacc)
 BU_MMA_1 (XXSETACCZ,	    "xxsetaccz",	MISC, mma_xxsetaccz)
@@ -2779,6 +2801,7 @@ BU_MMA_M2 (DISASSEMBLE_ACC, "disassemble_acc",  QUAD, nothing)
 BU_MMA_V2 (DISASSEMBLE_PAIR,"disassemble_pair", PAIR, nothing)
 BU_COMPAT (VSX_BUILTIN_DISASSEMBLE_PAIR, "mma_disassemble_pair")
 
+BU_MMA_V3 (BUILD_PAIR,	    "build_pair",	MISC, vsx_assemble_pair)
 BU_MMA_V3 (ASSEMBLE_PAIR,   "assemble_pair",	MISC, vsx_assemble_pair)
 BU_COMPAT (VSX_BUILTIN_ASSEMBLE_PAIR, "mma_assemble_pair")
 BU_MMA_3 (XVBF16GER2,	    "xvbf16ger2",	MISC, mma_xvbf16ger2)
@@ -2811,6 +2834,7 @@ BU_MMA_3 (XVI8GER4SPP,	    "xvi8ger4spp",      QUAD, mma_xvi8ger4spp)
 BU_MMA_3 (XVI16GER2PP,	    "xvi16ger2pp",      QUAD, mma_xvi16ger2pp)
 BU_MMA_3 (XVI16GER2SPP,	    "xvi16ger2spp",     QUAD, mma_xvi16ger2spp)
 
+BU_MMA_5 (BUILD_ACC,	    "build_acc",	MISC, mma_assemble_acc)
 BU_MMA_5 (ASSEMBLE_ACC,     "assemble_acc",	MISC, mma_assemble_acc)
 BU_MMA_5 (PMXVF32GER,	    "pmxvf32ger",       MISC, mma_pmxvf32ger)
 BU_MMA_5 (PMXVF64GER,	    "pmxvf64ger",       PAIR, mma_pmxvf64ger)
diff --git a/gcc/config/rs6000/rs6000-call.c b/gcc/config/rs6000/rs6000-call.c
index a112593878a..6a47389d564 100644
--- a/gcc/config/rs6000/rs6000-call.c
+++ b/gcc/config/rs6000/rs6000-call.c
@@ -9434,12 +9434,23 @@ mma_expand_builtin (tree exp, rtx target, bool *expandedp)
       pat = GEN_FCN (icode) (op[0], op[1]);
       break;
     case 3:
+      /* The ASSEMBLE builtin source operands are reversed in little-endian
+	 mode, so reorder them.  */
+      if (fcode == VSX_BUILTIN_ASSEMBLE_PAIR_INTERNAL && !WORDS_BIG_ENDIAN)
+	std::swap (op[1], op[2]);
       pat = GEN_FCN (icode) (op[0], op[1], op[2]);
       break;
     case 4:
       pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3]);
       break;
     case 5:
+      /* The ASSEMBLE builtin source operands are reversed in little-endian
+	 mode, so reorder them.  */
+      if (fcode == MMA_BUILTIN_ASSEMBLE_ACC_INTERNAL && !WORDS_BIG_ENDIAN)
+	{
+	  std::swap (op[1], op[4]);
+	  std::swap (op[2], op[3]);
+	}
       pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4]);
       break;
     case 6:
@@ -10837,17 +10848,15 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
   gimple *new_call;
   tree new_decl;
 
-  if (rs6000_builtin_info[fncode + 1].icode == CODE_FOR_nothing)
+  if (fncode == MMA_BUILTIN_DISASSEMBLE_ACC
+      || fncode == VSX_BUILTIN_DISASSEMBLE_PAIR)
     {
       /* This is an MMA disassemble built-in function.  */
-      gcc_assert (fncode == MMA_BUILTIN_DISASSEMBLE_ACC
-		  || fncode == VSX_BUILTIN_DISASSEMBLE_PAIR);
-
       push_gimplify_context (true);
       tree dst_ptr = gimple_call_arg (stmt, 0);
       tree src_ptr = gimple_call_arg (stmt, 1);
       tree src_type = TREE_TYPE (src_ptr);
-      tree src = make_ssa_name (TREE_TYPE (src_type));
+      tree src = create_tmp_reg_or_ssa_name (TREE_TYPE (src_type));
       gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);
 
       /* If we are disassembling an accumulator/pair and our destination is
@@ -10871,7 +10880,7 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
 	{
 	  new_decl = rs6000_builtin_decls[MMA_BUILTIN_XXMFACC_INTERNAL];
 	  new_call = gimple_build_call (new_decl, 1, src);
-	  src = make_ssa_name (vector_quad_type_node);
+	  src = create_tmp_reg_or_ssa_name (vector_quad_type_node);
 	  gimple_call_set_lhs (new_call, src);
 	  gimple_seq_add_stmt (&new_seq, new_call);
 	}
@@ -10897,6 +10906,38 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
       gsi_replace_with_seq (gsi, new_seq, true);
       return true;
     }
+  else if (fncode == VSX_BUILTIN_LXVP)
+    {
+      push_gimplify_context (true);
+      tree offset = gimple_call_arg (stmt, 0);
+      tree ptr = gimple_call_arg (stmt, 1);
+      tree lhs = gimple_call_lhs (stmt);
+      if (TREE_TYPE (TREE_TYPE (ptr)) != vector_pair_type_node)
+	ptr = build1 (VIEW_CONVERT_EXPR,
+		      build_pointer_type (vector_pair_type_node), ptr);
+      tree mem = build_simple_mem_ref (build2 (POINTER_PLUS_EXPR,
+					       TREE_TYPE (ptr), ptr, offset));
+      gimplify_assign (lhs, mem, &new_seq);
+      pop_gimplify_context (NULL);
+      gsi_replace_with_seq (gsi, new_seq, true);
+      return true;
+    }
+  else if (fncode == VSX_BUILTIN_STXVP)
+    {
+      push_gimplify_context (true);
+      tree src = gimple_call_arg (stmt, 0);
+      tree offset = gimple_call_arg (stmt, 1);
+      tree ptr = gimple_call_arg (stmt, 2);
+      if (TREE_TYPE (TREE_TYPE (ptr)) != vector_pair_type_node)
+	ptr = build1 (VIEW_CONVERT_EXPR,
+		      build_pointer_type (vector_pair_type_node), ptr);
+      tree mem = build_simple_mem_ref (build2 (POINTER_PLUS_EXPR,
+					       TREE_TYPE (ptr), ptr, offset));
+      gimplify_assign (mem, src, &new_seq);
+      pop_gimplify_context (NULL);
+      gsi_replace_with_seq (gsi, new_seq, true);
+      return true;
+    }
 
   /* Convert this built-in into an internal version that uses pass-by-value
      arguments.  The internal built-in follows immediately after this one.  */
@@ -10909,7 +10950,7 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
     {
       /* This built-in has a pass-by-reference accumulator input, so load it
 	 into a temporary accumulator for use as a pass-by-value input.  */
-      op[0] = make_ssa_name (vector_quad_type_node);
+      op[0] = create_tmp_reg_or_ssa_name (vector_quad_type_node);
       for (unsigned i = 1; i < nopnds; i++)
 	op[i] = gimple_call_arg (stmt, i);
       gimplify_assign (op[0], build_simple_mem_ref (acc), &new_seq);
@@ -10956,10 +10997,10 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
       gcc_unreachable ();
     }
 
-  if (fncode == VSX_BUILTIN_ASSEMBLE_PAIR)
-    lhs = make_ssa_name (vector_pair_type_node);
+  if (fncode == VSX_BUILTIN_BUILD_PAIR || fncode == VSX_BUILTIN_ASSEMBLE_PAIR)
+    lhs = create_tmp_reg_or_ssa_name (vector_pair_type_node);
   else
-    lhs = make_ssa_name (vector_quad_type_node);
+    lhs = create_tmp_reg_or_ssa_name (vector_quad_type_node);
   gimple_call_set_lhs (new_call, lhs);
   gimple_seq_add_stmt (&new_seq, new_call);
   gimplify_assign (build_simple_mem_ref (acc), lhs, &new_seq);
@@ -12544,23 +12585,17 @@ rs6000_init_builtins (void)
     }
 }
 
-/* Returns the rs6000 builtin decl for CODE.  */
+/* Returns the rs6000 builtin decl for CODE.  Note that we don't check
+   the builtin mask here since there could be some #pragma/attribute
+   target functions and the rs6000_builtin_mask could be wrong when
+   this checking happens, though it will be updated properly later.  */
 
 tree
 rs6000_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)
 {
-  HOST_WIDE_INT fnmask;
-
   if (code >= RS6000_BUILTIN_COUNT)
     return error_mark_node;
 
-  fnmask = rs6000_builtin_info[code].mask;
-  if ((fnmask & rs6000_builtin_mask) != fnmask)
-    {
-      rs6000_invalid_builtin ((enum rs6000_builtins)code);
-      return error_mark_node;
-    }
-
   return rs6000_builtin_decls[code];
 }
 
@@ -13190,11 +13225,15 @@ mma_init_builtins (void)
       if (gimple_func)
 	{
 	  gcc_assert (icode == CODE_FOR_nothing);
-	  op[nopnds++] = void_type_node;
 	  /* Some MMA built-ins that are expanded into gimple are converted
 	     into internal MMA built-ins that are expanded into rtl.
 	     The internal built-in follows immediately after this built-in.  */
-	  icode = d[1].icode;
+	  if (d->code != VSX_BUILTIN_LXVP
+	      && d->code != VSX_BUILTIN_STXVP)
+	    {
+	      op[nopnds++] = void_type_node;
+	      icode = d[1].icode;
+	    }
 	}
       else
 	{
@@ -13205,18 +13244,30 @@ mma_init_builtins (void)
 	  gcc_assert (attr_args == insn_data[icode].n_operands - 1);
 	}
 
-      if (icode == CODE_FOR_nothing)
+      if (d->code == MMA_BUILTIN_DISASSEMBLE_ACC
+	  || d->code == VSX_BUILTIN_DISASSEMBLE_PAIR)
 	{
 	  /* This is a disassemble MMA built-in function.  */
-	  gcc_assert (attr_args == RS6000_BTC_BINARY
-		      && (d->code == MMA_BUILTIN_DISASSEMBLE_ACC
-			  || d->code == VSX_BUILTIN_DISASSEMBLE_PAIR));
+	  gcc_assert (attr_args == RS6000_BTC_BINARY);
 	  op[nopnds++] = build_pointer_type (void_type_node);
 	  if (attr & RS6000_BTC_QUAD)
 	    op[nopnds++] = build_pointer_type (vector_quad_type_node);
 	  else
 	    op[nopnds++] = build_pointer_type (vector_pair_type_node);
 	}
+      else if (d->code == VSX_BUILTIN_LXVP)
+	{
+	  op[nopnds++] = vector_pair_type_node;
+	  op[nopnds++] = sizetype;
+	  op[nopnds++] = build_pointer_type (vector_pair_type_node);
+	}
+      else if (d->code == VSX_BUILTIN_STXVP)
+	{
+	  op[nopnds++] = void_type_node;
+	  op[nopnds++] = vector_pair_type_node;
+	  op[nopnds++] = sizetype;
+	  op[nopnds++] = build_pointer_type (vector_pair_type_node);
+	}
       else
 	{
 	  /* This is a normal MMA built-in function.  */
@@ -13226,8 +13277,10 @@ mma_init_builtins (void)
 	      machine_mode mode = insn_data[icode].operand[j].mode;
 	      if (gimple_func && mode == PXImode)
 		op[nopnds++] = build_pointer_type (vector_quad_type_node);
-	      else if (gimple_func && mode == POImode
-		       && d->code == VSX_BUILTIN_ASSEMBLE_PAIR)
+	      else if (gimple_func
+		       && mode == POImode
+		       && (d->code == VSX_BUILTIN_BUILD_PAIR
+			   || d->code == VSX_BUILTIN_ASSEMBLE_PAIR))
 		op[nopnds++] = build_pointer_type (vector_pair_type_node);
 	      else
 		/* MMA uses unsigned types.  */
@@ -13582,6 +13635,16 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,
       h.uns_p[2] = 1;
       break;
 
+    case VSX_BUILTIN_LXVP:
+      h.uns_p[0] = 1;
+      h.uns_p[2] = 1;
+      break;
+
+    case VSX_BUILTIN_STXVP:
+      h.uns_p[1] = 1;
+      h.uns_p[3] = 1;
+      break;
+
     default:
       break;
     }
diff --git a/gcc/config/rs6000/rs6000-logue.c b/gcc/config/rs6000/rs6000-logue.c
index 6aad1ff826a..fbde3b62f48 100644
--- a/gcc/config/rs6000/rs6000-logue.c
+++ b/gcc/config/rs6000/rs6000-logue.c
@@ -3254,10 +3254,13 @@ rs6000_emit_prologue (void)
 
   /* If we need to save CR, put it into r12 or r11.  Choose r12 except when
      r12 will be needed by out-of-line gpr save.  */
-  cr_save_regno = ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)
-		   && !(strategy & (SAVE_INLINE_GPRS
-				    | SAVE_NOINLINE_GPRS_SAVES_LR))
-		   ? 11 : 12);
+  if (DEFAULT_ABI == ABI_AIX
+      && !(strategy & (SAVE_INLINE_GPRS | SAVE_NOINLINE_GPRS_SAVES_LR)))
+    cr_save_regno = 11;
+  else if (DEFAULT_ABI == ABI_ELFv2)
+    cr_save_regno = 11;
+  else
+    cr_save_regno = 12;
   if (!WORLD_SAVE_P (info)
       && info->cr_save_p
       && REGNO (frame_reg_rtx) != cr_save_regno
@@ -4773,6 +4776,10 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)
       else if (REGNO (frame_reg_rtx) == 12)
 	cr_save_regno = 11;
 
+      /* For ELFv2 r12 is already in use as the GEP.  */
+      if (DEFAULT_ABI == ABI_ELFv2)
+	cr_save_regno = 11;
+
       cr_save_reg = load_cr_save (cr_save_regno, frame_reg_rtx,
 				  info->cr_save_offset + frame_off,
 				  exit_func);
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
index 3d5dc7d8aae..4a358646830 100644
--- a/gcc/config/rs6000/rs6000-p8swap.c
+++ b/gcc/config/rs6000/rs6000-p8swap.c
@@ -1501,6 +1501,22 @@ replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)
   insn->set_deleted ();
 }
 
+/* INSN is known to contain a SUBREG, which we can normally handle,
+   but if the SUBREG itself contains a MULT then we need to leave it alone
+   to avoid turning a mult_hipart into a mult_lopart, for example.  */
+static bool
+has_part_mult (rtx_insn *insn)
+{
+  rtx body = PATTERN (insn);
+  if (GET_CODE (body) != SET)
+    return false;
+  rtx src = SET_SRC (body);
+  if (GET_CODE (src) != SUBREG)
+    return false;
+  rtx inner = XEXP (src, 0);
+  return (GET_CODE (inner) == MULT);
+}
+
 /* Make NEW_MEM_EXP's attributes and flags resemble those of
    ORIGINAL_MEM_EXP.  */
 static void
@@ -2437,6 +2453,9 @@ rs6000_analyze_swaps (function *fun)
 		    insn_entry[uid].is_swappable = 0;
 		  else if (special != SH_NONE)
 		    insn_entry[uid].special_handling = special;
+		  else if (insn_entry[uid].contains_subreg
+			   && has_part_mult (insn))
+		    insn_entry[uid].is_swappable = 0;
 		  else if (insn_entry[uid].contains_subreg)
 		    insn_entry[uid].special_handling = SH_SUBREG;
 		}
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index a6dc1156994..8ca7f2fe543 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -5550,7 +5550,7 @@ rs6000_machine_from_flags (void)
   HOST_WIDE_INT flags = rs6000_isa_flags;
 
   /* Disable the flags that should never influence the .machine selection.  */
-  flags &= ~(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_PPC_GPOPT);
+  flags &= ~(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_PPC_GPOPT | OPTION_MASK_ISEL);
 
   if ((flags & (ISA_3_1_MASKS_SERVER & ~ISA_3_0_MASKS_SERVER)) != 0)
     return "power10";
@@ -16023,9 +16023,11 @@ rs6000_split_multireg_move (rtx dst, rtx src)
 		      && XINT (src, 1) == UNSPEC_MMA_ASSEMBLE_ACC);
 
 	  reg_mode = GET_MODE (XVECEXP (src, 0, 0));
-	  for (int i = 0; i < XVECLEN (src, 0); i++)
+	  int nvecs = XVECLEN (src, 0);
+	  for (int i = 0; i < nvecs; i++)
 	    {
-	      rtx dst_i = gen_rtx_REG (reg_mode, reg + i);
+	      int index = WORDS_BIG_ENDIAN ? i : nvecs - 1 - i;
+	      rtx dst_i = gen_rtx_REG (reg_mode, reg + index);
 	      emit_insn (gen_rtx_SET (dst_i, XVECEXP (src, 0, i)));
 	    }
 
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index c4d7cdb6fa7..61a14fb5b9f 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -4806,6 +4806,42 @@
   [(set_attr "type" "fp")
    (set_attr "isa" "*,<Fisa>")])
 
+(define_expand "fmod<mode>3"
+  [(use (match_operand:SFDF 0 "gpc_reg_operand"))
+	(use (match_operand:SFDF 1 "gpc_reg_operand"))
+	(use (match_operand:SFDF 2 "gpc_reg_operand"))]
+  "TARGET_HARD_FLOAT
+   && TARGET_FPRND
+   && flag_unsafe_math_optimizations"
+{
+  rtx div = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_div<mode>3 (div, operands[1], operands[2]));
+
+  rtx friz = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_btrunc<mode>2 (friz, div));
+
+  emit_insn (gen_nfms<mode>4 (operands[0], operands[2], friz, operands[1]));
+  DONE;
+ })
+
+(define_expand "remainder<mode>3"
+  [(use (match_operand:SFDF 0 "gpc_reg_operand"))
+	(use (match_operand:SFDF 1 "gpc_reg_operand"))
+	(use (match_operand:SFDF 2 "gpc_reg_operand"))]
+  "TARGET_HARD_FLOAT
+   && TARGET_FPRND
+   && flag_unsafe_math_optimizations"
+{
+  rtx div = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_div<mode>3 (div, operands[1], operands[2]));
+
+  rtx frin = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_round<mode>2 (frin, div));
+
+  emit_insn (gen_nfms<mode>4 (operands[0], operands[2], frin, operands[1]));
+  DONE;
+ })
+
 (define_insn "*rsqrt<mode>2"
   [(set (match_operand:SFDF 0 "gpc_reg_operand" "=<Ff>,wa")
 	(unspec:SFDF [(match_operand:SFDF 1 "gpc_reg_operand" "<Ff>,wa")]
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index cf53ef1b791..4039107a7be 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -973,7 +973,7 @@
 	(match_operand:GPR 2 "memory_operand"))
    (set (reg CC_REGNUM)
 	(compare (match_dup 0) (match_operand:GPR 1 "const0_operand")))]
-  "s390_match_ccmode(insn, CCSmode) && TARGET_EXTIMM
+  "s390_match_ccmode (peep2_next_insn (1), CCSmode) && TARGET_EXTIMM
    && GENERAL_REG_P (operands[0])
    && satisfies_constraint_T (operands[2])
    && !contains_constant_pool_address_p (operands[2])"
diff --git a/gcc/config/s390/vecintrin.h b/gcc/config/s390/vecintrin.h
index 8ef4f44bb34..6022aded6bb 100644
--- a/gcc/config/s390/vecintrin.h
+++ b/gcc/config/s390/vecintrin.h
@@ -109,8 +109,8 @@ __lcbb(const void *ptr, int bndry)
 #define vec_rint(X)   __builtin_s390_vfi((X), 0, 0)
 #define vec_roundc(X) __builtin_s390_vfi((X), 4, 0)
 #define vec_round(X)  __builtin_s390_vfi((X), 4, 4)
-#define vec_doublee(X) __builtin_s390_vfll((X))
-#define vec_floate(X) __builtin_s390_vflr((X), 0, 0)
+#define vec_doublee(X) __builtin_s390_vflls((X))
+#define vec_floate(X) __builtin_s390_vflrd((X), 0, 0)
 #define vec_load_len_r(X,L)				\
   (__vector unsigned char)__builtin_s390_vlrlr((L),(X))
 #define vec_store_len_r(X,Y,L) \
diff --git a/gcc/config/sparc/leon5.md b/gcc/config/sparc/leon5.md
new file mode 100644
index 00000000000..6a065b1a974
--- /dev/null
+++ b/gcc/config/sparc/leon5.md
@@ -0,0 +1,103 @@
+;; Scheduling description for LEON5.
+;;   Copyright (C) 2021 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+
+;; The LEON5 can often dual issue instructions from the same 64-bit aligned
+;; double word if there are no data dependencies.
+;;
+;; Avoid scheduling load/store, FPU, and multiply instructions back to
+;; back, regardless of data dependencies.
+;;
+;; Push comparisons away from the associated branch instruction.
+;;
+;; Avoid scheduling ALU instructions with data dependencies back to back.
+;;
+;; Schedule three instructions between load and dependent instruction.
+
+(define_automaton "leon5")
+
+(define_cpu_unit "leon5_memory" "leon5")
+(define_cpu_unit "leon5_mul" "leon5")
+(define_cpu_unit "grfpu_d" "grfpu")
+(define_cpu_unit "grfpu_s" "grfpu")
+
+(define_insn_reservation "leon5_load" 4
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "load,sload"))
+  "leon5_memory * 2, nothing * 2")
+
+(define_insn_reservation "leon5_fpload" 2
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "fpload"))
+  "leon5_memory * 2 + grfpu_alu * 2")
+
+(define_insn_reservation "leon5_store" 2
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "store"))
+  "leon5_memory * 2")
+
+(define_insn_reservation "leon5_fpstore" 2
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "fpstore"))
+  "leon5_memory * 2 + grfpu_alu * 2")
+
+(define_insn_reservation "leon5_ialu" 2
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "ialu, shift, ialuX"))
+  "nothing * 2")
+
+(define_insn_reservation "leon5_compare" 5
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "compare"))
+  "nothing * 5")
+
+(define_insn_reservation "leon5_imul" 4
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "imul"))
+  "leon5_mul * 2, nothing * 2")
+
+(define_insn_reservation "leon5_idiv" 35
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "imul"))
+  "nothing * 35")
+
+(define_insn_reservation "leon5_fp_alu" 5
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "fp,fpcmp,fpmul,fpmove"))
+  "grfpu_alu * 2, nothing*3")
+
+(define_insn_reservation "leon5_fp_divs" 17
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "fpdivs"))
+  "grfpu_alu * 2 + grfpu_d*16, nothing")
+
+(define_insn_reservation "leon5_fp_divd" 18
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "fpdivd"))
+  "grfpu_alu * 2 + grfpu_d*17, nothing")
+
+(define_insn_reservation "leon5_fp_sqrts" 25
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "fpsqrts"))
+  "grfpu_alu * 2 + grfpu_s*24, nothing")
+
+(define_insn_reservation "leon5_fp_sqrtd" 26
+  (and (eq_attr "cpu" "leon5")
+  (eq_attr "type" "fpsqrtd"))
+  "grfpu_alu * 2 + grfpu_s*25, nothing")
diff --git a/gcc/config/sparc/sparc-modes.def b/gcc/config/sparc/sparc-modes.def
index 69fe32bcd13..02528120036 100644
--- a/gcc/config/sparc/sparc-modes.def
+++ b/gcc/config/sparc/sparc-modes.def
@@ -23,6 +23,9 @@ along with GCC; see the file COPYING3.  If not see
 /* 128-bit floating point */
 FLOAT_MODE (TF, 16, ieee_quad_format);
 
+/* We need a 32-byte mode to return structures in the 64-bit ABI.  */
+INT_MODE (OI, 32);
+
 /* Add any extra modes needed to represent the condition code.
 
    We have a CCNZ mode which is used for implicit comparisons with zero when
diff --git a/gcc/config/sparc/sparc-opts.h b/gcc/config/sparc/sparc-opts.h
index 5bda749ee38..59ad06e491f 100644
--- a/gcc/config/sparc/sparc-opts.h
+++ b/gcc/config/sparc/sparc-opts.h
@@ -31,6 +31,7 @@ enum sparc_processor_type {
   PROCESSOR_HYPERSPARC,
   PROCESSOR_LEON,
   PROCESSOR_LEON3,
+  PROCESSOR_LEON5,
   PROCESSOR_LEON3V7,
   PROCESSOR_SPARCLITE,
   PROCESSOR_F930,
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index d0843102148..e87e0386359 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -269,6 +269,31 @@ struct processor_costs leon3_costs = {
   3 /* branch cost */
 };
 
+static const
+struct processor_costs leon5_costs = {
+  COSTS_N_INSNS (1), /* int load */
+  COSTS_N_INSNS (1), /* int signed load */
+  COSTS_N_INSNS (1), /* int zeroed load */
+  COSTS_N_INSNS (1), /* float load */
+  COSTS_N_INSNS (1), /* fmov, fneg, fabs */
+  COSTS_N_INSNS (1), /* fadd, fsub */
+  COSTS_N_INSNS (1), /* fcmp */
+  COSTS_N_INSNS (1), /* fmov, fmovr */
+  COSTS_N_INSNS (1), /* fmul */
+  COSTS_N_INSNS (17), /* fdivs */
+  COSTS_N_INSNS (18), /* fdivd */
+  COSTS_N_INSNS (25), /* fsqrts */
+  COSTS_N_INSNS (26), /* fsqrtd */
+  COSTS_N_INSNS (4), /* imul */
+  COSTS_N_INSNS (4), /* imulX */
+  0, /* imul bit factor */
+  COSTS_N_INSNS (35), /* idiv */
+  COSTS_N_INSNS (35), /* idivX */
+  COSTS_N_INSNS (1), /* movcc/movr */
+  0, /* shift penalty */
+  3 /* branch cost */
+};
+
 static const
 struct processor_costs sparclet_costs = {
   COSTS_N_INSNS (3), /* int load */
@@ -594,6 +619,7 @@ static int function_arg_slotno (const CUMULATIVE_ARGS *, machine_mode,
 
 static int supersparc_adjust_cost (rtx_insn *, int, rtx_insn *, int);
 static int hypersparc_adjust_cost (rtx_insn *, int, rtx_insn *, int);
+static int leon5_adjust_cost (rtx_insn *, int, rtx_insn *, int);
 
 static void sparc_emit_set_const32 (rtx, rtx);
 static void sparc_emit_set_const64 (rtx, rtx);
@@ -1049,6 +1075,43 @@ atomic_insn_for_leon3_p (rtx_insn *insn)
     }
 }
 
+/* True if INSN is a store instruction.  */
+
+static bool
+store_insn_p (rtx_insn *insn)
+{
+  if (GET_CODE (PATTERN (insn)) != SET)
+    return false;
+
+  switch (get_attr_type (insn))
+    {
+    case TYPE_STORE:
+    case TYPE_FPSTORE:
+      return true;
+    default:
+      return false;
+    }
+}
+
+/* True if INSN is a load instruction.  */
+
+static bool
+load_insn_p (rtx_insn *insn)
+{
+  if (GET_CODE (PATTERN (insn)) != SET)
+    return false;
+
+  switch (get_attr_type (insn))
+    {
+    case TYPE_LOAD:
+    case TYPE_SLOAD:
+    case TYPE_FPLOAD:
+      return true;
+    default:
+      return false;
+    }
+}
+
 /* We use a machine specific pass to enable workarounds for errata.
 
    We need to have the (essentially) final form of the insn stream in order
@@ -1061,10 +1124,29 @@ atomic_insn_for_leon3_p (rtx_insn *insn)
    && GET_CODE (PATTERN (INSN)) != USE					\
    && GET_CODE (PATTERN (INSN)) != CLOBBER)
 
+rtx_insn *
+next_active_non_empty_insn (rtx_insn *insn)
+{
+  insn = next_active_insn (insn);
+
+  while (insn
+	 && (GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE
+	     || GET_CODE (PATTERN (insn)) == ASM_INPUT
+	     || (USEFUL_INSN_P (insn)
+		 && (asm_noperands (PATTERN (insn)) >= 0)
+		 && !strcmp (decode_asm_operands (PATTERN (insn),
+						  NULL, NULL, NULL,
+						  NULL, NULL), ""))))
+    insn = next_active_insn (insn);
+
+  return insn;
+}
+
 static unsigned int
 sparc_do_work_around_errata (void)
 {
   rtx_insn *insn, *next;
+  bool find_first_useful = true;
 
   /* Force all instructions to be split into their final form.  */
   split_all_insns_noflow ();
@@ -1089,6 +1171,16 @@ sparc_do_work_around_errata (void)
       else
 	jump = NULL;
 
+      /* Do not begin function with atomic instruction.  */
+      if (sparc_fix_ut700
+	  && find_first_useful
+	  && USEFUL_INSN_P (insn))
+	{
+	  find_first_useful = false;
+	  if (atomic_insn_for_leon3_p (insn))
+	    emit_insn_before (gen_nop (), insn);
+	}
+
       /* Place a NOP at the branch target of an integer branch if it is a
 	 floating-point operation or a floating-point branch.  */
       if (sparc_fix_gr712rc
@@ -1109,9 +1201,7 @@ sparc_do_work_around_errata (void)
 	 instruction at branch target.  */
       if (sparc_fix_ut700
 	  && NONJUMP_INSN_P (insn)
-	  && (set = single_set (insn)) != NULL_RTX
-	  && mem_ref (SET_SRC (set))
-	  && REG_P (SET_DEST (set)))
+	  && load_insn_p (insn))
 	{
 	  if (jump && jump_to_label_p (jump))
 	    {
@@ -1120,7 +1210,7 @@ sparc_do_work_around_errata (void)
 		emit_insn_before (gen_nop (), target);
 	    }
 
-	  next = next_active_insn (insn);
+	  next = next_active_non_empty_insn (insn);
 	  if (!next)
 	    break;
 
@@ -1216,30 +1306,19 @@ sparc_do_work_around_errata (void)
       if (sparc_fix_b2bst
 	  && NONJUMP_INSN_P (insn)
 	  && (set = single_set (insn)) != NULL_RTX
-	  && MEM_P (SET_DEST (set)))
+	  && store_insn_p (insn))
 	{
 	  /* Sequence B begins with a double-word store.  */
 	  bool seq_b = GET_MODE_SIZE (GET_MODE (SET_DEST (set))) == 8;
 	  rtx_insn *after;
 	  int i;
 
-	  next = next_active_insn (insn);
+	  next = next_active_non_empty_insn (insn);
 	  if (!next)
 	    break;
 
 	  for (after = next, i = 0; i < 2; i++)
 	    {
-	      /* Skip empty assembly statements.  */
-	      if ((GET_CODE (PATTERN (after)) == UNSPEC_VOLATILE)
-		  || (USEFUL_INSN_P (after)
-		      && (asm_noperands (PATTERN (after))>=0)
-		      && !strcmp (decode_asm_operands (PATTERN (after),
-						       NULL, NULL, NULL,
-						       NULL, NULL), "")))
-		after = next_active_insn (after);
-	      if (!after)
-		break;
-
 	      /* If the insn is a branch, then it cannot be problematic.  */
 	      if (!NONJUMP_INSN_P (after)
 		  || GET_CODE (PATTERN (after)) == SEQUENCE)
@@ -1249,8 +1328,7 @@ sparc_do_work_around_errata (void)
 	      if (seq_b)
 		{
 		  /* Add NOP if followed by a store.  */
-		  if ((set = single_set (after)) != NULL_RTX
-		      && MEM_P (SET_DEST (set)))
+		  if (store_insn_p (after))
 		    insert_nop = true;
 
 		  /* Otherwise it is ok.  */
@@ -1265,15 +1343,14 @@ sparc_do_work_around_errata (void)
 		      && (MEM_P (SET_DEST (set)) || mem_ref (SET_SRC (set))))
 		    break;
 
-		  after = next_active_insn (after);
+		  after = next_active_non_empty_insn (after);
 		  if (!after)
 		    break;
 		}
 
 	      /* Add NOP if third instruction is a store.  */
 	      if (i == 1
-		  && (set = single_set (after)) != NULL_RTX
-		  && MEM_P (SET_DEST (set)))
+		  && store_insn_p (after))
 		insert_nop = true;
 	    }
 	}
@@ -1600,6 +1677,10 @@ dump_target_flag_bits (const int flags)
     fprintf (stderr, "CBCOND ");
   if (flags & MASK_DEPRECATED_V8_INSNS)
     fprintf (stderr, "DEPRECATED_V8_INSNS ");
+  if (flags & MASK_LEON)
+    fprintf (stderr, "LEON ");
+  if (flags & MASK_LEON3)
+    fprintf (stderr, "LEON3 ");
   if (flags & MASK_SPARCLET)
     fprintf (stderr, "SPARCLET ");
   if (flags & MASK_SPARCLITE)
@@ -1636,6 +1717,7 @@ sparc_option_override (void)
     { TARGET_CPU_hypersparc, PROCESSOR_HYPERSPARC },
     { TARGET_CPU_leon, PROCESSOR_LEON },
     { TARGET_CPU_leon3, PROCESSOR_LEON3 },
+    { TARGET_CPU_leon5, PROCESSOR_LEON5 },
     { TARGET_CPU_leon3v7, PROCESSOR_LEON3V7 },
     { TARGET_CPU_sparclite, PROCESSOR_F930 },
     { TARGET_CPU_sparclite86x, PROCESSOR_SPARCLITE86X },
@@ -1667,6 +1749,7 @@ sparc_option_override (void)
     { "hypersparc",	MASK_ISA, MASK_V8 },
     { "leon",		MASK_ISA|MASK_FSMULD, MASK_V8|MASK_LEON },
     { "leon3",		MASK_ISA, MASK_V8|MASK_LEON3 },
+    { "leon5",		MASK_ISA, MASK_V8|MASK_LEON3 },
     { "leon3v7",	MASK_ISA, MASK_LEON3 },
     { "sparclite",	MASK_ISA, MASK_SPARCLITE },
     /* The Fujitsu MB86930 is the original sparclite chip, with no FPU.  */
@@ -1977,6 +2060,9 @@ sparc_option_override (void)
     case PROCESSOR_LEON3V7:
       sparc_costs = &leon3_costs;
       break;
+    case PROCESSOR_LEON5:
+      sparc_costs = &leon5_costs;
+      break;
     case PROCESSOR_SPARCLET:
     case PROCESSOR_TSC701:
       sparc_costs = &sparclet_costs;
@@ -10157,12 +10243,65 @@ hypersparc_adjust_cost (rtx_insn *insn, int dtype, rtx_insn *dep_insn,
   return cost;
 }
 
+static int
+leon5_adjust_cost (rtx_insn *insn, int dtype, rtx_insn *dep_insn,
+		   int cost)
+{
+  enum attr_type insn_type, dep_type;
+  rtx pat = PATTERN (insn);
+  rtx dep_pat = PATTERN (dep_insn);
+
+  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)
+    return cost;
+
+  insn_type = get_attr_type (insn);
+  dep_type = get_attr_type (dep_insn);
+
+  switch (dtype)
+    {
+    case REG_DEP_TRUE:
+      /* Data dependency; DEP_INSN writes a register that INSN reads some
+	 cycles later.  */
+
+      switch (insn_type)
+	{
+	case TYPE_STORE:
+	  /* Try to schedule three instructions between the store and
+	     the ALU instruction that generated the data.  */
+	  if (dep_type == TYPE_IALU || dep_type == TYPE_SHIFT)
+	    {
+	      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)
+		break;
+
+	      if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))
+		return 4;
+	    }
+	  break;
+	default:
+	  break;
+	}
+      break;
+    case REG_DEP_ANTI:
+      /* Penalize anti-dependencies for FPU instructions.  */
+      if (fpop_insn_p (insn) || insn_type == TYPE_FPLOAD)
+	return 4;
+      break;
+    default:
+      break;
+    }
+
+  return cost;
+}
+
 static int
 sparc_adjust_cost (rtx_insn *insn, int dep_type, rtx_insn *dep, int cost,
 		   unsigned int)
 {
   switch (sparc_cpu)
     {
+    case PROCESSOR_LEON5:
+      cost = leon5_adjust_cost (insn, dep_type, dep, cost);
+      break;
     case PROCESSOR_SUPERSPARC:
       cost = supersparc_adjust_cost (insn, dep_type, dep, cost);
       break;
diff --git a/gcc/config/sparc/sparc.h b/gcc/config/sparc/sparc.h
index c5f098ed971..82df0f79b80 100644
--- a/gcc/config/sparc/sparc.h
+++ b/gcc/config/sparc/sparc.h
@@ -119,21 +119,22 @@ along with GCC; see the file COPYING3.  If not see
 #define TARGET_CPU_leon		4
 #define TARGET_CPU_leon3	5
 #define TARGET_CPU_leon3v7	6
-#define TARGET_CPU_sparclite	7
-#define TARGET_CPU_f930		7       /* alias */
-#define TARGET_CPU_f934		7       /* alias */
-#define TARGET_CPU_sparclite86x	8
-#define TARGET_CPU_sparclet	9
-#define TARGET_CPU_tsc701	9       /* alias */
-#define TARGET_CPU_v9		10	/* generic v9 implementation */
-#define TARGET_CPU_sparcv9	10	/* alias */
-#define TARGET_CPU_sparc64	10	/* alias */
-#define TARGET_CPU_ultrasparc	11
-#define TARGET_CPU_ultrasparc3	12
-#define TARGET_CPU_niagara	13
-#define TARGET_CPU_niagara2	14
-#define TARGET_CPU_niagara3	15
-#define TARGET_CPU_niagara4	16
+#define TARGET_CPU_leon5	7
+#define TARGET_CPU_sparclite	8
+#define TARGET_CPU_f930		8       /* alias */
+#define TARGET_CPU_f934		8       /* alias */
+#define TARGET_CPU_sparclite86x	9
+#define TARGET_CPU_sparclet	10
+#define TARGET_CPU_tsc701	10       /* alias */
+#define TARGET_CPU_v9		11	/* generic v9 implementation */
+#define TARGET_CPU_sparcv9	11	/* alias */
+#define TARGET_CPU_sparc64	11	/* alias */
+#define TARGET_CPU_ultrasparc	12
+#define TARGET_CPU_ultrasparc3	13
+#define TARGET_CPU_niagara	14
+#define TARGET_CPU_niagara2	15
+#define TARGET_CPU_niagara3	16
+#define TARGET_CPU_niagara4	17
 #define TARGET_CPU_niagara7	19
 #define TARGET_CPU_m8		20
 
@@ -228,7 +229,8 @@ along with GCC; see the file COPYING3.  If not see
 #endif
 
 #if TARGET_CPU_DEFAULT == TARGET_CPU_leon \
- || TARGET_CPU_DEFAULT == TARGET_CPU_leon3
+ || TARGET_CPU_DEFAULT == TARGET_CPU_leon3 \
+ || TARGET_CPU_DEFAULT == TARGET_CPU_leon5
 #define CPP_CPU32_DEFAULT_SPEC "-D__leon__ -D__sparc_v8__"
 #define ASM_CPU32_DEFAULT_SPEC AS_LEON_FLAG
 #endif
@@ -284,6 +286,7 @@ along with GCC; see the file COPYING3.  If not see
 %{mcpu=hypersparc:-D__hypersparc__ -D__sparc_v8__} \
 %{mcpu=leon:-D__leon__ -D__sparc_v8__} \
 %{mcpu=leon3:-D__leon__ -D__sparc_v8__} \
+%{mcpu=leon5:-D__leon__ -D__sparc_v8__} \
 %{mcpu=leon3v7:-D__leon__} \
 %{mcpu=v9:-D__sparc_v9__} \
 %{mcpu=ultrasparc:-D__sparc_v9__} \
@@ -336,6 +339,7 @@ along with GCC; see the file COPYING3.  If not see
 %{mcpu=hypersparc:-Av8} \
 %{mcpu=leon:" AS_LEON_FLAG "} \
 %{mcpu=leon3:" AS_LEON_FLAG "} \
+%{mcpu=leon5:" AS_LEON_FLAG "} \
 %{mcpu=leon3v7:" AS_LEONV7_FLAG "} \
 %{mv8plus:-Av8plus} \
 %{mcpu=v9:-Av9} \
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 6e9ccb4ecfd..b242c4b4481 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -233,6 +233,7 @@
    hypersparc,
    leon,
    leon3,
+   leon5,
    leon3v7,
    sparclite,
    f930,
@@ -638,6 +639,7 @@
 (include "supersparc.md")
 (include "hypersparc.md")
 (include "leon.md")
+(include "leon5.md")
 (include "sparclet.md")
 (include "ultra1_2.md")
 (include "ultra3.md")
@@ -8353,9 +8355,15 @@ visl")
 	(unspec:SI [(match_operand:SI 1 "memory_operand" "m")] UNSPEC_SP_SET))
    (set (match_scratch:SI 2 "=&r") (const_int 0))]
   "TARGET_ARCH32"
-  "ld\t%1, %2\;st\t%2, %0\;mov\t0, %2"
+{
+  if (sparc_fix_b2bst)
+    return "ld\t%1, %2\;st\t%2, %0\;mov\t0, %2\;nop";
+  else
+    return "ld\t%1, %2\;st\t%2, %0\;mov\t0, %2";
+}
   [(set_attr "type" "multi")
-   (set_attr "length" "3")])
+   (set (attr "length") (if_then_else (eq_attr "fix_b2bst" "true")
+		      (const_int 4) (const_int 3)))])
 
 (define_insn "stack_protect_setdi"
   [(set (match_operand:DI 0 "memory_operand" "=m")
diff --git a/gcc/config/sparc/sparc.opt b/gcc/config/sparc/sparc.opt
index b3d688b392f..3eb1f3e9a48 100644
--- a/gcc/config/sparc/sparc.opt
+++ b/gcc/config/sparc/sparc.opt
@@ -175,6 +175,9 @@ Enum(sparc_processor) String(leon3) Value(PROCESSOR_LEON3)
 EnumValue
 Enum(sparc_processor) String(leon3v7) Value(PROCESSOR_LEON3V7)
 
+EnumValue
+Enum(sparc_processor) String(leon5) Value(PROCESSOR_LEON5)
+
 EnumValue
 Enum(sparc_processor) String(sparclite) Value(PROCESSOR_SPARCLITE)
 
diff --git a/gcc/configure b/gcc/configure
index 8fe9c91fd7c..84e0ea21054 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -29405,7 +29405,7 @@ $as_echo "#define HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE 1" >>confdefs.h
 esac
 
 case "$target:$tm_file" in
-  powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
+  powerpc64*-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
   case "$target" in
      *le-*-linux*)
      emul_name="-melf64lppc"
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 84dceb8074a..d068618bd8f 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -5871,7 +5871,7 @@ EOF
 esac
 
 case "$target:$tm_file" in
-  powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
+  powerpc64*-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
   case "$target" in
      *le-*-linux*)
      emul_name="-melf64lppc"
diff --git a/gcc/coretypes.h b/gcc/coretypes.h
index cda22697cc3..4b0618ab278 100644
--- a/gcc/coretypes.h
+++ b/gcc/coretypes.h
@@ -219,15 +219,17 @@ enum profile_reproducibility {
     PROFILE_REPRODUCIBILITY_MULTITHREADED
 };
 
-/* Types of unwind/exception handling info that can be generated.  */
+/* Types of unwind/exception handling info that can be generated.
+   Note that a UI_TARGET (or larger) setting is considered to be
+   incompatible with -freorder-blocks-and-partition.  */
 
 enum unwind_info_type
 {
   UI_NONE,
   UI_SJLJ,
   UI_DWARF2,
-  UI_TARGET,
-  UI_SEH
+  UI_SEH,
+  UI_TARGET
 };
 
 /* Callgraph node profile representation.  */
diff --git a/gcc/coverage.c b/gcc/coverage.c
index 38820bc170f..2747f8f1b4c 100644
--- a/gcc/coverage.c
+++ b/gcc/coverage.c
@@ -616,18 +616,16 @@ coverage_compute_cfg_checksum (struct function *fn)
 int
 coverage_begin_function (unsigned lineno_checksum, unsigned cfg_checksum)
 {
-  expanded_location xloc;
-  unsigned long offset;
-
   /* We don't need to output .gcno file unless we're under -ftest-coverage
      (e.g. -fprofile-arcs/generate/use don't need .gcno to work). */
   if (no_coverage || !bbg_file_name)
     return 0;
 
-  xloc = expand_location (DECL_SOURCE_LOCATION (current_function_decl));
+  expanded_location startloc
+    = expand_location (DECL_SOURCE_LOCATION (current_function_decl));
 
   /* Announce function */
-  offset = gcov_write_tag (GCOV_TAG_FUNCTION);
+  unsigned long offset = gcov_write_tag (GCOV_TAG_FUNCTION);
   if (param_profile_func_internal_id)
     gcov_write_unsigned (current_function_funcdef_no + 1);
   else
@@ -644,16 +642,24 @@ coverage_begin_function (unsigned lineno_checksum, unsigned cfg_checksum)
   gcov_write_unsigned (DECL_ARTIFICIAL (current_function_decl)
 		       && !DECL_FUNCTION_VERSIONED (current_function_decl)
 		       && !DECL_LAMBDA_FUNCTION_P (current_function_decl));
-  gcov_write_filename (xloc.file);
-  gcov_write_unsigned (xloc.line);
-  gcov_write_unsigned (xloc.column);
+  gcov_write_filename (startloc.file);
+  gcov_write_unsigned (startloc.line);
+  gcov_write_unsigned (startloc.column);
 
   expanded_location endloc = expand_location (cfun->function_end_locus);
 
   /* Function can start in a single file and end in another one.  */
-  int end_line = endloc.file == xloc.file ? endloc.line : xloc.line;
-  int end_column = endloc.file == xloc.file ? endloc.column: xloc.column;
-  gcc_assert (xloc.line <= end_line);
+  int end_line
+    = endloc.file == startloc.file ? endloc.line : startloc.line;
+  int end_column
+    = endloc.file == startloc.file ? endloc.column: startloc.column;
+
+  if (startloc.line > end_line)
+    {
+      end_line = startloc.line;
+      end_column = startloc.column;
+    }
+
   gcov_write_unsigned (end_line);
   gcov_write_unsigned (end_column);
   gcov_write_length (offset);
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index b576f9a3678..7b8bdab9c72 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,376 @@
+2021-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-07-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/95520
+	* coroutines.cc (struct coroutine_info): Add fields for
+	actor and destroy function decls.
+	(to_ramp): New.
+	(coro_get_ramp_function): New.
+	(coro_get_actor_function): New.
+	(coro_get_destroy_function): New.
+	(act_des_fn): Set up mapping between ramp, actor and
+	destroy functions.
+	(morph_fn_to_coro): Adjust interface to the builder for
+	helper function decls.
+	* cp-tree.h (DECL_ACTOR_FN, DECL_DESTROY_FN, DECL_RAMP_FN,
+	JOIN_STR): New.
+	* mangle.c (write_encoding): Handle coroutine helpers.
+	(write_unqualified_name): Handle lambda coroutine helpers.
+
+2021-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-07-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* coroutines.cc (build_actor_fn): Move common code to
+	act_des_fn.
+	(build_destroy_fn): Likewise.
+	(act_des_fn): Build the void return here.  Ensure that the
+	source location matches the original function.
+
+2021-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-07-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* coroutines.cc
+	(coro_rewrite_function_body): Connect the replacement
+	function block to the block nest correctly.
+
+2021-10-03  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2021-03-18  Martin Liska  <mliska@suse.cz>
+
+	PR c++/99617
+	* coroutines.cc (struct var_nest_node): Init then_cl and else_cl
+	to NULL.
+
+2021-07-08  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-07-08  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/101087
+	* cp-tree.h (unevaluated_p): New.
+	* except.c (check_noexcept_r): Use it.  Don't walk into
+	unevaluated operands.
+
+2021-06-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101029
+	* init.c (build_vec_init): Shortcut [0] case.
+
+2021-06-07  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100102
+	* pt.c (tsubst_function_decl): Remove old code for reducing
+	args when it has excess levels.
+
+2021-06-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100797
+	PR c++/95719
+	* call.c (build_over_call): Adjust base_binfo in
+	resolves_to_fixed_type_p case.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100489
+	* constexpr.c (get_or_insert_ctor_field): Remove assert.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/80456
+	* call.c (build_new_method_call_1): Check again for side-effects
+	with a volatile object.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100054
+	PR c++/90479
+	* init.c (get_nsdmi): Do more context adjustment for local classes.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100032
+	* pt.c (get_underlying_template): Compare TYPE_QUALS.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91933
+	* class.c (build_base_path): Shortcut simple non-pointer case.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99180
+	PR c++/93295
+	PR c++/93867
+	PR c++/99118
+	PR c++/96873
+	* pt.c (alias_ctad_tweaks): Handle failure better.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41723
+	* parser.c (cp_parser_class_name): Check dependent_scope_p.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/52625
+	* pt.c (maybe_process_partial_specialization): Check
+	DECL_SELF_REFERENCE_P.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92918
+	* name-lookup.c (push_class_level_binding_1): Do overload a new
+	function with a previous using-declaration.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96673
+	* init.c (get_nsdmi): Don't defer access checking.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99901
+	* decl.c (cp_finish_decl): mark_needed an implicitly inline
+	static data member with an out-of-class redeclaration.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96311
+	* typeck.c (check_return_expr): Call mark_exp_read in dependent
+	case.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95870
+	* pt.c (enclosing_instantiation_of): Compare DECL_SOURCE_LOCATION if
+	there is no enclosing non-lambda function.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99201
+	* pt.c (class el_data): Add visited field.
+	(extract_local_specs): Pass it to cp_walk_tree.
+	(extract_locals_r): Walk into the body of a lambda.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99643
+	* typeck2.c (massage_init_elt): Don't strip TARGET_EXPR.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90664
+	* cvt.c (can_convert_qual): Check fnptr_conv_p.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91217
+	* pt.c (tsubst_lambda_expr): Skip the body block from
+	DECL_SAVED_TREE.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/97938
+	* cp-tree.h (PACK_EXPANSION_AUTO_P): New.
+	* lambda.c (add_capture): Set it.
+	* pt.c (tsubst_pack_expansion): Handle it.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-09-19  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97051
+	* constraint.cc (satisfy_atom): Pass true as the
+	manifestly_const_eval argument to maybe_constant_value.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-07-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95486
+	* pt.c (alias_ctad_tweaks): Call remove_constraints before
+	calling set_constraints.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-08  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97052
+	* constraint.cc (build_type_constraint): Temporarily increment
+	processing_template_decl before calling build_concept_check.
+	* pt.c (make_constrained_placeholder_type): Likewise.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-01-20  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95434
+	* pt.c (tsubst) <case TEMPLATE_TYPE_PARM>: If tsubsting
+	CLASS_PLACEHOLDER_TEMPLATE yields a TEMPLATE_TEMPLATE_PARM,
+	adjust to its TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-14  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/83476
+	PR c++/99885
+	* pt.c (deducible_expression): Look through implicit
+	INDIRECT_REFs as well.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/100111
+	* constexpr.c (cxx_eval_store_expression): Don't add CONSTRUCTORs
+	for empty classes into *valp when types don't match even when *valp
+	is NULL.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99833
+	* pt.c (extract_locals_r): When handling DECL_EXPR of a structured
+	binding, add to data.internal also all corresponding structured
+	binding decls.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99859
+	* constexpr.c (addr_of_non_const_var): New function.
+	(cxx_bind_parameters_in_call): Set *non_constant_args to true
+	even if cp_walk_tree on arg with addr_of_non_const_var callback
+	returns true.
+
+2021-04-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97966
+	* pt.c (instantiate_class_template_1): Use FOR_EACH_VEC_ELT instead
+	of range-based for loop.
+
+2021-04-10  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97973
+	* call.c (conv_unsafe_in_template_p): New.
+	(convert_like): Use it.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99806
+	* parser.c (cp_parser_member_declaration): Call
+	cp_parser_save_default_args even for function templates.  Use
+	STRIP_TEMPLATE on the declaration we're passing.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91416
+	* parser.c: Create a GC root for attributes in a decl specifier.
+	(cp_parser_type_specifier): Push/pop ->attributes onto/from it.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99831
+	* method.c (defaulted_late_check): ++ and -- function_depth around
+	the call to synthesize_method.
+	* pt.c: Remove the saved_trees global.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99331
+	* call.c (build_converted_constant_expr_internal): Don't emit
+	-Wconversion warnings.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	DR 1312
+	PR c++/99176
+	* constexpr.c (is_std_construct_at): New overload.
+	(is_std_allocator_allocate): New overload.
+	(cxx_eval_call_expression): Use the new overloads.
+	(cxx_eval_constant_expression): Reject casting
+	from void * as per DR 1312.  Don't check can_convert.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99120
+	* name-lookup.c (check_local_shadow): Check if the type of decl
+	is non-null before checking TYPE_PTR*.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99374
+	* call.c (standard_conversion): When converting pointers to
+	member, don't return NULL when the bases are equivalent but
+	incomplete.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-02-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98947
+	* call.c (build_conditional_expr_1): Don't call mark_lvalue_use
+	on arg2/arg3.
+	* expr.c (mark_use) <case MODIFY_EXPR>: Don't check read_p when
+	issuing the -Wvolatile warning.  Only set TREE_THIS_VOLATILE if
+	a warning was emitted.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97966
+	* pt.c (instantiate_class_template_1): Instantiate members
+	marked with attribute used only after we're done instantiating
+	the class.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-01-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98333
+	* parser.c (cp_parser_class_specifier_1): Perform late-parsing
+	of NSDMIs before late-parsing of noexcept-specifiers.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index aa8d84fa90c..87598974b6b 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -1434,7 +1434,9 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,
       tree fbase = class_of_this_parm (fromfn);
       tree tbase = class_of_this_parm (tofn);
 
-      if (!DERIVED_FROM_P (fbase, tbase))
+      /* If FBASE and TBASE are equivalent but incomplete, DERIVED_FROM_P
+	 yields false.  But a pointer to member of incomplete class is OK.  */
+      if (!same_type_p (fbase, tbase) && !DERIVED_FROM_P (fbase, tbase))
 	return NULL;
 
       tree fstat = static_fn_type (fromfn);
@@ -4392,6 +4394,9 @@ build_converted_constant_expr_internal (tree type, tree expr,
 	  && processing_template_decl)
 	conv = next_conversion (conv);
 
+      /* Issuing conversion warnings for value-dependent expressions is
+	 likely too noisy.  */
+      warning_sentinel w (warn_conversion);
       conv->check_narrowing = true;
       conv->check_narrowing_const_only = true;
       expr = convert_like (conv, expr, complain);
@@ -5474,8 +5479,6 @@ build_conditional_expr_1 (const op_location_t &loc,
       && same_type_p (arg2_type, arg3_type))
     {
       result_type = arg2_type;
-      arg2 = mark_lvalue_use (arg2);
-      arg3 = mark_lvalue_use (arg3);
       goto valid_operands;
     }
 
@@ -7302,6 +7305,27 @@ maybe_warn_array_conv (location_t loc, conversion *c, tree expr)
 	     "are only available with %<-std=c++2a%> or %<-std=gnu++2a%>");
 }
 
+/* Return true if converting FROM to TO is unsafe in a template.  */
+
+static bool
+conv_unsafe_in_template_p (tree to, tree from)
+{
+  /* Converting classes involves TARGET_EXPR.  */
+  if (CLASS_TYPE_P (to) || CLASS_TYPE_P (from))
+    return true;
+
+  /* Converting real to integer produces FIX_TRUNC_EXPR which tsubst
+     doesn't handle.  */
+  if (SCALAR_FLOAT_TYPE_P (from) && INTEGRAL_OR_ENUMERATION_TYPE_P (to))
+    return true;
+
+  /* Converting integer to real isn't a trivial conversion, either.  */
+  if (INTEGRAL_OR_ENUMERATION_TYPE_P (from) && SCALAR_FLOAT_TYPE_P (to))
+    return true;
+
+  return false;
+}
+
 /* Wrapper for convert_like_real_1 that handles creating IMPLICIT_CONV_EXPR.  */
 
 static tree
@@ -7317,7 +7341,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,
   tree conv_expr = NULL_TREE;
   if (processing_template_decl
       && convs->kind != ck_identity
-      && (CLASS_TYPE_P (convs->type) || CLASS_TYPE_P (TREE_TYPE (expr))))
+      && conv_unsafe_in_template_p (convs->type, TREE_TYPE (expr)))
     {
       conv_expr = build1 (IMPLICIT_CONV_EXPR, convs->type, expr);
       if (convs->kind != ck_ref_bind)
@@ -8738,19 +8762,6 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
 	  || CLASSTYPE_FINAL (TYPE_METHOD_BASETYPE (TREE_TYPE (fn))))
 	flags |= LOOKUP_NONVIRTUAL;
 
-      /* If we know the dynamic type of the object, look up the final overrider
-	 in the BINFO.  */
-      if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0
-	  && resolves_to_fixed_type_p (arg))
-	{
-	  tree binfo = cand->conversion_path;
-	  if (BINFO_TYPE (binfo) != DECL_CONTEXT (fn))
-	    binfo = lookup_base (binfo, DECL_CONTEXT (fn), ba_unique,
-				 NULL, complain);
-	  fn = lookup_vfn_in_binfo (DECL_VINDEX (fn), binfo);
-	  flags |= LOOKUP_NONVIRTUAL;
-	}
-
       /* [class.mfct.nonstatic]: If a nonstatic member function of a class
 	 X is called for an object that is not of type X, or of a type
 	 derived from X, the behavior is undefined.
@@ -8760,10 +8771,6 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
       gcc_assert (TYPE_PTR_P (parmtype));
       /* Convert to the base in which the function was declared.  */
       gcc_assert (cand->conversion_path != NULL_TREE);
-      converted_arg = build_base_path (PLUS_EXPR,
-				       arg,
-				       cand->conversion_path,
-				       1, complain);
       /* Check that the base class is accessible.  */
       if (!accessible_base_p (TREE_TYPE (argtype),
 			      BINFO_TYPE (cand->conversion_path), true))
@@ -8778,10 +8785,33 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
       /* If fn was found by a using declaration, the conversion path
 	 will be to the derived class, not the base declaring fn. We
 	 must convert from derived to base.  */
-      base_binfo = lookup_base (TREE_TYPE (TREE_TYPE (converted_arg)),
+      base_binfo = lookup_base (cand->conversion_path,
 				TREE_TYPE (parmtype), ba_unique,
 				NULL, complain);
-      converted_arg = build_base_path (PLUS_EXPR, converted_arg,
+
+      /* If we know the dynamic type of the object, look up the final overrider
+	 in the BINFO.  */
+      if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0
+	  && resolves_to_fixed_type_p (arg))
+	{
+	  tree ov = lookup_vfn_in_binfo (DECL_VINDEX (fn), base_binfo);
+
+	  /* And unwind base_binfo to match.  If we don't find the type we're
+	     looking for in BINFO_INHERITANCE_CHAIN, we're looking at diamond
+	     inheritance; for now do a normal virtual call in that case.  */
+	  tree octx = DECL_CONTEXT (ov);
+	  tree obinfo = base_binfo;
+	  while (obinfo && !SAME_BINFO_TYPE_P (BINFO_TYPE (obinfo), octx))
+	    obinfo = BINFO_INHERITANCE_CHAIN (obinfo);
+	  if (obinfo)
+	    {
+	      fn = ov;
+	      base_binfo = obinfo;
+	      flags |= LOOKUP_NONVIRTUAL;
+	    }
+	}
+
+      converted_arg = build_base_path (PLUS_EXPR, arg,
 				       base_binfo, 1, complain);
 
       argarray[j++] = converted_arg;
@@ -10423,7 +10453,8 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,
 		  tree a = instance;
 		  if (TREE_THIS_VOLATILE (a))
 		    a = build_this (a);
-		  call = build2 (COMPOUND_EXPR, TREE_TYPE (call), a, call);
+		  if (TREE_SIDE_EFFECTS (a))
+		    call = build2 (COMPOUND_EXPR, TREE_TYPE (call), a, call);
 		}
 	      else if (call != error_mark_node
 		       && DECL_DESTRUCTOR_P (cand->fn)
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index c0101130ba3..a22e5769dca 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -331,6 +331,15 @@ build_base_path (enum tree_code code,
       return error_mark_node;
     }
 
+  bool uneval = (cp_unevaluated_operand != 0
+		 || processing_template_decl
+		 || in_template_function ());
+
+  /* For a non-pointer simple base reference, express it as a COMPONENT_REF
+     without taking its address (and so causing lambda capture, 91933).  */
+  if (code == PLUS_EXPR && !v_binfo && !want_pointer && !has_empty && !uneval)
+    return build_simple_base_path (expr, binfo);
+
   if (!want_pointer)
     {
       rvalue = !lvalue_p (expr);
@@ -358,9 +367,7 @@ build_base_path (enum tree_code code,
      template (even in instantiate_non_dependent_expr), we don't have vtables
      set up properly yet, and the value doesn't matter there either; we're
      just interested in the result of overload resolution.  */
-  if (cp_unevaluated_operand != 0
-      || processing_template_decl
-      || in_template_function ())
+  if (uneval)
     {
       expr = build_nop (ptr_target_type, expr);
       goto indout;
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index ad3853940ff..566ba5b362a 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -1495,6 +1495,30 @@ free_constructor (tree t)
     }
 }
 
+/* Helper function of cxx_bind_parameters_in_call.  Return non-NULL
+   if *TP is address of a static variable (or part of it) currently being
+   constructed or of a heap artificial variable.  */
+
+static tree
+addr_of_non_const_var (tree *tp, int *walk_subtrees, void *data)
+{
+  if (TREE_CODE (*tp) == ADDR_EXPR)
+    if (tree var = get_base_address (TREE_OPERAND (*tp, 0)))
+      if (VAR_P (var) && TREE_STATIC (var))
+	{
+	  if (DECL_NAME (var) == heap_uninit_identifier
+	      || DECL_NAME (var) == heap_identifier)
+	    return var;
+
+	  constexpr_global_ctx *global = (constexpr_global_ctx *) data;
+	  if (global->values.get (var))
+	    return var;
+	}
+  if (TYPE_P (*tp))
+    *walk_subtrees = false;
+  return NULL_TREE;
+}
+
 /* Subroutine of cxx_eval_call_expression.
    We are processing a call expression (either CALL_EXPR or
    AGGR_INIT_EXPR) in the context of CTX.  Evaluate
@@ -1549,6 +1573,16 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,
 	    arg = adjust_temp_type (type, arg);
 	  if (!TREE_CONSTANT (arg))
 	    *non_constant_args = true;
+	    /* If arg is or contains address of a heap artificial variable or
+	       of a static variable being constructed, avoid caching the
+	       function call, as those variables might be modified by the
+	       function, or might be modified by the callers in between
+	       the cached function and just read by the function.  */
+	  else if (!*non_constant_args
+		   && cp_walk_tree (&arg, addr_of_non_const_var, ctx->global,
+				    NULL))
+	    *non_constant_args = true;
+
 	  /* For virtual calls, adjust the this argument, so that it is
 	     the object on which the method is called, rather than
 	     one of its bases.  */
@@ -1769,6 +1803,16 @@ is_std_construct_at (tree fndecl)
   return name && id_equal (name, "construct_at");
 }
 
+/* Overload for the above taking constexpr_call*.  */
+
+static inline bool
+is_std_construct_at (const constexpr_call *call)
+{
+  return (call
+	  && call->fundef
+	  && is_std_construct_at (call->fundef->decl));
+}
+
 /* Return true if FNDECL is std::allocator<T>::{,de}allocate.  */
 
 static inline bool
@@ -1791,6 +1835,16 @@ is_std_allocator_allocate (tree fndecl)
   return decl_in_std_namespace_p (decl);
 }
 
+/* Overload for the above taking constexpr_call*.  */
+
+static inline bool
+is_std_allocator_allocate (const constexpr_call *call)
+{
+  return (call
+	  && call->fundef
+	  && is_std_allocator_allocate (call->fundef->decl));
+}
+
 /* Return true if FNDECL is __dynamic_cast.  */
 
 static inline bool
@@ -2197,9 +2251,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,
       if (TREE_CODE (t) == CALL_EXPR
 	  && cxx_replaceable_global_alloc_fn (fun)
 	  && (CALL_FROM_NEW_OR_DELETE_P (t)
-	      || (ctx->call
-		  && ctx->call->fundef
-		  && is_std_allocator_allocate (ctx->call->fundef->decl))))
+	      || is_std_allocator_allocate (ctx->call)))
 	{
 	  const int nargs = call_expr_nargs (t);
 	  tree arg0 = NULL_TREE;
@@ -2267,9 +2319,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,
 	 argument.  */
       if (TREE_CODE (t) == CALL_EXPR
 	  && cxx_placement_new_fn (fun)
-	  && ctx->call
-	  && ctx->call->fundef
-	  && is_std_construct_at (ctx->call->fundef->decl))
+	  && is_std_construct_at (ctx->call))
 	{
 	  const int nargs = call_expr_nargs (t);
 	  tree arg1 = NULL_TREE;
@@ -3311,9 +3361,7 @@ get_or_insert_ctor_field (tree ctor, tree index, int pos_hint = -1)
     }
   else
     {
-      gcc_assert (TREE_CODE (index) == FIELD_DECL
-		  && (same_type_ignoring_top_level_qualifiers_p
-		      (DECL_CONTEXT (index), TREE_TYPE (ctor))));
+      gcc_assert (TREE_CODE (index) == FIELD_DECL);
 
       /* We must keep the CONSTRUCTOR's ELTS in FIELD order.
 	 Usually we meet initializers in that order, but it is
@@ -5096,6 +5144,14 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,
       CONSTRUCTOR_NO_CLEARING (*valp)
 	= CONSTRUCTOR_NO_CLEARING (init);
     }
+  else if (TREE_CODE (init) == CONSTRUCTOR
+	   && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init),
+							  type))
+    {
+      /* See above on initialization of empty bases.  */
+      gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);
+      return init;
+    }
   else
     *valp = init;
 
@@ -6270,6 +6326,36 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 	if (VOID_TYPE_P (type))
 	  return void_node;
 
+	/* [expr.const]: a conversion from type cv void* to a pointer-to-object
+	   type cannot be part of a core constant expression as a resolution to
+	   DR 1312.  */
+	if (integer_zerop (op) /* FIXME: Remove in GCC 12.  */
+	    && TYPE_PTROB_P (type)
+	    && TYPE_PTR_P (TREE_TYPE (op))
+	    && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (op)))
+	    /* Inside a call to std::construct_at or to
+	       std::allocator<T>::{,de}allocate, we permit casting from void*
+	       because that is compiler-generated code.  */
+	    && !is_std_construct_at (ctx->call)
+	    && !is_std_allocator_allocate (ctx->call))
+	  {
+	    /* Likewise, don't error when casting from void* when OP is
+	       &heap uninit and similar.  */
+	    tree sop = tree_strip_nop_conversions (op);
+	    if (TREE_CODE (sop) == ADDR_EXPR
+		&& VAR_P (TREE_OPERAND (sop, 0))
+		&& DECL_ARTIFICIAL (TREE_OPERAND (sop, 0)))
+	      /* OK */;
+	    else
+	      {
+		if (!ctx->quiet)
+		  error_at (loc, "cast from %qT is not allowed",
+			    TREE_TYPE (op));
+		*non_constant_p = true;
+		return t;
+	      }
+	  }
+
 	if (TREE_CODE (op) == PTRMEM_CST && !TYPE_PTRMEM_P (type))
 	  op = cplus_expand_constant (op);
 
@@ -6288,26 +6374,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 		if (TYPE_REF_P (type))
 		  {
 		    if (!ctx->quiet)
-		      error_at (loc,
-				"dereferencing a null pointer");
+		      error_at (loc, "dereferencing a null pointer");
 		    *non_constant_p = true;
 		    return t;
 		  }
-		else if (TYPE_PTR_P (TREE_TYPE (op)))
-		  {
-		    tree from = TREE_TYPE (op);
-
-		    if (!can_convert (type, from, tf_none))
-		      {
-			if (!ctx->quiet)
-			  error_at (loc,
-				    "conversion of %qT null pointer to %qT "
-				    "is not a constant expression",
-				    from, type);
-			*non_constant_p = true;
-			return t;
-		      }
-		  }
 	      }
 	    else
 	      {
diff --git a/gcc/cp/constraint.cc b/gcc/cp/constraint.cc
index 5f6488e514f..f28239a35d6 100644
--- a/gcc/cp/constraint.cc
+++ b/gcc/cp/constraint.cc
@@ -1420,7 +1420,9 @@ tree
 build_type_constraint (tree decl, tree args, tsubst_flags_t complain)
 {
   tree wildcard = build_nt (WILDCARD_DECL);
+  ++processing_template_decl;
   tree check = build_concept_check (decl, wildcard, args, complain);
+  --processing_template_decl;
   if (check == error_mark_node)
     return error_mark_node;
   return unpack_concept_check (check);
@@ -2628,7 +2630,8 @@ satisfy_atom (tree t, tree args, subst_info info)
     result = cxx_constant_value (result);
   else
     {
-      result = maybe_constant_value (result);
+      result = maybe_constant_value (result, NULL_TREE,
+				     /*manifestly_const_eval=*/true);
       if (!TREE_CONSTANT (result))
 	result = error_mark_node;
     }
diff --git a/gcc/cp/coroutines.cc b/gcc/cp/coroutines.cc
index 4ea9454c961..d65a5da5c1e 100644
--- a/gcc/cp/coroutines.cc
+++ b/gcc/cp/coroutines.cc
@@ -82,11 +82,13 @@ static bool coro_promise_type_found_p (tree, location_t);
 struct GTY((for_user)) coroutine_info
 {
   tree function_decl; /* The original function decl.  */
-  tree promise_type; /* The cached promise type for this function.  */
-  tree handle_type;  /* The cached coroutine handle for this function.  */
-  tree self_h_proxy; /* A handle instance that is used as the proxy for the
-			one that will eventually be allocated in the coroutine
-			frame.  */
+  tree actor_decl;    /* The synthesized actor function.  */
+  tree destroy_decl;  /* The synthesized destroy function.  */
+  tree promise_type;  /* The cached promise type for this function.  */
+  tree handle_type;   /* The cached coroutine handle for this function.  */
+  tree self_h_proxy;  /* A handle instance that is used as the proxy for the
+			 one that will eventually be allocated in the coroutine
+			 frame.  */
   tree promise_proxy; /* Likewise, a proxy promise instance.  */
   tree return_void;   /* The expression for p.return_void() if it exists.  */
   location_t first_coro_keyword; /* The location of the keyword that made this
@@ -525,6 +527,46 @@ coro_promise_type_found_p (tree fndecl, location_t loc)
   return true;
 }
 
+/* Map from actor or destroyer to ramp.  */
+static GTY(()) hash_map<tree, tree> *to_ramp;
+
+/* Given a tree that is an actor or destroy, find the ramp function.  */
+
+tree
+coro_get_ramp_function (tree decl)
+{
+  if (!to_ramp)
+    return NULL_TREE;
+  tree *p = to_ramp->get (decl);
+  if (p)
+    return *p;
+  return NULL_TREE;
+}
+
+/* Given the DECL for a ramp function (the user's original declaration) return
+   the actor function if it has been defined.  */
+
+tree
+coro_get_actor_function (tree decl)
+{
+  if (coroutine_info *info = get_coroutine_info (decl))
+    return info->actor_decl;
+
+  return NULL_TREE;
+}
+
+/* Given the DECL for a ramp function (the user's original declaration) return
+   the destroy function if it has been defined.  */
+
+tree
+coro_get_destroy_function (tree decl)
+{
+  if (coroutine_info *info = get_coroutine_info (decl))
+    return info->destroy_decl;
+
+  return NULL_TREE;
+}
+
 /* These functions assumes that the caller has verified that the state for
    the decl has been initialized, we try to minimize work here.  */
 
@@ -2179,13 +2221,6 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,
   /* One param, the coro frame pointer.  */
   tree actor_fp = DECL_ARGUMENTS (actor);
 
-  /* A void return.  */
-  tree resdecl = build_decl (loc, RESULT_DECL, 0, void_type_node);
-  DECL_ARTIFICIAL (resdecl) = 1;
-  DECL_IGNORED_P (resdecl) = 1;
-  DECL_RESULT (actor) = resdecl;
-  DECL_COROUTINE_P (actor) = 1;
-
   /* We have a definition here.  */
   TREE_STATIC (actor) = 1;
 
@@ -2556,15 +2591,8 @@ build_destroy_fn (location_t loc, tree coro_frame_type, tree destroy,
   /* One param, the coro frame pointer.  */
   tree destr_fp = DECL_ARGUMENTS (destroy);
 
-  /* A void return.  */
-  tree resdecl = build_decl (loc, RESULT_DECL, 0, void_type_node);
-  DECL_ARTIFICIAL (resdecl) = 1;
-  DECL_IGNORED_P (resdecl) = 1;
-  DECL_RESULT (destroy) = resdecl;
-
   /* We have a definition here.  */
   TREE_STATIC (destroy) = 1;
-  DECL_COROUTINE_P (destroy) = 1;
 
   tree destr_outer = push_stmt_list ();
   current_stmt_tree ()->stmts_are_full_exprs_p = 1;
@@ -2823,7 +2851,7 @@ struct var_nest_node
     : var(NULL_TREE), init(NULL_TREE),
       prev(NULL), next(NULL), then_cl(NULL), else_cl(NULL) {}
   var_nest_node (tree v, tree i, var_nest_node *p, var_nest_node *n)
-    : var(v), init(i), prev(p), next(n)
+    : var(v), init(i), prev(p), next(n), then_cl (NULL), else_cl (NULL)
     {
       if (p)
 	p->next = this;
@@ -4027,22 +4055,34 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)
   return NULL_TREE;
 }
 
-/* Build, return FUNCTION_DECL node with its coroutine frame pointer argument
-   for either actor or destroy functions.  */
+/* Build, return FUNCTION_DECL node based on ORIG with a type FN_TYPE which has
+   a single argument of type CORO_FRAME_PTR.  Build the actor function if
+   ACTOR_P is true, otherwise the destroy. */
 
 static tree
-act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)
+coro_build_actor_or_destroy_function (tree orig, tree fn_type,
+				      tree coro_frame_ptr, bool actor_p)
 {
-  tree fn_name = get_fn_local_identifier (orig, name);
-  tree fn = build_lang_decl (FUNCTION_DECL, fn_name, fn_type);
+  location_t loc = DECL_SOURCE_LOCATION (orig);
+  tree fn
+    = build_lang_decl (FUNCTION_DECL, copy_node (DECL_NAME (orig)), fn_type);
+
+  /* Allow for locating the ramp (original) function from this one.  */
+  if (!to_ramp)
+    to_ramp = hash_map<tree, tree>::create_ggc (10);
+  to_ramp->put (fn, orig);
+
   DECL_CONTEXT (fn) = DECL_CONTEXT (orig);
+  DECL_SOURCE_LOCATION (fn) = loc;
   DECL_ARTIFICIAL (fn) = true;
   DECL_INITIAL (fn) = error_mark_node;
+
   tree id = get_identifier ("frame_ptr");
   tree fp = build_lang_decl (PARM_DECL, id, coro_frame_ptr);
   DECL_CONTEXT (fp) = fn;
   DECL_ARG_TYPE (fp) = type_passed_as (coro_frame_ptr);
   DECL_ARGUMENTS (fn) = fp;
+
   /* Copy selected attributes from the original function.  */
   TREE_USED (fn) = TREE_USED (orig);
   if (DECL_SECTION_NAME (orig))
@@ -4054,6 +4094,28 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)
   DECL_USER_ALIGN (fn) = DECL_USER_ALIGN (orig);
   /* Apply attributes from the original fn.  */
   DECL_ATTRIBUTES (fn) = copy_list (DECL_ATTRIBUTES (orig));
+
+  /* A void return.  */
+  tree resdecl = build_decl (loc, RESULT_DECL, 0, void_type_node);
+  DECL_CONTEXT (resdecl) = fn;
+  DECL_ARTIFICIAL (resdecl) = 1;
+  DECL_IGNORED_P (resdecl) = 1;
+  DECL_RESULT (fn) = resdecl;
+
+  /* This is a coroutine component.  */
+  DECL_COROUTINE_P (fn) = 1;
+
+  /* Set up a means to find out if a decl is one of the helpers and, if so,
+     which one.  */
+  if (coroutine_info *info = get_coroutine_info (orig))
+    {
+      gcc_checking_assert ((actor_p && info->actor_decl == NULL_TREE)
+			   || info->destroy_decl == NULL_TREE);
+      if (actor_p)
+	info->actor_decl = fn;
+      else
+	info->destroy_decl = fn;
+    }
   return fn;
 }
 
@@ -4089,8 +4151,8 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,
       BIND_EXPR_BLOCK (first) = replace_blk;
       /* The top block has one child, so far, and we have now got a 
 	 superblock.  */
-      BLOCK_SUPERCONTEXT (block) = top_block;
-      BLOCK_SUBBLOCKS (top_block) = block;
+      BLOCK_SUPERCONTEXT (replace_blk) = top_block;
+      BLOCK_SUBBLOCKS (top_block) = replace_blk;
     }
 
   /* Wrap the function body in a try {} catch (...) {} block, if exceptions
@@ -4362,8 +4424,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)
   tree act_des_fn_ptr = build_pointer_type (act_des_fn_type);
 
   /* Declare the actor and destroyer function.  */
-  tree actor = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, "actor");
-  tree destroy = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, "destroy");
+  tree actor = coro_build_actor_or_destroy_function (orig, act_des_fn_type,
+						     coro_frame_ptr, true);
+  tree destroy = coro_build_actor_or_destroy_function (orig, act_des_fn_type,
+						       coro_frame_ptr, false);
 
   /* Construct the wrapped function body; we will analyze this to determine
      the requirements for the coroutine frame.  */
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 9a66fe5884f..15ec4cd199f 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -464,6 +464,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];
       IMPLICIT_CONV_EXPR_BRACED_INIT (in IMPLICIT_CONV_EXPR)
       TINFO_VAR_DECLARED_CONSTINIT (in TEMPLATE_INFO)
       CALL_FROM_NEW_OR_DELETE_P (in CALL_EXPR)
+      PACK_EXPANSION_AUTO_P (in *_PACK_EXPANSION)
    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).
       ICS_BAD_FLAG (in _CONV)
       FN_TRY_BLOCK_P (in TRY_BLOCK)
@@ -3728,6 +3729,9 @@ struct GTY(()) lang_decl {
 /* True iff this pack expansion is for sizeof....  */
 #define PACK_EXPANSION_SIZEOF_P(NODE) TREE_LANG_FLAG_1 (NODE)
 
+/* True iff this pack expansion is for auto... in lambda init-capture.  */
+#define PACK_EXPANSION_AUTO_P(NODE) TREE_LANG_FLAG_2 (NODE)
+
 /* True iff the wildcard can match a template parameter pack.  */
 #define WILDCARD_PACK_P(NODE) TREE_LANG_FLAG_0 (NODE)
 
@@ -5024,6 +5028,21 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)
 #define DECL_COROUTINE_P(NODE) \
   (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->coroutine_p)
 
+/* For a FUNCTION_DECL of a coroutine, this holds the ACTOR helper function
+   decl.  */
+#define DECL_ACTOR_FN(NODE) \
+  (coro_get_actor_function ((NODE)))
+
+/* For a FUNCTION_DECL of a coroutine, this holds the DESTROY helper function
+  decl.  */
+#define DECL_DESTROY_FN(NODE) \
+  (coro_get_destroy_function ((NODE)))
+
+/* For a FUNCTION_DECL of a coroutine helper (ACTOR or DESTROY), this points
+   back to the original (ramp) function.  */
+#define DECL_RAMP_FN(NODE) \
+  (coro_get_ramp_function (NODE))
+
 /* True for an OMP_ATOMIC that has dependent parameters.  These are stored
    as an expr in operand 1, and integer_zero_node or clauses in operand 0.  */
 #define OMP_ATOMIC_DEPENDENT_P(NODE) \
@@ -5459,6 +5478,7 @@ extern GTY(()) vec<tree, va_gc> *keyed_classes;
 #ifndef NO_DOT_IN_LABEL
 
 #define JOINER '.'
+#define JOIN_STR "."
 
 #define AUTO_TEMP_NAME "_.tmp_"
 #define VFIELD_BASE ".vf"
@@ -5470,6 +5490,7 @@ extern GTY(()) vec<tree, va_gc> *keyed_classes;
 #ifndef NO_DOLLAR_IN_LABEL
 
 #define JOINER '$'
+#define JOIN_STR "$"
 
 #define AUTO_TEMP_NAME "_$tmp_"
 #define VFIELD_BASE "$vf"
@@ -5478,6 +5499,8 @@ extern GTY(()) vec<tree, va_gc> *keyed_classes;
 
 #else /* NO_DOLLAR_IN_LABEL */
 
+#define JOIN_STR "_"
+
 #define VTABLE_NAME "__vt_"
 #define VTABLE_NAME_P(ID_NODE) \
   (!strncmp (IDENTIFIER_POINTER (ID_NODE), VTABLE_NAME, \
@@ -7988,6 +8011,9 @@ extern tree finish_co_yield_expr		(location_t, tree);
 extern tree coro_validate_builtin_call		(tree,
 						 tsubst_flags_t = tf_warning_or_error);
 extern bool morph_fn_to_coro			(tree, tree *, tree *);
+extern tree coro_get_actor_function		(tree);
+extern tree coro_get_destroy_function		(tree);
+extern tree coro_get_ramp_function		(tree);
 
 /* Inline bodies.  */
 
@@ -8132,6 +8158,19 @@ is_constrained_auto (const_tree t)
   return is_auto (t) && PLACEHOLDER_TYPE_CONSTRAINTS (t);
 }
 
+/* True if CODE, a tree code, denotes a tree whose operand is not evaluated
+   as per [expr.context], i.e., an operand to sizeof, typeof, decltype, or
+   alignof.  */
+
+inline bool
+unevaluated_p (tree_code code)
+{
+  return (code == DECLTYPE_TYPE
+	  || code == ALIGNOF_EXPR
+	  || code == SIZEOF_EXPR
+	  || code == NOEXCEPT_EXPR);
+}
+
 /* RAII class to push/pop class scope T; if T is not a class, do nothing.  */
 
 struct push_nested_class_guard
diff --git a/gcc/cp/cvt.c b/gcc/cp/cvt.c
index 9f9f6b658ad..0e11f060c53 100644
--- a/gcc/cp/cvt.c
+++ b/gcc/cp/cvt.c
@@ -2004,6 +2004,11 @@ can_convert_qual (tree type, tree expr)
   tree expr_type = TREE_TYPE (expr);
   gcc_assert (!same_type_p (type, expr_type));
 
+  /* A function pointer conversion also counts as a Qualification Adjustment
+     under [over.ics.scs].  */
+  if (fnptr_conv_p (type, expr_type))
+    return true;
+
   if (TYPE_PTR_P (type) && TYPE_PTR_P (expr_type))
     return comp_ptr_ttypes (TREE_TYPE (type), TREE_TYPE (expr_type));
   else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (expr_type))
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 4293ee6238f..03cd0a3a238 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -7489,10 +7489,13 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
   if (asmspec_tree && asmspec_tree != error_mark_node)
     asmspec = TREE_STRING_POINTER (asmspec_tree);
 
-  if (current_class_type
-      && CP_DECL_CONTEXT (decl) == current_class_type
-      && TYPE_BEING_DEFINED (current_class_type)
-      && !CLASSTYPE_TEMPLATE_INSTANTIATION (current_class_type)
+  bool in_class_decl
+    = (current_class_type
+       && CP_DECL_CONTEXT (decl) == current_class_type
+       && TYPE_BEING_DEFINED (current_class_type)
+       && !CLASSTYPE_TEMPLATE_INSTANTIATION (current_class_type));
+
+  if (in_class_decl
       && (DECL_INITIAL (decl) || init))
     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;
 
@@ -7863,6 +7866,13 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
 	  if (!flag_weak)
 	    /* Check again now that we have an initializer.  */
 	    maybe_commonize_var (decl);
+	  /* A class-scope constexpr variable with an out-of-class declaration.
+	     C++17 makes them implicitly inline, but still force it out.  */
+	  if (DECL_INLINE_VAR_P (decl)
+	      && !DECL_VAR_DECLARED_INLINE_P (decl)
+	      && !DECL_TEMPLATE_INSTANTIATION (decl)
+	      && !in_class_decl)
+	    mark_needed (decl);
 	}
 
       if (var_definition_p
diff --git a/gcc/cp/except.c b/gcc/cp/except.c
index 7e93c51f9ea..31cfc810133 100644
--- a/gcc/cp/except.c
+++ b/gcc/cp/except.c
@@ -1103,12 +1103,15 @@ check_handlers (tree handlers)
      expression whose type is a polymorphic class type (10.3).  */
 
 static tree
-check_noexcept_r (tree *tp, int * /*walk_subtrees*/, void * /*data*/)
+check_noexcept_r (tree *tp, int *walk_subtrees, void *)
 {
   tree t = *tp;
   enum tree_code code = TREE_CODE (t);
-  if ((code == CALL_EXPR && CALL_EXPR_FN (t))
-      || code == AGGR_INIT_EXPR)
+
+  if (unevaluated_p (code))
+    *walk_subtrees = false;
+  else if ((code == CALL_EXPR && CALL_EXPR_FN (t))
+	   || code == AGGR_INIT_EXPR)
     {
       /* We can only use the exception specification of the called function
 	 for determining the value of a noexcept expression; we can't use
diff --git a/gcc/cp/expr.c b/gcc/cp/expr.c
index 9b535708c57..6a7569418b1 100644
--- a/gcc/cp/expr.c
+++ b/gcc/cp/expr.c
@@ -226,17 +226,17 @@ mark_use (tree expr, bool rvalue_p, bool read_p,
 	     a volatile-qualified type is deprecated unless the assignment
 	     is either a discarded-value expression or appears in an
 	     unevaluated context."  */
-	  if (read_p
-	      && !cp_unevaluated_operand
+	  if (!cp_unevaluated_operand
 	      && (TREE_THIS_VOLATILE (lhs)
 		  || CP_TYPE_VOLATILE_P (TREE_TYPE (lhs)))
 	      && !TREE_THIS_VOLATILE (expr))
 	    {
-	      warning_at (location_of (expr), OPT_Wvolatile,
-			  "using value of simple assignment with %<volatile%>-"
-			  "qualified left operand is deprecated");
-	      /* Make sure not to warn about this assignment again.  */
-	      TREE_THIS_VOLATILE (expr) = true;
+	      if (warning_at (location_of (expr), OPT_Wvolatile,
+			      "using value of simple assignment with "
+			      "%<volatile%>-qualified left operand is "
+			      "deprecated"))
+		/* Make sure not to warn about this assignment again.  */
+		TREE_THIS_VOLATILE (expr) = true;
 	    }
 	  break;
 	}
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index 878099ecaad..e4a92e26e3b 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -585,16 +585,21 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)
 
 	  bool pushed = false;
 	  tree ctx = DECL_CONTEXT (member);
-	  if (!currently_open_class (ctx)
-	      && !LOCAL_CLASS_P (ctx))
+
+	  processing_template_decl_sentinel ptds (/*reset*/false);
+	  if (!currently_open_class (ctx))
 	    {
-	      push_to_top_level ();
+	      if (!LOCAL_CLASS_P (ctx))
+		push_to_top_level ();
+	      else
+		/* push_to_top_level would lose the necessary function context,
+		   just reset processing_template_decl.  */
+		processing_template_decl = 0;
 	      push_nested_class (ctx);
+	      push_deferring_access_checks (dk_no_deferred);
 	      pushed = true;
 	    }
 
-	  gcc_checking_assert (!processing_template_decl);
-
 	  inject_this_parameter (ctx, TYPE_UNQUALIFIED);
 
 	  start_lambda_scope (member);
@@ -615,8 +620,10 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)
 
 	  if (pushed)
 	    {
+	      pop_deferring_access_checks ();
 	      pop_nested_class ();
-	      pop_from_top_level ();
+	      if (!LOCAL_CLASS_P (ctx))
+		pop_from_top_level ();
 	    }
 
 	  input_location = sloc;
@@ -4332,6 +4339,14 @@ build_vec_init (tree base, tree maxindex, tree init,
   else
     ptype = atype;
 
+  if (integer_all_onesp (maxindex))
+    {
+      /* Shortcut zero element case to avoid unneeded constructor synthesis.  */
+      if (init && TREE_SIDE_EFFECTS (init))
+	base = build2 (COMPOUND_EXPR, ptype, init, base);
+      return base;
+    }
+
   /* The code we are generating looks like:
      ({
        T* t1 = (T*) base;
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index dea6e114303..f143cec61d3 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -607,8 +607,11 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,
 	   parameter pack in this context.  We will want as many fields as we
 	   have elements in the expansion of the initializer, so use its packs
 	   instead.  */
-	PACK_EXPANSION_PARAMETER_PACKS (type)
-	  = uses_parameter_packs (initializer);
+	{
+	  PACK_EXPANSION_PARAMETER_PACKS (type)
+	    = uses_parameter_packs (initializer);
+	  PACK_EXPANSION_AUTO_P (type) = true;
+	}
     }
 
   /* Make member variable.  */
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index 090fb529a98..cd2fdd91537 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -847,6 +847,18 @@ write_encoding (const tree decl)
       write_bare_function_type (fn_type,
 				mangle_return_type_p (decl),
 				d);
+
+      /* If this is a coroutine helper, then append an appropriate string to
+	 identify which.  */
+      if (tree ramp = DECL_RAMP_FN (decl))
+	{
+	  if (DECL_ACTOR_FN (ramp) == decl)
+	    write_string (JOIN_STR "actor");
+	  else if (DECL_DESTROY_FN (ramp) == decl)
+	    write_string (JOIN_STR "destroy");
+	  else
+	    gcc_unreachable ();
+	}
     }
 }
 
@@ -1383,9 +1395,12 @@ write_unqualified_name (tree decl)
 	}
       else if (DECL_OVERLOADED_OPERATOR_P (decl))
 	{
+	  tree t;
+	  if (!(t = DECL_RAMP_FN (decl)))
+	    t = decl;
 	  const char *mangled_name
-	    = (ovl_op_info[DECL_ASSIGNMENT_OPERATOR_P (decl)]
-	       [DECL_OVERLOADED_OPERATOR_CODE_RAW (decl)].mangled_name);
+	    = (ovl_op_info[DECL_ASSIGNMENT_OPERATOR_P (t)]
+	       [DECL_OVERLOADED_OPERATOR_CODE_RAW (t)].mangled_name);
 	  write_string (mangled_name);
 	}
       else if (UDLIT_OPER_P (DECL_NAME (decl)))
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
index 3a3e060843e..bfd1004dcaa 100644
--- a/gcc/cp/method.c
+++ b/gcc/cp/method.c
@@ -2934,7 +2934,12 @@ defaulted_late_check (tree fn)
       /* If the function was declared constexpr, check that the definition
 	 qualifies.  Otherwise we can define the function lazily.  */
       if (DECL_DECLARED_CONSTEXPR_P (fn) && !DECL_INITIAL (fn))
-	synthesize_method (fn);
+	{
+	  /* Prevent GC.  */
+	  function_depth++;
+	  synthesize_method (fn);
+	  function_depth--;
+	}
       return;
     }
 
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 76f3edb04c8..f8caa16fc76 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -2802,7 +2802,7 @@ check_local_shadow (tree decl)
   /* Don't warn for artificial things that are not implicit typedefs.  */
   if (DECL_ARTIFICIAL (decl) && !DECL_IMPLICIT_TYPEDEF_P (decl))
     return;
-  
+
   if (nonlambda_method_basetype ())
     if (tree member = lookup_member (current_nonlambda_class_type (),
 				     DECL_NAME (decl), /*protect=*/0,
@@ -2814,8 +2814,9 @@ check_local_shadow (tree decl)
 	   is a function or a pointer-to-function.  */
 	if (!OVL_P (member)
 	    || TREE_CODE (decl) == FUNCTION_DECL
-	    || TYPE_PTRFN_P (TREE_TYPE (decl))
-	    || TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))
+	    || (TREE_TYPE (decl)
+		&& (TYPE_PTRFN_P (TREE_TYPE (decl))
+		    || TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))))
 	  {
 	    auto_diagnostic_group d;
 	    if (warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wshadow,
@@ -4551,7 +4552,7 @@ push_class_level_binding_1 (tree name, tree x)
 	old_decl = bval;
       else if (TREE_CODE (bval) == USING_DECL
 	       && OVL_P (target_decl))
-	return true;
+	old_decl = bval;
       else if (OVL_P (target_decl)
 	       && OVL_P (target_bval))
 	old_decl = bval;
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 1f4a28ff7c0..f48c856fa94 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -17631,6 +17631,11 @@ cp_parser_explicit_specialization (cp_parser* parser)
   --parser->num_template_parameter_lists;
 }
 
+/* Preserve the attributes across a garbage collect (by making it a GC
+   root), which can occur when parsing a member function.  */
+
+static GTY(()) vec<tree, va_gc> *cp_parser_decl_specs_attrs;
+
 /* Parse a type-specifier.
 
    type-specifier:
@@ -17723,8 +17728,12 @@ cp_parser_type_specifier (cp_parser* parser,
       /* Parse tentatively so that we can back up if we don't find a
 	 class-specifier.  */
       cp_parser_parse_tentatively (parser);
+      if (decl_specs->attributes)
+	vec_safe_push (cp_parser_decl_specs_attrs, decl_specs->attributes);
       /* Look for the class-specifier.  */
       type_spec = cp_parser_class_specifier (parser);
+      if (decl_specs->attributes)
+	cp_parser_decl_specs_attrs->pop ();
       invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, type_spec);
       /* If that worked, we're done.  */
       if (cp_parser_parse_definitely (parser))
@@ -23663,7 +23672,7 @@ cp_parser_class_name (cp_parser *parser,
   /* Any name names a type if we're following the `typename' keyword
      in a qualified name where the enclosing scope is type-dependent.  */
   typename_p = (typename_keyword_p && scope && TYPE_P (scope)
-		&& dependent_type_p (scope));
+		&& dependent_scope_p (scope));
   /* Handle the common case (an identifier, but not a template-id)
      efficiently.  */
   if (token->type == CPP_NAME
@@ -24091,31 +24100,10 @@ cp_parser_class_specifier_1 (cp_parser* parser)
 	  maybe_end_member_template_processing ();
 	}
       vec_safe_truncate (unparsed_funs_with_default_args, 0);
-      /* Now parse any NSDMIs.  */
-      save_ccp = current_class_ptr;
-      save_ccr = current_class_ref;
-      FOR_EACH_VEC_SAFE_ELT (unparsed_nsdmis, ix, decl)
-	{
-	  if (class_type != DECL_CONTEXT (decl))
-	    {
-	      if (pushed_scope)
-		pop_scope (pushed_scope);
-	      class_type = DECL_CONTEXT (decl);
-	      pushed_scope = push_scope (class_type);
-	    }
-	  inject_this_parameter (class_type, TYPE_UNQUALIFIED);
-	  cp_parser_late_parsing_nsdmi (parser, decl);
-	}
-      vec_safe_truncate (unparsed_nsdmis, 0);
-      current_class_ptr = save_ccp;
-      current_class_ref = save_ccr;
-      if (pushed_scope)
-	pop_scope (pushed_scope);
 
       /* If there are noexcept-specifiers that have not yet been processed,
-	 take care of them now.  */
-      class_type = NULL_TREE;
-      pushed_scope = NULL_TREE;
+	 take care of them now.  Do this before processing NSDMIs as they
+	 may depend on noexcept-specifiers already having been processed.  */
       FOR_EACH_VEC_SAFE_ELT (unparsed_noexcepts, ix, decl)
 	{
 	  tree ctx = DECL_CONTEXT (decl);
@@ -24163,6 +24151,25 @@ cp_parser_class_specifier_1 (cp_parser* parser)
 	  maybe_end_member_template_processing ();
 	}
       vec_safe_truncate (unparsed_noexcepts, 0);
+
+      /* Now parse any NSDMIs.  */
+      save_ccp = current_class_ptr;
+      save_ccr = current_class_ref;
+      FOR_EACH_VEC_SAFE_ELT (unparsed_nsdmis, ix, decl)
+	{
+	  if (class_type != DECL_CONTEXT (decl))
+	    {
+	      if (pushed_scope)
+		pop_scope (pushed_scope);
+	      class_type = DECL_CONTEXT (decl);
+	      pushed_scope = push_scope (class_type);
+	    }
+	  inject_this_parameter (class_type, TYPE_UNQUALIFIED);
+	  cp_parser_late_parsing_nsdmi (parser, decl);
+	}
+      vec_safe_truncate (unparsed_nsdmis, 0);
+      current_class_ptr = save_ccp;
+      current_class_ref = save_ccr;
       if (pushed_scope)
 	pop_scope (pushed_scope);
 
@@ -25430,8 +25437,8 @@ cp_parser_member_declaration (cp_parser* parser)
 		  || !DECL_DECLARES_FUNCTION_P (decl))
 		finish_member_declaration (decl);
 
-	      if (TREE_CODE (decl) == FUNCTION_DECL)
-		cp_parser_save_default_args (parser, decl);
+	      if (DECL_DECLARES_FUNCTION_P (decl))
+		cp_parser_save_default_args (parser, STRIP_TEMPLATE (decl));
 	      else if (TREE_CODE (decl) == FIELD_DECL
 		       && DECL_INITIAL (decl))
 		/* Add DECL to the queue of NSDMI to be parsed later.  */
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index d329c0128ba..7ce9ac234f8 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -63,7 +63,6 @@ static GTY(()) struct pending_template *last_pending_template;
 int processing_template_parmlist;
 static int template_header_count;
 
-static GTY(()) tree saved_trees;
 static vec<int> inline_parm_levels;
 
 static GTY(()) struct tinst_level *current_tinst_level;
@@ -977,6 +976,10 @@ maybe_process_partial_specialization (tree type)
   if (CLASS_TYPE_P (type) && CLASSTYPE_LAMBDA_EXPR (type))
     return type;
 
+  /* An injected-class-name is not a specialization.  */
+  if (DECL_SELF_REFERENCE_P (TYPE_NAME (type)))
+    return type;
+
   if (TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)
     {
       error ("name of class shadows template template parameter %qD",
@@ -6516,6 +6519,10 @@ get_underlying_template (tree tmpl)
 	      != num_innermost_template_parms (underlying)))
 	break;
 
+      /* Does the alias add cv-quals?  */
+      if (TYPE_QUALS (TREE_TYPE (underlying)) != TYPE_QUALS (TREE_TYPE (tmpl)))
+	break;
+
       tree alias_args = INNERMOST_TEMPLATE_ARGS (generic_targs_for (tmpl));
       if (!comp_template_args (TI_ARGS (tinfo), alias_args))
 	break;
@@ -11762,6 +11769,9 @@ instantiate_class_template_1 (tree type)
      class, except we also need to push the enclosing classes.  */
   push_nested_class (type);
 
+  /* A vector to hold members marked with attribute used. */
+  auto_vec<tree> used;
+
   /* Now members are processed in the order of declaration.  */
   for (member = CLASSTYPE_DECL_LIST (pattern);
        member; member = TREE_CHAIN (member))
@@ -11839,7 +11849,7 @@ instantiate_class_template_1 (tree type)
 	      finish_member_declaration (r);
 	      /* Instantiate members marked with attribute used.  */
 	      if (r != error_mark_node && DECL_PRESERVE_P (r))
-		mark_used (r);
+		used.safe_push (r);
 	      if (TREE_CODE (r) == FUNCTION_DECL
 		  && DECL_OMP_DECLARE_REDUCTION_P (r))
 		cp_check_omp_declare_reduction (r);
@@ -11917,7 +11927,7 @@ instantiate_class_template_1 (tree type)
 			     /*flags=*/0);
 			  /* Instantiate members marked with attribute used. */
 			  if (r != error_mark_node && DECL_PRESERVE_P (r))
-			    mark_used (r);
+			    used.safe_push (r);
 			}
 		      else if (TREE_CODE (r) == FIELD_DECL)
 			{
@@ -12130,6 +12140,13 @@ instantiate_class_template_1 (tree type)
   if (TYPE_CONTAINS_VPTR_P (type) && CLASSTYPE_KEY_METHOD (type))
     vec_safe_push (keyed_classes, type);
 
+  /* Now that we've gone through all the members, instantiate those
+     marked with attribute used.  */
+  unsigned int i;
+  tree x;
+  FOR_EACH_VEC_ELT (used, i, x)
+    mark_used (x);
+
   return type;
 }
 
@@ -12663,7 +12680,11 @@ tsubst_binary_right_fold (tree t, tree args, tsubst_flags_t complain,
 class el_data
 {
 public:
+  /* Set of variables declared within the pattern.  */
   hash_set<tree> internal;
+  /* Set of AST nodes that have been visited by the traversal.  */
+  hash_set<tree> visited;
+  /* List of local_specializations used within the pattern.  */
   tree extra;
   tsubst_flags_t complain;
 
@@ -12682,7 +12703,36 @@ extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data_)
     tp = &TYPE_NAME (*tp);
 
   if (TREE_CODE (*tp) == DECL_EXPR)
-    data.internal.add (DECL_EXPR_DECL (*tp));
+    {
+      tree decl = DECL_EXPR_DECL (*tp);
+      data.internal.add (decl);
+      if (VAR_P (decl)
+	  && DECL_DECOMPOSITION_P (decl)
+	  && TREE_TYPE (decl) != error_mark_node)
+	{
+	  gcc_assert (DECL_NAME (decl) == NULL_TREE);
+	  for (tree decl2 = DECL_CHAIN (decl);
+	       decl2
+	       && VAR_P (decl2)
+	       && DECL_DECOMPOSITION_P (decl2)
+	       && DECL_NAME (decl2)
+	       && TREE_TYPE (decl2) != error_mark_node;
+	       decl2 = DECL_CHAIN (decl2))
+	    {
+	      gcc_assert (DECL_DECOMP_BASE (decl2) == decl);
+	      data.internal.add (decl2);
+	    }
+	}
+    }
+  else if (TREE_CODE (*tp) == LAMBDA_EXPR)
+    {
+      /* Since we defer implicit capture, look in the parms and body.  */
+      tree fn = lambda_function (*tp);
+      cp_walk_tree (&TREE_TYPE (fn), &extract_locals_r, &data,
+		    &data.visited);
+      cp_walk_tree (&DECL_SAVED_TREE (fn), &extract_locals_r, &data,
+		    &data.visited);
+    }
   else if (tree spec = retrieve_local_specialization (*tp))
     {
       if (data.internal.contains (*tp))
@@ -12739,7 +12789,7 @@ static tree
 extract_local_specs (tree pattern, tsubst_flags_t complain)
 {
   el_data data (complain);
-  cp_walk_tree_without_duplicates (&pattern, extract_locals_r, &data);
+  cp_walk_tree (&pattern, extract_locals_r, &data, &data.visited);
   return data.extra;
 }
 
@@ -13020,12 +13070,23 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 	 pattern and return a PACK_EXPANSION_*. The caller will need to
 	 deal with that.  */
       if (TREE_CODE (t) == EXPR_PACK_EXPANSION)
-	t = tsubst_expr (pattern, args, complain, in_decl,
+	result = tsubst_expr (pattern, args, complain, in_decl,
 			 /*integral_constant_expression_p=*/false);
       else
-	t = tsubst (pattern, args, complain, in_decl);
-      t = make_pack_expansion (t, complain);
-      return t;
+	result = tsubst (pattern, args, complain, in_decl);
+      result = make_pack_expansion (result, complain);
+      if (PACK_EXPANSION_AUTO_P (t))
+	{
+	  /* This is a fake auto... pack expansion created in add_capture with
+	     _PACKS that don't appear in the pattern.  Copy one over.  */
+	  packs = PACK_EXPANSION_PARAMETER_PACKS (t);
+	  pack = retrieve_local_specialization (TREE_VALUE (packs));
+	  gcc_checking_assert (DECL_PACK_P (pack));
+	  PACK_EXPANSION_PARAMETER_PACKS (result)
+	    = build_tree_list (NULL_TREE, pack);
+	  PACK_EXPANSION_AUTO_P (result) = true;
+	}
+      return result;
     }
 
   gcc_assert (len >= 0);
@@ -13750,45 +13811,6 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
 	  if (tree spec = retrieve_specialization (gen_tmpl, argvec, hash))
 	    return spec;
 	}
-
-      /* We can see more levels of arguments than parameters if
-	 there was a specialization of a member template, like
-	 this:
-
-	 template <class T> struct S { template <class U> void f(); }
-	 template <> template <class U> void S<int>::f(U);
-
-	 Here, we'll be substituting into the specialization,
-	 because that's where we can find the code we actually
-	 want to generate, but we'll have enough arguments for
-	 the most general template.
-
-	 We also deal with the peculiar case:
-
-	 template <class T> struct S {
-	   template <class U> friend void f();
-	 };
-	 template <class U> void f() {}
-	 template S<int>;
-	 template void f<double>();
-
-	 Here, the ARGS for the instantiation of will be {int,
-	 double}.  But, we only need as many ARGS as there are
-	 levels of template parameters in CODE_PATTERN.  We are
-	 careful not to get fooled into reducing the ARGS in
-	 situations like:
-
-	 template <class T> struct S { template <class U> void f(U); }
-	 template <class T> template <> void S<T>::f(int) {}
-
-	 which we can spot because the pattern will be a
-	 specialization in this case.  */
-      int args_depth = TMPL_ARGS_DEPTH (args);
-      int parms_depth =
-	TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (t)));
-
-      if (args_depth > parms_depth && !DECL_TEMPLATE_SPECIALIZATION (t))
-	args = get_innermost_template_args (args, parms_depth);
     }
   else
     {
@@ -14216,6 +14238,19 @@ enclosing_instantiation_of (tree otctx)
 		  || instantiated_lambda_fn_p (tctx));
        tctx = decl_function_context (tctx))
     ++lambda_count;
+
+  if (!tctx)
+    {
+      /* Match using DECL_SOURCE_LOCATION, which is unique for all lambdas.
+
+	 For GCC 11 the above condition limits this to the previously failing
+	 case where all enclosing functions are lambdas (95870).  FIXME.  */
+      for (tree ofn = fn; ofn; ofn = decl_function_context (ofn))
+	if (DECL_SOURCE_LOCATION (ofn) == DECL_SOURCE_LOCATION (otctx))
+	  return ofn;
+      gcc_unreachable ();
+    }
+
   for (; fn; fn = decl_function_context (fn))
     {
       tree ofn = fn;
@@ -15486,6 +15521,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 		    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))
 		      {
 			pl = tsubst_copy (pl, args, complain, in_decl);
+			if (TREE_CODE (pl) == TEMPLATE_TEMPLATE_PARM)
+			  pl = TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (pl);
 			CLASS_PLACEHOLDER_TEMPLATE (r) = pl;
 		      }
 		  }
@@ -19223,8 +19260,13 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	 the purposes of template argument deduction. */
       complain = tf_warning_or_error;
 
-      tsubst_expr (DECL_SAVED_TREE (oldfn), args, complain, r,
-		   /*constexpr*/false);
+      tree saved = DECL_SAVED_TREE (oldfn);
+      if (TREE_CODE (saved) == BIND_EXPR && BIND_EXPR_BODY_BLOCK (saved))
+	/* We already have a body block from start_lambda_function, we don't
+	   need another to confuse NRV (91217).  */
+	saved = BIND_EXPR_BODY (saved);
+
+      tsubst_expr (saved, args, complain, r, /*constexpr*/false);
 
       finish_lambda_function (body);
 
@@ -21670,8 +21712,10 @@ static bool uses_deducible_template_parms (tree type);
 static bool
 deducible_expression (tree expr)
 {
-  /* Strip implicit conversions.  */
-  while (CONVERT_EXPR_P (expr) || TREE_CODE (expr) == VIEW_CONVERT_EXPR)
+  /* Strip implicit conversions and implicit INDIRECT_REFs.  */
+  while (CONVERT_EXPR_P (expr)
+	 || TREE_CODE (expr) == VIEW_CONVERT_EXPR
+	 || REFERENCE_REF_P (expr))
     expr = TREE_OPERAND (expr, 0);
   return (TREE_CODE (expr) == TEMPLATE_PARM_INDEX);
 }
@@ -27964,7 +28008,9 @@ make_constrained_placeholder_type (tree type, tree con, tree args)
   tree expr = tmpl;
   if (TREE_CODE (con) == FUNCTION_DECL)
     expr = ovl_make (tmpl);
+  ++processing_template_decl;
   expr = build_concept_check (expr, type, args, tf_warning_or_error);
+  --processing_template_decl;
 
   PLACEHOLDER_TYPE_CONSTRAINTS (type) = expr;
 
@@ -28727,7 +28773,8 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	  unsigned len = TREE_VEC_LENGTH (ftparms);
 	  tree targs = make_tree_vec (len);
 	  int err = unify (ftparms, targs, ret, utype, UNIFY_ALLOW_NONE, false);
-	  gcc_assert (!err);
+	  if (err)
+	    continue;
 
 	  /* The number of parms for f' is the number of parms for A plus
 	     non-deduced parms of f.  */
@@ -28760,7 +28807,7 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	     guideness, and explicit-specifier.  */
 	  tree g = tsubst_decl (DECL_TEMPLATE_RESULT (f), targs, complain);
 	  if (g == error_mark_node)
-	    return error_mark_node;
+	    continue;
 	  DECL_USE_TEMPLATE (g) = 0;
 	  fprime = build_template_decl (g, gtparms, false);
 	  DECL_TEMPLATE_RESULT (fprime) = g;
@@ -28774,7 +28821,7 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	  if (ci)
 	    ci = tsubst_constraint_info (ci, targs, complain, in_decl);
 	  if (ci == error_mark_node)
-	    return error_mark_node;
+	    continue;
 
 	  /* Add a constraint that the return type matches the instantiation of
 	     A with the same template arguments.  */
@@ -28788,7 +28835,10 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	    }
 
 	  if (ci)
-	    set_constraints (fprime, ci);
+	    {
+	      remove_constraints (fprime);
+	      set_constraints (fprime, ci);
+	    }
 	}
       else
 	{
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 6ebf6319efd..a85a75c81ae 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -10037,6 +10037,9 @@ check_return_expr (tree retval, bool *no_warning)
     dependent:
       /* We should not have changed the return value.  */
       gcc_assert (retval == saved_retval);
+      /* We don't know if this is an lvalue or rvalue use, but
+	 either way we can mark it as read.  */
+      mark_exp_read (retval);
       return retval;
     }
 
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 96421caf22e..81caed45757 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -1442,9 +1442,6 @@ massage_init_elt (tree type, tree init, int nested, int flags,
   if (flags & LOOKUP_AGGREGATE_PAREN_INIT)
     new_flags |= LOOKUP_AGGREGATE_PAREN_INIT;
   init = digest_init_r (type, init, nested ? 2 : 1, new_flags, complain);
-  /* Strip a simple TARGET_EXPR when we know this is an initializer.  */
-  if (SIMPLE_TARGET_EXPR_P (init))
-    init = TARGET_EXPR_INITIAL (init);
   /* When we defer constant folding within a statement, we may want to
      defer this folding as well.  */
   tree t = fold_non_dependent_init (init, complain);
diff --git a/gcc/cprop.c b/gcc/cprop.c
index 169ca804e33..e084250380c 100644
--- a/gcc/cprop.c
+++ b/gcc/cprop.c
@@ -1007,16 +1007,18 @@ static int
 constprop_register (rtx from, rtx src, rtx_insn *insn)
 {
   rtx sset;
+  rtx_insn *next_insn;
 
   /* Check for reg or cc0 setting instructions followed by
      conditional branch instructions first.  */
   if ((sset = single_set (insn)) != NULL
-      && NEXT_INSN (insn)
-      && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))
+      && (next_insn = next_nondebug_insn (insn)) != NULL
+      && any_condjump_p (next_insn)
+      && onlyjump_p (next_insn))
     {
       rtx dest = SET_DEST (sset);
       if ((REG_P (dest) || CC0_P (dest))
-	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn),
+	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, next_insn,
 			 from, src))
 	return 1;
     }
diff --git a/gcc/cse.c b/gcc/cse.c
index 36bcfc354d8..f69a33a82e0 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -2637,6 +2637,11 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)
     CASE_CONST_UNIQUE:
       return x == y;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       return label_ref_label (x) == label_ref_label (y);
 
diff --git a/gcc/cselib.c b/gcc/cselib.c
index 53e9603868d..5ecedef0bb4 100644
--- a/gcc/cselib.c
+++ b/gcc/cselib.c
@@ -1048,6 +1048,11 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)
     case DEBUG_EXPR:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case DEBUG_IMPLICIT_PTR:
       return DEBUG_IMPLICIT_PTR_DECL (x)
 	     == DEBUG_IMPLICIT_PTR_DECL (y);
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index 8bc729ae32d..23ef4f15d9a 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,178 @@
+2021-12-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (get_symbol_decl): Align methods to MINIMUM_METHOD_BOUNDARY.
+
+2021-11-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (d_finish_decl): Use HOST_WIDE_INT for type size
+	temporaries.
+
+2021-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-10-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* d-spec.cc (lang_specific_driver): Push the -static-libstdc++
+	option back onto the command line for targets without support
+	for -Bstatic/dynamic.
+
+2021-10-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-10-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/102574
+	* d-spec.cc (lang_specific_driver): Link libstdc++ statically if
+	-static-libstdc++ was given on command-line.
+
+2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96435
+	* d-convert.cc (convert_for_rvalue): New function.
+	* d-tree.h (convert_for_rvalue): Declare.
+	* expr.cc (ExprVisitor::visit (CastExp *)): Use convert_for_rvalue.
+	(build_return_dtor): Likewise.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* expr.cc (binary_op): Use build2 instead of fold_build2.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* d-codegen.cc (build_array_index): Handle void arrays same as byte.
+	* d-convert.cc (convert_expr): Handle converting to zero-sized arrays.
+	* dmd/dcast.c (castTo): Handle casting to zero-sized arrays.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* dmd/expression.c (FuncInitExp::resolveLoc): Set type as `string'.
+	(PrettyFuncInitExp::resolveLoc): Likewise.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* d-builtins.cc (d_builtin_function_ext_scope): New function.
+	* d-lang.cc (LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE): Define.
+	* d-tree.h (d_builtin_function_ext_scope): Declare.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101619
+	* dmd/expression.c (DotTemplateExp::checkType): New function.
+	(DotTemplateExp::checkValue): New function.
+	* dmd/expression.h (class DotTemplateExp): Declare checkType and
+	checkValue.
+
+2021-06-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100999
+	* dmd/cond.c (lowerArrayAggregate): Run CTFE interpret on foreach
+	input range.
+	(createTupleType): Don't generate typeinfo when disabled.
+	(lowerNonArrayAggregate): Suppress errors when running type semantic.
+	(staticForeachPrepare): Don't run CTFE interpret from here.
+	* dmd/dinterpret.c (ctfeInterpret): Add more shortcut cases.
+	* dmd/expression.c (resolvePropertiesX): Remove early error.
+	(Expression::checkPostblit): Don't generate typeinfo when type is
+	missing from library.
+	* dmd/expressionsem.c (ExpressionSemanticVisitor): Set type of
+	DotTemplateExp as void.
+	* dmd/statementsem.c (StatementSemanticVisitor::declareVariable):
+	Don't override index type.
+	(StatementSemanticVisitor::makeTupleForeachBody): Check index type is
+	integral and index range fits type size.
+	(StatementSemanticVisitor::visit (ForeachStatement*)): Adjust index
+	range before testing.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* d-frontend.cc (getTypeInfoType): Move TypeInfo checks to
+	check_typeinfo_type and call new function.
+	* d-tree.h (check_typeinfo_type): Declare.
+	* typeinfo.cc: Include dmd/scope.h.
+	(create_frontend_tinfo_types): Generate front-end types even if Object
+	is missing.
+	(build_typeinfo): Move TypeInfo checks to check_typeinfo_type and call
+	new function.
+	(check_typeinfo_type): New function.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* dmd/expression.c (Expression::checkPostblit): Don't generate
+	TypeInfo when RTTI is disabled.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* dmd/mtype.c (Type::getProperty): Prefer explicit alignment over
+	natural alignment for alignof property.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* d-codegen.cc (build_assign): Construct initializations inside
+	TARGET_EXPR_INITIAL.
+	(compound_expr): Remove intermediate expressions that have no
+	side-effects.
+	(return_expr): Construct returns inside TARGET_EXPR_INITIAL.
+	* expr.cc (ExprVisitor::visit (CallExp *)): Remove useless assignment
+	to TARGET_EXPR_SLOT.
+
+2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98457
+	* d-diagnostic.cc (expand_d_format): Handle escaped backticks.
+	(escape_d_format): New funtion.
+	(verror): Call escape_d_format on prefixing strings.
+	(vdeprecation): Likewise.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/d/d-builtins.cc b/gcc/d/d-builtins.cc
index 1cb5407f8a9..0ca65a34153 100644
--- a/gcc/d/d-builtins.cc
+++ b/gcc/d/d-builtins.cc
@@ -1211,5 +1211,20 @@ d_builtin_function (tree decl)
   return decl;
 }
 
+/* Same as d_builtin_function, but used to delay putting in back-end builtin
+   functions until the ISA that defines the builtin has been declared.
+   However in D, there is no global namespace.  All builtins get pushed into the
+   `gcc.builtins' module, which is constructed during the semantic analysis
+   pass, which has already finished by the time target attributes are evaluated.
+   So builtins are not pushed because they would be ultimately ignored.
+   The purpose of having this function then is to improve compile-time
+   reflection support to allow user-code to determine whether a given back end
+   function is enabled by the ISA.  */
+
+tree
+d_builtin_function_ext_scope (tree decl)
+{
+  return decl;
+}
 
 #include "gt-d-d-builtins.h"
diff --git a/gcc/d/d-codegen.cc b/gcc/d/d-codegen.cc
index 8042f03f369..dcb8fc151f9 100644
--- a/gcc/d/d-codegen.cc
+++ b/gcc/d/d-codegen.cc
@@ -1269,6 +1269,7 @@ component_ref (tree object, tree field)
 tree
 build_assign (tree_code code, tree lhs, tree rhs)
 {
+  tree result;
   tree init = stabilize_expr (&lhs);
   init = compound_expr (init, stabilize_expr (&rhs));
 
@@ -1287,22 +1288,27 @@ build_assign (tree_code code, tree lhs, tree rhs)
   if (TREE_CODE (rhs) == TARGET_EXPR)
     {
       /* If CODE is not INIT_EXPR, can't initialize LHS directly,
-	 since that would cause the LHS to be constructed twice.
-	 So we force the TARGET_EXPR to be expanded without a target.  */
+	 since that would cause the LHS to be constructed twice.  */
       if (code != INIT_EXPR)
 	{
 	  init = compound_expr (init, rhs);
-	  rhs = TARGET_EXPR_SLOT (rhs);
+	  result = build_assign (code, lhs, TARGET_EXPR_SLOT (rhs));
 	}
       else
 	{
 	  d_mark_addressable (lhs);
-	  rhs = TARGET_EXPR_INITIAL (rhs);
+	  TARGET_EXPR_INITIAL (rhs) = build_assign (code, lhs,
+						    TARGET_EXPR_INITIAL (rhs));
+	  result = rhs;
 	}
     }
+  else
+    {
+      /* Simple assignment.  */
+      result = fold_build2_loc (input_location, code,
+				TREE_TYPE (lhs), lhs, rhs);
+    }
 
-  tree result = fold_build2_loc (input_location, code,
-				 TREE_TYPE (lhs), lhs, rhs);
   return compound_expr (init, result);
 }
 
@@ -1424,6 +1430,11 @@ compound_expr (tree arg0, tree arg1)
   if (arg0 == NULL_TREE || !TREE_SIDE_EFFECTS (arg0))
     return arg1;
 
+  /* Remove intermediate expressions that have no side-effects.  */
+  while (TREE_CODE (arg0) == COMPOUND_EXPR
+	 && !TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
+    arg0 = TREE_OPERAND (arg0, 0);
+
   if (TREE_CODE (arg1) == TARGET_EXPR)
     {
       /* If the rhs is a TARGET_EXPR, then build the compound expression
@@ -1444,6 +1455,19 @@ compound_expr (tree arg0, tree arg1)
 tree
 return_expr (tree ret)
 {
+  /* Same as build_assign, the DECL_RESULT assignment replaces the temporary
+     in TARGET_EXPR_SLOT.  */
+  if (ret != NULL_TREE && TREE_CODE (ret) == TARGET_EXPR)
+    {
+      tree exp = TARGET_EXPR_INITIAL (ret);
+      tree init = stabilize_expr (&exp);
+
+      exp = fold_build1_loc (input_location, RETURN_EXPR, void_type_node, exp);
+      TARGET_EXPR_INITIAL (ret) = compound_expr (init, exp);
+
+      return ret;
+    }
+
   return fold_build1_loc (input_location, RETURN_EXPR,
 			  void_type_node, ret);
 }
@@ -1547,21 +1571,9 @@ build_array_index (tree ptr, tree index)
   /* Array element size.  */
   tree size_exp = size_in_bytes (target_type);
 
-  if (integer_zerop (size_exp))
-    {
-      /* Test for array of void.  */
-      if (TYPE_MODE (target_type) == TYPE_MODE (void_type_node))
-	index = fold_convert (type, index);
-      else
-	{
-	  /* Should catch this earlier.  */
-	  error ("invalid use of incomplete type %qD", TYPE_NAME (target_type));
-	  ptr_type = error_mark_node;
-	}
-    }
-  else if (integer_onep (size_exp))
+  if (integer_zerop (size_exp) || integer_onep (size_exp))
     {
-      /* Array of bytes -- No need to multiply.  */
+      /* Array of void or bytes -- No need to multiply.  */
       index = fold_convert (type, index);
     }
   else
diff --git a/gcc/d/d-convert.cc b/gcc/d/d-convert.cc
index f93405ed956..87062513c33 100644
--- a/gcc/d/d-convert.cc
+++ b/gcc/d/d-convert.cc
@@ -473,13 +473,18 @@ convert_expr (tree exp, Type *etype, Type *totype)
 
 	  tree ptrtype = build_ctype (tbtype->nextOf ()->pointerTo ());
 
-	  if ((dim * esize) % tsize != 0)
+	  if (esize != tsize)
 	    {
-	      error ("cannot cast %qs to %qs since sizes do not line up",
-		     etype->toChars (), totype->toChars ());
-	      return error_mark_node;
+	      /* Array element sizes do not match, so we must adjust the
+		 dimensions.  */
+	      if (tsize == 0 || (dim * esize) % tsize != 0)
+		{
+		  error ("cannot cast %qs to %qs since sizes do not line up",
+			 etype->toChars (), totype->toChars ());
+		  return error_mark_node;
+		}
+	      dim = (dim * esize) / tsize;
 	    }
-	  dim = (dim * esize) / tsize;
 
 	  /* Assumes casting to dynamic array of same type or void.  */
 	  return d_array_value (build_ctype (totype), size_int (dim),
@@ -595,6 +600,42 @@ convert_expr (tree exp, Type *etype, Type *totype)
   return result ? result : convert (build_ctype (totype), exp);
 }
 
+/* Return a TREE represenwation of EXPR, whose type has been converted from
+ * ETYPE to TOTYPE, and is being used in an rvalue context.  */
+
+tree
+convert_for_rvalue (tree expr, Type *etype, Type *totype)
+{
+  tree result = NULL_TREE;
+
+  Type *ebtype = etype->toBasetype ();
+  Type *tbtype = totype->toBasetype ();
+
+  switch (ebtype->ty)
+    {
+    case Tbool:
+      /* If casting from bool, the result is either 0 or 1, any other value
+	 violates @safe code, so enforce that it is never invalid.  */
+      if (CONSTANT_CLASS_P (expr))
+	result = d_truthvalue_conversion (expr);
+      else
+	{
+	  /* Reinterpret the boolean as an integer and test the first bit.
+	     The generated code should end up being equivalent to:
+		*cast(ubyte *)&expr & 1;  */
+	  machine_mode bool_mode = TYPE_MODE (TREE_TYPE (expr));
+	  tree mtype = lang_hooks.types.type_for_mode (bool_mode, 1);
+	  result = fold_build2 (BIT_AND_EXPR, mtype,
+				build_vconvert (mtype, expr),
+				build_one_cst (mtype));
+	}
+
+      result = convert (build_ctype (tbtype), result);
+      break;
+    }
+
+  return result ? result : convert_expr (expr, etype, totype);
+}
 
 /* Apply semantics of assignment to a value of type TOTYPE to EXPR
    (e.g., pointer = array -> pointer = &array[0])
diff --git a/gcc/d/d-diagnostic.cc b/gcc/d/d-diagnostic.cc
index 6af35f71c31..dbe6bc1bb7b 100644
--- a/gcc/d/d-diagnostic.cc
+++ b/gcc/d/d-diagnostic.cc
@@ -48,7 +48,7 @@ expand_d_format (const char *format)
 
   for (const char *p = format; *p;)
     {
-      while (*p != '\0' && *p != '%' && *p != '`')
+      while (*p != '\0' && *p != '\\' && *p != '%' && *p != '`')
 	{
 	  buf.writeByte (*p);
 	  p++;
@@ -57,6 +57,21 @@ expand_d_format (const char *format)
       if (*p == '\0')
 	break;
 
+      if (*p == '\\')
+	{
+	  if (p[1] == '`')
+	    {
+	      /* Escaped backtick, don't expand it as a quoted string.  */
+	      buf.writeByte ('`');
+	      p++;;
+	    }
+	  else
+	    buf.writeByte (*p);
+
+	  p++;
+	  continue;
+	}
+
       if (*p == '`')
 	{
 	  /* Text enclosed by `...` are translated as a quoted string.  */
@@ -113,6 +128,43 @@ expand_d_format (const char *format)
   return buf.extractString ();
 }
 
+/* Rewrite the format string FORMAT to deal with any characters that require
+   escaping before expand_d_format expands it.  */
+
+static char *
+escape_d_format (const char *format)
+{
+  obstack buf;
+
+  gcc_obstack_init (&buf);
+
+  for (const char *p = format; *p; p++)
+    {
+      switch (*p)
+	{
+	case '%':
+	  /* Escape `%' characters so that pp_format does not confuse them
+	     for actual format specifiers.  */
+	  obstack_1grow (&buf, '%');
+	  break;
+
+	case '`':
+	  /* Escape '`' characters so that expand_d_format does not confuse them
+	     for a quoted string.  */
+	  obstack_1grow (&buf, '\\');
+	  break;
+
+	default:
+	  break;
+	}
+
+      obstack_1grow (&buf, *p);
+    }
+
+  obstack_1grow (&buf, '\0');
+  return (char *) obstack_finish (&buf);
+}
+
 /* Helper routine for all error routines.  Reports a diagnostic specified by
    KIND at the explicit location LOC.  The message FORMAT comes from the dmd
    front-end, which does not get translated by the gcc diagnostic routines.  */
@@ -177,9 +229,10 @@ verror (const Loc& loc, const char *format, va_list ap,
 
       /* Build string and emit.  */
       if (prefix2 != NULL)
-	xformat = xasprintf ("%s %s %s", prefix1, prefix2, format);
+	xformat = xasprintf ("%s %s %s", escape_d_format (prefix1),
+			     escape_d_format (prefix2), format);
       else if (prefix1 != NULL)
-	xformat = xasprintf ("%s %s", prefix1, format);
+	xformat = xasprintf ("%s %s", escape_d_format (prefix1), format);
       else
 	xformat = xasprintf ("%s", format);
 
@@ -287,9 +340,10 @@ vdeprecation (const Loc& loc, const char *format, va_list ap,
 
       /* Build string and emit.  */
       if (prefix2 != NULL)
-	xformat = xasprintf ("%s %s %s", prefix1, prefix2, format);
+	xformat = xasprintf ("%s %s %s", escape_d_format (prefix1),
+			     escape_d_format (prefix2), format);
       else if (prefix1 != NULL)
-	xformat = xasprintf ("%s %s", prefix1, format);
+	xformat = xasprintf ("%s %s", escape_d_format (prefix1), format);
       else
 	xformat = xasprintf ("%s", format);
 
diff --git a/gcc/d/d-frontend.cc b/gcc/d/d-frontend.cc
index ec08d62f53e..f8df264e7fe 100644
--- a/gcc/d/d-frontend.cc
+++ b/gcc/d/d-frontend.cc
@@ -614,39 +614,8 @@ eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)
 Type *
 getTypeInfoType (Loc loc, Type *type, Scope *sc)
 {
-  if (!global.params.useTypeInfo)
-    {
-      /* Even when compiling without RTTI we should still be able to evaluate
-	 TypeInfo at compile-time, just not at run-time.  */
-      if (!sc || !(sc->flags & SCOPEctfe))
-	{
-	  static int warned = 0;
-
-	  if (!warned)
-	    {
-	      error_at (make_location_t (loc),
-			"%<object.TypeInfo%> cannot be used with %<-fno-rtti%>");
-	      warned = 1;
-	    }
-	}
-    }
-
-  if (Type::dtypeinfo == NULL
-      || (Type::dtypeinfo->storage_class & STCtemp))
-    {
-      /* If TypeInfo has not been declared, warn about each location once.  */
-      static Loc warnloc;
-
-      if (!loc.equals (warnloc))
-	{
-	  error_at (make_location_t (loc),
-		    "%<object.TypeInfo%> could not be found, "
-		    "but is implicitly used");
-	  warnloc = loc;
-	}
-    }
-
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, sc);
   create_typeinfo (type, sc ? sc->_module->importedFrom : NULL);
   return type->vtinfo->type;
 }
diff --git a/gcc/d/d-lang.cc b/gcc/d/d-lang.cc
index 4f1bf4a6e6a..5850dace181 100644
--- a/gcc/d/d-lang.cc
+++ b/gcc/d/d-lang.cc
@@ -1825,6 +1825,7 @@ d_build_eh_runtime_type (tree type)
 #undef LANG_HOOKS_GET_ALIAS_SET
 #undef LANG_HOOKS_TYPES_COMPATIBLE_P
 #undef LANG_HOOKS_BUILTIN_FUNCTION
+#undef LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE
 #undef LANG_HOOKS_REGISTER_BUILTIN_TYPE
 #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL
 #undef LANG_HOOKS_GIMPLIFY_EXPR
@@ -1855,6 +1856,7 @@ d_build_eh_runtime_type (tree type)
 #define LANG_HOOKS_GET_ALIAS_SET	    d_get_alias_set
 #define LANG_HOOKS_TYPES_COMPATIBLE_P	    d_types_compatible_p
 #define LANG_HOOKS_BUILTIN_FUNCTION	    d_builtin_function
+#define LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE d_builtin_function_ext_scope
 #define LANG_HOOKS_REGISTER_BUILTIN_TYPE    d_register_builtin_type
 #define LANG_HOOKS_FINISH_INCOMPLETE_DECL   d_finish_incomplete_decl
 #define LANG_HOOKS_GIMPLIFY_EXPR	    d_gimplify_expr
diff --git a/gcc/d/d-spec.cc b/gcc/d/d-spec.cc
index f4744763ab6..48a3ddd1211 100644
--- a/gcc/d/d-spec.cc
+++ b/gcc/d/d-spec.cc
@@ -83,6 +83,9 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
   /* "-lstdc++" if it appears on the command line.  */
   const cl_decoded_option *saw_libcxx = 0;
 
+  /* True if we saw `-static-libstdc++'.  */
+  bool saw_static_libcxx = false;
+
   /* Whether we need the C++ STD library.  */
   bool need_stdcxx = false;
 
@@ -248,6 +251,11 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 	  shared_libgcc = false;
 	  break;
 
+	case OPT_static_libstdc__:
+	  saw_static_libcxx = true;
+	  args[i] |= SKIPOPT;
+	  break;
+
 	case OPT_static_libphobos:
 	  if (phobos_library != PHOBOS_NOLINK)
 	    phobos_library = PHOBOS_STATIC;
@@ -452,16 +460,39 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 #endif
     }
 
-  if (saw_libcxx)
-    new_decoded_options[j++] = *saw_libcxx;
-  else if (need_stdcxx)
+  if (saw_libcxx || need_stdcxx)
     {
-      generate_option (OPT_l,
-		       (saw_profile_flag
-			? LIBSTDCXX_PROFILE
-			: LIBSTDCXX),
-		       1, CL_DRIVER, &new_decoded_options[j++]);
-      added_libraries++;
+#ifdef HAVE_LD_STATIC_DYNAMIC
+      if (saw_static_libcxx && !static_link)
+	{
+	  generate_option (OPT_Wl_, LD_STATIC_OPTION, 1, CL_DRIVER,
+			   &new_decoded_options[j++]);
+	}
+#else
+      /* Push the -static-libstdc++ option back onto the command so that
+	 a target without LD_STATIC_DYNAMIC can use outfile substitution.  */
+      if (saw_static_libcxx && !static_link)
+	generate_option (OPT_static_libstdc__, NULL, 1, CL_DRIVER,
+			 &new_decoded_options[j++]);
+#endif
+      if (saw_libcxx)
+	new_decoded_options[j++] = *saw_libcxx;
+      else if (need_stdcxx)
+	{
+	  generate_option (OPT_l,
+			   (saw_profile_flag
+			    ? LIBSTDCXX_PROFILE
+			    : LIBSTDCXX),
+			   1, CL_DRIVER, &new_decoded_options[j++]);
+	  added_libraries++;
+	}
+#ifdef HAVE_LD_STATIC_DYNAMIC
+      if (saw_static_libcxx && !static_link)
+	{
+	  generate_option (OPT_Wl_, LD_DYNAMIC_OPTION, 1, CL_DRIVER,
+			   &new_decoded_options[j++]);
+	}
+#endif
     }
 
   if (shared_libgcc && !static_link)
diff --git a/gcc/d/d-tree.h b/gcc/d/d-tree.h
index 4d039adb0fa..7989033366e 100644
--- a/gcc/d/d-tree.h
+++ b/gcc/d/d-tree.h
@@ -491,6 +491,7 @@ extern const attribute_spec d_langhook_attribute_table[];
 extern const attribute_spec d_langhook_common_attribute_table[];
 
 extern tree d_builtin_function (tree);
+extern tree d_builtin_function_ext_scope (tree);
 extern void d_init_builtins (void);
 extern void d_register_builtin_type (tree, const char *);
 extern void d_build_builtins_module (Module *);
@@ -581,6 +582,7 @@ extern bool decl_with_nonnull_addr_p (const_tree);
 extern tree d_truthvalue_conversion (tree);
 extern tree d_convert (tree, tree);
 extern tree convert_expr (tree, Type *, Type *);
+extern tree convert_for_rvalue (tree, Type *, Type *);
 extern tree convert_for_assignment (tree, Type *, Type *);
 extern tree convert_for_argument (tree, Parameter *);
 extern tree convert_for_condition (tree, Type *);
@@ -655,6 +657,7 @@ extern tree layout_typeinfo (TypeInfoDeclaration *);
 extern tree layout_classinfo (ClassDeclaration *);
 extern tree get_typeinfo_decl (TypeInfoDeclaration *);
 extern tree get_classinfo_decl (ClassDeclaration *);
+extern void check_typeinfo_type (const Loc &, Scope *);
 extern tree build_typeinfo (const Loc &, Type *);
 extern void create_typeinfo (Type *, Module *);
 extern void create_tinfo_types (Module *);
diff --git a/gcc/d/decl.cc b/gcc/d/decl.cc
index f342688ba91..94f941f65a3 100644
--- a/gcc/d/decl.cc
+++ b/gcc/d/decl.cc
@@ -1253,6 +1253,9 @@ get_symbol_decl (Declaration *decl)
 	      DECL_VINDEX (decl->csym) = size_int (fd->vtblIndex);
 	      DECL_VIRTUAL_P (decl->csym) = 1;
 	    }
+
+	  /* Align method to the minimum boundary for target.  */
+	  SET_DECL_ALIGN (decl->csym, MINIMUM_METHOD_BOUNDARY);
 	}
       else if (fd->isMain () || fd->isCMain ())
 	{
@@ -1585,8 +1588,9 @@ d_finish_decl (tree decl)
   if (flag_checking && DECL_INITIAL (decl))
     {
       /* Initializer must never be bigger than symbol size.  */
-      dinteger_t tsize = int_size_in_bytes (TREE_TYPE (decl));
-      dinteger_t dtsize = int_size_in_bytes (TREE_TYPE (DECL_INITIAL (decl)));
+      HOST_WIDE_INT tsize = int_size_in_bytes (TREE_TYPE (decl));
+      HOST_WIDE_INT dtsize =
+	int_size_in_bytes (TREE_TYPE (DECL_INITIAL (decl)));
 
       if (tsize < dtsize)
 	{
diff --git a/gcc/d/dmd/cond.c b/gcc/d/dmd/cond.c
index b021f62c29b..54cd897d2fa 100644
--- a/gcc/d/dmd/cond.c
+++ b/gcc/d/dmd/cond.c
@@ -114,6 +114,7 @@ static void lowerArrayAggregate(StaticForeach *sfe, Scope *sc)
         sfe->aggrfe->aggr = new TupleExp(aggr->loc, es);
         sfe->aggrfe->aggr = semantic(sfe->aggrfe->aggr, sc);
         sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);
+        sfe->aggrfe->aggr = sfe->aggrfe->aggr->ctfeInterpret();
     }
     else
     {
@@ -200,7 +201,8 @@ static TypeStruct *createTupleType(Loc loc, Expressions *e)
     Type *ty = new TypeTypeof(loc, new TupleExp(loc, e));
     sdecl->members->push(new VarDeclaration(loc, ty, fid, NULL));
     TypeStruct *r = (TypeStruct *)sdecl->type;
-    r->vtinfo = TypeInfoStructDeclaration::create(r); // prevent typeinfo from going to object file
+    if (global.params.useTypeInfo && Type::dtypeinfo)
+        r->vtinfo = TypeInfoStructDeclaration::create(r); // prevent typeinfo from going to object file
     return r;
 }
 
@@ -314,15 +316,25 @@ static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)
     Identifier *idres = Identifier::generateId("__res");
     VarDeclaration *vard = new VarDeclaration(aloc, aty, idres, NULL);
     Statements *s2 = new Statements();
-    s2->push(new ExpStatement(aloc, vard));
-    Expression *catass = new CatAssignExp(aloc, new IdentifierExp(aloc, idres), res[1]);
-    s2->push(createForeach(sfe, aloc, pparams[1], new ExpStatement(aloc, catass)));
-    s2->push(new ReturnStatement(aloc, new IdentifierExp(aloc, idres)));
+
+    // Run 'typeof' gagged to avoid duplicate errors and if it fails just create
+    // an empty foreach to expose them.
+    unsigned olderrors = global.startGagging();
+    ety = ety->semantic(aloc, sc);
+    if (global.endGagging(olderrors))
+        s2->push(createForeach(sfe, aloc, pparams[1], NULL));
+    else
+    {
+        s2->push(new ExpStatement(aloc, vard));
+        Expression *catass = new CatAssignExp(aloc, new IdentifierExp(aloc, idres), res[1]);
+        s2->push(createForeach(sfe, aloc, pparams[1], new ExpStatement(aloc, catass)));
+        s2->push(new ReturnStatement(aloc, new IdentifierExp(aloc, idres)));
+    }
 
     Expression *aggr;
     Type *indexty;
 
-    if (sfe->rangefe && (indexty = ety->semantic(aloc, sc))->isintegral())
+    if (sfe->rangefe && (indexty = ety)->isintegral())
     {
         sfe->rangefe->lwr->type = indexty;
         sfe->rangefe->upr->type = indexty;
@@ -386,11 +398,6 @@ void staticForeachPrepare(StaticForeach *sfe, Scope *sc)
         sfe->aggrfe->aggr = semantic(sfe->aggrfe->aggr, sc);
         sc = sc->endCTFE();
         sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);
-        Type *tab = sfe->aggrfe->aggr->type->toBasetype();
-        if (tab->ty != Ttuple)
-        {
-            sfe->aggrfe->aggr = sfe->aggrfe->aggr->ctfeInterpret();
-        }
     }
 
     if (sfe->aggrfe && sfe->aggrfe->aggr->type->toBasetype()->ty == Terror)
diff --git a/gcc/d/dmd/dcast.c b/gcc/d/dmd/dcast.c
index a3df701c341..905aed72625 100644
--- a/gcc/d/dmd/dcast.c
+++ b/gcc/d/dmd/dcast.c
@@ -1494,13 +1494,16 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)
                     // cast(U[])sa; // ==> cast(U[])sa[];
                     d_uns64 fsize = t1b->nextOf()->size();
                     d_uns64 tsize = tob->nextOf()->size();
-                    if ((((TypeSArray *)t1b)->dim->toInteger() * fsize) % tsize != 0)
+                    if (fsize != tsize)
                     {
-                        // copied from sarray_toDarray() in e2ir.c
-                        e->error("cannot cast expression %s of type %s to %s since sizes don't line up",
-                            e->toChars(), e->type->toChars(), t->toChars());
-                        result = new ErrorExp();
-                        return;
+                        dinteger_t dim = ((TypeSArray *)t1b)->dim->toInteger();
+                        if (tsize == 0 || (dim * fsize) % tsize != 0)
+                        {
+                            e->error("cannot cast expression `%s` of type `%s` to `%s` since sizes don't line up",
+                                     e->toChars(), e->type->toChars(), t->toChars());
+                            result = new ErrorExp();
+                            return;
+                        }
                     }
                     goto Lok;
                 }
diff --git a/gcc/d/dmd/dinterpret.c b/gcc/d/dmd/dinterpret.c
index 8a02aa8d31d..214a73cd8bb 100644
--- a/gcc/d/dmd/dinterpret.c
+++ b/gcc/d/dmd/dinterpret.c
@@ -645,7 +645,16 @@ Expression *ctfeInterpret(Expression *e)
     case TOKfloat64:
     case TOKcomplex80:
     case TOKnull:
+    case TOKvoid:
     case TOKstring:
+    case TOKthis:
+    case TOKsuper:
+    case TOKtype:
+    case TOKtypeid:
+    case TOKtemplate:   // non-eponymous template/instance
+    case TOKscope:      // ditto
+    case TOKdottd:      // ditto, e.e1 doesn't matter here
+    case TOKdot:        // ditto
         if (e->type->ty == Terror)
             return new ErrorExp();
         /* fall through */
diff --git a/gcc/d/dmd/expression.c b/gcc/d/dmd/expression.c
index c639fd10aae..25ee68b68a4 100644
--- a/gcc/d/dmd/expression.c
+++ b/gcc/d/dmd/expression.c
@@ -459,11 +459,6 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)
             if (checkUnsafeAccess(sc, e1, true, true))
                 return new ErrorExp();
         }
-        else if (e1->op == TOKdot)
-        {
-            e1->error("expression has no value");
-            return new ErrorExp();
-        }
         else if (e1->op == TOKcall)
         {
             CallExp *ce = (CallExp *)e1;
@@ -2655,8 +2650,11 @@ bool Expression::checkPostblit(Scope *sc, Type *t)
     t = t->baseElemOf();
     if (t->ty == Tstruct)
     {
-        // Bugzilla 11395: Require TypeInfo generation for array concatenation
-        semanticTypeInfo(sc, t);
+        if (global.params.useTypeInfo && Type::dtypeinfo)
+        {
+            // Bugzilla 11395: Require TypeInfo generation for array concatenation
+            semanticTypeInfo(sc, t);
+        }
 
         StructDeclaration *sd = ((TypeStruct *)t)->sym;
         if (sd->postblit)
@@ -5250,6 +5248,18 @@ DotTemplateExp::DotTemplateExp(Loc loc, Expression *e, TemplateDeclaration *td)
     this->td = td;
 }
 
+bool DotTemplateExp::checkType()
+{
+    error("%s %s has no type", td->kind(), toChars());
+    return true;
+}
+
+bool DotTemplateExp::checkValue()
+{
+    error("%s %s has no value", td->kind(), toChars());
+    return true;
+}
+
 /************************************************************/
 
 DotVarExp::DotVarExp(Loc loc, Expression *e, Declaration *var, bool hasOverloads)
@@ -6729,7 +6739,7 @@ Expression *FuncInitExp::resolveLoc(Loc loc, Scope *sc)
         s = "";
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = semantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
@@ -6763,7 +6773,7 @@ Expression *PrettyFuncInitExp::resolveLoc(Loc loc, Scope *sc)
 
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = semantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
diff --git a/gcc/d/dmd/expression.h b/gcc/d/dmd/expression.h
index 60448600e24..20ab7848e6b 100644
--- a/gcc/d/dmd/expression.h
+++ b/gcc/d/dmd/expression.h
@@ -807,6 +807,8 @@ public:
     TemplateDeclaration *td;
 
     DotTemplateExp(Loc loc, Expression *e, TemplateDeclaration *td);
+    bool checkType();
+    bool checkValue();
     void accept(Visitor *v) { v->visit(this); }
 };
 
diff --git a/gcc/d/dmd/expressionsem.c b/gcc/d/dmd/expressionsem.c
index 5ec4683848e..5096754e55f 100644
--- a/gcc/d/dmd/expressionsem.c
+++ b/gcc/d/dmd/expressionsem.c
@@ -2506,11 +2506,18 @@ public:
 
     void visit(DotTemplateExp *e)
     {
+        if (e->type)
+        {
+            result = e;
+            return;
+        }
         if (Expression *ex = unaSemantic(e, sc))
         {
             result = ex;
             return;
         }
+        // 'void' like TemplateExp
+        e->type = Type::tvoid;
         result = e;
     }
 
diff --git a/gcc/d/dmd/mtype.c b/gcc/d/dmd/mtype.c
index c11772a7740..0ec577d0c1e 100644
--- a/gcc/d/dmd/mtype.c
+++ b/gcc/d/dmd/mtype.c
@@ -2060,7 +2060,10 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)
     }
     else if (ident == Id::__xalignof)
     {
-        e = new IntegerExp(loc, alignsize(), Type::tsize_t);
+        unsigned explicitAlignment = alignment();
+        unsigned naturalAlignment = alignsize();
+        unsigned actualAlignment = (explicitAlignment == STRUCTALIGN_DEFAULT ? naturalAlignment : explicitAlignment);
+        e = new IntegerExp(loc, actualAlignment, Type::tsize_t);
     }
     else if (ident == Id::_init)
     {
diff --git a/gcc/d/dmd/statementsem.c b/gcc/d/dmd/statementsem.c
index 26e5950518a..765e9c3b8c9 100644
--- a/gcc/d/dmd/statementsem.c
+++ b/gcc/d/dmd/statementsem.c
@@ -568,9 +568,6 @@ public:
             else
             {
                 e = resolveProperties(sc, e);
-                type = e->type;
-                if (paramtype)
-                    type = paramtype;
                 Initializer *ie = new ExpInitializer(Loc(), e);
                 VarDeclaration *v = new VarDeclaration(loc, type, ident, ie);
                 if (storageClass & STCref)
@@ -651,22 +648,23 @@ public:
                 }
             }
             p->type = p->type->semantic(loc, sc);
-            TY keyty = p->type->ty;
-            if (keyty != Tint32 && keyty != Tuns32)
+
+            if (!p->type->isintegral())
             {
-                if (global.params.isLP64)
-                {
-                    if (keyty != Tint64 && keyty != Tuns64)
-                    {
-                        fs->error("foreach: key type must be int or uint, long or ulong, not %s", p->type->toChars());
-                        return false;
-                    }
-                }
-                else
-                {
-                    fs->error("foreach: key type must be int or uint, not %s", p->type->toChars());
-                    return false;
-                }
+                fs->error("foreach: key cannot be of non-integral type `%s`",
+                          p->type->toChars());
+                return false;
+            }
+
+            unsigned length = te ? te->exps->dim : tuple->arguments->dim;
+            IntRange dimrange = IntRange(SignExtendedNumber(length)).cast(Type::tsize_t);
+            // https://issues.dlang.org/show_bug.cgi?id=12504
+            dimrange.imax = SignExtendedNumber(dimrange.imax.value-1);
+            if (!IntRange::fromType(p->type).contains(dimrange))
+            {
+                fs->error("index type `%s` cannot cover index range 0..%llu",
+			  p->type->toChars(), (ulonglong)length);
+                return false;
             }
             Initializer *ie = new ExpInitializer(Loc(), new IntegerExp(k));
             VarDeclaration *var = new VarDeclaration(loc, p->type, p->ident, ie);
@@ -1079,6 +1077,8 @@ public:
                             {
                                 TypeSArray *ta =  (TypeSArray *)tab;
                                 IntRange dimrange = getIntRange(ta->dim);
+                                // https://issues.dlang.org/show_bug.cgi?id=12504
+                                dimrange.imax = SignExtendedNumber(dimrange.imax.value-1);
                                 if (!IntRange::fromType(var->type).contains(dimrange))
                                 {
                                     fs->error("index type '%s' cannot cover index range 0..%llu", p->type->toChars(), ta->dim->toInteger());
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index ad2255e1cd1..a579356104e 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -162,7 +162,7 @@ class ExprVisitor : public Visitor
 	    eptype = type;
 	  }
 
-	ret = fold_build2 (code, eptype, arg0, arg1);
+	ret = build2 (code, eptype, arg0, arg1);
       }
 
     return d_convert (type, ret);
@@ -1468,7 +1468,7 @@ public:
     if (tbtype->ty == Tvoid)
       this->result_ = build_nop (build_ctype (tbtype), result);
     else
-      this->result_ = convert_expr (result, ebtype, tbtype);
+      this->result_ = convert_for_rvalue (result, ebtype, tbtype);
   }
 
   /* Build a delete expression.  */
@@ -1870,15 +1870,10 @@ public:
       exp = d_convert (build_ctype (e->type), exp);
 
     /* If this call was found to be a constructor for a temporary with a
-       cleanup, then move the call inside the TARGET_EXPR.  The original
-       initializer is turned into an assignment, to keep its side effect.  */
+       cleanup, then move the call inside the TARGET_EXPR.  */
     if (cleanup != NULL_TREE)
       {
 	tree init = TARGET_EXPR_INITIAL (cleanup);
-	tree slot = TARGET_EXPR_SLOT (cleanup);
-	d_mark_addressable (slot);
-	init = build_assign (INIT_EXPR, slot, init);
-
 	TARGET_EXPR_INITIAL (cleanup) = compound_expr (init, exp);
 	exp = cleanup;
       }
@@ -3144,11 +3139,14 @@ build_return_dtor (Expression *e, Type *type, TypeFunction *tf)
   tree result = build_expr (e);
 
   /* Convert for initializing the DECL_RESULT.  */
-  result = convert_expr (result, e->type, type);
-
-  /* If we are returning a reference, take the address.  */
   if (tf->isref)
-    result = build_address (result);
+    {
+      /* If we are returning a reference, take the address.  */
+      result = convert_expr (result, e->type, type);
+      result = build_address (result);
+    }
+  else
+    result = convert_for_rvalue (result, e->type, type);
 
   /* The decl to store the return expression.  */
   tree decl = DECL_RESULT (cfun->decl);
diff --git a/gcc/d/typeinfo.cc b/gcc/d/typeinfo.cc
index 6aa4f64a713..973729d3d8a 100644
--- a/gcc/d/typeinfo.cc
+++ b/gcc/d/typeinfo.cc
@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dmd/identifier.h"
 #include "dmd/module.h"
 #include "dmd/mtype.h"
+#include "dmd/scope.h"
 #include "dmd/template.h"
 #include "dmd/target.h"
 
@@ -244,8 +245,8 @@ create_tinfo_types (Module *mod)
 static void
 create_frontend_tinfo_types (void)
 {
-  /* If there's no Object class defined, then neither can TypeInfo be.  */
-  if (object_module == NULL || ClassDeclaration::object == NULL)
+  /* If there's no object module, then neither can there be TypeInfo.  */
+  if (object_module == NULL)
     return;
 
   /* Create all frontend TypeInfo classes declarations.  We rely on all
@@ -1370,16 +1371,19 @@ get_classinfo_decl (ClassDeclaration *decl)
   return decl->csym;
 }
 
-/* Returns typeinfo reference for TYPE.  */
+/* Performs sanity checks on the `object.TypeInfo' type, raising an error if
+   RTTI is disabled, or the type is missing.  */
 
-tree
-build_typeinfo (const Loc &loc, Type *type)
+void
+check_typeinfo_type (const Loc &loc, Scope *sc)
 {
   if (!global.params.useTypeInfo)
     {
       static int warned = 0;
 
-      if (!warned)
+      /* Even when compiling without RTTI we should still be able to evaluate
+	 TypeInfo at compile-time, just not at run-time.  */
+      if (!warned && (!sc || !(sc->flags & SCOPEctfe)))
 	{
 	  error_at (make_location_t (loc),
 		    "%<object.TypeInfo%> cannot be used with %<-fno-rtti%>");
@@ -1387,7 +1391,29 @@ build_typeinfo (const Loc &loc, Type *type)
 	}
     }
 
+  if (Type::dtypeinfo == NULL
+      || (Type::dtypeinfo->storage_class & STCtemp))
+    {
+      /* If TypeInfo has not been declared, warn about each location once.  */
+      static Loc warnloc;
+
+      if (!warnloc.equals (loc))
+	{
+	  error_at (make_location_t (loc),
+		    "%<object.TypeInfo%> could not be found, "
+		    "but is implicitly used");
+	  warnloc = loc;
+	}
+    }
+}
+
+/* Returns typeinfo reference for TYPE.  */
+
+tree
+build_typeinfo (const Loc &loc, Type *type)
+{
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, NULL);
   create_typeinfo (type, NULL);
   return build_address (get_typeinfo_decl (type->vtinfo));
 }
diff --git a/gcc/doc/cpp.texi b/gcc/doc/cpp.texi
index 33f876ab706..b24b5f4444e 100644
--- a/gcc/doc/cpp.texi
+++ b/gcc/doc/cpp.texi
@@ -2311,11 +2311,13 @@ mechanism based on @code{setjmp} and @code{longjmp} for exception
 handling.
 
 @item __GXX_EXPERIMENTAL_CXX0X__
-This macro is defined when compiling a C++ source file with the option
-@option{-std=c++0x} or @option{-std=gnu++0x}. It indicates that some
-features likely to be included in C++0x are available. Note that these
-features are experimental, and may change or be removed in future
-versions of GCC.
+This macro is defined when compiling a C++ source file with C++11 features
+enabled, i.e., for all C++ language dialects except @option{-std=c++98}
+and @option{-std=gnu++98}. This macro is obsolete, but can be used to
+detect experimental C++0x features in very old versions of GCC. Since
+GCC 4.7.0 the @code{__cplusplus} macro is defined correctly, so most
+code should test @code{__cplusplus >= 201103L} instead of using this
+macro.
 
 @item __GXX_WEAK__
 This macro is defined when compiling a C++ source file.  It has the
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 9c734595950..8184f59e820 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -3228,15 +3228,18 @@ calls.
 This tells the compiler that a function is @code{malloc}-like, i.e.,
 that the pointer @var{P} returned by the function cannot alias any
 other pointer valid when the function returns, and moreover no
-pointers to valid objects occur in any storage addressed by @var{P}.
-
-Using this attribute can improve optimization.  Compiler predicts
-that a function with the attribute returns non-null in most cases.
-Functions like
-@code{malloc} and @code{calloc} have this property because they return
-a pointer to uninitialized or zeroed-out storage.  However, functions
-like @code{realloc} do not have this property, as they can return a
-pointer to storage containing pointers.
+pointers to valid objects occur in any storage addressed by @var{P}. In
+addition, GCC predicts that a function with the attribute returns
+non-null in most cases.
+
+Using the attribute is designed to improve optimization
+by relying on the aliasing property it implies.  Functions like @code{malloc}
+and @code{calloc} have this property because they return a pointer to
+uninitialized or zeroed-out, newly obtained storage.  However, functions
+like @code{realloc} do not have this property, as they may return pointers
+to storage containing pointers to existing objects.  Additionally, since
+all such functions are assumed to return null only infrequently, callers
+can be optimized based on that assumption.
 
 @item no_icf
 @cindex @code{no_icf} function attribute
@@ -20953,14 +20956,17 @@ void __builtin_mma_xxmtacc (__vector_quad *);
 void __builtin_mma_xxmfacc (__vector_quad *);
 void __builtin_mma_xxsetaccz (__vector_quad *);
 
-void __builtin_mma_assemble_acc (__vector_quad *, vec_t, vec_t, vec_t, vec_t);
+void __builtin_mma_build_acc (__vector_quad *, vec_t, vec_t, vec_t, vec_t);
 void __builtin_mma_disassemble_acc (void *, __vector_quad *);
 
-void __builtin_vsx_assemble_pair (__vector_pair *, vec_t, vec_t);
+void __builtin_vsx_build_pair (__vector_pair *, vec_t, vec_t);
 void __builtin_vsx_disassemble_pair (void *, __vector_pair *);
 
 vec_t __builtin_vsx_xvcvspbf16 (vec_t);
 vec_t __builtin_vsx_xvcvbf16spn (vec_t);
+
+__vector_pair __builtin_vsx_lxvp (size_t, __vector_pair *);
+void __builtin_vsx_stxvp (__vector_pair, size_t, __vector_pair *);
 @end smallexample
 
 @node RISC-V Built-in Functions
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index eabeec944e7..81e14773f42 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -770,6 +770,7 @@ Objective-C and Objective-C++ Dialects}.
 -mverbose-cost-dump @gol
 -mpure-code @gol
 -mcmse @gol
+-mfix-cmse-cve-2021-35465 @gol
 -mfdpic}
 
 @emph{AVR Options}
@@ -13599,7 +13600,8 @@ The option cannot be combined with @option{-fsanitize=thread}.
 @opindex fsanitize=undefined
 Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector.
 Various computations are instrumented to detect undefined behavior
-at runtime.  Current suboptions are:
+at runtime.  See @uref{https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html} for more details.   The run-time behavior can be influenced using the
+@env{UBSAN_OPTIONS} environment variable.  Current suboptions are:
 
 @table @gcctabopt
 
@@ -13884,7 +13886,8 @@ which functions and calls should be skipped from instrumentation
 (@pxref{Function Attributes}).
 
 Currently the x86 GNU/Linux target provides an implementation based
-on Intel Control-flow Enforcement Technology (CET).
+on Intel Control-flow Enforcement Technology (CET) which works for
+i686 processor or newer.
 
 @item -fstack-protector
 @opindex fstack-protector
@@ -16994,8 +16997,9 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
 @samp{cortex-a76}, @samp{cortex-a76ae}, @samp{cortex-a77},
 @samp{cortex-a65}, @samp{cortex-a65ae}, @samp{cortex-a34},
-@samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor}, @samp{neoverse-e1},
-@samp{neoverse-n1}, @samp{neoverse-n2}, @samp{neoverse-v1}, @samp{qdf24xx},
+@samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
+@samp{neoverse-e1}, @samp{neoverse-n1}, @samp{neoverse-n2},
+@samp{neoverse-v1}, @samp{neoverse-512tvb}, @samp{qdf24xx},
 @samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan}, @samp{octeontx},
 @samp{octeontx81},  @samp{octeontx83},
 @samp{octeontx2}, @samp{octeontx2t98}, @samp{octeontx2t96}
@@ -17015,6 +17019,15 @@ The values @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
 @samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55} specify that GCC
 should tune for a big.LITTLE system.
 
+The value @samp{neoverse-512tvb} specifies that GCC should tune
+for Neoverse cores that (a) implement SVE and (b) have a total vector
+bandwidth of 512 bits per cycle.  In other words, the option tells GCC to
+tune for Neoverse cores that can execute 4 128-bit Advanced SIMD arithmetic
+instructions a cycle and that can execute an equivalent number of SVE
+arithmetic instructions per cycle (2 for 256-bit SVE, 4 for 128-bit SVE).
+This is more general than tuning for a specific core like Neoverse V1
+but is more specific than the default tuning described below.
+
 Additionally on native AArch64 GNU/Linux systems the value
 @samp{native} tunes performance to the host system.  This option has no effect
 if the compiler is unable to recognize the processor of the host system.
@@ -17044,6 +17057,16 @@ by @option{-mtune}).  Where this option is used in conjunction
 with @option{-march} or @option{-mtune}, those options take precedence
 over the appropriate part of this option.
 
+@option{-mcpu=neoverse-512tvb} is special in that it does not refer
+to a specific core, but instead refers to all Neoverse cores that
+(a) implement SVE and (b) have a total vector bandwidth of 512 bits
+a cycle.  Unless overridden by @option{-march},
+@option{-mcpu=neoverse-512tvb} generates code that can run on a
+Neoverse V1 core, since Neoverse V1 is the first Neoverse core with
+these properties.  Unless overridden by @option{-mtune},
+@option{-mcpu=neoverse-512tvb} tunes code in the same way as for
+@option{-mtune=neoverse-512tvb}.
+
 @item -moverride=@var{string}
 @opindex moverride
 Override tuning decisions made by the back-end in response to a
@@ -19236,6 +19259,14 @@ Generate secure code as per the "ARMv8-M Security Extensions: Requirements on
 Development Tools Engineering Specification", which can be found on
 @url{https://developer.arm.com/documentation/ecm0359818/latest/}.
 
+@item -mfix-cmse-cve-2021-35465
+@opindex mfix-cmse-cve-2021-35465
+Mitigate against a potential security issue with the @code{VLLDM} instruction
+in some M-profile devices when using CMSE (CVE-2021-365465).  This option is
+enabled by default when the option @option{-mcpu=} is used with
+@code{cortex-m33}, @code{cortex-m35p} or @code{cortex-m55}.  The option
+@option{-mno-fix-cmse-cve-2021-35465} can be used to disable the mitigation.
+
 @item -mfdpic
 @itemx -mno-fdpic
 @opindex mfdpic
@@ -25640,7 +25671,7 @@ Supported values for @var{cpu_type} are @samp{401}, @samp{403},
 @samp{e6500}, @samp{ec603e}, @samp{G3}, @samp{G4}, @samp{G5},
 @samp{titan}, @samp{power3}, @samp{power4}, @samp{power5}, @samp{power5+},
 @samp{power6}, @samp{power6x}, @samp{power7}, @samp{power8},
-@samp{power9}, @samp{future}, @samp{powerpc}, @samp{powerpc64},
+@samp{power9}, @samp{power10}, @samp{powerpc}, @samp{powerpc64},
 @samp{powerpc64le}, @samp{rs64}, and @samp{native}.
 
 @option{-mcpu=powerpc}, @option{-mcpu=powerpc64}, and
@@ -25821,10 +25852,9 @@ Enable/disable the @var{__float128} keyword for IEEE 128-bit floating point
 and use either software emulation for IEEE 128-bit floating point or
 hardware instructions.
 
-The VSX instruction set (@option{-mvsx}, @option{-mcpu=power7},
-@option{-mcpu=power8}), or @option{-mcpu=power9} must be enabled to
-use the IEEE 128-bit floating point support.  The IEEE 128-bit
-floating point support only works on PowerPC Linux systems.
+The VSX instruction set (@option{-mvsx}) must be enabled to use the IEEE
+128-bit floating point support.  The IEEE 128-bit floating point is only
+supported on Linux.
 
 The default for @option{-mfloat128} is enabled on PowerPC Linux
 systems using the VSX instruction set, and disabled on other systems.
@@ -26654,24 +26684,25 @@ the offset with a symbol reference to a canary in the TLS block.
 @itemx -mno-pcrel
 @opindex mpcrel
 @opindex mno-pcrel
-Generate (do not generate) pc-relative addressing when the option
-@option{-mcpu=future} is used.  The @option{-mpcrel} option requires
-that the medium code model (@option{-mcmodel=medium}) and prefixed
-addressing (@option{-mprefixed}) options are enabled.
+Generate (do not generate) pc-relative addressing.  The @option{-mpcrel}
+option requires that the medium code model (@option{-mcmodel=medium})
+and prefixed addressing (@option{-mprefixed}) options are enabled.
 
 @item -mprefixed
 @itemx -mno-prefixed
 @opindex mprefixed
 @opindex mno-prefixed
 Generate (do not generate) addressing modes using prefixed load and
-store instructions when the option @option{-mcpu=future} is used.
+store instructions.  The @option{-mprefixed} option requires that
+the option @option{-mcpu=power10} (or later) is enabled.
 
 @item -mmma
 @itemx -mno-mma
 @opindex mmma
 @opindex mno-mma
-Generate (do not generate) the MMA instructions when the option
-@option{-mcpu=future} is used.
+Generate (do not generate) the MMA instructions.  The @option{-mma}
+option requires that the option @option{-mcpu=power10} (or later)
+is enabled.
 @end table
 
 @node RX Options
@@ -27817,10 +27848,11 @@ so @option{-mno-lra} needs to be passed to get old Reload.
 Set the instruction set, register set, and instruction scheduling parameters
 for machine type @var{cpu_type}.  Supported values for @var{cpu_type} are
 @samp{v7}, @samp{cypress}, @samp{v8}, @samp{supersparc}, @samp{hypersparc},
-@samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{sparclite}, @samp{f930},
-@samp{f934}, @samp{sparclite86x}, @samp{sparclet}, @samp{tsc701}, @samp{v9},
-@samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2},
-@samp{niagara3}, @samp{niagara4}, @samp{niagara7} and @samp{m8}.
+@samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{leon5}, @samp{sparclite},
+@samp{f930}, @samp{f934}, @samp{sparclite86x}, @samp{sparclet}, @samp{tsc701},
+@samp{v9}, @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara},
+@samp{niagara2}, @samp{niagara3}, @samp{niagara4}, @samp{niagara7} and
+@samp{m8}.
 
 Native Solaris and GNU/Linux toolchains also support the value @samp{native},
 which selects the best architecture option for the host processor.
@@ -27839,7 +27871,7 @@ implementations.
 cypress, leon3v7
 
 @item v8
-supersparc, hypersparc, leon, leon3
+supersparc, hypersparc, leon, leon3, leon5
 
 @item sparclite
 f930, f934, sparclite86x
@@ -27906,7 +27938,7 @@ The same values for @option{-mcpu=@var{cpu_type}} can be used for
 @option{-mtune=@var{cpu_type}}, but the only useful values are those
 that select a particular CPU implementation.  Those are
 @samp{cypress}, @samp{supersparc}, @samp{hypersparc}, @samp{leon},
-@samp{leon3}, @samp{leon3v7}, @samp{f930}, @samp{f934},
+@samp{leon3}, @samp{leon3v7}, @samp{leon5}, @samp{f930}, @samp{f934},
 @samp{sparclite86x}, @samp{tsc701}, @samp{ultrasparc},
 @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3},
 @samp{niagara4}, @samp{niagara7} and @samp{m8}.  With native Solaris
@@ -30812,8 +30844,7 @@ Substitute the contents of spec string @var{name} at this point.
 Accumulate an option for @samp{%X}.
 
 @item %X
-Output the accumulated linker options specified by @option{-Wl} or a @samp{%x}
-spec string.
+Output the accumulated linker options specified by a @samp{%x} spec string.
 
 @item %Y
 Output the accumulated assembler options specified by @option{-Wa}.
diff --git a/gcc/doc/trouble.texi b/gcc/doc/trouble.texi
index 419a24b5b18..cf80cbda809 100644
--- a/gcc/doc/trouble.texi
+++ b/gcc/doc/trouble.texi
@@ -865,10 +865,11 @@ objects behave unspecified when being assigned.  For example:
 @smallexample
 struct Base@{
   char *name;
-  Base(char *n) : name(strdup(n))@{@}
+  Base(const char *n) : name(strdup(n))@{@}
   Base& operator= (const Base& other)@{
    free (name);
    name = strdup (other.name);
+   return *this;
   @}
 @};
 
@@ -901,8 +902,8 @@ inside @samp{func} in the example).
 G++ implements the ``intuitive'' algorithm for copy-assignment: assign all
 direct bases, then assign all members.  In that algorithm, the virtual
 base subobject can be encountered more than once.  In the example, copying
-proceeds in the following order: @samp{val}, @samp{name} (via
-@code{strdup}), @samp{bval}, and @samp{name} again.
+proceeds in the following order: @samp{name} (via @code{strdup}),
+@samp{val}, @samp{name} again, and @samp{bval}.
 
 If application code relies on copy-assignment, a user-defined
 copy-assignment operator removes any uncertainties.  With such an
diff --git a/gcc/dse.c b/gcc/dse.c
index c8dcf46ed29..ec6f7b63449 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -1950,8 +1950,7 @@ get_stored_val (store_info *store_info, machine_mode read_mode,
 
 static bool
 replace_read (store_info *store_info, insn_info_t store_insn,
-	      read_info_t read_info, insn_info_t read_insn, rtx *loc,
-	      bitmap regs_live)
+	      read_info_t read_info, insn_info_t read_insn, rtx *loc)
 {
   machine_mode store_mode = GET_MODE (store_info->mem);
   machine_mode read_mode = GET_MODE (read_info->mem);
@@ -2020,7 +2019,8 @@ replace_read (store_info *store_info, insn_info_t store_insn,
 	  note_stores (this_insn, look_for_hardregs, regs_set);
 	}
 
-      bitmap_and_into (regs_set, regs_live);
+      if (store_insn->fixed_regs_live)
+	bitmap_and_into (regs_set, store_insn->fixed_regs_live);
       if (!bitmap_empty_p (regs_set))
 	{
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -2199,6 +2199,11 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)
     }
   if (maybe_ne (offset, 0))
     mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);
+  /* Avoid passing VALUE RTXen as mem_addr to canon_true_dependence
+     which will over and over re-create proper RTL and re-apply the
+     offset above.  See PR80960 where we almost allocate 1.6GB of PLUS
+     RTXen that way.  */
+  mem_addr = get_addr (mem_addr);
 
   if (group_id >= 0)
     {
@@ -2261,7 +2266,7 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)
 						 offset - store_info->offset,
 						 width)
 		      && replace_read (store_info, i_ptr, read_info,
-				       insn_info, loc, bb_info->regs_live))
+				       insn_info, loc))
 		    return;
 
 		  /* The bases are the same, just see if the offsets
@@ -2327,8 +2332,7 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)
 				   store_info->width)
 	      && all_positions_needed_p (store_info,
 					 offset - store_info->offset, width)
-	      && replace_read (store_info, i_ptr,  read_info, insn_info, loc,
-			       bb_info->regs_live))
+	      && replace_read (store_info, i_ptr,  read_info, insn_info, loc))
 	    return;
 
 	  remove = canon_true_dependence (store_info->mem,
diff --git a/gcc/early-remat.c b/gcc/early-remat.c
index 9f5f8541644..2a3265e559d 100644
--- a/gcc/early-remat.c
+++ b/gcc/early-remat.c
@@ -1059,7 +1059,7 @@ early_remat::sort_candidates (void)
 
   m_candidates.qsort (compare_candidates);
 
-  delete postorder_index;
+  delete[] postorder_index;
 }
 
 /* Commit to the current candidate indices and initialize cross-references.  */
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 972512e8115..9dbde16989e 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -5936,6 +5936,7 @@ bool
 valid_for_const_vector_p (machine_mode, rtx x)
 {
   return (CONST_SCALAR_INT_P (x)
+	  || CONST_POLY_INT_P (x)
 	  || CONST_DOUBLE_AS_FLOAT_P (x)
 	  || CONST_FIXED_P (x));
 }
diff --git a/gcc/explow.c b/gcc/explow.c
index b838f035870..21ac074ad55 100644
--- a/gcc/explow.c
+++ b/gcc/explow.c
@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "recog.h"
 #include "diagnostic-core.h"
 #include "stor-layout.h"
+#include "langhooks.h"
 #include "except.h"
 #include "dojump.h"
 #include "explow.h"
@@ -1614,8 +1615,14 @@ set_stack_check_libfunc (const char *libfunc_name)
 {
   gcc_assert (stack_check_libfunc == NULL_RTX);
   stack_check_libfunc = gen_rtx_SYMBOL_REF (Pmode, libfunc_name);
+  tree ptype
+    = Pmode == ptr_mode
+      ? ptr_type_node
+      : lang_hooks.types.type_for_mode (Pmode, 1);
+  tree ftype
+    = build_function_type_list (void_type_node, ptype, NULL_TREE);
   tree decl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL,
-			  get_identifier (libfunc_name), void_type_node);
+			  get_identifier (libfunc_name), ftype);
   DECL_EXTERNAL (decl) = 1;
   SET_SYMBOL_REF_DECL (stack_check_libfunc, decl);
 }
diff --git a/gcc/expr.c b/gcc/expr.c
index 991b26f3341..c4bffd0f199 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -8050,7 +8050,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, scalar_int_mode tmode,
 	 array with address of COMPOUND_LITERAL_EXPR in DECL_INITIAL;
 	 the initializers aren't gimplified.  */
       if (COMPOUND_LITERAL_EXPR_DECL (exp)
-	  && TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (exp)))
+	  && is_global_var (COMPOUND_LITERAL_EXPR_DECL (exp)))
 	return expand_expr_addr_expr_1 (COMPOUND_LITERAL_EXPR_DECL (exp),
 					target, tmode, modifier, as);
       /* FALLTHRU */
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 6e635382fb4..7b4c9c0eb7f 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -511,7 +511,7 @@ negate_expr_p (tree t)
       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)
 	{
 	  tree op1 = TREE_OPERAND (t, 1);
-	  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)
+	  if (wi::to_wide (op1) == element_precision (type) - 1)
 	    return true;
 	}
       break;
@@ -704,7 +704,7 @@ fold_negate_expr_1 (location_t loc, tree t)
       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)
 	{
 	  tree op1 = TREE_OPERAND (t, 1);
-	  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)
+	  if (wi::to_wide (op1) == element_precision (type) - 1)
 	    {
 	      tree ntype = TYPE_UNSIGNED (type)
 			   ? signed_type_for (type)
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index aa5932be872..033dec69c07 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,597 @@
+2022-01-07  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-05-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100551
+	* trans-expr.c (gfc_conv_procedure_call): Adjust check for
+	implicit conversion of actual argument to an unlimited polymorphic
+	procedure argument.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103418
+	* check.c (variable_check): Replace previous check of procedure
+	dummy arguments with INTENT(IN) attribute when passed to intrinsic
+	procedures by gfc_check_vardef_context.
+	* expr.c (gfc_check_vardef_context): Correct check of INTENT(IN)
+	dummy arguments for the case of sub-components of a CLASS pointer.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103778
+	* check.c (is_c_interoperable): A BOZ literal constant is not
+	interoperable.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-18  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/101329
+	* check.c (is_c_interoperable): Reject NULL() as it is not
+	interoperable.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103588
+	* array.c (gfc_ref_dimen_size): Do not generate internal error on
+	failed simplification of stride expression; just return failure.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-03  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103505
+	* array.c (match_array_element_spec): Try to simplify array
+	element specifications to improve early checking.
+	* expr.c (gfc_try_simplify_expr): New.  Try simplification of an
+	expression via gfc_simplify_expr.  When an error occurs, roll
+	back.
+	* gfortran.h (gfc_try_simplify_expr): Declare it.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103412
+	* check.c (gfc_check_sizeof): Reject BOZ type argument.
+
+2021-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103610
+	* array.c (spec_dimen_size): Fix simplification of SHAPE:
+	dimensions must be non-negative.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103606
+	* resolve.c (resolve_fl_procedure): Do not access CLASS components
+	before class container has been built.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103717
+	* frontend-passes.c (doloop_code): Prevent NULL pointer
+	dereference when checking for passing a do-loop variable to a
+	contained procedure with an interface mismatch.
+
+2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-30  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102787
+	* array.c (expand_constructor): When encountering a constant array
+	expression or array section within a constructor, simplify it to
+	enable better expansion.
+
+2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102717
+	* simplify.c (gfc_simplify_reshape): Replace assert by error
+	message for negative elements in SHAPE array.
+
+2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103411
+	* check.c (gfc_check_reshape): Improve check of size of source
+	array for the RESHAPE intrinsic against the given shape when pad
+	is not given, and shape is a parameter.  Try other simplifications
+	of shape.
+
+2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103607
+	* frontend-passes.c (do_subscript): Ensure that array bounds are
+	of type INTEGER before performing checks on array subscripts.
+
+2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103392
+	* simplify.c (simplify_bound): Do not try to simplify
+	LBOUND/UBOUND for arrays with POINTER or ALLOCATABLE attribute.
+
+2021-11-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-21  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/99061
+	* trans-intrinsic.c (gfc_lookup_intrinsic): Helper function for
+	looking up gfortran builtin intrinsics.
+	(gfc_conv_intrinsic_atrigd): Use it.
+	(gfc_conv_intrinsic_cotan): Likewise.
+	(gfc_conv_intrinsic_cotand): Likewise.
+	(gfc_conv_intrinsic_atan2d): Likewise.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-10  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103137
+	PR fortran/103138
+	* check.c (gfc_check_shape): Avoid NULL pointer dereference on
+	missing ref.
+	* simplify.c (gfc_simplify_cshift): Avoid NULL pointer dereference
+	when shape not set.
+	(gfc_simplify_transpose): Likewise.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102816
+	* resolve.c (resolve_structure_cons): Reject invalid array spec of
+	a DT component referenced in a structure constructor.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-15  Harald Anlauf  <anlauf@gmx.de>
+		    Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/102685
+	* decl.c (match_clist_expr): Set rank/shape of clist initializer
+	to match LHS.
+	* resolve.c (resolve_structure_cons): In a structure constructor,
+	compare shapes of array components against declared shape.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-06  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102715
+	* decl.c (add_init_expr_to_sym): Reject rank mismatch between
+	array and its initializer.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102817
+	* expr.c (simplify_parameter_variable): Copy shape of referenced
+	subobject when simplifying.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-10  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99348
+	PR fortran/102521
+	* decl.c (add_init_expr_to_sym): Extend initialization of
+	parameter arrays from scalars to handle derived types.
+
+2021-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102716
+	* check.c (gfc_check_shape): Reorder checks so that invalid KIND
+	arguments can be detected.
+
+2021-10-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102458
+	* simplify.c (simplify_size): Resolve expressions used in array
+	specifications so that SIZE can be simplified.
+
+2021-10-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102458
+	* expr.c (is_non_constant_intrinsic): Check for intrinsics
+	excluded in constant expressions (F2018:10.1.12).
+	(gfc_is_constant_expr): Use that check.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82314
+	* decl.c (add_init_expr_to_sym): For proper initialization of
+	array-valued named constants the array bounds need to be
+	simplified before adding the initializer.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102520
+	* array.c (expand_constructor): Do not dereference NULL pointer.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85130
+	* expr.c (find_substring_ref): Handle given substring start and
+	end indices as signed integers, not unsigned.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102287
+	* trans-expr.c (gfc_conv_procedure_call): Wrap deallocation of
+	allocatable components of optional allocatable derived type
+	procedure arguments with INTENT(OUT) into a presence check.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102366
+	* trans-decl.c (gfc_finish_var_decl): Disable the warning message
+	for variables moved from stack to static storange if they are
+	declared in the main, but allow the move to happen.
+
+2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101327
+	* expr.c (find_array_element): When bounds cannot be determined as
+	constant, return error instead of aborting.
+
+2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98490
+	* trans-expr.c (gfc_conv_substring): Do not generate substring
+	bounds check for implied do loop index variable before it actually
+	becomes defined.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97612
+	* primary.c (build_actual_constructor): Missing allocatable
+	components are set unallocated using EXPR_NULL. Then missing
+	components are tested for a default initializer.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98565
+	* trans-intrinsic.c (gfc_conv_associated): Do not add a _data
+	component for scalar class function targets. Instead, fix the
+	function result and access the _data from that.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97694
+	PR fortran/97723
+	* check.c (allocatable_check): Select rank temporaries are
+	permitted even though they are treated as associate variables.
+	* resolve.c (gfc_resolve_code): Break on select rank as well as
+	select type so that the block os resolved.
+	* trans-stmt.c (trans_associate_var): Class associate variables
+	that are optional dummies must use the backend_decl.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93701
+	* resolve.c (find_array_spec): Put static prototype for
+	resolve_assoc_var before this function and call for associate
+	variables.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98472
+	* trans-array.c (gfc_conv_expr_descriptor): Include elemental
+	procedure pointers in the assert under the comment 'elemental
+	function' and eliminate the second, spurious assert.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/100110
+	* trans-decl.c (gfc_get_symbol_decl): Replace test for host
+	association with a check that the current and symbol namespaces
+	are the same.
+
+2021-08-30  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-05-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/46691
+	PR fortran/99819
+	* class.c (gfc_build_class_symbol): Remove the error that
+	disables assumed size class arrays. Class array types that are
+	not deferred shape or assumed rank are given a unique name and
+	placed in the procedure namespace.
+	* trans-array.c (gfc_trans_g77_array): Obtain the data pointer
+	for class arrays.
+	(gfc_trans_dummy_array_bias): Suppress the runtime error for
+	extent violations in explicit shape class arrays because it
+	always fails.
+	* trans-expr.c (gfc_conv_procedure_call): Handle assumed size
+	class actual arguments passed to non-descriptor formal args by
+	using the data pointer, stored as the symbol's backend decl.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99818
+	* interface.c (compare_parameter): The codimension attribute is
+	applied to the _data field of class formal arguments.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93924
+	PR fortran/93925
+	* trans-expr.c (gfc_conv_procedure_call): Suppress the call to
+	gfc_conv_intrinsic_to_class for unlimited polymorphic procedure
+	pointers.
+	(gfc_trans_assignment_1): Similarly suppress class assignment
+	for class valued procedure pointers.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93794
+	* trans-expr.c (gfc_conv_component_ref): Remove the condition
+	that deferred character length components only be allocatable.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99125
+	* trans-array.c (gfc_conv_expr_descriptor): For deferred length
+	length components use the ss_info string length instead of
+	gfc_get_expr_charlen. Make sure that the deferred string length
+	is a variable before assigning to it. Otherwise use the expr.
+	* trans-expr.c (gfc_conv_string_length): Make sure that the
+	deferred string length is a variable before assigning to it.
+
+2021-08-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98411
+	* trans-decl.c (gfc_finish_var_decl): Adjust check to handle
+	implicit SAVE as well as variables in the main program.  Improve
+	warning message text.
+
+2021-07-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101514
+	* target-memory.c (gfc_interpret_derived): Size of array component
+	of derived type can only be computed here for explicit shape.
+	* trans-types.c (gfc_get_nodesc_array_type): Do not dereference
+	NULL pointers.
+
+2021-07-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101536
+	* check.c (array_check): Adjust check for the case of CLASS
+	arrays.
+
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101084
+	* io.c (resolve_tag_format): Extend FORMAT check to unknown type.
+
+2021-07-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100949
+	* trans-expr.c (gfc_trans_class_init_assign): Call
+	gfc_conv_expr_present only for dummy variables.
+
+2021-07-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2021-07-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/100227
+	* frontend-passes.c (traverse_io_block): Adjust test for
+	when a variable is eligible for the transformation to
+	array slice.
+
+2021-06-18  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95501
+	PR fortran/95502
+	* expr.c (gfc_check_pointer_assign): Avoid NULL pointer
+	dereference.
+	* match.c (gfc_match_pointer_assignment): Likewise.
+	* parse.c (gfc_check_do_variable): Avoid comparison with NULL
+	symtree.
+
+2021-06-16  Jos√© Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/82376
+	* trans-expr.c (gfc_conv_procedure_call): Evaluate function result
+	and then pass a pointer.
+
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* frontend-passes.c (inline_matmul_assign): Do not inline matmul
+	if the assignment to the resulting array if it is not of canonical
+	type (real/integer/complex/logical).
+
+2021-05-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-05-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98411
+	* trans-decl.c (gfc_finish_var_decl): Add check for explicit SAVE
+	attribute.
+
+2021-05-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-05-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100274
+	* interface.c (gfc_compare_actual_formal): Continue checks after
+	emitting warning for argument length mismatch.
+	* trans-expr.c (gfc_conv_procedure_call): Check for NULL pointer
+	dereference.
+
+2021-04-29  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-04-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	* openmp.c (gfc_match_omp_variable_list): Gobble whitespace before
+	checking whether a '%' or parenthesis-open follows as next character.
+
+2021-04-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100154
+	* check.c (variable_check): Allow function reference having a data
+	pointer result.
+	(arg_strlen_is_zero): New function.
+	(gfc_check_fgetputc_sub): Add static check of character and status
+	arguments.
+	(gfc_check_fgetput_sub): Likewise.
+	* intrinsic.c (add_subroutines): Fix argument name for the
+	character argument to intrinsic subroutines fget[c], fput[c].
+
+2021-04-18  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-16  Harald Anlauf  <anlauf@gmx.de>
+		    Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/63797
+	* module.c (write_symtree): Do not write interface of intrinsic
+	procedure to module file for F2003 and newer.
+
+2021-04-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-04-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/99817
+	* trans-types.c (gfc_get_function_type): Also generate hidden
+	coarray argument for character arguments.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index 471523fb767..edf5cef61ec 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -492,6 +492,8 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
+  gfc_try_simplify_expr (*upper, 0);
+
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
@@ -524,6 +526,8 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
+  gfc_try_simplify_expr (*upper, 0);
+
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
@@ -1798,9 +1802,18 @@ expand_constructor (gfc_constructor_base base)
 
       e = c->expr;
 
+      if (e == NULL)
+	return false;
+
       if (empty_constructor)
 	empty_ts = e->ts;
 
+      /* Simplify constant array expression/section within constructor.  */
+      if (e->expr_type == EXPR_VARIABLE && e->rank > 0 && e->ref
+	  && e->symtree && e->symtree->n.sym
+	  && e->symtree->n.sym->attr.flavor == FL_PARAMETER)
+	gfc_simplify_expr (e, 0);
+
       if (e->expr_type == EXPR_ARRAY)
 	{
 	  if (!expand_constructor (e->value.constructor))
@@ -2283,8 +2296,7 @@ gfc_copy_iterator (gfc_iterator *src)
 /********* Subroutines for determining the size of an array *********/
 
 /* These are needed just to accommodate RESHAPE().  There are no
-   diagnostics here, we just return a negative number if something
-   goes wrong.  */
+   diagnostics here, we just return false if something goes wrong.  */
 
 
 /* Get the size of single dimension of an array specification.  The
@@ -2317,6 +2329,9 @@ spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)
 
   mpz_add_ui (*result, *result, 1);
 
+  if (mpz_cmp_si (*result, 0) < 0)
+    mpz_set_si (*result, 0);
+
   return true;
 }
 
@@ -2390,12 +2405,11 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)
 	{
 	  stride_expr = gfc_copy_expr(ar->stride[dimen]); 
 
-	  if(!gfc_simplify_expr(stride_expr, 1))
-	    gfc_internal_error("Simplification error");
-
-	  if (stride_expr->expr_type != EXPR_CONSTANT
-	      || mpz_cmp_ui (stride_expr->value.integer, 0) == 0)
+	  if (!gfc_simplify_expr (stride_expr, 1)
+	     || stride_expr->expr_type != EXPR_CONSTANT
+	     || mpz_cmp_ui (stride_expr->value.integer, 0) == 0)
 	    {
+	      gfc_free_expr (stride_expr);
 	      mpz_clear (stride);
 	      return false;
 	    }
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index ca6f582625d..392786ac48e 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -289,7 +289,7 @@ bin2real (gfc_expr *x, int kind)
 }
 
 
-/* Fortran 2018 treats a BOZ as simply a string of bits.  gfc_boz2real () 
+/* Fortran 2018 treats a BOZ as simply a string of bits.  gfc_boz2real ()
    converts the string into a REAL of the appropriate kind.  The treatment
    of the sign bit is processor dependent.  */
 
@@ -377,12 +377,12 @@ gfc_boz2real (gfc_expr *x, int kind)
 }
 
 
-/* Fortran 2018 treats a BOZ as simply a string of bits.  gfc_boz2int () 
+/* Fortran 2018 treats a BOZ as simply a string of bits.  gfc_boz2int ()
    converts the string into an INTEGER of the appropriate kind.  The
    treatment of the sign bit is processor dependent.  If the  converted
    value exceeds the range of the type, then wrap-around semantics are
    applied.  */
- 
+
 bool
 gfc_boz2int (gfc_expr *x, int kind)
 {
@@ -731,12 +731,11 @@ logical_array_check (gfc_expr *array, int n)
 static bool
 array_check (gfc_expr *e, int n)
 {
-  if (e->ts.type == BT_CLASS && gfc_expr_attr (e).class_ok
+  if (e->rank != 0 && e->ts.type == BT_CLASS && gfc_expr_attr (e).class_ok
 	&& CLASS_DATA (e)->attr.dimension
 	&& CLASS_DATA (e)->as->rank)
     {
       gfc_add_class_array_ref (e);
-      return true;
     }
 
   if (e->rank != 0 && e->ts.type != BT_PROCEDURE)
@@ -975,7 +974,8 @@ allocatable_check (gfc_expr *e, int n)
   symbol_attribute attr;
 
   attr = gfc_variable_attr (e, NULL);
-  if (!attr.allocatable || attr.associate_var)
+  if (!attr.allocatable
+     || (attr.associate_var && !attr.select_rank_temporary))
     {
       gfc_error ("%qs argument of %qs intrinsic at %L must be ALLOCATABLE",
 		 gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,
@@ -1011,33 +1011,13 @@ variable_check (gfc_expr *e, int n, bool allow_proc)
   if (e->expr_type == EXPR_VARIABLE
       && e->symtree->n.sym->attr.intent == INTENT_IN
       && (gfc_current_intrinsic_arg[n]->intent == INTENT_OUT
-	  || gfc_current_intrinsic_arg[n]->intent == INTENT_INOUT))
+	  || gfc_current_intrinsic_arg[n]->intent == INTENT_INOUT)
+      && !gfc_check_vardef_context (e, false, true, false, NULL))
     {
-      gfc_ref *ref;
-      bool pointer = e->symtree->n.sym->ts.type == BT_CLASS
-		     && CLASS_DATA (e->symtree->n.sym)
-		     ? CLASS_DATA (e->symtree->n.sym)->attr.class_pointer
-		     : e->symtree->n.sym->attr.pointer;
-
-      for (ref = e->ref; ref; ref = ref->next)
-	{
-	  if (pointer && ref->type == REF_COMPONENT)
-	    break;
-	  if (ref->type == REF_COMPONENT
-	      && ((ref->u.c.component->ts.type == BT_CLASS
-		   && CLASS_DATA (ref->u.c.component)->attr.class_pointer)
-		  || (ref->u.c.component->ts.type != BT_CLASS
-		      && ref->u.c.component->attr.pointer)))
-	    break;
-	}
-
-      if (!ref)
-	{
-	  gfc_error ("%qs argument of %qs intrinsic at %L cannot be "
-		     "INTENT(IN)", gfc_current_intrinsic_arg[n]->name,
-		     gfc_current_intrinsic, &e->where);
-	  return false;
-	}
+      gfc_error ("%qs argument of %qs intrinsic at %L cannot be INTENT(IN)",
+		 gfc_current_intrinsic_arg[n]->name,
+		 gfc_current_intrinsic, &e->where);
+      return false;
     }
 
   if (e->expr_type == EXPR_VARIABLE
@@ -1054,6 +1034,13 @@ variable_check (gfc_expr *e, int n, bool allow_proc)
 	  return true;
     }
 
+  /* F2018:R902: function reference having a data pointer result.  */
+  if (e->expr_type == EXPR_FUNCTION
+      && e->symtree->n.sym->attr.flavor == FL_PROCEDURE
+      && e->symtree->n.sym->attr.function
+      && e->symtree->n.sym->attr.pointer)
+    return true;
+
   gfc_error ("%qs argument of %qs intrinsic at %L must be a variable",
 	     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic, &e->where);
 
@@ -3230,7 +3217,7 @@ gfc_check_intconv (gfc_expr *x)
       || strcmp (gfc_current_intrinsic, "long") == 0)
     {
       gfc_error ("%qs intrinsic subprogram at %L has been deprecated.  "
-		 "Use INT intrinsic subprogram.", gfc_current_intrinsic, 
+		 "Use INT intrinsic subprogram.", gfc_current_intrinsic,
 		 &x->where);
       return false;
     }
@@ -3958,7 +3945,7 @@ gfc_check_findloc (gfc_actual_arglist *ap)
   /* Check the kind of the characters argument match.  */
   if (a1 && v1 && a->ts.kind != v->ts.kind)
     goto incompat;
-	 
+
   d = ap->next->next->expr;
   m = ap->next->next->next->expr;
   k = ap->next->next->next->next->expr;
@@ -4681,6 +4668,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,
   mpz_t size;
   mpz_t nelems;
   int shape_size;
+  bool shape_is_const;
 
   if (!array_check (source, 0))
     return false;
@@ -4714,7 +4702,11 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,
 		 "than %d elements", &shape->where, GFC_MAX_DIMENSIONS);
       return false;
     }
-  else if (shape->expr_type == EXPR_ARRAY && gfc_is_constant_expr (shape))
+
+  gfc_simplify_expr (shape, 0);
+  shape_is_const = gfc_is_constant_expr (shape);
+
+  if (shape->expr_type == EXPR_ARRAY && shape_is_const)
     {
       gfc_expr *e;
       int i, extent;
@@ -4730,38 +4722,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,
 	      gfc_error ("%qs argument of %qs intrinsic at %L has "
 			 "negative element (%d)",
 			 gfc_current_intrinsic_arg[1]->name,
-			 gfc_current_intrinsic, &e->where, extent);
-	      return false;
-	    }
-	}
-    }
-  else if (shape->expr_type == EXPR_VARIABLE && shape->ref
-	   && shape->ref->u.ar.type == AR_FULL && shape->ref->u.ar.dimen == 1
-	   && shape->ref->u.ar.as
-	   && shape->ref->u.ar.as->lower[0]->expr_type == EXPR_CONSTANT
-	   && shape->ref->u.ar.as->lower[0]->ts.type == BT_INTEGER
-	   && shape->ref->u.ar.as->upper[0]->expr_type == EXPR_CONSTANT
-	   && shape->ref->u.ar.as->upper[0]->ts.type == BT_INTEGER
-	   && shape->symtree->n.sym->attr.flavor == FL_PARAMETER
-	   && shape->symtree->n.sym->value)
-    {
-      int i, extent;
-      gfc_expr *e, *v;
-
-      v = shape->symtree->n.sym->value;
-
-      for (i = 0; i < shape_size; i++)
-	{
-	  e = gfc_constructor_lookup_expr (v->value.constructor, i);
-	  if (e == NULL)
-	     break;
-
-	  gfc_extract_int (e, &extent);
-
-	  if (extent < 0)
-	    {
-	      gfc_error ("Element %d of actual argument of RESHAPE at %L "
-			 "cannot be negative", i + 1, &shape->where);
+			 gfc_current_intrinsic, &shape->where, extent);
 	      return false;
 	    }
 	}
@@ -4838,8 +4799,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,
 	}
     }
 
-  if (pad == NULL && shape->expr_type == EXPR_ARRAY
-      && gfc_is_constant_expr (shape)
+  if (pad == NULL && shape->expr_type == EXPR_ARRAY && shape_is_const
       && !(source->expr_type == EXPR_VARIABLE && source->symtree->n.sym->as
 	   && source->symtree->n.sym->as->type == AS_ASSUMED_SIZE))
     {
@@ -5068,9 +5028,19 @@ gfc_check_shape (gfc_expr *source, gfc_expr *kind)
   if (gfc_invalid_null_arg (source))
     return false;
 
+  if (!kind_check (kind, 1, BT_INTEGER))
+    return false;
+  if (kind && !gfc_notify_std (GFC_STD_F2003, "%qs intrinsic "
+			       "with KIND argument at %L",
+			       gfc_current_intrinsic, &kind->where))
+    return false;
+
   if (source->rank == 0 || source->expr_type != EXPR_VARIABLE)
     return true;
 
+  if (source->ref == NULL)
+    return false;
+
   ar = gfc_find_array_ref (source);
 
   if (ar->as && ar->as->type == AS_ASSUMED_SIZE && ar->type == AR_FULL)
@@ -5080,13 +5050,6 @@ gfc_check_shape (gfc_expr *source, gfc_expr *kind)
       return false;
     }
 
-  if (!kind_check (kind, 1, BT_INTEGER))
-    return false;
-  if (kind && !gfc_notify_std (GFC_STD_F2003, "%qs intrinsic "
-			       "with KIND argument at %L",
-			       gfc_current_intrinsic, &kind->where))
-    return false;
-
   return true;
 }
 
@@ -5161,6 +5124,9 @@ gfc_check_sizeof (gfc_expr *arg)
       return false;
     }
 
+  if (illegal_boz_arg (arg))
+    return false;
+
   /* TYPE(*) is acceptable if and only if it uses an array descriptor.  */
   if (arg->ts.type == BT_ASSUMED
       && (arg->symtree->n.sym->as == NULL
@@ -5202,6 +5168,18 @@ is_c_interoperable (gfc_expr *expr, const char **msg, bool c_loc, bool c_f_ptr)
 {
   *msg = NULL;
 
+  if (expr->expr_type == EXPR_NULL)
+    {
+      *msg = "NULL() is not interoperable";
+      return false;
+    }
+
+  if (expr->ts.type == BT_BOZ)
+    {
+      *msg = "BOZ literal constant";
+      return false;
+    }
+
   if (expr->ts.type == BT_CLASS)
     {
       *msg = "Expression is polymorphic";
@@ -5681,6 +5659,19 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)
 /* Functions for checking FGETC, FPUTC, FGET and FPUT (subroutines and
    functions).  */
 
+bool
+arg_strlen_is_zero (gfc_expr *c, int n)
+{
+  if (gfc_var_strlen (c) == 0)
+    {
+      gfc_error ("%qs argument of %qs intrinsic at %L must have "
+		 "length at least 1", gfc_current_intrinsic_arg[n]->name,
+		 gfc_current_intrinsic, &c->where);
+      return true;
+    }
+  return false;
+}
+
 bool
 gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)
 {
@@ -5694,13 +5685,19 @@ gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)
     return false;
   if (!kind_value_check (c, 1, gfc_default_character_kind))
     return false;
+  if (strcmp (gfc_current_intrinsic, "fgetc") == 0
+      && !variable_check (c, 1, false))
+    return false;
+  if (arg_strlen_is_zero (c, 1))
+    return false;
 
   if (status == NULL)
     return true;
 
   if (!type_check (status, 2, BT_INTEGER)
       || !kind_value_check (status, 2, gfc_default_integer_kind)
-      || !scalar_check (status, 2))
+      || !scalar_check (status, 2)
+      || !variable_check (status, 2, false))
     return false;
 
   return true;
@@ -5721,13 +5718,19 @@ gfc_check_fgetput_sub (gfc_expr *c, gfc_expr *status)
     return false;
   if (!kind_value_check (c, 0, gfc_default_character_kind))
     return false;
+  if (strcmp (gfc_current_intrinsic, "fget") == 0
+      && !variable_check (c, 0, false))
+    return false;
+  if (arg_strlen_is_zero (c, 0))
+    return false;
 
   if (status == NULL)
     return true;
 
   if (!type_check (status, 1, BT_INTEGER)
       || !kind_value_check (status, 1, gfc_default_integer_kind)
-      || !scalar_check (status, 1))
+      || !scalar_check (status, 1)
+      || !variable_check (status, 1, false))
     return false;
 
   return true;
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index f017fbe3be7..51bd6d18317 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -628,6 +628,7 @@ gfc_get_len_component (gfc_expr *e, int k)
    component '_vptr' which determines the dynamic type.  When this CLASS
    entity is unlimited polymorphic, then also add a component '_len' to
    store the length of string when that is stored in it.  */
+static int ctr = 0;
 
 bool
 gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
@@ -643,13 +644,6 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
 
   gcc_assert (as);
 
-  if (*as && (*as)->type == AS_ASSUMED_SIZE)
-    {
-      gfc_error ("Assumed size polymorphic objects or components, such "
-		 "as that at %C, have not yet been implemented");
-      return false;
-    }
-
   if (attr->class_ok)
     /* Class container has already been built.  */
     return true;
@@ -691,7 +685,30 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
   else
     ns = ts->u.derived->ns;
 
-  gfc_find_symbol (name, ns, 0, &fclass);
+  /* Although this might seem to be counterintuitive, we can build separate
+     class types with different array specs because the TKR interface checks
+     work on the declared type. All array type other than deferred shape or
+     assumed rank are added to the function namespace to ensure that they
+     are properly distinguished.  */
+  if (attr->dummy && !attr->codimension && (*as)
+      && !((*as)->type == AS_DEFERRED || (*as)->type == AS_ASSUMED_RANK))
+    {
+      char *sname;
+      ns = gfc_current_ns;
+      gfc_find_symbol (name, ns, 0, &fclass);
+      /* If a local class type with this name already exists, update the
+	 name with an index.  */
+      if (fclass)
+	{
+	  fclass = NULL;
+	  sname = xasprintf ("%s_%d", name, ++ctr);
+	  free (name);
+	  name = sname;
+	}
+    }
+  else
+    gfc_find_symbol (name, ns, 0, &fclass);
+
   if (fclass == NULL)
     {
       gfc_symtree *st;
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 9273976aa9a..2ad9fb63399 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -896,9 +896,6 @@ match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
       expr->ts = *ts;
       expr->value.constructor = array_head;
 
-      expr->rank = as->rank;
-      expr->shape = gfc_get_shape (expr->rank);
-
       /* Validate sizes.  We built expr ourselves, so cons_size will be
 	 constant (we fail above for non-constant expressions).
 	 We still need to verify that the sizes match.  */
@@ -911,6 +908,12 @@ match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
       mpz_clear (cons_size);
       if (cmp)
 	goto cleanup;
+
+      /* Set the rank/shape to match the LHS as auto-reshape is implied. */
+      expr->rank = as->rank;
+      expr->shape = gfc_get_shape (as->rank);
+      for (int i = 0; i < as->rank; ++i)
+	spec_dimen_size (as, i, &expr->shape[i]);
     }
 
   /* Make sure scalar types match. */
@@ -2020,6 +2023,14 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	    }
 	}
 
+      if (sym->attr.flavor == FL_PARAMETER && sym->attr.dimension && sym->as
+	  && sym->as->rank && init->rank && init->rank != sym->as->rank)
+	{
+	  gfc_error ("Rank mismatch of array at %L and its initializer "
+		     "(%d/%d)", &sym->declared_at, sym->as->rank, init->rank);
+	  return false;
+	}
+
       /* If sym is implied-shape, set its upper bounds from init.  */
       if (sym->attr.flavor == FL_PARAMETER && sym->attr.dimension
 	  && sym->as->type == AS_IMPLIED_SHAPE)
@@ -2078,6 +2089,24 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	  sym->as->type = AS_EXPLICIT;
 	}
 
+      /* Ensure that explicit bounds are simplified.  */
+      if (sym->attr.flavor == FL_PARAMETER && sym->attr.dimension
+	  && sym->as->type == AS_EXPLICIT)
+	{
+	  for (int dim = 0; dim < sym->as->rank; ++dim)
+	    {
+	      gfc_expr *e;
+
+	      e = sym->as->lower[dim];
+	      if (e->expr_type != EXPR_CONSTANT)
+		gfc_reduce_init_expr (e);
+
+	      e = sym->as->upper[dim];
+	      if (e->expr_type != EXPR_CONSTANT)
+		gfc_reduce_init_expr (e);
+	    }
+	}
+
       /* Need to check if the expression we initialized this
 	 to was one of the iso_c_binding named constants.  If so,
 	 and we're a parameter (constant), let it be iso_c.
@@ -2105,12 +2134,16 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	  gfc_expr *array;
 	  int n;
 	  if (sym->attr.flavor == FL_PARAMETER
-		&& init->expr_type == EXPR_CONSTANT
-		&& spec_size (sym->as, &size)
-		&& mpz_cmp_si (size, 0) > 0)
+	      && gfc_is_constant_expr (init)
+	      && (init->expr_type == EXPR_CONSTANT
+		  || init->expr_type == EXPR_STRUCTURE)
+	      && spec_size (sym->as, &size)
+	      && mpz_cmp_si (size, 0) > 0)
 	    {
 	      array = gfc_get_array_expr (init->ts.type, init->ts.kind,
 					  &init->where);
+	      if (init->ts.type == BT_DERIVED)
+		array->ts.u.derived = init->ts.u.derived;
 	      for (n = 0; n < (int)mpz_get_si (size); n++)
 		gfc_constructor_append_expr (&array->value.constructor,
 					     n == 0
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index f946145eb1b..95b35153941 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -990,6 +990,34 @@ done:
 }
 
 
+/* Standard intrinsics listed under F2018:10.1.12 (6), which are excluded in
+   constant expressions, except TRANSFER (c.f. item (8)), which would need
+   separate treatment.  */
+
+static bool
+is_non_constant_intrinsic (gfc_expr *e)
+{
+  if (e->expr_type == EXPR_FUNCTION
+      && e->value.function.isym)
+    {
+      switch (e->value.function.isym->id)
+	{
+	  case GFC_ISYM_COMMAND_ARGUMENT_COUNT:
+	  case GFC_ISYM_GET_TEAM:
+	  case GFC_ISYM_NULL:
+	  case GFC_ISYM_NUM_IMAGES:
+	  case GFC_ISYM_TEAM_NUMBER:
+	  case GFC_ISYM_THIS_IMAGE:
+	    return true;
+
+	default:
+	  return false;
+	}
+    }
+  return false;
+}
+
+
 /* Determine if an expression is constant in the sense of F08:7.1.12.
  * This function expects that the expression has already been simplified.  */
 
@@ -1023,6 +1051,10 @@ gfc_is_constant_expr (gfc_expr *e)
       gcc_assert (e->symtree || e->value.function.esym
 		  || e->value.function.isym);
 
+      /* Check for intrinsics excluded in constant expressions.  */
+      if (e->value.function.isym && is_non_constant_intrinsic (e))
+	return false;
+
       /* Call to intrinsic with at least one argument.  */
       if (e->value.function.isym && e->value.function.actual)
 	{
@@ -1337,7 +1369,9 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,
   for (i = 0; i < ar->dimen; i++)
     {
       if (!gfc_reduce_init_expr (ar->as->lower[i])
-	  || !gfc_reduce_init_expr (ar->as->upper[i]))
+	  || !gfc_reduce_init_expr (ar->as->upper[i])
+	  || ar->as->upper[i]->expr_type != EXPR_CONSTANT
+	  || ar->as->lower[i]->expr_type != EXPR_CONSTANT)
 	{
 	  t = false;
 	  cons = NULL;
@@ -1351,9 +1385,6 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,
 	  goto depart;
 	}
 
-      gcc_assert (ar->as->upper[i]->expr_type == EXPR_CONSTANT
-		  && ar->as->lower[i]->expr_type == EXPR_CONSTANT);
-
       /* Check the bounds.  */
       if ((ar->as->upper[i]
 	   && mpz_cmp (e->value.integer,
@@ -1725,8 +1756,8 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)
   *newp = gfc_copy_expr (p);
   free ((*newp)->value.character.string);
 
-  end = (gfc_charlen_t) mpz_get_ui (p->ref->u.ss.end->value.integer);
-  start = (gfc_charlen_t) mpz_get_ui (p->ref->u.ss.start->value.integer);
+  end = (gfc_charlen_t) mpz_get_si (p->ref->u.ss.end->value.integer);
+  start = (gfc_charlen_t) mpz_get_si (p->ref->u.ss.start->value.integer);
   if (end >= start)
     length = end - start + 1;
   else
@@ -2095,6 +2126,8 @@ simplify_parameter_variable (gfc_expr *p, int type)
       if (e == NULL)
 	return false;
 
+      gfc_free_shape (&e->shape, e->rank);
+      e->shape = gfc_copy_shape (p->shape, p->rank);
       e->rank = p->rank;
 
       if (e->ts.type == BT_CHARACTER && p->ts.u.cl)
@@ -2295,6 +2328,31 @@ gfc_simplify_expr (gfc_expr *p, int type)
 }
 
 
+/* Try simplification of an expression via gfc_simplify_expr.
+   When an error occurs (arithmetic or otherwise), roll back.  */
+
+bool
+gfc_try_simplify_expr (gfc_expr *e, int type)
+{
+  gfc_expr *n;
+  bool t, saved_div0;
+
+  if (e == NULL || e->expr_type == EXPR_CONSTANT)
+    return true;
+
+  saved_div0 = gfc_seen_div0;
+  gfc_seen_div0 = false;
+  n = gfc_copy_expr (e);
+  t = gfc_simplify_expr (n, type) && !gfc_seen_div0;
+  if (t)
+    gfc_replace_expr (e, n);
+  else
+    gfc_free_expr (n);
+  gfc_seen_div0 = saved_div0;
+  return t;
+}
+
+
 /* Returns the type of an expression with the exception that iterator
    variables are automatically integers no matter what else they may
    be declared as.  */
@@ -3809,6 +3867,9 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue,
   int proc_pointer;
   bool same_rank;
 
+  if (!lvalue->symtree)
+    return false;
+
   lhs_attr = gfc_expr_attr (lvalue);
   if (lvalue->ts.type == BT_UNKNOWN && !lhs_attr.proc_pointer)
     {
@@ -6168,10 +6229,13 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,
     {
       if (ptr_component && ref->type == REF_COMPONENT)
 	check_intentin = false;
-      if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
+      if (ref->type == REF_COMPONENT)
 	{
-	  ptr_component = true;
-	  if (!pointer)
+	  gfc_component *comp = ref->u.c.component;
+	  ptr_component = (comp->ts.type == BT_CLASS && comp->attr.class_ok)
+			? CLASS_DATA (comp)->attr.class_pointer
+			: comp->attr.pointer;
+	  if (ptr_component && !pointer)
 	    check_intentin = false;
 	}
     }
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index 5e768b12854..cbadb9c1b22 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -1299,8 +1299,8 @@ traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)
 		std::swap (start->value.op.op1, start->value.op.op2);
 	      gcc_fallthrough ();
 	    case INTRINSIC_MINUS:
-	      if ((start->value.op.op1->expr_type!= EXPR_VARIABLE
-		   && start->value.op.op2->expr_type != EXPR_CONSTANT)
+	      if (start->value.op.op1->expr_type!= EXPR_VARIABLE
+		  || start->value.op.op2->expr_type != EXPR_CONSTANT
 		  || start->value.op.op1->ref)
 		return false;
 	      if (!stack_top || !stack_top->iter
@@ -2414,7 +2414,7 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
 
 	      do_sym = cl->ext.iterator->var->symtree->n.sym;
 
-	      if (a->expr && a->expr->symtree
+	      if (a->expr && a->expr->symtree && f->sym
 		  && a->expr->symtree->n.sym == do_sym)
 		{
 		  if (f->sym->attr.intent == INTENT_OUT)
@@ -2677,6 +2677,7 @@ do_subscript (gfc_expr **e)
 		    {
 		      if (ar->as->lower[i]
 			  && ar->as->lower[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->lower[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld < %ld) in loop beginning at %L",
@@ -2686,6 +2687,7 @@ do_subscript (gfc_expr **e)
 
 		      if (ar->as->upper[i]
 			  && ar->as->upper[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->upper[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)
 			    gfc_warning (warn, "Array reference at %L out of bounds "
 					 "(%ld > %ld) in loop beginning at %L",
@@ -2701,6 +2703,7 @@ do_subscript (gfc_expr **e)
 		    {
 		      if (ar->as->lower[i]
 			  && ar->as->lower[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->lower[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld < %ld) in loop beginning at %L",
@@ -2710,6 +2713,7 @@ do_subscript (gfc_expr **e)
 
 		      if (ar->as->upper[i]
 			  && ar->as->upper[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->upper[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld > %ld) in loop beginning at %L",
@@ -3919,6 +3923,19 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,
   if (m_case == none)
     return 0;
 
+  /* We only handle assignment to numeric or logical variables.  */
+  switch(expr1->ts.type)
+    {
+    case BT_INTEGER:
+    case BT_LOGICAL:
+    case BT_REAL:
+    case BT_COMPLEX:
+      break;
+
+    default:
+      return 0;
+    }
+
   ns = insert_block ();
 
   /* Assign the type of the zero expression for initializing the resulting
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index e4bb8b8591f..2a669a37708 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -3307,6 +3307,7 @@ void gfc_free_ref_list (gfc_ref *);
 void gfc_type_convert_binary (gfc_expr *, int);
 bool gfc_is_constant_expr (gfc_expr *);
 bool gfc_simplify_expr (gfc_expr *, int);
+bool gfc_try_simplify_expr (gfc_expr *, int);
 int gfc_has_vector_index (gfc_expr *);
 
 gfc_expr *gfc_get_expr (void);
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index 70219a537b9..a09a09c925e 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -2326,6 +2326,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
   bool rank_check, is_pointer;
   char err[200];
   gfc_component *ppc;
+  bool codimension = false;
 
   /* If the formal arg has type BT_VOID, it's to one of the iso_c_binding
      procs c_f_pointer or c_f_procpointer, and we need to accept most
@@ -2489,7 +2490,12 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
       return false;
     }
 
-  if (formal->attr.codimension && !gfc_is_coarray (actual))
+  if (formal->ts.type == BT_CLASS && formal->attr.class_ok)
+    codimension = CLASS_DATA (formal)->attr.codimension;
+  else
+    codimension = formal->attr.codimension;
+
+  if (codimension && !gfc_is_coarray (actual))
     {
       if (where)
 	gfc_error ("Actual argument to %qs at %L must be a coarray",
@@ -2497,7 +2503,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
       return false;
     }
 
-  if (formal->attr.codimension && formal->attr.allocatable)
+  if (codimension && formal->attr.allocatable)
     {
       gfc_ref *last = NULL;
 
@@ -2519,7 +2525,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
 	}
     }
 
-  if (formal->attr.codimension)
+  if (codimension)
     {
       /* F2008, 12.5.2.8 + Corrig 2 (IR F08/0048).  */
       /* F2018, 12.5.2.8.  */
@@ -2585,7 +2591,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
       return false;
     }
 
-  if (formal->attr.allocatable && !formal->attr.codimension
+  if (formal->attr.allocatable && !codimension
       && actual_attr.codimension)
     {
       if (formal->attr.intent == INTENT_OUT)
@@ -3248,10 +3254,13 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
 	  && f->sym->attr.flavor != FL_PROCEDURE)
 	{
 	  if (a->expr->ts.type == BT_CHARACTER && !f->sym->as && where)
-	    gfc_warning (0, "Character length of actual argument shorter "
-			 "than of dummy argument %qs (%lu/%lu) at %L",
-			 f->sym->name, actual_size, formal_size,
-			 &a->expr->where);
+	    {
+	      gfc_warning (0, "Character length of actual argument shorter "
+			   "than of dummy argument %qs (%lu/%lu) at %L",
+			   f->sym->name, actual_size, formal_size,
+			   &a->expr->where);
+	      goto skip_size_check;
+	    }
           else if (where)
 	    {
 	      /* Emit a warning for -std=legacy and an error otherwise. */
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index 6188ef86e53..efe79a9bec6 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -3423,7 +3423,7 @@ add_subroutines (void)
   /* Argument names.  These are used as argument keywords and so need to
      match the documentation.  Please keep this list in sorted order.  */
   static const char
-    *a = "a", *c = "count", *cm = "count_max", *com = "command",
+    *a = "a", *c_ = "c", *c = "count", *cm = "count_max", *com = "command",
     *cr = "count_rate", *dt = "date", *errmsg = "errmsg", *f = "from",
     *fp = "frompos", *gt = "get", *h = "harvest", *han = "handler",
     *length = "length", *ln = "len", *md = "mode", *msk = "mask",
@@ -3803,12 +3803,12 @@ add_subroutines (void)
   add_sym_3s ("fgetc", GFC_ISYM_FGETC, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetputc_sub, NULL, gfc_resolve_fgetc_sub,
 	      ut, BT_INTEGER, di, REQUIRED, INTENT_IN,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_2s ("fget", GFC_ISYM_FGET, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetput_sub, NULL, gfc_resolve_fget_sub,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_1s ("flush", GFC_ISYM_FLUSH, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
@@ -3818,12 +3818,12 @@ add_subroutines (void)
   add_sym_3s ("fputc", GFC_ISYM_FPUTC, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetputc_sub, NULL, gfc_resolve_fputc_sub,
 	      ut, BT_INTEGER, di, REQUIRED, INTENT_IN,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_2s ("fput", GFC_ISYM_FPUT, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetput_sub, NULL, gfc_resolve_fput_sub,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_1s ("free", GFC_ISYM_FREE, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index 2a387535d05..5d444edccd7 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -1763,7 +1763,7 @@ resolve_tag_format (gfc_expr *e)
   if (e->ts.type != BT_CHARACTER)
     {
       if (e->ts.type == BT_DERIVED || e->ts.type == BT_CLASS
-	  || e->ts.type == BT_VOID)
+	  || e->ts.type == BT_VOID || e->ts.type == BT_UNKNOWN)
 	{
 	  gfc_error ("Non-character non-Hollerith in FORMAT tag at %L",
 		     &e->where);
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index e1e4c1caeb4..ef6c86af2f9 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -1409,7 +1409,7 @@ gfc_match_pointer_assignment (void)
   gfc_matching_procptr_assignment = 0;
 
   m = gfc_match (" %v =>", &lvalue);
-  if (m != MATCH_YES)
+  if (m != MATCH_YES || !lvalue->symtree)
     {
       m = MATCH_NO;
       goto cleanup;
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index 9a5b1cb7625..0c14f2a8105 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -6078,6 +6078,17 @@ write_symtree (gfc_symtree *st)
   if (check_unique_name (st->name))
     return;
 
+  /* From F2003 onwards, intrinsic procedures are no longer subject to
+     the restriction, "that an elemental intrinsic function here be of
+     type integer or character and each argument must be an initialization
+     expr of type integer or character" is lifted so that intrinsic
+     procedures can be over-ridden. This requires that the intrinsic
+     symbol not appear in the module file, thereby preventing ambiguity
+     when USEd.  */
+  if (strcmp (sym->module, "(intrinsic)") == 0
+      && (gfc_option.allow_std & GFC_STD_F2003))
+    return;
+
   p = find_pointer (sym);
   if (p == NULL)
     gfc_internal_error ("write_symtree(): Symbol not written");
diff --git a/gcc/fortran/openmp.c b/gcc/fortran/openmp.c
index 3175999dd4a..41ef75a0e0c 100644
--- a/gcc/fortran/openmp.c
+++ b/gcc/fortran/openmp.c
@@ -260,6 +260,7 @@ gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,
 	case MATCH_YES:
 	  gfc_expr *expr;
 	  expr = NULL;
+	  gfc_gobble_whitespace ();
 	  if ((allow_sections && gfc_peek_ascii_char () == '(')
 	      || (allow_derived && gfc_peek_ascii_char () == '%'))
 	    {
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 3e19d5fdfbe..1501abfffd2 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -4440,6 +4440,9 @@ gfc_check_do_variable (gfc_symtree *st)
 {
   gfc_state_data *s;
 
+  if (!st)
+    return 0;
+
   for (s=gfc_state_stack; s; s = s->previous)
     if (s->do_variable == st)
       {
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index 8edc83a42c3..b03961a9981 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -3062,26 +3062,36 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,
 	  continue;
 	}
 
-      /* If it was not found, try the default initializer if there's any;
+      /* If it was not found, apply NULL expression to set the component as
+	 unallocated. Then try the default initializer if there's any;
 	 otherwise, it's an error unless this is a deferred parameter.  */
       if (!comp_iter)
 	{
-	  if (comp->initializer)
-	    {
-	      if (!gfc_notify_std (GFC_STD_F2003, "Structure constructor "
-				   "with missing optional arguments at %C"))
-		return false;
-	      value = gfc_copy_expr (comp->initializer);
-	    }
-	  else if (comp->attr.allocatable
-		   || (comp->ts.type == BT_CLASS
-		       && CLASS_DATA (comp)->attr.allocatable))
+	  /* F2018 7.5.10: If an allocatable component has no corresponding
+	     component-data-source, then that component has an allocation
+	     status of unallocated....  */
+	  if (comp->attr.allocatable
+	      || (comp->ts.type == BT_CLASS
+		  && CLASS_DATA (comp)->attr.allocatable))
 	    {
 	      if (!gfc_notify_std (GFC_STD_F2008, "No initializer for "
 				   "allocatable component %qs given in the "
 				   "structure constructor at %C", comp->name))
 		return false;
+	      value = gfc_get_null_expr (&gfc_current_locus);
+	    }
+	  /* ....(Preceeding sentence) If a component with default
+	     initialization has no corresponding component-data-source, then
+	     the default initialization is applied to that component.  */
+	  else if (comp->initializer)
+	    {
+	      if (!gfc_notify_std (GFC_STD_F2003, "Structure constructor "
+				   "with missing optional arguments at %C"))
+		return false;
+	      value = gfc_copy_expr (comp->initializer);
 	    }
+	  /* Do not trap components such as the string length for deferred
+	     length character components.  */
 	  else if (!comp->attr.artificial)
 	    {
 	      gfc_error ("No initializer for component %qs given in the"
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 7ca5f44f419..591b36fa4bd 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1436,6 +1436,41 @@ resolve_structure_cons (gfc_expr *expr, int init)
 	    }
 	}
 
+      /* Validate shape, except for dynamic or PDT arrays.  */
+      if (cons->expr->expr_type == EXPR_ARRAY && rank == cons->expr->rank
+	  && comp->as && !comp->attr.allocatable && !comp->attr.pointer
+	  && !comp->attr.pdt_array)
+	{
+	  mpz_t len;
+	  mpz_init (len);
+	  for (int n = 0; n < rank; n++)
+	    {
+	      if (comp->as->upper[n]->expr_type != EXPR_CONSTANT
+		  || comp->as->lower[n]->expr_type != EXPR_CONSTANT)
+		{
+		  gfc_error ("Bad array spec of component %qs referenced in "
+			     "structure constructor at %L",
+			     comp->name, &cons->expr->where);
+		  t = false;
+		  break;
+		};
+	      mpz_set_ui (len, 1);
+	      mpz_add (len, len, comp->as->upper[n]->value.integer);
+	      mpz_sub (len, len, comp->as->lower[n]->value.integer);
+	      if (mpz_cmp (cons->expr->shape[n], len) != 0)
+		{
+		  gfc_error ("The shape of component %qs in the structure "
+			     "constructor at %L differs from the shape of the "
+			     "declared component for dimension %d (%ld/%ld)",
+			     comp->name, &cons->expr->where, n+1,
+			     mpz_get_si (cons->expr->shape[n]),
+			     mpz_get_si (len));
+		  t = false;
+		}
+	    }
+	  mpz_clear (len);
+	}
+
       if (!comp->attr.pointer || comp->attr.proc_pointer
 	  || cons->expr->expr_type == EXPR_NULL)
 	continue;
@@ -4858,6 +4893,8 @@ gfc_resolve_dim_arg (gfc_expr *dim)
    base symbol.  We traverse the list of reference structures, setting
    the stored reference to references.  Component references can
    provide an additional array specification.  */
+static void
+resolve_assoc_var (gfc_symbol* sym, bool resolve_target);
 
 static void
 find_array_spec (gfc_expr *e)
@@ -4867,6 +4904,13 @@ find_array_spec (gfc_expr *e)
   gfc_ref *ref;
   bool class_as = false;
 
+  if (e->symtree->n.sym->assoc)
+    {
+      if (e->symtree->n.sym->assoc->target)
+	gfc_resolve_expr (e->symtree->n.sym->assoc->target);
+      resolve_assoc_var (e->symtree->n.sym, false);
+    }
+
   if (e->symtree->n.sym->ts.type == BT_CLASS)
     {
       as = CLASS_DATA (e->symtree->n.sym)->as;
@@ -11733,8 +11777,9 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)
 	      gfc_resolve_omp_do_blocks (code, ns);
 	      break;
 	    case EXEC_SELECT_TYPE:
-	      /* Blocks are handled in resolve_select_type because we have
-		 to transform the SELECT TYPE into ASSOCIATE first.  */
+	    case EXEC_SELECT_RANK:
+	      /* Blocks are handled in resolve_select_type/rank because we
+		 have to transform the SELECT TYPE into ASSOCIATE first.  */
 	      break;
             case EXEC_DO_CONCURRENT:
 	      gfc_do_concurrent_flag = 1;
@@ -13095,7 +13140,8 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
 
   /* An elemental function is required to return a scalar 12.7.1  */
   if (sym->attr.elemental && sym->attr.function
-      && (sym->as || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as)))
+      && (sym->as || (sym->ts.type == BT_CLASS && sym->attr.class_ok
+		      && CLASS_DATA (sym)->as)))
     {
       gfc_error ("ELEMENTAL function %qs at %L must have a scalar "
 		 "result", sym->name, &sym->declared_at);
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index d28aa7a3c16..8d40fdf251a 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -2077,6 +2077,9 @@ gfc_simplify_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)
   else
     which = 0;
 
+  if (array->shape == NULL)
+    return NULL;
+
   gfc_array_size (array, &size);
   arraysize = mpz_get_ui (size);
   mpz_clear (size);
@@ -4231,6 +4234,12 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)
 	     || (as->type == AS_ASSUMED_SHAPE && upper)))
     return NULL;
 
+  /* 'array' shall not be an unallocated allocatable variable or a pointer that
+     is not associated.  */
+  if (array->expr_type == EXPR_VARIABLE
+      && (gfc_expr_attr (array).allocatable || gfc_expr_attr (array).pointer))
+    return NULL;
+
   gcc_assert (!as
 	      || (as->type != AS_DEFERRED
 		  && array->expr_type == EXPR_VARIABLE
@@ -6759,7 +6768,13 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,
       gfc_extract_int (e, &shape[rank]);
 
       gcc_assert (rank >= 0 && rank < GFC_MAX_DIMENSIONS);
-      gcc_assert (shape[rank] >= 0);
+      if (shape[rank] < 0)
+	{
+	  gfc_error ("The SHAPE array for the RESHAPE intrinsic at %L has a "
+		     "negative value %d for dimension %d",
+		     &shape_exp->where, shape[rank], rank+1);
+	  return &gfc_bad_expr;
+	}
 
       rank++;
     }
@@ -7379,6 +7394,7 @@ simplify_size (gfc_expr *array, gfc_expr *dim, int k)
   mpz_t size;
   gfc_expr *return_value;
   int d;
+  gfc_ref *ref;
 
   /* For unary operations, the size of the result is given by the size
      of the operand.  For binary ones, it's the size of the first operand
@@ -7435,6 +7451,10 @@ simplify_size (gfc_expr *array, gfc_expr *dim, int k)
       return simplified;
     }
 
+  for (ref = array->ref; ref; ref = ref->next)
+    if (ref->type == REF_ARRAY && ref->u.ar.as)
+      gfc_resolve_array_spec (ref->u.ar.as, 0);
+
   if (dim == NULL)
     {
       if (!gfc_array_size (array, &size))
@@ -8071,6 +8091,9 @@ gfc_simplify_transpose (gfc_expr *matrix)
 
   gcc_assert (matrix->rank == 2);
 
+  if (matrix->shape == NULL)
+    return NULL;
+
   result = gfc_get_array_expr (matrix->ts.type, matrix->ts.kind,
 			       &matrix->where);
   result->rank = 2;
diff --git a/gcc/fortran/target-memory.c b/gcc/fortran/target-memory.c
index 7f209913028..a3ef392b5d7 100644
--- a/gcc/fortran/target-memory.c
+++ b/gcc/fortran/target-memory.c
@@ -534,6 +534,9 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu
 	{
 	  int n;
 
+	  if (cmp->as->type != AS_EXPLICIT)
+	    return 0;
+
 	  e->expr_type = EXPR_ARRAY;
 	  e->rank = cmp->as->rank;
 
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index 46fd1dda4c4..65f66b8cdd3 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -6611,7 +6611,14 @@ gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)
   /* Set the pointer itself if we aren't using the parameter directly.  */
   if (TREE_CODE (parm) != PARM_DECL)
     {
-      tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));
+      tmp = GFC_DECL_SAVED_DESCRIPTOR (parm);
+      if (sym->ts.type == BT_CLASS)
+	{
+	  tmp = build_fold_indirect_ref_loc (input_location, tmp);
+	  tmp = gfc_class_data_get (tmp);
+	  tmp = gfc_conv_descriptor_data_get (tmp);
+	}
+      tmp = convert (TREE_TYPE (parm), tmp);
       gfc_add_modify (&init, parm, tmp);
     }
   stmt = gfc_finish_block (&init);
@@ -6713,7 +6720,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,
       && VAR_P (sym->ts.u.cl->backend_decl))
     gfc_conv_string_length (sym->ts.u.cl, NULL, &init);
 
-  checkparm = (as->type == AS_EXPLICIT
+  /* TODO: Fix the exclusion of class arrays from extent checking.  */
+  checkparm = (as->type == AS_EXPLICIT && !is_classarray
 	       && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS));
 
   no_repack = !(GFC_DECL_PACKED_ARRAY (tmpdesc)
@@ -7531,9 +7539,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
 			 && expr->value.function.esym->attr.elemental)
 			|| (expr->value.function.isym != NULL
 			    && expr->value.function.isym->elemental)
+			|| (gfc_expr_attr (expr).proc_pointer
+			    && gfc_expr_attr (expr).elemental)
 			|| gfc_inline_intrinsic_function_p (expr));
-	  else
-	    gcc_assert (ss_type == GFC_SS_INTRINSIC);
 
 	  need_tmp = 1;
 	  if (expr->ts.type == BT_CHARACTER
@@ -7722,15 +7730,21 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
       /* Set the string_length for a character array.  */
       if (expr->ts.type == BT_CHARACTER)
 	{
-	  se->string_length =  gfc_get_expr_charlen (expr);
+	  if (deferred_array_component)
+	    se->string_length = ss_info->string_length;
+	  else
+	    se->string_length =  gfc_get_expr_charlen (expr);
+
 	  if (VAR_P (se->string_length)
 	      && expr->ts.u.cl->backend_decl == se->string_length)
 	    tmp = ss_info->string_length;
 	  else
 	    tmp = se->string_length;
 
-	  if (expr->ts.deferred)
+	  if (expr->ts.deferred && VAR_P (expr->ts.u.cl->backend_decl))
 	    gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl, tmp);
+	  else
+	    expr->ts.u.cl->backend_decl = tmp;
 	}
 
       /* If we have an array section or are assigning make sure that
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 529417fa8aa..8aa71ede989 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -737,6 +737,8 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
   /* Keep variables larger than max-stack-var-size off stack.  */
   if (!(sym->ns->proc_name && sym->ns->proc_name->attr.recursive)
       && !sym->attr.automatic
+      && sym->attr.save != SAVE_EXPLICIT
+      && sym->attr.save != SAVE_IMPLICIT
       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))
       && !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))
 	 /* Put variable length auto array pointers always into stack.  */
@@ -747,15 +749,21 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
 	  || sym->attr.allocatable)
       && !DECL_ARTIFICIAL (decl))
     {
-      if (flag_max_stack_var_size > 0)
+      if (flag_max_stack_var_size > 0
+	  && !(sym->ns->proc_name
+	       && sym->ns->proc_name->attr.is_main_program))
 	gfc_warning (OPT_Wsurprising,
-		     "Array %qs at %L is larger than limit set by"
-		     " %<-fmax-stack-var-size=%>, moved from stack to static"
-		     " storage. This makes the procedure unsafe when called"
-		     " recursively, or concurrently from multiple threads."
-		     " Consider using %<-frecursive%>, or increase the"
-		     " %<-fmax-stack-var-size=%> limit, or change the code to"
-		     " use an ALLOCATABLE array.",
+		     "Array %qs at %L is larger than limit set by "
+		     "%<-fmax-stack-var-size=%>, moved from stack to static "
+		     "storage. This makes the procedure unsafe when called "
+		     "recursively, or concurrently from multiple threads. "
+		     "Consider increasing the %<-fmax-stack-var-size=%> "
+		     "limit (or use %<-frecursive%>, which implies "
+		     "unlimited %<-fmax-stack-var-size%>) - or change the "
+		     "code to use an ALLOCATABLE array. If the variable is "
+		     "never accessed concurrently, this warning can be "
+		     "ignored, and the variable could also be declared with "
+		     "the SAVE attribute.",
 		     sym->name, &sym->declared_at);
 
       TREE_STATIC (decl) = 1;
@@ -1527,7 +1535,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)
      declaration of the entity and memory allocated/deallocated.  */
   if ((sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
       && sym->param_list != NULL
-      && !(sym->attr.host_assoc || sym->attr.use_assoc || sym->attr.dummy))
+      && gfc_current_ns == sym->ns
+      && !(sym->attr.use_assoc || sym->attr.dummy))
     gfc_defer_symbol_init (sym);
 
   /* Dummy PDT 'len' parameters should be checked when they are explicit.  */
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index c2321a9ff5f..c0ade411991 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1648,8 +1648,9 @@ gfc_trans_class_init_assign (gfc_code *code)
 	}
     }
 
-  if (code->expr1->symtree->n.sym->attr.optional
-      || code->expr1->symtree->n.sym->ns->proc_name->attr.entry_master)
+  if (code->expr1->symtree->n.sym->attr.dummy
+      && (code->expr1->symtree->n.sym->attr.optional
+	  || code->expr1->symtree->n.sym->ns->proc_name->attr.entry_master))
     {
       tree present = gfc_conv_expr_present (code->expr1->symtree->n.sym);
       tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),
@@ -2470,7 +2471,7 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)
 			     se.expr, build_zero_cst (TREE_TYPE (se.expr)));
   gfc_add_block_to_block (pblock, &se.pre);
 
-  if (cl->backend_decl)
+  if (cl->backend_decl && VAR_P (cl->backend_decl))
     gfc_add_modify (pblock, cl->backend_decl, se.expr);
   else
     cl->backend_decl = gfc_evaluate_now (se.expr, pblock);
@@ -2536,7 +2537,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,
   if (!CONSTANT_CLASS_P (tmp) && !DECL_P (tmp))
     end.expr = gfc_evaluate_now (end.expr, &se->pre);
 
-  if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)
+  if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)
+      && (ref->u.ss.start->symtree
+	  && !ref->u.ss.start->symtree->n.sym->attr.implied_index))
     {
       tree nonempty = fold_build2_loc (input_location, LE_EXPR,
 				       logical_type_node, start.expr,
@@ -2669,7 +2672,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
   /* Allocatable deferred char arrays are to be handled by the gfc_deferred_
      strlen () conditional below.  */
   if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
-      && !(c->attr.allocatable && c->ts.deferred)
+      && !c->ts.deferred
       && !c->attr.pdt_string)
     {
       tmp = c->ts.u.cl->backend_decl;
@@ -5770,7 +5773,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				     CLASS_DATA (fsym)->attr.class_pointer
 				     || CLASS_DATA (fsym)->attr.allocatable);
 	}
-      else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS)
+      else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS
+	       && e->ts.type != BT_PROCEDURE
+	       && (gfc_expr_attr (e).flavor != FL_PROCEDURE
+		   || gfc_expr_attr (e).proc != PROC_UNKNOWN))
 	{
 	  /* The intrinsic type needs to be converted to a temporary
 	     CLASS object for the unlimited polymorphic formal.  */
@@ -5958,11 +5964,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 			    || (!e->value.function.esym
 				&& e->symtree->n.sym->attr.pointer))
 			&& fsym && fsym->attr.target)
-		{
-		  gfc_conv_expr (&parmse, e);
-		  parmse.expr = gfc_build_addr_expr (NULL_TREE, parmse.expr);
-		}
-
+		/* Make sure the function only gets called once.  */
+		gfc_conv_expr_reference (&parmse, e, false);
 	      else if (e->expr_type == EXPR_FUNCTION
 		       && e->symtree->n.sym->result
 		       && e->symtree->n.sym->result != e->symtree->n.sym
@@ -6072,6 +6075,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		      bool add_clobber;
 		      add_clobber = fsym && fsym->attr.intent == INTENT_OUT
 			&& !fsym->attr.allocatable && !fsym->attr.pointer
+			&& e->symtree && e->symtree->n.sym
 			&& !e->symtree->n.sym->attr.dimension
 			&& !e->symtree->n.sym->attr.pointer
 			&& !e->symtree->n.sym->attr.allocatable
@@ -6364,6 +6368,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 
+	      else if (e->ts.type == BT_CLASS && CLASS_DATA (e)->as
+		       && CLASS_DATA (e)->as->type == AS_ASSUMED_SIZE
+		       && nodesc_arg && fsym->ts.type == BT_DERIVED)
+		/* An assumed size class actual argument being passed to
+		   a 'no descriptor' formal argument just requires the
+		   data pointer to be passed. For class dummy arguments
+		   this is stored in the symbol backend decl..  */
+		parmse.expr = e->symtree->n.sym->backend_decl;
+
 	      else if (gfc_is_class_array_ref (e, NULL)
 		       && fsym && fsym->ts.type == BT_DERIVED)
 		/* The actual argument is a component reference to an
@@ -6435,6 +6448,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    // deallocate the components first
 		    tmp = gfc_deallocate_alloc_comp (fsym->ts.u.derived,
 						     parmse.expr, e->rank);
+		    /* But check whether dummy argument is optional.  */
+		    if (tmp != NULL_TREE
+			&& fsym->attr.optional
+			&& e->expr_type == EXPR_VARIABLE
+			&& e->symtree->n.sym->attr.optional)
+		      {
+			tree present;
+			present = gfc_conv_expr_present (e->symtree->n.sym);
+			tmp = build3_v (COND_EXPR, present, tmp,
+					build_empty_stmt (input_location));
+		      }
 		    if (tmp != NULL_TREE)
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		  }
@@ -11046,7 +11070,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 		       || gfc_is_class_array_ref (expr1, NULL)
 		       || gfc_is_class_scalar_expr (expr1)
 		       || gfc_is_class_array_ref (expr2, NULL)
-		       || gfc_is_class_scalar_expr (expr2));
+		       || gfc_is_class_scalar_expr (expr2))
+		   && lhs_attr.flavor != FL_PROCEDURE;
 
   realloc_flag = flag_realloc_lhs
 		 && gfc_is_reallocatable_lhs (expr1)
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 29f8f932aa3..aa396691c9c 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -4411,6 +4411,18 @@ rad2deg (int kind)
 }
 
 
+static gfc_intrinsic_map_t *
+gfc_lookup_intrinsic (gfc_isym_id id)
+{
+  gfc_intrinsic_map_t *m = gfc_intrinsic_map;
+  for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)
+    if (id == m->id)
+      break;
+  gcc_assert (id == m->id);
+  return m;
+}
+
+
 /* ACOSD(x) is translated into ACOS(x) * 180 / pi.
    ASIND(x) is translated into ASIN(x) * 180 / pi.
    ATAND(x) is translated into ATAN(x) * 180 / pi.  */
@@ -4421,20 +4433,27 @@ gfc_conv_intrinsic_atrigd (gfc_se * se, gfc_expr * expr, gfc_isym_id id)
   tree arg;
   tree atrigd;
   tree type;
+  gfc_intrinsic_map_t *m;
 
   type = gfc_typenode_for_spec (&expr->ts);
 
   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);
 
-  if (id == GFC_ISYM_ACOSD)
-    atrigd = gfc_builtin_decl_for_float_kind (BUILT_IN_ACOS, expr->ts.kind);
-  else if (id == GFC_ISYM_ASIND)
-    atrigd = gfc_builtin_decl_for_float_kind (BUILT_IN_ASIN, expr->ts.kind);
-  else if (id == GFC_ISYM_ATAND)
-    atrigd = gfc_builtin_decl_for_float_kind (BUILT_IN_ATAN, expr->ts.kind);
-  else
-    gcc_unreachable ();
-
+  switch (id)
+    {
+    case GFC_ISYM_ACOSD:
+      m = gfc_lookup_intrinsic (GFC_ISYM_ACOS);
+      break;
+    case GFC_ISYM_ASIND:
+      m = gfc_lookup_intrinsic (GFC_ISYM_ASIN);
+      break;
+    case GFC_ISYM_ATAND:
+      m = gfc_lookup_intrinsic (GFC_ISYM_ATAN);
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  atrigd = gfc_get_intrinsic_lib_fndecl (m, expr);
   atrigd = build_call_expr_loc (input_location, atrigd, 1, arg);
 
   se->expr = fold_build2_loc (input_location, MULT_EXPR, type, atrigd,
@@ -4470,13 +4489,9 @@ gfc_conv_intrinsic_cotan (gfc_se *se, gfc_expr *expr)
       mpfr_clear (pio2);
 
       /* Find tan builtin function.  */
-      m = gfc_intrinsic_map;
-      for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)
-	if (GFC_ISYM_TAN == m->id)
-	  break;
-
-      tmp = fold_build2_loc (input_location, PLUS_EXPR, type, arg, tmp);
+      m = gfc_lookup_intrinsic (GFC_ISYM_TAN);
       tan = gfc_get_intrinsic_lib_fndecl (m, expr);
+      tmp = fold_build2_loc (input_location, PLUS_EXPR, type, arg, tmp);
       tan = build_call_expr_loc (input_location, tan, 1, tmp);
       se->expr = fold_build1_loc (input_location, NEGATE_EXPR, type, tan);
     }
@@ -4486,20 +4501,12 @@ gfc_conv_intrinsic_cotan (gfc_se *se, gfc_expr *expr)
       tree cos;
 
       /* Find cos builtin function.  */
-      m = gfc_intrinsic_map;
-      for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)
-	if (GFC_ISYM_COS == m->id)
-	  break;
-
+      m = gfc_lookup_intrinsic (GFC_ISYM_COS);
       cos = gfc_get_intrinsic_lib_fndecl (m, expr);
       cos = build_call_expr_loc (input_location, cos, 1, arg);
 
       /* Find sin builtin function.  */
-      m = gfc_intrinsic_map;
-      for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)
-	if (GFC_ISYM_SIN == m->id)
-	  break;
-
+      m = gfc_lookup_intrinsic (GFC_ISYM_SIN);
       sin = gfc_get_intrinsic_lib_fndecl (m, expr);
       sin = build_call_expr_loc (input_location, sin, 1, arg);
 
@@ -4531,11 +4538,7 @@ gfc_conv_intrinsic_cotand (gfc_se *se, gfc_expr *expr)
   mpfr_clear (ninety);
 
   /* Find tand.  */
-  gfc_intrinsic_map_t *m = gfc_intrinsic_map;
-  for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)
-    if (GFC_ISYM_TAND == m->id)
-      break;
-
+  gfc_intrinsic_map_t *m = gfc_lookup_intrinsic (GFC_ISYM_TAND);
   tree tand = gfc_get_intrinsic_lib_fndecl (m, expr);
   tand = build_call_expr_loc (input_location, tand, 1, arg);
 
@@ -4555,7 +4558,8 @@ gfc_conv_intrinsic_atan2d (gfc_se *se, gfc_expr *expr)
   gfc_conv_intrinsic_function_args (se, expr, args, 2);
   type = TREE_TYPE (args[0]);
 
-  atan2d = gfc_builtin_decl_for_float_kind (BUILT_IN_ATAN2, expr->ts.kind);
+  gfc_intrinsic_map_t *m = gfc_lookup_intrinsic (GFC_ISYM_ATAN2);
+  atan2d = gfc_get_intrinsic_lib_fndecl (m, expr);
   atan2d = build_call_expr_loc (input_location, atan2d, 2, args[0], args[1]);
 
   se->expr = fold_build2_loc (input_location, MULT_EXPR, type, atan2d,
@@ -8822,7 +8826,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)
   else
     {
       /* An optional target.  */
-      if (arg2->expr->ts.type == BT_CLASS)
+      if (arg2->expr->ts.type == BT_CLASS
+	  && arg2->expr->expr_type != EXPR_FUNCTION)
 	gfc_add_data_component (arg2->expr);
 
       if (scalar)
@@ -8843,6 +8848,11 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)
 	      && arg2->expr->symtree->n.sym->attr.dummy)
 	    arg2se.expr = build_fold_indirect_ref_loc (input_location,
 						       arg2se.expr);
+	  if (arg2->expr->ts.type == BT_CLASS)
+	    {
+	      arg2se.expr = gfc_evaluate_now (arg2se.expr, &arg2se.pre);
+	      arg2se.expr = gfc_class_data_get (arg2se.expr);
+	    }
 	  gfc_add_block_to_block (&se->pre, &arg1se.pre);
 	  gfc_add_block_to_block (&se->post, &arg1se.post);
 	  gfc_add_block_to_block (&se->pre, &arg2se.pre);
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index a425c98c076..27d885d1c89 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -1757,7 +1757,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
       if (e->ts.type == BT_CLASS)
 	{
 	  /* Go straight to the class data.  */
-	  if (sym2->attr.dummy)
+	  if (sym2->attr.dummy && !sym2->attr.optional)
 	    {
 	      class_decl = DECL_LANG_SPECIFIC (sym2->backend_decl) ?
 			   GFC_DECL_SAVED_DESCRIPTOR (sym2->backend_decl) :
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index d3fef08b4b9..24758ddadee 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1618,7 +1618,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,
       GFC_TYPE_ARRAY_STRIDE (type, n) = tmp;
 
       expr = as->lower[n];
-      if (expr->expr_type == EXPR_CONSTANT)
+      if (expr && expr->expr_type == EXPR_CONSTANT)
         {
           tmp = gfc_conv_mpz_to_tree (expr->value.integer,
 				      gfc_index_integer_kind);
@@ -1668,7 +1668,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,
   for (n = as->rank; n < as->rank + as->corank; n++)
     {
       expr = as->lower[n];
-      if (expr->expr_type == EXPR_CONSTANT)
+      if (expr && expr->expr_type == EXPR_CONSTANT)
 	tmp = gfc_conv_mpz_to_tree (expr->value.integer,
 				    gfc_index_integer_kind);
       else
@@ -3115,14 +3115,14 @@ gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 	vec_safe_push (typelist, boolean_type_node);
       /* Coarrays which are descriptorless or assumed-shape pass with
 	 -fcoarray=lib the token and the offset as hidden arguments.  */
-      else if (arg
-	       && flag_coarray == GFC_FCOARRAY_LIB
-	       && ((arg->ts.type != BT_CLASS
-		    && arg->attr.codimension
-		    && !arg->attr.allocatable)
-		   || (arg->ts.type == BT_CLASS
-		       && CLASS_DATA (arg)->attr.codimension
-		       && !CLASS_DATA (arg)->attr.allocatable)))
+      if (arg
+	  && flag_coarray == GFC_FCOARRAY_LIB
+	  && ((arg->ts.type != BT_CLASS
+	       && arg->attr.codimension
+	       && !arg->attr.allocatable)
+	      || (arg->ts.type == BT_CLASS
+		  && CLASS_DATA (arg)->attr.codimension
+		  && !CLASS_DATA (arg)->attr.allocatable)))
 	{
 	  vec_safe_push (typelist, pvoid_type_node);  /* caf_token.  */
 	  vec_safe_push (typelist, gfc_array_index_type);  /* caf_offset.  */
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index da3536ecd4e..912540dc8a7 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -445,7 +445,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)
 					   CONSTRUCTOR_ELTS (rhs));
 	  }
 
-	else if (DECL_P (rhs))
+	else if (DECL_P (rhs)
+		 && is_gimple_reg_type (TREE_TYPE (rhs)))
 	  return get_symbol_constant_value (rhs);
       }
       break;
@@ -4840,6 +4841,7 @@ static bool
 maybe_canonicalize_mem_ref_addr (tree *t, bool is_debug = false)
 {
   bool res = false;
+  tree *orig_t = t;
 
   if (TREE_CODE (*t) == ADDR_EXPR)
     t = &TREE_OPERAND (*t, 0);
@@ -4952,6 +4954,8 @@ maybe_canonicalize_mem_ref_addr (tree *t, bool is_debug = false)
       if (tem)
 	{
 	  *t = tem;
+	  if (TREE_CODE (*orig_t) == ADDR_EXPR)
+	    recompute_tree_invariant_for_addr_expr (*orig_t);
 	  res = true;
 	}
     }
diff --git a/gcc/gimple-loop-interchange.cc b/gcc/gimple-loop-interchange.cc
index 2379848808f..6f9f612b39f 100644
--- a/gcc/gimple-loop-interchange.cc
+++ b/gcc/gimple-loop-interchange.cc
@@ -1044,7 +1044,10 @@ tree_loop_interchange::valid_data_dependences (unsigned i_idx, unsigned o_idx,
 
 	  /* Be conservative, skip case if either direction at i_idx/o_idx
 	     levels is not '=' or '<'.  */
-	  if (dist_vect[i_idx] < 0 || dist_vect[o_idx] < 0)
+	  if ((!DDR_REVERSED_P (ddr) && dist_vect[i_idx] < 0)
+	      || (DDR_REVERSED_P (ddr) && dist_vect[i_idx] > 0)
+	      || (!DDR_REVERSED_P (ddr) && dist_vect[o_idx] < 0)
+	      || (DDR_REVERSED_P (ddr) && dist_vect[o_idx] > 0))
 	    return false;
 	}
     }
diff --git a/gcc/gimple-ssa-evrp-analyze.c b/gcc/gimple-ssa-evrp-analyze.c
index 9f8ce5575a2..8389a58b00d 100644
--- a/gcc/gimple-ssa-evrp-analyze.c
+++ b/gcc/gimple-ssa-evrp-analyze.c
@@ -220,7 +220,11 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)
 	      push_value_range (vrs[i].first, vrs[i].second);
 	      if (is_fallthru
 		  && m_update_global_ranges
-		  && all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt))
+		  && all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt)
+		  /* The condition must post-dominate the definition point.  */
+		  && (SSA_NAME_IS_DEFAULT_DEF (vrs[i].first)
+		      || (gimple_bb (SSA_NAME_DEF_STMT (vrs[i].first))
+			  == pred_e->src)))
 		{
 		  set_ssa_range_info (vrs[i].first, vrs[i].second);
 		  maybe_set_nonzero_bits (pred_e, vrs[i].first);
diff --git a/gcc/go/gofrontend/expressions.cc b/gcc/go/gofrontend/expressions.cc
index 8f59b18d47f..f27375d52a6 100644
--- a/gcc/go/gofrontend/expressions.cc
+++ b/gcc/go/gofrontend/expressions.cc
@@ -9075,7 +9075,7 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,
               ref2 = Expression::make_cast(uint_type, ref2, loc);
               cond = Expression::make_binary(OPERATOR_GT, ref, ref2, loc);
               zero = Expression::make_integer_ul(0, int_type, loc);
-              call = Expression::make_conditional(cond, call, zero, loc);
+              call = Expression::make_conditional(cond, zero, call, loc);
             }
         }
       else
diff --git a/gcc/ipa-fnsummary.c b/gcc/ipa-fnsummary.c
index 1105f6ae5c2..825db3c973d 100644
--- a/gcc/ipa-fnsummary.c
+++ b/gcc/ipa-fnsummary.c
@@ -4239,13 +4239,20 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,
       bp = streamer_read_bitpack (&ib);
       if (info)
 	{
-          info->inlinable = bp_unpack_value (&bp, 1);
-          info->fp_expressions = bp_unpack_value (&bp, 1);
+	  info->inlinable = bp_unpack_value (&bp, 1);
+	  /* On the side of streaming out, there is still one bit
+	     streamed out between inlinable and fp_expressions bits,
+	     which was used for cilk+ before but now always false.
+	     To remove the bit packing need to bump LTO minor version,
+	     so unpack a dummy bit here to keep consistent instead.  */
+	  bp_unpack_value (&bp, 1);
+	  info->fp_expressions = bp_unpack_value (&bp, 1);
 	}
       else
 	{
-          bp_unpack_value (&bp, 1);
-          bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
 	}
 
       count2 = streamer_read_uhwi (&ib);
diff --git a/gcc/ipa-param-manipulation.c b/gcc/ipa-param-manipulation.c
index fbeea454084..2ec4517420e 100644
--- a/gcc/ipa-param-manipulation.c
+++ b/gcc/ipa-param-manipulation.c
@@ -1676,7 +1676,9 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p)
       if (tree lhs = gimple_call_lhs (stmt))
 	{
 	  modify_expression (&lhs, false);
-	  gimple_call_set_lhs (new_stmt, lhs);
+	  /* Avoid adjusting SSA_NAME_DEF_STMT of a SSA lhs, SSA names
+	     have not yet been remapped.  */
+	  *gimple_call_lhs_ptr (new_stmt) = lhs;
 	}
       *stmt_p = new_stmt;
       return true;
diff --git a/gcc/ipa-pure-const.c b/gcc/ipa-pure-const.c
index 564c6629c92..890826aea4c 100644
--- a/gcc/ipa-pure-const.c
+++ b/gcc/ipa-pure-const.c
@@ -1665,9 +1665,9 @@ propagate_pure_const (void)
 	  if (w_l->state_previously_known != IPA_NEITHER
 	      && this_state > w_l->state_previously_known)
 	    {
-              this_state = w_l->state_previously_known;
 	      if (this_state == IPA_NEITHER)
-	        this_looping = w_l->looping_previously_known;
+		this_looping = w_l->looping_previously_known;
+	      this_state = w_l->state_previously_known;
 	    }
 	  if (!this_looping && self_recursive_p (w))
 	    this_looping = true;
diff --git a/gcc/ipa-sra.c b/gcc/ipa-sra.c
index b706fceff42..2f7fa9f9fc8 100644
--- a/gcc/ipa-sra.c
+++ b/gcc/ipa-sra.c
@@ -340,7 +340,7 @@ class isra_call_summary
 public:
   isra_call_summary ()
     : m_arg_flow (), m_return_ignored (false), m_return_returned (false),
-      m_bit_aligned_arg (false)
+      m_bit_aligned_arg (false), m_before_any_store (false)
   {}
 
   void init_inputs (unsigned arg_count);
@@ -359,6 +359,10 @@ public:
 
   /* Set when any of the call arguments are not byte-aligned.  */
   unsigned m_bit_aligned_arg : 1;
+
+  /* Set to true if the call happend before any (other) store to memory in the
+     caller.  */
+  unsigned m_before_any_store : 1;
 };
 
 /* Class to manage function summaries.  */
@@ -472,6 +476,8 @@ isra_call_summary::dump (FILE *f)
     fprintf (f, "    return value ignored\n");
   if (m_return_returned)
     fprintf (f, "    return value used only to compute caller return value\n");
+  if (m_before_any_store)
+    fprintf (f, "    happens before any store to memory\n");
   for (unsigned i = 0; i < m_arg_flow.length (); i++)
     {
       fprintf (f, "    Parameter %u:\n", i);
@@ -516,6 +522,7 @@ ipa_sra_call_summaries::duplicate (cgraph_edge *, cgraph_edge *,
   new_sum->m_return_ignored = old_sum->m_return_ignored;
   new_sum->m_return_returned = old_sum->m_return_returned;
   new_sum->m_bit_aligned_arg = old_sum->m_bit_aligned_arg;
+  new_sum->m_before_any_store = old_sum->m_before_any_store;
 }
 
 
@@ -979,15 +986,17 @@ ptr_parm_has_nonarg_uses (cgraph_node *node, function *fun, tree parm,
       if (gimple_assign_single_p (stmt))
 	{
 	  tree rhs = gimple_assign_rhs1 (stmt);
-	  while (handled_component_p (rhs))
-	    rhs = TREE_OPERAND (rhs, 0);
-	  if (TREE_CODE (rhs) == MEM_REF
-	      && TREE_OPERAND (rhs, 0) == name
-	      && integer_zerop (TREE_OPERAND (rhs, 1))
-	      && types_compatible_p (TREE_TYPE (rhs),
-				     TREE_TYPE (TREE_TYPE (name)))
-	      && !TREE_THIS_VOLATILE (rhs))
-	    uses_ok++;
+	  if (!TREE_THIS_VOLATILE (rhs))
+	    {
+	      while (handled_component_p (rhs))
+		rhs = TREE_OPERAND (rhs, 0);
+	      if (TREE_CODE (rhs) == MEM_REF
+		  && TREE_OPERAND (rhs, 0) == name
+		  && integer_zerop (TREE_OPERAND (rhs, 1))
+		  && types_compatible_p (TREE_TYPE (rhs),
+					 TREE_TYPE (TREE_TYPE (name))))
+		uses_ok++;
+	    }
 	}
       else if (is_gimple_call (stmt))
 	{
@@ -1021,15 +1030,17 @@ ptr_parm_has_nonarg_uses (cgraph_node *node, function *fun, tree parm,
 		  continue;
 		}
 
-	      while (handled_component_p (arg))
-		arg = TREE_OPERAND (arg, 0);
-	      if (TREE_CODE (arg) == MEM_REF
-		  && TREE_OPERAND (arg, 0) == name
-		  && integer_zerop (TREE_OPERAND (arg, 1))
-		  && types_compatible_p (TREE_TYPE (arg),
-					 TREE_TYPE (TREE_TYPE (name)))
-		  && !TREE_THIS_VOLATILE (arg))
-		uses_ok++;
+	      if (!TREE_THIS_VOLATILE (arg))
+		{
+		  while (handled_component_p (arg))
+		    arg = TREE_OPERAND (arg, 0);
+		  if (TREE_CODE (arg) == MEM_REF
+		      && TREE_OPERAND (arg, 0) == name
+		      && integer_zerop (TREE_OPERAND (arg, 1))
+		      && types_compatible_p (TREE_TYPE (arg),
+					     TREE_TYPE (TREE_TYPE (name))))
+		    uses_ok++;
+		}
 	    }
 	}
 
@@ -1901,7 +1912,8 @@ scan_function (cgraph_node *node, struct function *fun)
 		if (lhs)
 		  scan_expr_access (lhs, stmt, ISRA_CTX_STORE, bb);
 		int flags = gimple_call_flags (stmt);
-		if ((flags & (ECF_CONST | ECF_PURE)) == 0)
+		if (((flags & (ECF_CONST | ECF_PURE)) == 0)
+		    || (flags & ECF_LOOPING_CONST_OR_PURE))
 		  bitmap_set_bit (final_bbs, bb->index);
 	      }
 	      break;
@@ -2355,6 +2367,7 @@ process_scan_results (cgraph_node *node, struct function *fun,
 	unsigned count = gimple_call_num_args (call_stmt);
 	isra_call_summary *csum = call_sums->get_create (cs);
 	csum->init_inputs (count);
+	csum->m_before_any_store = uses_memory_as_obtained;
 	for (unsigned argidx = 0; argidx < count; argidx++)
 	  {
 	    if (!csum->m_arg_flow[argidx].pointer_pass_through)
@@ -2601,6 +2614,7 @@ isra_write_edge_summary (output_block *ob, cgraph_edge *e)
   bp_pack_value (&bp, csum->m_return_ignored, 1);
   bp_pack_value (&bp, csum->m_return_returned, 1);
   bp_pack_value (&bp, csum->m_bit_aligned_arg, 1);
+  bp_pack_value (&bp, csum->m_before_any_store, 1);
   streamer_write_bitpack (&bp);
 }
 
@@ -2719,6 +2733,7 @@ isra_read_edge_summary (struct lto_input_block *ib, cgraph_edge *cs)
   csum->m_return_ignored = bp_unpack_value (&bp, 1);
   csum->m_return_returned = bp_unpack_value (&bp, 1);
   csum->m_bit_aligned_arg = bp_unpack_value (&bp, 1);
+  csum->m_before_any_store = bp_unpack_value (&bp, 1);
 }
 
 /* Read intraprocedural analysis information about NODE and all of its outgoing
@@ -3475,7 +3490,8 @@ param_splitting_across_edge (cgraph_edge *cs)
 	    }
 	  else if (!ipf->safe_to_import_accesses)
 	    {
-	      if (!all_callee_accesses_present_p (param_desc, arg_desc))
+	      if (!csum->m_before_any_store
+		  || !all_callee_accesses_present_p (param_desc, arg_desc))
 		{
 		  if (dump_file && (dump_flags & TDF_DETAILS))
 		    fprintf (dump_file, "  %u->%u: cannot import accesses.\n",
diff --git a/gcc/jit/ChangeLog b/gcc/jit/ChangeLog
index a8bc5cea3e6..3f2abe51c29 100644
--- a/gcc/jit/ChangeLog
+++ b/gcc/jit/ChangeLog
@@ -1,3 +1,10 @@
+2021-11-24  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2021-11-24  Martin Liska  <mliska@suse.cz>
+
+	* jit-playback.c (function): Initialize m_blocks vector.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/jit/jit-playback.c b/gcc/jit/jit-playback.c
index d2c8bb4c154..0d21251c9ab 100644
--- a/gcc/jit/jit-playback.c
+++ b/gcc/jit/jit-playback.c
@@ -1357,7 +1357,8 @@ function (context *ctxt,
 : m_ctxt(ctxt),
   m_inner_fndecl (fndecl),
   m_inner_bind_expr (NULL),
-  m_kind (kind)
+  m_kind (kind),
+  m_blocks ()
 {
   if (m_kind != GCC_JIT_FUNCTION_IMPORTED)
     {
diff --git a/gcc/jump.c b/gcc/jump.c
index 34a8f209e20..803c297b0fc 100644
--- a/gcc/jump.c
+++ b/gcc/jump.c
@@ -1767,6 +1767,11 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       /* We can't assume nonlocal labels have their following insns yet.  */
       if (LABEL_REF_NONLOCAL_P (x) || LABEL_REF_NONLOCAL_P (y))
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
index 7cc479b3042..30d088afbca 100644
--- a/gcc/lra-constraints.c
+++ b/gcc/lra-constraints.c
@@ -235,12 +235,17 @@ get_reg_class (int regno)
    CL.  Use elimination first if REG is a hard register.  If REG is a
    reload pseudo created by this constraints pass, assume that it will
    be allocated a hard register from its allocno class, but allow that
-   class to be narrowed to CL if it is currently a superset of CL.
+   class to be narrowed to CL if it is currently a superset of CL and
+   if either:
+
+   - ALLOW_ALL_RELOAD_CLASS_CHANGES_P is true or
+   - the instruction we're processing is not a reload move.
 
    If NEW_CLASS is nonnull, set *NEW_CLASS to the new allocno class of
    REGNO (reg), or NO_REGS if no change in its class was needed.  */
 static bool
-in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)
+in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class,
+	    bool allow_all_reload_class_changes_p = false)
 {
   enum reg_class rclass, common_class;
   machine_mode reg_mode;
@@ -267,7 +272,8 @@ in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)
 	 typically moves that have many alternatives, and restricting
 	 reload pseudos for one alternative may lead to situations
 	 where other reload pseudos are no longer allocatable.  */
-      || (INSN_UID (curr_insn) >= new_insn_uid_start
+      || (!allow_all_reload_class_changes_p
+	  && INSN_UID (curr_insn) >= new_insn_uid_start
 	  && src != NULL
 	  && ((REG_P (src) || MEM_P (src))
 	      || (GET_CODE (src) == SUBREG
@@ -570,13 +576,12 @@ init_curr_insn_input_reloads (void)
   curr_insn_input_reloads_num = 0;
 }
 
-/* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse already
-   created input reload pseudo (only if TYPE is not OP_OUT).  Don't
-   reuse pseudo if IN_SUBREG_P is true and the reused pseudo should be
-   wrapped up in SUBREG.  The result pseudo is returned through
-   RESULT_REG.  Return TRUE if we created a new pseudo, FALSE if we
-   reused the already created input reload pseudo.  Use TITLE to
-   describe new registers for debug purposes.  */
+/* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse an existing
+   reload pseudo.  Don't reuse an existing reload pseudo if IN_SUBREG_P
+   is true and the reused pseudo should be wrapped up in a SUBREG.
+   The result pseudo is returned through RESULT_REG.  Return TRUE if we
+   created a new pseudo, FALSE if we reused an existing reload pseudo.
+   Use TITLE to describe new registers for debug purposes.  */
 static bool
 get_reload_reg (enum op_type type, machine_mode mode, rtx original,
 		enum reg_class rclass, bool in_subreg_p,
@@ -588,6 +593,40 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,
 
   if (type == OP_OUT)
     {
+      /* Output reload registers tend to start out with a conservative
+	 choice of register class.  Usually this is ALL_REGS, although
+	 a target might narrow it (for performance reasons) through
+	 targetm.preferred_reload_class.  It's therefore quite common
+	 for a reload instruction to require a more restrictive class
+	 than the class that was originally assigned to the reload register.
+
+	 In these situations, it's more efficient to refine the choice
+	 of register class rather than create a second reload register.
+	 This also helps to avoid cycling for registers that are only
+	 used by reload instructions.  */
+      rtx src = curr_insn_set != NULL ? SET_SRC (curr_insn_set) : NULL;
+      if (REG_P (original)
+	  && (int) REGNO (original) >= new_regno_start
+	  && INSN_UID (curr_insn) >= new_insn_uid_start
+	  && in_class_p (original, rclass, &new_class, true)
+	  && src != NULL
+	  && ((REG_P (src) || MEM_P (src))
+	      || (GET_CODE (src) == SUBREG
+		  && (REG_P (SUBREG_REG (src)) || MEM_P (SUBREG_REG (src))))))
+	{
+	  unsigned int regno = REGNO (original);
+	  if (lra_dump_file != NULL)
+	    {
+	      fprintf (lra_dump_file, "	 Reuse r%d for output ", regno);
+	      dump_value_slim (lra_dump_file, original, 1);
+	    }
+	  if (new_class != lra_get_allocno_class (regno))
+	    lra_change_class (regno, new_class, ", change to", false);
+	  if (lra_dump_file != NULL)
+	    fprintf (lra_dump_file, "\n");
+	  *result_reg = original;
+	  return false;
+	}
       *result_reg
 	= lra_create_new_reg_with_unique_value (mode, original, rclass, title);
       return true;
@@ -751,6 +790,11 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)
     CASE_CONST_UNIQUE:
       return false;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       return label_ref_label (x) == label_ref_label (y);
     case SYMBOL_REF:
@@ -1014,7 +1058,7 @@ match_reload (signed char out, signed char *ins, signed char *outs,
 	  for (i = 0; outs[i] >= 0; i++)
 	    {
 	      rtx other_out_rtx = *curr_id->operand_loc[outs[i]];
-	      if (REG_P (other_out_rtx)
+	      if (outs[i] != out && REG_P (other_out_rtx)
 		  && (regno_val_use_in (REGNO (in_rtx), other_out_rtx)
 		      != NULL_RTX))
 		{
@@ -4262,7 +4306,10 @@ curr_insn_transform (bool check_only_p)
       }
 
   n_outputs = 0;
-  outputs[0] = -1;
+  for (i = 0; i < n_operands; i++)
+    if (curr_static_id->operand[i].type == OP_OUT)
+      outputs[n_outputs++] = i;
+  outputs[n_outputs] = -1;
   for (i = 0; i < n_operands; i++)
     {
       int regno;
@@ -4337,8 +4384,6 @@ curr_insn_transform (bool check_only_p)
 		     lra-lives.c.  */
 		  match_reload (i, goal_alt_matched[i], outputs, goal_alt[i], &before,
 				&after, TRUE);
-		  outputs[n_outputs++] = i;
-		  outputs[n_outputs] = -1;
 		}
 	      continue;
 	    }
@@ -4509,14 +4554,6 @@ curr_insn_transform (bool check_only_p)
 	   process_alt_operands decides that it is possible.  */
 	gcc_unreachable ();
 
-      /* Memorise processed outputs so that output remaining to be processed
-	 can avoid using the same register value (see match_reload).  */
-      if (curr_static_id->operand[i].type == OP_OUT)
-	{
-	  outputs[n_outputs++] = i;
-	  outputs[n_outputs] = -1;
-	}
-
       if (optional_p)
 	{
 	  rtx reg = op;
diff --git a/gcc/lra-eliminations.c b/gcc/lra-eliminations.c
index cf745dc6a26..7c70cc00f1f 100644
--- a/gcc/lra-eliminations.c
+++ b/gcc/lra-eliminations.c
@@ -885,7 +885,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,
 			poly_int64 update_sp_offset)
 {
   int icode = recog_memoized (insn);
-  rtx old_set = single_set (insn);
+  rtx set, old_set = single_set (insn);
   bool validate_p;
   int i;
   rtx substed_operand[MAX_RECOG_OPERANDS];
@@ -1038,6 +1038,35 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,
   for (i = 0; i < static_id->n_dups; i++)
     *id->dup_loc[i] = substed_operand[(int) static_id->dup_num[i]];
 
+  /* Transform plus (plus (hard reg, const), pseudo) to plus (plus (pseudo,
+     const), hard reg) in order to keep insn containing eliminated register
+     after all reloads calculating its offset.  This permits to keep register
+     pressure under control and helps to avoid LRA cycling in patalogical
+     cases.  */
+  if (! replace_p && (set = single_set (insn)) != NULL
+      && GET_CODE (SET_SRC (set)) == PLUS
+      && GET_CODE (XEXP (SET_SRC (set), 0)) == PLUS)
+    {
+      rtx reg1, reg2, op1, op2;
+      
+      reg1 = op1 = XEXP (XEXP (SET_SRC (set), 0), 0);
+      reg2 = op2 = XEXP (SET_SRC (set), 1);
+      if (GET_CODE (reg1) == SUBREG)
+	reg1 = SUBREG_REG (reg1);
+      if (GET_CODE (reg2) == SUBREG)
+	reg2 = SUBREG_REG (reg2);
+      if (REG_P (reg1) && REG_P (reg2)
+	  && REGNO (reg1) < FIRST_PSEUDO_REGISTER
+	  && REGNO (reg2) >= FIRST_PSEUDO_REGISTER
+	  && GET_MODE (reg1) == Pmode
+	  && !have_addptr3_insn (lra_pmode_pseudo, reg1,
+				 XEXP (XEXP (SET_SRC (set), 0), 1)))
+	{
+	  XEXP (XEXP (SET_SRC (set), 0), 0) = op2;
+	  XEXP (SET_SRC (set), 1) = op1;
+	}
+    }
+
   /* If we had a move insn but now we don't, re-recognize it.
      This will cause spurious re-recognition if the old move had a
      PARALLEL since the new one still will, but we can't call
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index 01fcbfa2664..c24a98fc244 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -326,6 +326,7 @@ extern void lra_register_new_scratch_op (rtx_insn *, int, int);
 extern int lra_new_regno_start;
 extern int lra_constraint_new_regno_start;
 extern int lra_bad_spill_regno_start;
+extern rtx lra_pmode_pseudo;
 extern bitmap_head lra_inheritance_pseudos;
 extern bitmap_head lra_split_regs;
 extern bitmap_head lra_subreg_reload_pseudos;
diff --git a/gcc/lra.c b/gcc/lra.c
index 3543ce3993c..2d40471a4a1 100644
--- a/gcc/lra.c
+++ b/gcc/lra.c
@@ -2306,6 +2306,9 @@ int lra_constraint_new_regno_start;
    it is possible.  */
 int lra_bad_spill_regno_start;
 
+/* A pseudo of Pmode.  */
+rtx lra_pmode_pseudo;
+
 /* Inheritance pseudo regnos before the new spill pass.	 */
 bitmap_head lra_inheritance_pseudos;
 
@@ -2366,6 +2369,7 @@ lra (FILE *f)
 
   lra_dump_file = f;
   lra_asm_error_p = false;
+  lra_pmode_pseudo = gen_reg_rtx (Pmode);
   
   timevar_push (TV_LRA);
 
diff --git a/gcc/lto-streamer.h b/gcc/lto-streamer.h
index 03440f0254c..7ac3b63fd33 100644
--- a/gcc/lto-streamer.h
+++ b/gcc/lto-streamer.h
@@ -121,7 +121,7 @@ along with GCC; see the file COPYING3.  If not see
      form followed by the data for the string.  */
 
 #define LTO_major_version 9
-#define LTO_minor_version 3
+#define LTO_minor_version 4
 
 typedef unsigned char	lto_decl_flags_t;
 
diff --git a/gcc/modulo-sched.c b/gcc/modulo-sched.c
index 4593871ea92..1b8785ce33f 100644
--- a/gcc/modulo-sched.c
+++ b/gcc/modulo-sched.c
@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-pass.h"
 #include "dbgcnt.h"
 #include "loop-unroll.h"
+#include "hard-reg-set.h"
 
 #ifdef INSN_SCHEDULING
 
@@ -1354,6 +1355,7 @@ sms_schedule (void)
   basic_block condition_bb = NULL;
   edge latch_edge;
   HOST_WIDE_INT trip_count, max_trip_count;
+  HARD_REG_SET prohibited_regs;
 
   loop_optimizer_init (LOOPS_HAVE_PREHEADERS
 		       | LOOPS_HAVE_RECORDED_EXITS);
@@ -1383,6 +1385,8 @@ sms_schedule (void)
      We use loop->num as index into this array.  */
   g_arr = XCNEWVEC (ddg_ptr, number_of_loops (cfun));
 
+  REG_SET_TO_HARD_REG_SET (prohibited_regs, &df->regular_block_artificial_uses);
+
   if (dump_file)
   {
     fprintf (dump_file, "\n\nSMS analysis phase\n");
@@ -1467,23 +1471,31 @@ sms_schedule (void)
       }
 
       /* Don't handle BBs with calls or barriers
-	 or !single_set with the exception of instructions that include
-	 count_reg---these instructions are part of the control part
-	 that do-loop recognizes.
+	 or !single_set with the exception of do-loop control part insns.
          ??? Should handle insns defining subregs.  */
-     for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))
-      {
-         rtx set;
-
-        if (CALL_P (insn)
-            || BARRIER_P (insn)
-            || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)
-                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE
-                && !reg_mentioned_p (count_reg, insn))
-            || (INSN_P (insn) && (set = single_set (insn))
-                && GET_CODE (SET_DEST (set)) == SUBREG))
-        break;
-      }
+      for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))
+	{
+	  if (INSN_P (insn))
+	    {
+	      HARD_REG_SET regs;
+	      CLEAR_HARD_REG_SET (regs);
+	      note_stores (insn, record_hard_reg_sets, &regs);
+	      if (hard_reg_set_intersect_p (regs, prohibited_regs))
+		break;
+	    }
+
+	  if (CALL_P (insn)
+	      || BARRIER_P (insn)
+	      || (INSN_P (insn) && single_set (insn)
+		  && GET_CODE (SET_DEST (single_set (insn))) == SUBREG)
+	      /* Not a single set.  */
+	      || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)
+		  && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE
+		  /* But non-single-set allowed in one special case.  */
+		  && (insn != prev_nondebug_insn (tail)
+		      || !reg_mentioned_p (count_reg, insn))))
+	    break;
+	}
 
       if (insn != NEXT_INSN (tail))
 	{
@@ -1493,11 +1505,13 @@ sms_schedule (void)
 		fprintf (dump_file, "SMS loop-with-call\n");
 	      else if (BARRIER_P (insn))
 		fprintf (dump_file, "SMS loop-with-barrier\n");
-              else if ((NONDEBUG_INSN_P (insn) && !JUMP_P (insn)
-                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))
-                fprintf (dump_file, "SMS loop-with-not-single-set\n");
-              else
-               fprintf (dump_file, "SMS loop with subreg in lhs\n");
+	      else if (INSN_P (insn) && single_set (insn)
+		       && GET_CODE (SET_DEST (single_set (insn))) == SUBREG)
+		fprintf (dump_file, "SMS loop with subreg in lhs\n");
+	      else
+		fprintf (dump_file,
+			 "SMS loop-with-not-single-set-or-prohibited-reg\n");
+
 	      print_rtl_single (dump_file, insn);
 	    }
 
diff --git a/gcc/omp-expand.c b/gcc/omp-expand.c
index 90df5c90547..af4059cc2ab 100644
--- a/gcc/omp-expand.c
+++ b/gcc/omp-expand.c
@@ -1548,8 +1548,8 @@ struct oacc_collapse
 static tree
 expand_oacc_collapse_init (const struct omp_for_data *fd,
 			   gimple_stmt_iterator *gsi,
-			   oacc_collapse *counts, tree bound_type,
-			   location_t loc)
+			   oacc_collapse *counts, tree diff_type,
+			   tree bound_type, location_t loc)
 {
   tree tiling = fd->tiling;
   tree total = build_int_cst (bound_type, 1);
@@ -1566,17 +1566,12 @@ expand_oacc_collapse_init (const struct omp_for_data *fd,
       const omp_for_data_loop *loop = &fd->loops[ix];
 
       tree iter_type = TREE_TYPE (loop->v);
-      tree diff_type = iter_type;
       tree plus_type = iter_type;
 
-      gcc_assert (loop->cond_code == fd->loop.cond_code);
+      gcc_assert (loop->cond_code == LT_EXPR || loop->cond_code == GT_EXPR);
 
       if (POINTER_TYPE_P (iter_type))
 	plus_type = sizetype;
-      if (POINTER_TYPE_P (diff_type) || TYPE_UNSIGNED (diff_type))
-	diff_type = signed_type_for (diff_type);
-      if (TYPE_PRECISION (diff_type) < TYPE_PRECISION (integer_type_node))
-	diff_type = integer_type_node;
 
       if (tiling)
 	{
@@ -1664,7 +1659,8 @@ expand_oacc_collapse_init (const struct omp_for_data *fd,
 static void
 expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,
 			   gimple_stmt_iterator *gsi,
-			   const oacc_collapse *counts, tree ivar)
+			   const oacc_collapse *counts, tree ivar,
+			   tree diff_type)
 {
   tree ivar_type = TREE_TYPE (ivar);
 
@@ -1676,7 +1672,6 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,
       const oacc_collapse *collapse = &counts[ix];
       tree v = inner ? loop->v : collapse->outer;
       tree iter_type = TREE_TYPE (v);
-      tree diff_type = TREE_TYPE (collapse->step);
       tree plus_type = iter_type;
       enum tree_code plus_code = PLUS_EXPR;
       tree expr;
@@ -1698,7 +1693,7 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,
 	}
 
       expr = fold_build2 (MULT_EXPR, diff_type, fold_convert (diff_type, expr),
-			  collapse->step);
+			  fold_convert (diff_type, collapse->step));
       expr = fold_build2 (plus_code, iter_type,
 			  inner ? collapse->outer : collapse->base,
 			  fold_convert (plus_type, expr));
@@ -6039,6 +6034,12 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
       plus_code = POINTER_PLUS_EXPR;
       plus_type = sizetype;
     }
+  for (int ix = fd->collapse; ix--;)
+    {
+      tree diff_type2 = TREE_TYPE (fd->loops[ix].step);
+      if (TYPE_PRECISION (diff_type) < TYPE_PRECISION (diff_type2))
+	diff_type = diff_type2;
+    }
   if (POINTER_TYPE_P (diff_type) || TYPE_UNSIGNED (diff_type))
     diff_type = signed_type_for (diff_type);
   if (TYPE_PRECISION (diff_type) < TYPE_PRECISION (integer_type_node))
@@ -6122,7 +6123,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
     {
       gcc_assert (!gimple_in_ssa_p (cfun) && up);
       counts = XALLOCAVEC (struct oacc_collapse, fd->collapse);
-      tree total = expand_oacc_collapse_init (fd, &gsi, counts,
+      tree total = expand_oacc_collapse_init (fd, &gsi, counts, diff_type,
 					      TREE_TYPE (fd->loop.n2), loc);
 
       if (SSA_VAR_P (fd->loop.n2))
@@ -6284,7 +6285,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
       gsi_insert_before (&gsi, ass, GSI_SAME_STMT);
 
       if (fd->collapse > 1 || fd->tiling)
-	expand_oacc_collapse_vars (fd, false, &gsi, counts, v);
+	expand_oacc_collapse_vars (fd, false, &gsi, counts, v, diff_type);
 
       if (fd->tiling)
 	{
@@ -6354,7 +6355,8 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
 
 	  /* Initialize the user's loop vars.  */
 	  gsi = gsi_start_bb (elem_body_bb);
-	  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset);
+	  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset,
+				     diff_type);
 	}
     }
 
diff --git a/gcc/postreload.c b/gcc/postreload.c
index 8849679ae0f..225489bb571 100644
--- a/gcc/postreload.c
+++ b/gcc/postreload.c
@@ -1700,7 +1700,8 @@ move2add_valid_value_p (int regno, scalar_int_mode mode)
     {
       scalar_int_mode old_mode;
       if (!is_a <scalar_int_mode> (reg_mode[regno], &old_mode)
-	  || !MODES_OK_FOR_MOVE2ADD (mode, old_mode))
+	  || !MODES_OK_FOR_MOVE2ADD (mode, old_mode)
+	  || !REG_CAN_CHANGE_MODE_P (regno, old_mode, mode))
 	return false;
       /* The value loaded into regno in reg_mode[regno] is also valid in
 	 mode after truncation only if (REG:mode regno) is the lowpart of
diff --git a/gcc/reload.c b/gcc/reload.c
index 78b4049f465..5f099be43b3 100644
--- a/gcc/reload.c
+++ b/gcc/reload.c
@@ -2291,6 +2291,11 @@ operands_match_p (rtx x, rtx y)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       return label_ref_label (x) == label_ref_label (y);
     case SYMBOL_REF:
diff --git a/gcc/rtl.c b/gcc/rtl.c
index 4411e067ba8..63f0a26c912 100644
--- a/gcc/rtl.c
+++ b/gcc/rtl.c
@@ -466,6 +466,11 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case DEBUG_IMPLICIT_PTR:
       return DEBUG_IMPLICIT_PTR_DECL (x)
 	     == DEBUG_IMPLICIT_PTR_DECL (y);
@@ -608,6 +613,11 @@ rtx_equal_p (const_rtx x, const_rtx y)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case DEBUG_IMPLICIT_PTR:
       return DEBUG_IMPLICIT_PTR_DECL (x)
 	     == DEBUG_IMPLICIT_PTR_DECL (y);
diff --git a/gcc/rtl.h b/gcc/rtl.h
index b29afca8d6b..5d57ac6bc5f 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -3087,6 +3087,23 @@ vec_series_p (const_rtx x, rtx *base_out, rtx *step_out)
   return const_vec_series_p (x, base_out, step_out);
 }
 
+/* Return true if CONST_VECTORs X and Y, which are known to have the same mode,
+   also have the same encoding.  This means that they are equal whenever their
+   operands are equal.  */
+
+inline bool
+same_vector_encodings_p (const_rtx x, const_rtx y)
+{
+  /* Don't be fussy about the encoding of constant-length vectors,
+     since XVECEXP (X, 0) and XVECEXP (Y, 0) list all the elements anyway.  */
+  if (poly_uint64 (CONST_VECTOR_NUNITS (x)).is_constant ())
+    return true;
+
+  return (CONST_VECTOR_NPATTERNS (x) == CONST_VECTOR_NPATTERNS (y)
+	  && (CONST_VECTOR_NELTS_PER_PATTERN (x)
+	      == CONST_VECTOR_NELTS_PER_PATTERN (y)));
+}
+
 /* Return the unpromoted (outer) mode of SUBREG_PROMOTED_VAR_P subreg X.  */
 
 inline scalar_int_mode
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 0ebde7622db..e65d06d5bca 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -463,12 +463,17 @@ rtx_addr_can_trap_p_1 (const_rtx x, poly_int64 offset, poly_int64 size,
 		       machine_mode mode, bool unaligned_mems)
 {
   enum rtx_code code = GET_CODE (x);
-  gcc_checking_assert (mode == BLKmode || known_size_p (size));
+  gcc_checking_assert (mode == BLKmode
+		       || mode == VOIDmode
+		       || known_size_p (size));
   poly_int64 const_x1;
 
   /* The offset must be a multiple of the mode size if we are considering
      unaligned memory references on strict alignment machines.  */
-  if (STRICT_ALIGNMENT && unaligned_mems && mode != BLKmode)
+  if (STRICT_ALIGNMENT
+      && unaligned_mems
+      && mode != BLKmode
+      && mode != VOIDmode)
     {
       poly_int64 actual_offset = offset;
 
diff --git a/gcc/rtx-vector-builder.c b/gcc/rtx-vector-builder.c
index 90a8a1a2ef9..2468cdc5816 100644
--- a/gcc/rtx-vector-builder.c
+++ b/gcc/rtx-vector-builder.c
@@ -46,11 +46,11 @@ rtx_vector_builder::build (rtvec v)
 
 rtx
 rtx_vector_builder::apply_step (rtx base, unsigned int factor,
-				const wide_int &step) const
+				const poly_wide_int &step) const
 {
   scalar_int_mode int_mode = as_a <scalar_int_mode> (GET_MODE_INNER (m_mode));
-  return immed_wide_int_const (wi::add (rtx_mode_t (base, int_mode),
-					factor * step),
+  return immed_wide_int_const (wi::to_poly_wide (base, int_mode)
+			       + factor * step,
 			       int_mode);
 }
 
diff --git a/gcc/rtx-vector-builder.h b/gcc/rtx-vector-builder.h
index 99edad8a950..f33489286a9 100644
--- a/gcc/rtx-vector-builder.h
+++ b/gcc/rtx-vector-builder.h
@@ -44,8 +44,8 @@ private:
   bool equal_p (rtx, rtx) const;
   bool allow_steps_p () const;
   bool integral_p (rtx) const;
-  wide_int step (rtx, rtx) const;
-  rtx apply_step (rtx, unsigned int, const wide_int &) const;
+  poly_wide_int step (rtx, rtx) const;
+  rtx apply_step (rtx, unsigned int, const poly_wide_int &) const;
   bool can_elide_p (rtx) const { return true; }
   void note_representative (rtx *, rtx) {}
 
@@ -115,11 +115,11 @@ rtx_vector_builder::integral_p (rtx elt) const
 /* Return the value of element ELT2 minus the value of element ELT1.
    Both elements are known to be CONST_SCALAR_INT_Ps.  */
 
-inline wide_int
+inline poly_wide_int
 rtx_vector_builder::step (rtx elt1, rtx elt2) const
 {
-  return wi::sub (rtx_mode_t (elt2, GET_MODE_INNER (m_mode)),
-		  rtx_mode_t (elt1, GET_MODE_INNER (m_mode)));
+  return (wi::to_poly_wide (elt2, GET_MODE_INNER (m_mode))
+	  - wi::to_poly_wide (elt1, GET_MODE_INNER (m_mode)));
 }
 
 #endif
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 2913065bf31..ae4a9d33d7f 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,1726 @@
+2022-01-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97953
+	* gcc.dg/pr97953.c: New testcase.
+
+2022-01-07  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-05-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100551
+	* gfortran.dg/pr100551.f90: New test.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103418
+	* gfortran.dg/move_alloc_8.f90: Adjust error messages.
+	* gfortran.dg/pointer_intent_9.f90: New test.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/103634
+	* gfortran.dg/intrinsic_pack_6.f90: New test.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103778
+	* gfortran.dg/illegal_boz_arg_3.f90: New test.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-18  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/101329
+	* gfortran.dg/pr101329.f90: New test.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103588
+	* gfortran.dg/pr103588.f90: New test.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-03  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103505
+	* gfortran.dg/pr103505.f90: New test.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103412
+	* gfortran.dg/illegal_boz_arg_2.f90: New test.
+
+2021-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103610
+	* gfortran.dg/shape_11.f90: New test.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103606
+	* gfortran.dg/pr103606.f90: New test.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103717
+	* gfortran.dg/do_check_19.f90: New test.
+
+2021-12-15  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-11-30  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/102347
+	* gcc.target/powerpc/pr102347.c: New test.
+
+2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-30  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.dg/array_constructor_54.f90: New test.
+
+2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102717
+	* gfortran.dg/reshape_shape_2.f90: New test.
+
+2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103411
+	* gfortran.dg/pr68153.f90: Adjust test to improved check.
+	* gfortran.dg/reshape_7.f90: Likewise.
+	* gfortran.dg/reshape_9.f90: New test.
+
+2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103607
+	* gfortran.dg/pr103607.f90: New test.
+
+2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103392
+	* gfortran.dg/bound_simplification_7.f90: New test.
+
+2021-11-25  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-20  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/103052
+	* gcc.c-torture/execute/pr103052.c: New test.
+
+2021-11-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101985
+	* gcc.target/powerpc/pr101985-1.c: New.
+	* gcc.target/powerpc/pr101985-2.c: New.
+
+2021-11-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-21  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/99061
+	* gfortran.dg/dec_math_5.f90: New test.
+
+2021-11-22  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2021-11-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/20211119.c: New test.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102816
+	* gfortran.dg/pr102816.f90: New test.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-15  Harald Anlauf  <anlauf@gmx.de>
+		    Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/102685
+	* gfortran.dg/derived_constructor_char_1.f90: Fix invalid code.
+	* gfortran.dg/pr70931.f90: Likewise.
+	* gfortran.dg/transfer_simplify_2.f90: Likewise.
+	* gfortran.dg/pr102685.f90: New test.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-06  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102715
+	* gfortran.dg/pr68019.f90: Adjust error message.
+	* gfortran.dg/pr102715.f90: New test.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102817
+	* gfortran.dg/pr102817.f90: New test.
+
+2021-11-13  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-10  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99348
+	PR fortran/102521
+	* gfortran.dg/parameter_array_init_8.f90: New test.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/102714
+	* gcc.dg/ipa/pr102714.c: New testcase.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100672
+	* gcc.dg/torture/pr100672.c: New testcase.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100253
+	* g++.dg/pr100253.C: New testcase.
+
+2021-11-03  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/102842
+	* g++.target/arm/pr102842.C: New test.
+
+2021-11-02  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-10-21  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/102505
+	* g++.dg/torture/pr102505.C: New test.
+
+2021-10-27  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/102761
+	* gcc.target/i386/pr102761.c: New test.
+
+2021-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102716
+	* gfortran.dg/shape_10.f90: New test.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/102046
+	* gcc.dg/vect/pr102046.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101925
+	* gcc.dg/sso-16.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101373
+	PR tree-optimization/101868
+	* gcc.dg/lto/pr101868_0.c: New testcase.
+	* gcc.dg/lto/pr101868_1.c: Likewise.
+	* gcc.dg/lto/pr101868_2.c: Likewise.
+	* gcc.dg/lto/pr101868_3.c: Likewise.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101824
+	* gcc.dg/tree-ssa/pr101824.c: New testcase.
+
+2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/102622
+	* gcc.c-torture/execute/bitfld-10.c: New test.
+
+2021-10-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102458
+	* gfortran.dg/pr102458b.f90: New test.
+
+2021-10-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-10-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102458
+	* gfortran.dg/pr102458.f90: New test.
+
+2021-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-07-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/95520
+	* g++.dg/coroutines/pr95520.C: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82314
+	* gfortran.dg/pr82314.f90: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102520
+	* gfortran.dg/pr102520.f90: New test.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85130
+	* gfortran.dg/substr_6.f90: Revert commit r8-7574, adding again
+	test that was erroneously considered as illegal.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102287
+	* gfortran.dg/intent_out_14.f90: New test.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102366
+	* gfortran.dg/pr102366.f90: New test.
+
+2021-09-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* lib/target-supports.exp (no_fsanitize_address): Add missing bits.
+	* gcc.dg/pr91441.c: Likewise.
+	* gcc.dg/pr96260.c: Likewise.
+	* gcc.dg/pr96307.c: Likewise.
+	* g++.dg/abi/anon4.C: Likewise.
+
+2021-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20210917-1.c: New test.
+
+2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101327
+	* gfortran.dg/pr101327.f90: New test.
+
+2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98490
+	* gfortran.dg/bounds_check_23.f90: New test.
+
+2021-09-14  Xionghu Luo  <luoxhu@linux.ibm.com>
+
+	Backported from master:
+	2021-09-07  Xionghu Luo  <luoxhu@linux.ibm.com>
+
+	PR target/97142
+	* gcc.target/powerpc/pr97142.c: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97612
+	* gfortran.dg/structure_constructor_17.f90: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98565
+	* gfortran.dg/associated_target_7.f90 : New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97694
+	PR fortran/97723
+	* gfortran.dg/select_rank_5.f90: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93701
+	* gfortran.dg/associate_54.f90: New test.
+	* gfortran.dg/associate_55.f90: New test.
+	* gfortran.dg/associate_56.f90: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98472
+	* gfortran.dg/elemental_function_5.f90 : New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/100110
+	* gfortran.dg/pdt_31.f03: New test.
+	* gfortran.dg/pdt_26.f03: Reduce 'builtin_malloc' count from 9
+	to 8.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101394
+	* gcc.dg/torture/pr101394.c: New testcase.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101173
+	PR tree-optimization/101280
+	* gcc.dg/torture/pr101173.c: New testcase.
+	* gcc.dg/tree-ssa/loop-interchange-16.c: New file.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-24  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101105
+	* gcc.dg/torture/pr101105.c: New testcase.
+
+2021-09-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101009
+	* gcc.dg/torture/pr101009.c: New testcase.
+
+2021-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-08-19  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101849
+	* gcc.target/powerpc/pr101849.c: New test.
+
+2021-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-07-02  Peter Bergner  <bergner@linux.ibm.com>
+
+	* gcc.target/powerpc/mma-builtin-7.c: New test.
+	* gcc.target/powerpc/mma-builtin-8.c: New test.
+
+2021-08-30  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-05-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/46691
+	PR fortran/99819
+	* gfortran.dg/class_dummy_6.f90: New test.
+	* gfortran.dg/class_dummy_7.f90: New test.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99818
+	* gfortran.dg/coarray_48.f90: New test.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93924
+	PR fortran/93925
+	* gfortran.dg/proc_ptr_52.f90 : New test.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93794
+	* gfortran.dg/deferred_character_35.f90 : New test.
+
+2021-08-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99125
+	* gfortran.dg/alloc_deferred_comp_1.f90: New test.
+
+2021-08-27  konglin1  <lingling.kong@intel.com>
+
+	PR target/101472
+	* gcc.target/i386/avx512f-pr101472.c: New test.
+	* gcc.target/i386/avx512vl-pr101472.c: New test.
+
+2021-08-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98411
+	* gfortran.dg/pr98411.f90: Adjust testcase options to restrict to
+	F2008, and verify case of implicit SAVE.
+
+2021-08-25  konglin1  <lingling.kong@intel.com>
+
+	PR target/101471
+	* gcc.target/i386/avx512f-pr101471.c: New test.
+
+2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/102035
+	* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13a.c: New test.
+	* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7a.c: Likewise.
+	* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8a.c: Likewise.
+	* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7a.c: Likewise.
+	* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8a.c: Likewise.
+	* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13a.c: Likewise.
+	* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7a.c: Likewise.
+	* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8a.c: Likewise.
+
+2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	* lib/target-supports.exp (check_effective_target_arm_cmse_hw):
+	New function.
+
+2021-08-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-23  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/97565
+	* g++.dg/lto/pr97565_0.C: New testcase.
+	* g++.dg/lto/pr97565_1.C: Likewise.
+
+2021-08-23  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	Backported from master:
+	2021-08-06  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	PR target/101723
+	* gcc.target/arm/pr69245.c: Make sure to emit code for fn1, fix
+	typo.
+
+2021-08-23  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	Backported from master:
+	2021-08-06  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	PR target/101723
+	* gcc.target/arm/attr-neon3.c: Fix typo.
+	* gcc.target/arm/pragma_fpu_attribute_2.c: Fix typo.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/101723
+	* gcc.target/arm/cortex-m55-nofp-flag-hard.c: Update expected output.
+	* gcc.target/arm/cortex-m55-nofp-flag-softfp.c: Likewise.
+	* gcc.target/arm/cortex-m55-nofp-nomve-flag-softfp.c: Likewise.
+	* gcc.target/arm/mve/intrinsics/mve_fpu1.c: Convert to dg-do assemble.
+	Add a non-no-op function body.
+	* gcc.target/arm/mve/intrinsics/mve_fpu2.c: Likewise.
+	* gcc.target/arm/attr-neon.c: Tighten scan-assembler tests.
+	* gcc.target/arm/attr-neon2.c: Use -Ofast, convert test to use
+	check-function-bodies.
+	* gcc.target/arm/attr-neon3.c: Likewise.
+	* gcc.target/arm/pr69245.c: Tighten scan-assembler match, but allow
+	multiple instances.
+	* gcc.target/arm/pragma_fpu_attribute.c: Likewise.
+	* gcc.target/arm/pragma_fpu_attribute_2.c: Likewise.
+
+2021-08-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/101969
+	* gcc.dg/pr78213.c: Fix up for '--enable-checking=release' etc.
+
+2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* gcc.dg/pr78213.c: Restore testing.
+
+2021-08-17  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-28  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/100305
+	* gcc.c-torture/compile/pr100305.c: New test.
+
+2021-08-13  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/100788
+	* gcc.dg/pr100788.c: New test.
+
+2021-07-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101514
+	* gfortran.dg/pr101514.f90: New test.
+
+2021-07-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101536
+	* gfortran.dg/pr101536.f90: New test.
+
+2021-07-29  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101531
+	* gcc.target/powerpc/pr101129.c: Adjust.
+
+2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96435
+	* gdc.dg/pr96435.d: New test.
+
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101084
+	* gfortran.dg/fmt_nonchar_3.f90: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* gdc.dg/pr101640.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* gdc.dg/pr101490.d: New test.
+	* gdc.test/fail_compilation/fail22144.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* gdc.test/compilable/b19002.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* gdc.dg/pr101127a.d: New test.
+	* gdc.dg/pr101127b.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101619
+	* gdc.test/fail_compilation/fail7424b.d: Update test.
+	* gdc.test/fail_compilation/fail7424c.d: Update test.
+	* gdc.test/fail_compilation/fail7424d.d: Update test.
+	* gdc.test/fail_compilation/fail7424e.d: Update test.
+	* gdc.test/fail_compilation/fail7424f.d: Update test.
+	* gdc.test/fail_compilation/fail7424g.d: Update test.
+	* gdc.test/fail_compilation/fail7424h.d: Update test.
+	* gdc.test/fail_compilation/fail7424i.d: Update test.
+	* gdc.test/compilable/test22133.d: New test.
+	* gdc.test/fail_compilation/fail22133.d: New test.
+
+2021-07-20  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-07-08  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/101066
+	* gcc.dg/ipa/pr101066.c: New test.
+
+2021-07-20  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* gcc.target/i386/pr71245-1.c: Remove.
+	* gcc.target/i386/pr71245-2.c: Ditto.
+
+2021-07-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101129
+	* gcc.target/powerpc/pr101129.c: New.
+
+2021-07-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100949
+	* gfortran.dg/pr100949.f90: New test.
+
+2021-07-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2021-07-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/100227
+	* gfortran.dg/implied_do_io_7.f90: New test.
+
+2021-07-08  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-07-08  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/101087
+	* g++.dg/cpp0x/noexcept70.C: New test.
+
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* gcc.target/i386/pr101175.c: New test.
+
+2021-06-18  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95501
+	PR fortran/95502
+	* gfortran.dg/pr95502.f90: New test.
+
+2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/100856
+	* gcc.target/arm/acle/pr100856.c: New test.
+	* gcc.target/arm/multilib.exp: Add tests for cde options.
+
+2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2021-06-11  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/101016
+	* gcc.target/arm/mve/intrinsics/pr101016.c: New test.
+
+2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2021-06-11  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/99939
+	* gcc.target/arm/cmse/cmse-18.c: Add separate scan-assembler
+	directives check for target is v8.1-m.main+mve or not before
+	comparing the assembly output.
+	* gcc.target/arm/cmse/cmse-20.c: New test.
+
+2021-06-18  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-06-14  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/100777
+	* gcc.target/powerpc/pr100777.c: New test.
+
+2021-06-18  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-06-10  Peter Bergner  <bergner@linux.ibm.com>
+
+	* gcc.target/powerpc/mma-builtin-4.c (__builtin_vsx_build_pair): Add
+	tests.  Update expected counts.
+	* gcc.target/powerpc/mma-builtin-5.c (__builtin_mma_build_acc): Add
+	tests.  Update expected counts.
+
+2021-06-18  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2021-05-31  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/99842
+	* g++.target/powerpc/pr99842.C: New.
+
+2021-06-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101029
+	* g++.dg/ext/array4.C: New test.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100934
+	* gcc.dg/torture/pr100934.c: New testcase.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-28  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/100791
+	* gcc.dg/pr100791.c: New testcase.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100509
+	* gcc.dg/pr100509.c: New testcase.
+
+2021-06-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100492
+	* gcc.dg/torture/pr100492.c: New testcase.
+
+2021-06-16  Jos√© Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/82376
+	* gfortran.dg/PR82376.f90: New test.
+
+2021-06-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100999
+	* gdc.test/compilable/staticforeach.d: Add new tests.
+	* gdc.test/fail_compilation/diag16976.d: Likewise.
+	* gdc.test/fail_compilation/fail117.d: Likewise.
+	* gdc.test/fail_compilation/fail238_m32.d: Likewise.
+	* gdc.test/fail_compilation/fail238_m64.d: Likewise.
+	* gdc.test/fail_compilation/fail7424b.d: Likewise.
+	* gdc.test/fail_compilation/fail7424c.d: Likewise.
+	* gdc.test/fail_compilation/fail7424d.d: Likewise.
+	* gdc.test/fail_compilation/fail7424e.d: Likewise.
+	* gdc.test/fail_compilation/fail7424f.d: Likewise.
+	* gdc.test/fail_compilation/fail7424g.d: Likewise.
+	* gdc.test/fail_compilation/fail7424h.d: Likewise.
+	* gdc.test/fail_compilation/fail7424i.d: Likewise.
+	* gdc.test/fail_compilation/fail9766.d: Likewise.
+	* gdc.test/fail_compilation/ice9406.d: Likewise.
+	* gdc.test/compilable/extra-files/minimal/object.d: New file.
+	* gdc.test/compilable/interpret5.d: New test.
+	* gdc.test/compilable/minimal3.d: New test.
+	* gdc.test/compilable/test21742.d: New test.
+	* gdc.test/compilable/test22006.d: New test.
+	* gdc.test/fail_compilation/b12504.d: New test.
+	* gdc.test/fail_compilation/fail22006.d: New test.
+	* gdc.test/fail_compilation/test21927.d: New test.
+	* gdc.test/fail_compilation/test21939.d: New test.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* gdc.dg/pr100967.d: New test.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* gdc.test/compilable/betterCarray.d: Add test cases.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* gdc.test/compilable/aggr_alignment.d: Add test cases.
+
+2021-06-07  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100102
+	* g++.dg/cpp0x/alias-decl-72.C: New test.
+	* g++.dg/cpp0x/alias-decl-72a.C: New test.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* gdc.dg/pr100882a.d: New test.
+	* gdc.dg/pr100882b.d: New test.
+	* gdc.dg/pr100882c.d: New test.
+	* gdc.dg/pr100882d.d: New test.
+
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* gfortran.dg/inline_matmul_25.f90: New test.
+
+2021-06-04  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-19  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/100333
+	* gcc.target/arm/cmse/pr100333.c: New test.
+
+2021-06-02  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	Backported from master:
+	2021-01-21  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/98777
+	* gcc.target/riscv/pr98777.c: New.
+
+2021-06-02  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	Backported from master:
+	2021-01-20  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/98722
+	* g++.target/s390/pr98722.C: New.
+
+2021-06-02  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	Backported from master:
+	2021-01-12  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR target/97969
+	* gcc.target/arm/pr97969.c: New.
+
+2021-06-01  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-11  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99725
+	* gcc.target/arm/cmse/pr99725.c: New test.
+
+2021-06-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100797
+	PR c++/95719
+	* g++.dg/inherit/virtual15.C: New test.
+	* g++.dg/inherit/virtual15a.C: New test.
+
+2021-05-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-05-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98411
+	* gfortran.dg/pr98411.f90: New test.
+
+2021-05-25  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-10  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99960
+	* gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_s64.c:
+	Update now that we're (correctly) using full 128-bit vector
+	loads/stores.
+	* gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_u64.c:
+	Likewise.
+	* gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_s64.c:
+	Likewise.
+	* gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_u64.c:
+	Likewise.
+	* gcc.target/arm/mve/intrinsics/vuninitializedq_int.c: Likewise.
+	* gcc.target/arm/mve/intrinsics/vuninitializedq_int1.c:
+	Likewise.
+
+2021-05-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/derived_type7.adb, gnat.dg/derived_type7.ads: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100489
+	* g++.dg/cpp2a/desig18.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/80456
+	* g++.dg/cpp0x/constexpr-volatile3.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100054
+	* g++.dg/cpp1y/lambda-generic-local-class1.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100032
+	* g++.dg/cpp0x/alias-decl-equiv1.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91933
+	* g++.dg/cpp0x/constexpr-base7.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99180
+	PR c++/93295
+	PR c++/93867
+	PR c++/95486
+	* g++.dg/cpp2a/class-deduction-alias5.C: New test.
+	* g++.dg/cpp2a/class-deduction-alias6.C: New test.
+	* g++.dg/cpp2a/class-deduction-alias7.C: New test.
+	* g++.dg/cpp2a/class-deduction-alias8.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41723
+	* g++.dg/template/friend71.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/52625
+	* g++.dg/template/friend70.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92918
+	* g++.dg/lookup/using66.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96673
+	* g++.dg/cpp1y/nsdmi-aggr13.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99901
+	* g++.dg/cpp1z/inline-var9.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96311
+	* g++.dg/cpp1y/lambda-generic-Wunused.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95870
+	* g++.dg/cpp0x/lambda/lambda-nsdmi10.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99201
+	* g++.dg/cpp1z/constexpr-if-lambda4.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99643
+	* g++.dg/cpp0x/initlist-new5.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90664
+	* g++.dg/cpp1z/noexcept-type24.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91217
+	* g++.dg/opt/nrv20.C: New test.
+
+2021-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/97938
+	* g++.dg/cpp2a/lambda-pack-init6.C: New test.
+
+2021-05-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR testsuite/96488
+	* gnat.dg/unchecked_convert5.adb: Do not run on PowerPC64 LE.
+	* gnat.dg/unchecked_convert6.adb: Likewise.
+
+2021-05-20  Alex Coplan  <alex.coplan@arm.com>
+	    Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/99977
+	* gcc.target/arm/pr99977.c: New test.
+
+2021-05-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100566
+	* gcc.dg/torture/pr100566.c: New testcase.
+
+2021-05-13  Richard Earnshaw  <rearnsha@arm.com>
+
+	* gcc.dg/pr100563.c: New test.
+
+2021-05-12  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/100571
+	* gcc.dg/Wstringop-overflow-67.c: New test.
+
+2021-05-12  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-05-11  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99988
+	* gcc.target/aarch64/pr99988.c: New test.
+
+2021-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/100450
+	* c-c++-common/gomp/pr100450.c: New test.
+
+2021-05-06  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backported from master:
+	2021-04-30  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/100225
+	PR rtl-optimization/84878
+	* gcc.dg/pr100225.c: New test.
+
+2021-05-06  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backported from master:
+	2020-09-15  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/pr95646.c: Fix testism.
+
+2021-05-06  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2020-06-23  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	PR target/95646
+	* gcc.target/arm/pr95646.c: New test.
+
+2021-05-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20210505-1.c: New test.
+
+2021-05-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-05-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100274
+	* gfortran.dg/argument_checking_25.f90: New test.
+
+2021-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98786
+	* gcc.dg/torture/pr98786.c: New testcase.
+
+2021-05-05  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100278
+	* gcc.dg/tree-ssa/pr100278.c: New testcase.
+
+2021-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/100254
+	* g++.dg/opt/pr100254.C: New test.
+
+2021-04-30  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-30  Richard Biener  <rguenther@suse.de>
+
+	PR c++/98032
+	* g++.dg/pr98032.C: New testcase.
+
+2021-04-30  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96513
+	* gcc.dg/torture/pr96513.c: New testcase.
+
+2021-04-29  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-04-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	* gfortran.dg/gomp/map-5.f90: New test.
+
+2021-04-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-04-23  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* gcc.target/i386/pr100182.c: New test.
+	* gcc.target/i386/pr71245-1.c (dg-final): Xfail scan-assembler-not.
+	* gcc.target/i386/pr71245-2.c (dg-final): Ditto.
+
+2021-04-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100154
+	* gfortran.dg/pr100154.f90: New test.
+
+2021-04-27  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/98952
+	* gcc.target/powerpc/pr98952.c: New test.  Test backported from
+	trunk change on 4/23, 886b6c1e8af502b69e3f318b9830b73b88215878.
+
+2021-04-26  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-04-08  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99647
+	* gcc.c-torture/compile/pr99647.c: New test.
+
+2021-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100053
+	* gcc.dg/torture/pr100053.c: New testcase.
+	* gcc.dg/tree-ssa/ssa-fre-93.c: Likewise.
+
+2021-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/99954
+	* gcc.dg/torture/pr99954.c: New testcase.
+
+2021-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/99880
+	* gcc.dg/torture/pr99880.c: New testcase.
+
+2021-04-24  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/96796
+	* gcc.c-torture/compile/pr96796.c: New test.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/pr99929_1.c: New file.
+	* gcc.target/aarch64/sve/pr99929_2.c: Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98119
+	* gcc.target/aarch64/sve/pr98119.c: New test.
+
+2021-04-23  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2021-04-07  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/98736
+	* gcc.c-torture/execute/pr98736.c: New test.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-31  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/torture/20200727-0.c: New testcase.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/99249
+	* gcc.target/aarch64/sve/acle/general/pr99246.c: New test.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/97141
+	PR rtl-optimization/98726
+	* gcc.c-torture/compile/pr97141.c: New test.
+	* gcc.c-torture/compile/pr98726.c: Likewise.
+	* gcc.target/aarch64/sve/pr97141.c: Likewise.
+	* gcc.target/aarch64/sve/pr98726.c: Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-30  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98136
+	* g++.dg/pr98136.C: New test.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/98268
+	* gcc.target/aarch64/sve/pr98268-1.c: New test.
+	* gcc.target/aarch64/sve/pr98268-2.c: Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/99726
+	* gcc.target/i386/pr99726.c: New test.
+
+2021-04-22  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99216
+	* g++.target/aarch64/sve/pr99216.C: New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-09-19  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97051
+	* g++.dg/cpp2a/is-constant-evaluated11.C: New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-07-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95486
+	* g++.dg/cpp2a/class-deduction-alias3.C: New test.
+
+2021-04-21  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-21  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/100176
+	* g++.dg/compat/struct-layout-1_generate.c: Add missing return.
+	* gcc.dg/compat/struct-layout-1_generate.c: Likewise.
+
+2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/100148
+	* g++.dg/opt/pr100148.C: New test.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-08  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97052
+	* g++.dg/cpp2a/concepts-defarg2.C: New test.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-01-20  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95434
+	* g++.dg/cpp2a/lambda-generic9.C: New test.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-14  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/83476
+	PR c++/99885
+	* g++.dg/cpp1z/class-deduction85.C: New test.
+	* g++.dg/template/ref11.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/100111
+	* g++.dg/cpp0x/constexpr-100111.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/99767
+	* gcc.target/aarch64/pr99767.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99833
+	* g++.dg/cpp1z/pr99833.C: New test.
+	* g++.dg/cpp2a/pr99833.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99905
+	* gcc.target/i386/pr99905.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/99830
+	* gcc.dg/pr99830.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/99990
+	* gcc.dg/pr99990.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/99849
+	* gcc.dg/lto/pr99849_0.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/98601
+	* gcc.dg/torture/pr98601.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99859
+	* g++.dg/cpp1y/constexpr-99859-1.C: New test.
+	* g++.dg/cpp1y/constexpr-99859-2.C: New test.
+	* g++.dg/cpp2a/constexpr-new18.C: New test.
+	* g++.dg/cpp2a/constexpr-new19.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99863
+	* gcc.target/i386/pr99863.c: New test.
+
+2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98457
+	* gdc.dg/pr98457.d: New test.
+
+2021-04-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-11-27  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR c/97880
+	* gcc.dg/goacc/tile-1.c: New test.
+
+2021-04-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt92.adb: New test.
+
+2021-04-18  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-16  Harald Anlauf  <anlauf@gmx.de>
+		    Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/63797
+	* gfortran.dg/pr63797.f90: New test.
+
+2021-04-18  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	Backported from master:
+	2021-04-11  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	PR middle-end/98088
+	* c-c++-common/goacc/collapse-2.c: New.
+
+2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/100048
+	* gcc.target/aarch64/sve/pr100048.c: New test.
+
+2021-04-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-04-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/99817
+	* gfortran.dg/coarray/dummy_2.f90: New test.
+
+2021-04-10  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97973
+	* g++.dg/conversion/real-to-int1.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99806
+	* g++.dg/concepts/abbrev10.C: New test.
+	* g++.dg/concepts/abbrev11.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91416
+	* g++.dg/other/gc7.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99831
+	* g++.dg/other/gc6.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99331
+	* g++.dg/warn/Wconversion5.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	DR 1312
+	PR c++/99176
+	* g++.dg/cpp0x/constexpr-nullptr-2.C: Adjust dg-error.
+	* g++.dg/cpp0x/constexpr-cast2.C: New test.
+	* g++.dg/cpp0x/constexpr-cast3.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99120
+	* g++.dg/warn/Wshadow-17.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99374
+	* g++.dg/cpp1z/noexcept-type23.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-02-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98947
+	* g++.dg/cpp2a/volatile5.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97966
+	* g++.dg/cpp0x/noexcept63.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-01-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98333
+	* g++.dg/cpp0x/noexcept62.C: New test.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/testsuite/c-c++-common/goacc/collapse-2.c b/gcc/testsuite/c-c++-common/goacc/collapse-2.c
new file mode 100644
index 00000000000..e46028cd5c4
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/collapse-2.c
@@ -0,0 +1,56 @@
+/* Test for ICE as reported in PR98088.  */
+
+int i, j;
+
+void
+f1 (void)
+{
+  #pragma acc parallel
+  #pragma acc loop collapse (2)
+  for (i = 5; i > 5; i--)
+	for (j = 5; j > 0; j--)
+	  ;
+}
+
+void
+f2 (void)
+{
+  #pragma acc parallel
+  #pragma acc loop collapse (2)
+  for (i = 0; i < 5; i++)
+	for (j = 5; j > 0; j--)
+	  ;
+}
+
+void
+f3 (void)
+{
+  #pragma acc parallel
+  #pragma acc loop collapse (2)
+  for (i = 5; i >= 0; i--)
+	for (j = 5; j >= 0; j--)
+	  ;
+}
+
+void f4 ()
+{
+  #pragma acc parallel loop tile(2, 3)
+  for (int i = 0; i > 8; i++)
+    for (int j = 0; j > 8; j++);
+}
+
+void f5 ()
+{
+  #pragma acc parallel loop tile(2, 3)
+  for (int i = 0; i > 8; i++)
+    for (long j = 0; j > 8; j++);
+}
+
+void
+f6 (int a[32][32])
+{
+  #pragma acc parallel loop collapse(2)
+  for (int i = 16; i > 8; i--)
+    for (int j = 16; j > 8; j--)
+      a[i][j] = i + j;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr100450.c b/gcc/testsuite/c-c++-common/gomp/pr100450.c
new file mode 100644
index 00000000000..a6d2a2829ff
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr100450.c
@@ -0,0 +1,20 @@
+/* PR c/100450 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -save-temps -Wunknown-pragmas" } */
+
+#define TEST(T) { \
+     {T} \
+}
+#define CLAUSES reduction(+:red)
+#define PARALLEL_FOR(X) TEST({ \
+_Pragma("omp for CLAUSES") \
+X \
+})
+
+void foo()
+{
+  int red = 0;
+  int A[3] = {};
+  #pragma omp parallel shared(red)
+  PARALLEL_FOR( for(int i=0; i < 3; i++) red += A[i]; )
+}
diff --git a/gcc/testsuite/g++.dg/abi/anon4.C b/gcc/testsuite/g++.dg/abi/anon4.C
index 088ba994019..8200f4bb270 100644
--- a/gcc/testsuite/g++.dg/abi/anon4.C
+++ b/gcc/testsuite/g++.dg/abi/anon4.C
@@ -1,4 +1,5 @@
 // PR c++/65209
+// { dg-additional-options "-fno-pie" { target sparc*-*-* } }
 // { dg-final { scan-assembler-not "comdat" } }
 
 // Everything involving the anonymous namespace bits should be private, not
diff --git a/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c b/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
index 990e6f439e5..e9ece645cd0 100644
--- a/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
+++ b/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
@@ -983,6 +983,8 @@ subvalues (struct entry *e, char *p, char *letter)
       if (e[0].len != 0)
 	output_FNB ('B', e);
       return 1;
+    default:
+      return 0;
     }
 }
 
diff --git a/gcc/testsuite/g++.dg/concepts/abbrev10.C b/gcc/testsuite/g++.dg/concepts/abbrev10.C
new file mode 100644
index 00000000000..b611346e926
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/abbrev10.C
@@ -0,0 +1,18 @@
+// PR c++/99806
+// { dg-do compile { target c++14 } }
+// { dg-additional-options "-fconcepts" }
+
+struct S {
+  void f(auto, auto, int = 3);
+  void f2(auto, auto, int = 3) { }
+  template<typename T> static T g(T, auto, int = 3);
+};
+
+void
+g ()
+{
+  S::g(1, 2);
+  S s;
+  s.f(1, 2);
+  s.f2(1, 2);
+}
diff --git a/gcc/testsuite/g++.dg/concepts/abbrev11.C b/gcc/testsuite/g++.dg/concepts/abbrev11.C
new file mode 100644
index 00000000000..ddb479313df
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/abbrev11.C
@@ -0,0 +1,10 @@
+// PR c++/99806
+// { dg-do compile { target c++14 } }
+// { dg-additional-options "-fconcepts" }
+
+template <typename T> concept C = requires (T a) { a.f(0); };
+struct S {
+  void f(auto) noexcept(B);
+  static constexpr bool B = true;
+};
+static_assert(C<S>, "");
diff --git a/gcc/testsuite/g++.dg/conversion/real-to-int1.C b/gcc/testsuite/g++.dg/conversion/real-to-int1.C
new file mode 100644
index 00000000000..f7b990b3f4b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/conversion/real-to-int1.C
@@ -0,0 +1,17 @@
+// PR c++/97973
+
+void (*foo[1])(const int &);
+void (*foo2[1])(const double &);
+
+template<typename>
+void f ()
+{
+  (foo[0])(1.1);
+  (foo2[0])(1);
+}
+
+void
+g ()
+{
+  f<char> ();
+}
diff --git a/gcc/testsuite/g++.dg/coroutines/pr95520.C b/gcc/testsuite/g++.dg/coroutines/pr95520.C
new file mode 100644
index 00000000000..4849b0789c7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/coroutines/pr95520.C
@@ -0,0 +1,29 @@
+// { dg-do run }
+// { dg-output "coroutine name: MyFoo" }
+#include <coroutine>
+#include <cstdio>
+
+struct pt
+{
+    using handle_t = std::coroutine_handle<pt>;
+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }
+
+    std::suspend_never initial_suspend () const noexcept { return {}; }
+    std::suspend_never final_suspend () const noexcept { return {}; }
+    void return_void() const noexcept {}
+    void unhandled_exception() const noexcept {}
+};
+
+template <> struct std::coroutine_traits<pt::handle_t>
+    { using promise_type = pt; };
+
+static pt::handle_t MyFoo ()
+{ 
+    printf ("coroutine name: %s\n", __builtin_FUNCTION());
+    co_return;
+}
+
+int main()
+{
+    MyFoo ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/alias-decl-72.C b/gcc/testsuite/g++.dg/cpp0x/alias-decl-72.C
new file mode 100644
index 00000000000..8009756dcba
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/alias-decl-72.C
@@ -0,0 +1,9 @@
+// PR c++/100102
+// { dg-do compile { target c++11 } }
+
+template<int()> struct ratio;
+template<class T, class U> struct duration {
+  static constexpr int _S_gcd();
+  template<class> using __is_harmonic = ratio<_S_gcd>;
+  using type = __is_harmonic<int>;
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/alias-decl-72a.C b/gcc/testsuite/g++.dg/cpp0x/alias-decl-72a.C
new file mode 100644
index 00000000000..a4443e18f9d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/alias-decl-72a.C
@@ -0,0 +1,9 @@
+// PR c++/100102
+// { dg-do compile { target c++11 } }
+
+template<int> struct ratio;
+template<class T> struct duration {
+  static constexpr int _S_gcd();
+  template<class> using __is_harmonic = ratio<(duration::_S_gcd)()>;
+  using type = __is_harmonic<int>;
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/alias-decl-equiv1.C b/gcc/testsuite/g++.dg/cpp0x/alias-decl-equiv1.C
new file mode 100644
index 00000000000..ae27c43bc0a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/alias-decl-equiv1.C
@@ -0,0 +1,13 @@
+// PR c++/100032
+// { dg-do compile { target c++11 } }
+
+template <template<class> class> struct X { };
+template <class> struct Y { };
+template <class T> using Z = const Y<T>;
+
+template <class T> using W = Z<T>;
+using U = X<Z>;
+using U = X<W>;
+
+using T = X<Y>;
+using T = X<Z>;			// { dg-error "conflicting declaration" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-100111.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-100111.C
new file mode 100644
index 00000000000..446d21d03c5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-100111.C
@@ -0,0 +1,7 @@
+// PR c++/100111
+// { dg-do compile { target c++11 } }
+// { dg-options "-fno-elide-constructors" }
+
+struct A {};
+struct B : A { int b; constexpr B (A x) : A(x), b() {} };
+struct C { B c; constexpr C () : c({}) {} } d;
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-base7.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-base7.C
new file mode 100644
index 00000000000..14e026ec202
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-base7.C
@@ -0,0 +1,15 @@
+// PR c++/91933
+// { dg-do compile { target c++11 } }
+
+struct NoMut1 { int a, b; };
+struct NoMut3 : NoMut1 {
+  constexpr NoMut3(int a, int b) : NoMut1{a, b} {}
+};
+void mutable_subobjects() {
+  constexpr NoMut3 nm3 = {1, 2};
+  struct A {
+    void f() {
+      static_assert(nm3.a == 1, "");
+    }
+  };
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-cast2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast2.C
new file mode 100644
index 00000000000..7c37f6a3f5a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast2.C
@@ -0,0 +1,16 @@
+// DR 1312 - Simulated reinterpret_cast in constant expressions.
+// PR c++/99176
+// { dg-do compile { target c++11 } }
+
+static int i;
+constexpr void *vp0 = nullptr;
+constexpr void *vpi = &i;
+constexpr int *p1 = (int *) vp0; // { dg-error "cast from .void\\*. is not allowed" }
+constexpr int *p2 = (int *) vpi; // { dg-error "cast from .void\\*. is not allowed" "integer_zerop" { xfail *-*-* } }
+constexpr int *p3 = static_cast<int *>(vp0); // { dg-error "cast from .void\\*. is not allowed" }
+constexpr int *p4 = static_cast<int *>(vpi); // { dg-error "cast from .void\\*. is not allowed" "integer_zerop" { xfail *-*-* } }
+constexpr void *p5 = vp0;
+constexpr void *p6 = vpi;
+
+constexpr int *pi = &i;
+constexpr bool b = ((int *)(void *) pi == pi); // { dg-error "cast from .void\\*. is not allowed" "integer_zerop" { xfail *-*-* } }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-cast3.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast3.C
new file mode 100644
index 00000000000..a330a99f7de
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast3.C
@@ -0,0 +1,14 @@
+// PR c++/99176
+// { dg-do compile { target c++11 } }
+
+constexpr const int *p = nullptr;
+constexpr int *q1 = const_cast<int*>(p);
+constexpr int *q2 = (int *)(const int *) nullptr;
+
+struct B { };
+struct D : B { };
+constexpr B *q3 = static_cast<B*>(nullptr);
+constexpr D *pd = nullptr;
+constexpr B *pb = nullptr;
+constexpr B *q4 = static_cast<B*>(pd);
+constexpr D *q5 = static_cast<D*>(pb);
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
index afb4b37be5a..92f3bbdc0a6 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
@@ -163,7 +163,7 @@ constexpr const void *pv2 = pv0;
 constexpr void *pv3 = pv2;      // { dg-error "invalid conversion|not a constant expression" }
 constexpr const void *pv4 = pv2;
 
-constexpr X *px4 = pv0;	 // { dg-error "invalid conversion|not a constant expression" }
+constexpr X *px4 = pv0;	 // { dg-error "cast from|invalid conversion|not a constant expression" }
 
 }
 
@@ -226,7 +226,7 @@ constexpr A *pa3 = pd0;		   // { dg-error "ambiguous base" }
 constexpr A *pa4 = static_cast<A*>(pd0);  // { dg-error "ambiguous base" }
 
 constexpr B *pb1 = pa0;		   // { dg-error "invalid conversion|not a constant expression" }
-constexpr B *pb2 = static_cast<B*>(pa0);  // { dg-error "not a constant expression" }
+constexpr B *pb2 = static_cast<B*>(pa0);
 
 constexpr C *pc1 = pa0;		   // { dg-error "invalid conversion|not a constant expression" }
 constexpr D *pd1 = pa0;		   // { dg-error "ambiguous base|invalid conversion" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-volatile3.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-volatile3.C
new file mode 100644
index 00000000000..5c1e865e0ac
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-volatile3.C
@@ -0,0 +1,15 @@
+// PR c++/80456
+// { dg-do compile { target c++11 } }
+
+struct A {
+  static constexpr bool test() noexcept { return true; }
+
+  void f() volatile {
+    constexpr bool b = test();
+  }
+};
+
+void g() {
+  A a;
+  a.f();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-new5.C b/gcc/testsuite/g++.dg/cpp0x/initlist-new5.C
new file mode 100644
index 00000000000..da54d8981d4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-new5.C
@@ -0,0 +1,9 @@
+// PR c++/99643
+// { dg-do compile { target c++11 } }
+
+struct Foo {};
+Foo get_foo();
+
+int main() {
+    new Foo[1]{get_foo()};
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nsdmi10.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nsdmi10.C
new file mode 100644
index 00000000000..810ed538719
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nsdmi10.C
@@ -0,0 +1,12 @@
+// PR c++/95870
+// { dg-do compile { target c++11 } }
+
+template <typename> struct S {
+  S();
+  int b = []() -> int { enum E {}; return 1; }();
+};
+struct C : S<int> {
+  C();
+};
+template <typename T> S<T>::S() = default;
+C::C() {}
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept62.C b/gcc/testsuite/g++.dg/cpp0x/noexcept62.C
new file mode 100644
index 00000000000..53606c79142
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept62.C
@@ -0,0 +1,10 @@
+// PR c++/98333
+// { dg-do compile { target c++11 } }
+
+struct T {
+  template <bool N>
+  struct S {
+    S () noexcept (N) {}
+  };
+  int a = __has_nothrow_constructor (S<true>);
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept63.C b/gcc/testsuite/g++.dg/cpp0x/noexcept63.C
new file mode 100644
index 00000000000..cf048f56c2a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept63.C
@@ -0,0 +1,63 @@
+// PR c++/97966
+// { dg-do compile { target c++11 } }
+
+template <int>
+struct S1 {
+  __attribute__((used)) S1() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S2 {
+  __attribute__((used)) void bar() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S3 {
+  void __attribute__((used)) bar() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S4 {
+  [[gnu::used]] void bar() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S5 {
+  void bar() noexcept(noexcept(this->foo())) __attribute__((used)) { }
+  void foo();
+};
+
+template <int>
+struct S6 {
+  template <int>
+  struct N {
+    [[gnu::used]] void bar() noexcept(noexcept(this->foo())) { }
+    void foo();
+  };
+};
+
+void
+g ()
+{
+  S1<1> s1;
+  S2<1> s2;
+  S3<1> s3;
+  S4<1> s4;
+  S5<1> s5;
+  S6<1>::N<1> n;
+}
+
+// Make sure that we did emit the functions marked with attribute used
+// even though they're not referenced in this TU.  (Well, the S1()
+// constructor is.)
+// { dg-final { scan-assembler "_ZN2S1ILi1EEC1Ev" } }
+// { dg-final { scan-assembler "_ZN2S1ILi1EEC2Ev" } }
+// { dg-final { scan-assembler "_ZN2S2ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S3ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S4ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S5ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S6ILi1EE1NILi1EE3barEv" } }
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept70.C b/gcc/testsuite/g++.dg/cpp0x/noexcept70.C
new file mode 100644
index 00000000000..45a6137dd6f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept70.C
@@ -0,0 +1,5 @@
+// PR c++/101087
+// { dg-do compile { target c++11 } }
+
+int f();
+static_assert(noexcept(sizeof(f())), "");
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-1.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-1.C
new file mode 100644
index 00000000000..dea5a5b56f8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-1.C
@@ -0,0 +1,24 @@
+// PR c++/99859
+// { dg-do compile { target c++14 } }
+
+constexpr int
+foo (int *x)
+{
+  return ++*x;
+}
+
+struct S { constexpr S () : a(0) { foo (&a); foo (&a); } int a; };
+constexpr S s = S ();
+static_assert (s.a == 2, "");
+
+struct R { int *p; };
+
+constexpr int
+bar (R x)
+{
+  return ++*x.p;
+}
+
+struct T { int a = 0; constexpr T () { bar (R{&a}); bar (R{&a}); } };
+constexpr T t = T ();
+static_assert (t.a == 2, "");
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-2.C
new file mode 100644
index 00000000000..a249f474666
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-2.C
@@ -0,0 +1,12 @@
+// PR c++/99859
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  int i;
+  constexpr int f() { return i; }
+  constexpr A() : i(0) { i = f(); i = 1; i = f(); }
+};
+
+constexpr A a = A();
+static_assert (a.i == 1, "");
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-Wunused.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-Wunused.C
new file mode 100644
index 00000000000..b43cbe6b675
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-Wunused.C
@@ -0,0 +1,18 @@
+// PR c++/96311
+// { dg-do compile { target c++14 } }
+// { dg-additional-options -Wunused }
+
+auto foo()
+{
+  constexpr int used = 0;
+  return
+    [](auto unused)
+    {
+      return used;
+    };
+}
+
+int main()
+{
+  foo()(42);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-local-class1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-local-class1.C
new file mode 100644
index 00000000000..7498327981b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-local-class1.C
@@ -0,0 +1,10 @@
+// PR c++/100054
+// { dg-do compile { target c++14 } }
+
+template <class T>
+void f() {
+  struct A { T m{}; };
+  [](auto){ return A{}; };
+}
+
+template void f<int>();
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr13.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr13.C
new file mode 100644
index 00000000000..845e26ff593
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr13.C
@@ -0,0 +1,33 @@
+// PR c++/96673
+// { dg-do compile { target c++11 } }
+
+template <class T>
+class A {};
+
+template <class T>
+class B;
+
+template <class T>
+class C {
+    private:
+
+    friend class B<T>;
+
+    explicit C(A<T>&) {};
+};
+
+
+template <class T>
+class B {
+    public:
+    B() = default;
+    //B() {};       // << This implementation of the constructor makes it work
+
+    A<T> a = {};
+    C<T> c = C<T>{a};
+};
+
+int main() {
+    auto b = B<int>{};
+    auto &c = b.c;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C
new file mode 100644
index 00000000000..0b22f8eb982
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C
@@ -0,0 +1,16 @@
+// PR c++/99885
+// { dg-do compile { target c++17 } }
+
+template <auto const& A>
+struct Foo {};
+
+template <auto const& A>
+struct Bar {
+    constexpr auto foo() const -> Foo<A> {
+        return {};
+    }
+};
+
+constexpr int a = 1;
+constexpr Bar<a> bar;
+Foo foo = bar.foo(); // <-- CTAD failure
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda4.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda4.C
new file mode 100644
index 00000000000..99408025629
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda4.C
@@ -0,0 +1,22 @@
+// PR c++/99201
+// { dg-do compile { target c++17 } }
+
+template <typename RefF>
+  auto
+  make_tester(const RefF& reffun)
+  {
+    return [=](auto in) {
+      auto&& expected = [&](const auto&... vs) {
+        if constexpr (sizeof(in) > 0)
+          return [&](int i) { return reffun(vs[i]...); }(0);
+        else
+          return [&](int i) { return reffun(vs[i]...); }(0);
+      };
+    };
+  }
+
+int main()
+{
+  make_tester([](int x) { return x; })(0);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/inline-var9.C b/gcc/testsuite/g++.dg/cpp1z/inline-var9.C
new file mode 100644
index 00000000000..43c9748877b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/inline-var9.C
@@ -0,0 +1,40 @@
+// PR c++/99901
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler-not "_ZN1A1aE" } }
+// { dg-final { scan-assembler-not "_ZN2A21aE" } }
+// { dg-final { scan-assembler-not "_ZN1CIiE1cE" } }
+// { dg-final { scan-assembler "_ZN1B1bE" } }
+// { dg-final { scan-assembler "_ZN2B21bE" } }
+// { dg-final { scan-assembler "_ZN2B31bE" } }
+
+struct A {
+  static const int a = 5;
+};
+
+struct A2 {
+  static constexpr int a = 5;
+};
+
+struct B {
+  static const int b;
+};
+constexpr int B::b = 5;
+
+struct B2 {
+  static const int b = 5;
+};
+constexpr int B2::b;
+
+struct B3 {
+  static constexpr int b = 5;
+};
+const int B3::b;
+
+template <class T>
+struct C {
+  static constexpr int c = 5;
+};
+template <class T>
+constexpr int C<T>::c;
+
+int i = C<int>::c;
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type23.C b/gcc/testsuite/g++.dg/cpp1z/noexcept-type23.C
new file mode 100644
index 00000000000..612dd6ceb5e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type23.C
@@ -0,0 +1,14 @@
+// PR c++/99374
+// { dg-do compile { target c++17 } }
+
+struct S;
+struct R;
+using F1 = int (S::*)();
+using F2 = int (S::*)() noexcept;
+using F3 = int (R::*)() noexcept;
+using T = S;
+using F4 = int (T::*)() noexcept;
+F1 f21 = F2();
+F1 f41 = F4();
+F2 f12 = F1(); // { dg-error "cannot convert" }
+F1 f31 = F3(); // { dg-error "cannot convert" }
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type24.C b/gcc/testsuite/g++.dg/cpp1z/noexcept-type24.C
new file mode 100644
index 00000000000..df16ea78641
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type24.C
@@ -0,0 +1,22 @@
+// PR c++/90664
+// { dg-do compile { target c++11 } }
+
+template <typename TT, typename MFP, MFP> struct OpM;
+
+template <typename TR, typename TT, TR (TT::*f)()>
+struct OpM<TT, TR (TT::*)(), f>
+{};
+
+class Class {
+public:
+  int address() noexcept { return 0; }
+  void address(int) noexcept {}
+};
+
+struct Sk {
+  template <class C, typename R> Sk(R (C::*p)()) {
+    typedef OpM<C, R (C::*)() /* noexcept */, &Class::address> OP;
+  }
+};
+
+Sk sk(static_cast<int (Class::*)()>(&Class::address));
diff --git a/gcc/testsuite/g++.dg/cpp1z/pr99833.C b/gcc/testsuite/g++.dg/cpp1z/pr99833.C
new file mode 100644
index 00000000000..f7c995887f8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/pr99833.C
@@ -0,0 +1,11 @@
+// PR c++/99833
+// { dg-do compile { target c++17 } }
+
+struct S { int a, b; };
+template <class>
+void
+foo ()
+{
+  [](auto d) { if constexpr (auto [a, b]{d}; sizeof (a) > 0) a++; } (S{});
+}
+template void foo<S> ();
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias3.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias3.C
new file mode 100644
index 00000000000..318d4c942ce
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias3.C
@@ -0,0 +1,11 @@
+// PR c++/95486
+// { dg-do compile { target c++20 } }
+
+template<class T, class U>
+struct X { X(U) requires __is_same(U, int) {} };
+
+template<class U>
+using Y = X<void, U>;
+
+Y y{1};
+Y z{'a'}; // { dg-error "failed|no match" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias5.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias5.C
new file mode 100644
index 00000000000..69143a3277b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias5.C
@@ -0,0 +1,18 @@
+// PR c++/99180
+// { dg-do compile { target c++17 } }
+
+template <bool, typename... Ts>
+struct A {
+  A(Ts...) {}
+};
+
+template <typename... Ts>
+using B = A<false, Ts...>;
+
+template <typename... Ts>
+A(Ts...) -> A<true, Ts...>;
+
+int main() {
+  B{};				// { dg-error "alias" "" { target c++17_down } }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias6.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias6.C
new file mode 100644
index 00000000000..26a38641ab3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias6.C
@@ -0,0 +1,11 @@
+// PR c++/93295
+// { dg-do compile { target c++20 } }
+
+template<typename T, bool B = false>
+struct Foo {
+    Foo(T) {}
+};
+
+template<typename T> Foo(T) -> Foo<T>;
+template<typename T> using Bar = Foo<T, true>;
+Bar b{0};
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias7.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias7.C
new file mode 100644
index 00000000000..0d8bff7610d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias7.C
@@ -0,0 +1,32 @@
+// PR c++/93867
+// { dg-do compile { target c++20 } }
+
+template <typename CharT, unsigned N>
+struct basic_fixed_string
+{
+  constexpr basic_fixed_string(const CharT *p) {
+    for (int i = 0; i < N; ++i) {
+      m_data[i] = p[i];
+    }
+  }
+
+  CharT m_data[N] {};
+};
+
+template <typename CharT, unsigned N>
+basic_fixed_string(const CharT (&)[N]) -> basic_fixed_string<CharT,N>;
+
+template <unsigned N>
+using fixed_string = basic_fixed_string<char, N>;
+
+template <fixed_string path>
+constexpr int foo()
+{
+  return 42;
+}
+
+int main(int argc, char const *argv[])
+{
+  foo<"hello">();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias8.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias8.C
new file mode 100644
index 00000000000..ec005956fa6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias8.C
@@ -0,0 +1,14 @@
+// PR c++/95486
+// { dg-do compile { target c++20 } }
+
+template<class T, class U>
+struct X { X(U) requires __is_same(U, int) {} };
+
+template<class U>
+X(U) -> X<char, U>;
+
+template<class U>
+using Y = X<void, U>;
+
+Y y{1};
+Y z{'a'}; // { dg-error "failed|no match" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-defarg2.C b/gcc/testsuite/g++.dg/cpp2a/concepts-defarg2.C
new file mode 100644
index 00000000000..a63ca4e133d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-defarg2.C
@@ -0,0 +1,13 @@
+// PR c++/97052
+// { dg-do compile { target c++20 } }
+
+template<typename T, typename U = typename T::type>
+concept C = true;
+
+constexpr bool f(C auto) {
+  return true;
+}
+
+static_assert(f(0));
+
+C auto x = 0;
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-new18.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-new18.C
new file mode 100644
index 00000000000..24b298aafd4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-new18.C
@@ -0,0 +1,45 @@
+// PR c++/99859
+// { dg-do compile { target c++20 } }
+
+template <class T>
+struct intrusive_ptr
+{
+  T *ptr = nullptr;
+  constexpr explicit intrusive_ptr(T* p) : ptr(p) {
+    ++ptr->count_;
+  }
+  constexpr ~intrusive_ptr() {
+    if (ptr->dec() == 0)
+      delete ptr;
+  }
+  constexpr intrusive_ptr(intrusive_ptr const& a) : ptr(a.ptr) {
+    ++ptr->count_;
+  }
+};
+
+struct Foo {
+  int count_ = 0;
+  constexpr int dec() {
+    return --count_;
+  }
+};
+
+constexpr bool baz() {
+  Foo f { 4 };
+  intrusive_ptr a(&f);
+  return true;
+}
+constexpr bool x = baz();
+
+constexpr void bar(intrusive_ptr<Foo> a) 
+{
+  if (a.ptr->count_ != 2) throw 1;
+}
+
+constexpr bool foo() {
+  intrusive_ptr a(new Foo());
+  bar(a);
+  return true;
+}
+
+static_assert(foo());
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-new19.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-new19.C
new file mode 100644
index 00000000000..7a73deed693
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-new19.C
@@ -0,0 +1,43 @@
+// PR c++/99859
+// { dg-do compile { target c++20 } }
+
+constexpr void
+foo (int *x)
+{
+  ++*x;
+}
+
+constexpr int
+bar ()
+{
+  int *x = new int (0);
+  foo (x);
+  foo (x);
+  int y = *x;
+  delete x;
+  return y;
+}
+
+static_assert (bar () == 2);
+
+struct R { int a, *b; };
+
+constexpr void
+baz (R x)
+{
+  ++*x.b;
+}
+
+constexpr int
+qux ()
+{
+  int *x = new int (0);
+  R r{1, x};
+  baz (r);
+  baz (r);
+  int y = *x;
+  delete x;
+  return y;
+}
+
+static_assert (qux () == 2);
diff --git a/gcc/testsuite/g++.dg/cpp2a/desig18.C b/gcc/testsuite/g++.dg/cpp2a/desig18.C
new file mode 100644
index 00000000000..4851579b7c7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/desig18.C
@@ -0,0 +1,17 @@
+// PR c++/100489
+// { dg-options "" }
+
+union U
+{
+  union
+  {
+    unsigned char a;
+  };
+
+  unsigned char b[1];
+};
+
+void f(unsigned char a)
+{
+  union U u = { .a = a };
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated11.C b/gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated11.C
new file mode 100644
index 00000000000..a31867f74fb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated11.C
@@ -0,0 +1,16 @@
+// PR c++/97051
+// { dg-do compile { target c++20 } }
+
+namespace std {
+  constexpr inline bool
+  is_constant_evaluated () noexcept
+  {
+    return __builtin_is_constant_evaluated ();
+  }
+}
+
+template<typename>
+  requires (std::is_constant_evaluated())
+constexpr int a = 0;
+
+constexpr int b = a<int>;
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-generic9.C b/gcc/testsuite/g++.dg/cpp2a/lambda-generic9.C
new file mode 100644
index 00000000000..043301ba015
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-generic9.C
@@ -0,0 +1,9 @@
+// PR c++/95434
+// { dg-do compile { target c++20 } }
+
+template <class>
+void f() {
+  [] <template <class> class U> () { U{0}; };
+}
+
+template void f<int>();
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init6.C b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init6.C
new file mode 100644
index 00000000000..3ee500ed999
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init6.C
@@ -0,0 +1,27 @@
+// PR c++/97938
+// { dg-do compile { target c++20 } }
+
+template <typename... Args>
+int sink(Args&&... args) { return 2; }
+
+auto fwd1(const auto&&... ts1) {
+  return
+    [...ts1 = ts1] {
+      return sink(ts1...);
+    }();
+}
+
+template <typename T1>
+auto fwd2(const T1& t1) {
+  return
+    [] (auto&&... ts1) {
+      return
+	[...ts1 = ts1] {
+	  return sink(ts1...);
+	}();
+    }();
+}
+
+int main() {
+  return fwd1() + fwd2(1);
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/pr99833.C b/gcc/testsuite/g++.dg/cpp2a/pr99833.C
new file mode 100644
index 00000000000..33230535e10
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/pr99833.C
@@ -0,0 +1,18 @@
+// PR c++/99833
+// { dg-do compile { target c++20 } }
+
+#include <tuple>
+
+auto f(auto&& x)
+{
+  [&](auto...) {
+    auto y = std::tuple{ "what's happening here?", x };
+    if constexpr (auto [_, z] = y; requires { z; })
+      return;
+  }();
+}
+
+int main()
+{
+  f(42);
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile5.C b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
new file mode 100644
index 00000000000..1f9d23845b4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
@@ -0,0 +1,15 @@
+// PR c++/98947
+// { dg-do compile }
+
+volatile int x, y, z;
+
+void
+f (bool b)
+{
+  (b ? x : y) = 1;
+  (b ? x : y) += 1; // { dg-warning "compound assignment" "" { target c++20 } }
+  z = (b ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  ((z = 2) ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  (b ? (x = 2) : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  (b ? x : (y = 5)) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+}
diff --git a/gcc/testsuite/g++.dg/ext/array4.C b/gcc/testsuite/g++.dg/ext/array4.C
new file mode 100644
index 00000000000..0068ea854e1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/array4.C
@@ -0,0 +1,172 @@
+// PR c++/101029
+// { dg-do compile { target c++11 } }
+// { dg-options "" } allow [0]
+
+template <int __v> struct integral_constant {
+  static constexpr int value = __v;
+  typedef int value_type;
+  constexpr operator value_type() { return __v; }
+};
+template <bool __v> using __bool_constant = integral_constant<__v>;
+template <bool, typename> struct conditional;
+template <typename...> struct __and_;
+template <typename _B1, typename _B2, typename _B3, typename... _Bn>
+struct __and_<_B1, _B2, _B3, _Bn...> : conditional<_B1::value, _B1> {};
+template <typename _Tp>
+constexpr integral_constant<true> __is_complete_or_unbounded(_Tp) {
+  return {};
+}
+struct Trans_NS_std_formatter;
+template <typename _Tp>
+struct is_default_constructible : integral_constant<false> {
+  static_assert(__is_complete_or_unbounded(_Tp{}), "");
+};
+template <typename _Tp, typename _Up>
+struct is_same : integral_constant<__is_same_as(_Tp, _Up)> {};
+template <bool> struct enable_if;
+template <typename _Iffalse> struct conditional<false, _Iffalse> {
+  typedef _Iffalse type;
+};
+struct pair {
+  template <typename _U1 = int, typename _U2 = int,
+            typename enable_if<__and_<is_default_constructible<_U1>, _U2,
+                                      int>::valuebool>::type>
+  pair();
+};
+
+class BucketLogger;
+struct __shared_ptr_access {
+  using element_type = BucketLogger;
+  element_type *operator->();
+};
+struct DcpProducer {
+  __shared_ptr_access logger;
+  void bufferAcknowledgement();
+};
+struct atomic {
+  atomic(long);
+};
+inline namespace v7 {
+template <bool B, class, class F>
+using conditional_t = typename conditional<B, F>::type;
+template <typename> struct basic_string_view { basic_string_view(int, int); };
+template <typename, typename> struct formatter;
+template <typename, typename>
+using has_formatter =
+    __bool_constant<__is_constructible(Trans_NS_std_formatter)>;
+struct fallback_formatter;
+template <typename Context> struct custom_value {
+  using parse_context = typename Context::parse_context_type;
+  void (*format)(const void *, parse_context &, Context &);
+};
+template <typename Context> struct value {
+  float float_value;
+  custom_value<Context> custom;
+  template <typename T> value(T) {
+    custom.format =
+        format_custom_arg<T, conditional_t<has_formatter<T, Context>::value,
+                                           typename Context::formatter_type<T>,
+                                           fallback_formatter>>;
+  }
+  template <typename, typename Formatter>
+  static void format_custom_arg(const void *arg,
+                                typename Context::parse_context_type &,
+                                Context &ctx) {
+    Formatter f;
+    f.format(*static_cast<const int *>(arg), ctx);
+  }
+};
+enum { max_packed_args };
+template <typename Context> struct basic_format_arg { value<Context> value_; };
+template <typename Visitor, typename Context>
+void visit_format_arg(Visitor vis, Context arg) {
+  vis(arg.value_.float_value);
+}
+template <typename Context, typename T> basic_format_arg<Context> make_arg(T);
+struct basic_format_context {
+  using char_type = int;
+  using parse_context_type = int;
+  template <typename T> using formatter_type = formatter<T, char_type>;
+};
+struct format_arg_store {
+  using value_type = conditional_t<max_packed_args, basic_format_context,
+                                   basic_format_arg<basic_format_context>>;
+  value_type data_;
+};
+template <typename... Args, typename S>
+auto make_args_checked(S, Args... args) -> format_arg_store {
+  return {args...};
+}
+struct basic_format_specs {};
+template <typename Char, typename OutputIt, typename T>
+void write(OutputIt, T, Char) {
+  if (is_same<T, float>())
+    ;
+}
+struct arg_formatter_base {
+  using iterator = int;
+  using format_specs = basic_format_specs;
+  iterator out_;
+  template <typename T> void operator()(T value) {
+    auto specs = format_specs();
+    write(out_, value, specs);
+  }
+};
+struct arg_formatter : arg_formatter_base {
+  using context_type = basic_format_context;
+  arg_formatter(context_type, int *, format_specs *);
+};
+template <typename T, typename> struct formatter {
+  template <typename FormatContext> void format(T val, FormatContext ctx) {
+    using af = arg_formatter;
+    basic_format_arg<FormatContext> __trans_tmp_2 = make_arg<FormatContext>(val);
+    visit_format_arg(af(ctx, nullptr, &specs_), __trans_tmp_2);
+  }
+  basic_format_specs specs_;
+};
+} // namespace v7
+namespace level {
+enum level_enum { warn };
+}
+struct BucketLogger {
+  template <typename S, typename... Args>
+  void log(level::level_enum, const S &, Args &&...);
+  template <typename... Args> void warn(const char *, const Args &...);
+};
+namespace v7 {
+struct fallback_formatter : formatter<basic_string_view<int>, int> {
+  template <typename OutputIt> void format(int, OutputIt ctx) {
+    basic_string_view<int> str(0, 0);
+    formatter::format(str, ctx);
+  }
+};
+} // namespace v7
+template <typename S, typename... Args>
+void BucketLogger::log(level::level_enum, const S &fmt, Args &&...args) {
+  make_args_checked(fmt, args...);
+}
+template <typename... Args>
+void BucketLogger::warn(const char *fmt, const Args &...args) {
+  log(level::warn, fmt, args...);
+}
+template <class KeyT> struct AtomicHashArray {
+  static void create();
+  atomic isFull_;
+  atomic numErases_;
+  pair cells_[0];
+  AtomicHashArray(int, KeyT, KeyT, KeyT, double, unsigned);
+};
+template <class KeyT>
+AtomicHashArray<KeyT>::AtomicHashArray(int, KeyT, KeyT, KeyT, double, unsigned)
+    : isFull_(0), numErases_(0) {}
+template <class KeyT> void AtomicHashArray<KeyT>::create() {
+  int c_4, capacity;
+  double c_3;
+  char c_2, c_1, c_0;
+  AtomicHashArray(capacity, c_0, c_1, c_2, c_3, c_4);
+}
+int bufferAcknowledgement_vbucket;
+void DcpProducer::bufferAcknowledgement() {
+  logger->warn("", bufferAcknowledgement_vbucket);
+}
+void (*makeStreamsMap_p)() = AtomicHashArray<char>::create;
diff --git a/gcc/testsuite/g++.dg/inherit/virtual15.C b/gcc/testsuite/g++.dg/inherit/virtual15.C
new file mode 100644
index 00000000000..ebd8e3ad29b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/inherit/virtual15.C
@@ -0,0 +1,18 @@
+// PR c++/100797
+// { dg-do run }
+
+bool ok = false;
+struct S1 { virtual ~S1() {} };
+struct S2 { virtual void f1() = 0; };
+struct S3: S1, S2 {
+    void f1() { f2(); }
+    virtual void f2() = 0;
+};
+struct S4: S3 {
+  void f2() { ok = true; }
+  using S2::f1;
+};
+int main() {
+  S4().f1();
+  if (!ok) __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/inherit/virtual15a.C b/gcc/testsuite/g++.dg/inherit/virtual15a.C
new file mode 100644
index 00000000000..6139385192d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/inherit/virtual15a.C
@@ -0,0 +1,19 @@
+// PR c++/100797 plus diamond inheritance
+// { dg-do run }
+
+bool ok = false;
+struct S1 { virtual ~S1() {} };
+struct S2 { virtual void f1() = 0; };
+struct S3: S1, virtual S2 {
+    void f1() { f2(); }
+    virtual void f2() = 0;
+};
+struct SX: virtual S2 { };
+struct S4: SX, S3 {
+  void f2() { ok = true; }
+  using S2::f1;
+};
+int main() {
+  S4().f1();
+  if (!ok) __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/lookup/using66.C b/gcc/testsuite/g++.dg/lookup/using66.C
new file mode 100644
index 00000000000..02383bbea3e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/using66.C
@@ -0,0 +1,23 @@
+// PR c++/92918
+// { dg-do compile { target c++11 } }
+
+struct Base03
+{
+    static void impl();
+};
+
+struct Problem : Base03
+{
+    using Base03::impl;
+    static int impl(char const *);
+
+    template <typename T>
+    auto f(const T &t) const
+    -> decltype(impl(t))
+    {
+        return impl(t);
+    }
+};
+
+Problem t;
+int i = t.f("42");
diff --git a/gcc/testsuite/g++.dg/lto/pr97565_0.C b/gcc/testsuite/g++.dg/lto/pr97565_0.C
new file mode 100644
index 00000000000..f4572e17bf5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lto/pr97565_0.C
@@ -0,0 +1,7 @@
+// { dg-lto-do link }
+// { dg-lto-options { "-O -flto -fipa-pta" } }
+
+extern "C" void abort(void)
+{
+  abort();
+}
diff --git a/gcc/testsuite/g++.dg/lto/pr97565_1.C b/gcc/testsuite/g++.dg/lto/pr97565_1.C
new file mode 100644
index 00000000000..ff7b638e9c5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lto/pr97565_1.C
@@ -0,0 +1,6 @@
+extern "C" void abort(void);
+
+int main(int argc, char * argv[])
+{
+  abort();
+}
diff --git a/gcc/testsuite/g++.dg/opt/nrv20.C b/gcc/testsuite/g++.dg/opt/nrv20.C
new file mode 100644
index 00000000000..ade0c28824a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/nrv20.C
@@ -0,0 +1,20 @@
+// PR c++/91217
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fdump-tree-gimple }
+// { dg-final { scan-tree-dump-not "<retval> = a" "gimple" } }
+
+struct A
+{
+  int ar[42];
+};
+
+template <class T>
+A f()
+{
+  return [] { A a; return a; }();
+}
+
+int main()
+{
+  f<int>();
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr100148.C b/gcc/testsuite/g++.dg/opt/pr100148.C
new file mode 100644
index 00000000000..d038879b6b8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr100148.C
@@ -0,0 +1,27 @@
+// PR rtl-optimization/100148
+// { dg-do compile }
+// { dg-options "-O2 -fno-dce -fno-tree-dce -fno-tree-dominator-opts -fno-tree-sink -fcompare-debug" }
+
+int i;
+enum E { } e, ee;
+
+bool
+baz (int)
+{
+  return ee;
+}
+
+bool bar ();
+bool a, b;
+
+void
+foo ()
+{
+  switch (ee)
+    {
+    case 0:
+      e = E (a ? : i);
+    case 1:
+      !(b || baz (0) && bar ());
+    }
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr100254.C b/gcc/testsuite/g++.dg/opt/pr100254.C
new file mode 100644
index 00000000000..dbdac1638c7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr100254.C
@@ -0,0 +1,101 @@
+// PR rtl-optimization/100254
+// { dg-do compile }
+// { dg-options "-O2 -fno-guess-branch-probability -fipa-pta -fnon-call-exceptions -fcompare-debug" }
+// { dg-additional-options "-mtune=goldmont" { target i?86-*-* x86_64-*-* } }
+
+struct _Rb_tree_node_base {
+  typedef _Rb_tree_node_base *_Base_ptr;
+  typedef _Rb_tree_node_base *_Const_Base_ptr;
+  _Base_ptr _M_left;
+};
+template <typename _Key_compare> struct _Rb_tree_key_compare {
+  _Key_compare _M_key_compare;
+};
+struct _Rb_tree_header {
+  _Rb_tree_node_base _M_header;
+};
+struct _Rb_tree_iterator {
+  _Rb_tree_iterator(_Rb_tree_node_base::_Base_ptr);
+  friend bool operator==(_Rb_tree_iterator, _Rb_tree_iterator);
+};
+template <typename _Tp> struct _Rb_tree_const_iterator {
+  typedef _Rb_tree_const_iterator _Self;
+  _Rb_tree_const_iterator(_Rb_tree_node_base::_Const_Base_ptr) {}
+  _Tp operator*();
+  template <typename _Up>
+  friend bool operator!=(_Rb_tree_const_iterator<_Up>, _Rb_tree_const_iterator<_Up>);
+};
+template <typename _Key, typename _Val, typename _Compare> struct _Rb_tree {
+  template <typename _Key_compare>
+  struct _Rb_tree_impl : _Rb_tree_key_compare<_Key_compare>, _Rb_tree_header {};
+  _Rb_tree_impl<_Compare> _M_impl;
+  _Key _S_key();
+  typedef _Rb_tree_const_iterator<_Val> const_iterator;
+  const_iterator begin() { return _M_impl._M_header._M_left; }
+  _Rb_tree_iterator find(const _Key &);
+};
+template <typename _Key, typename _Val, typename _Compare>
+_Rb_tree_iterator _Rb_tree<_Key, _Val, _Compare>::find(const _Key &__k) {
+  _Rb_tree_iterator __j = 0;
+  return __j == 0 || _M_impl._M_key_compare(__k, _S_key()) ? 0 : __j;
+}
+template <typename _Key, typename _Compare = _Key> struct set {
+  typedef _Key key_type;
+  typedef _Rb_tree<key_type, _Key, _Compare> _Rep_type;
+  _Rep_type _M_t;
+  typedef typename _Rep_type::const_iterator iterator;
+  iterator begin() { return _M_t.begin(); }
+  iterator end();
+  void find(key_type __x) { _M_t.find(__x); }
+};
+struct WindowDesc {
+  WindowDesc(short);
+} _station_view_desc(0);
+struct Window {
+  void IsWidgetLowered();
+  virtual void OnClick(int, int, int);
+};
+int AllocateWindowDescFront_window_number;
+template <typename Wcls> void AllocateWindowDescFront(WindowDesc *desc, bool) {
+  Wcls(desc, AllocateWindowDescFront_window_number);
+}
+class CargoDataEntry;
+struct CargoSorter {
+  bool operator()(const CargoDataEntry *, const CargoDataEntry *) const;
+};
+struct CargoDataEntry {
+  ~CargoDataEntry();
+  char Retrieve_cargo;
+  void Retrieve() {
+    CargoDataEntry t(Retrieve_cargo);
+    children->find(&t);
+  }
+  CargoDataEntry(char);
+  set<CargoDataEntry *, CargoSorter> *children;
+};
+CargoDataEntry::CargoDataEntry(char) : children() {}
+CargoDataEntry::~CargoDataEntry() {
+  if (children)
+    for (set<CargoDataEntry *>::iterator i = children->begin();
+         i != children->end();)
+      delete *i;
+}
+bool CargoSorter::operator()(const CargoDataEntry *,
+                             const CargoDataEntry *) const { return false; }
+struct StationViewWindow : Window {
+  StationViewWindow(WindowDesc *, int);
+  CargoDataEntry HandleCargoWaitingClick_filter;
+  void OnClick(int, int widget, int) {
+    switch (widget) {
+    case 0:
+      HandleCargoWaitingClick_filter.Retrieve();
+      HandleCargoWaitingClick_filter.Retrieve();
+    case 1:
+      IsWidgetLowered();
+    }
+  }
+};
+void ShowStationViewWindow_station() {
+  AllocateWindowDescFront<StationViewWindow>(&_station_view_desc,
+                                             ShowStationViewWindow_station);
+}
diff --git a/gcc/testsuite/g++.dg/other/gc6.C b/gcc/testsuite/g++.dg/other/gc6.C
new file mode 100644
index 00000000000..ff45dd313d6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/gc6.C
@@ -0,0 +1,16 @@
+// PR c++/99831
+// { dg-do compile { target c++20 } }
+// { dg-options "--param ggc-min-heapsize=0 --param ggc-min-expand=0" }
+
+template <int N> struct S {
+  constexpr S(const char (&str)[N]) : value{} { }
+  char value[N];
+};
+template <S> struct string {
+  constexpr bool operator==(const string &) const = default;
+};
+template <S L2> void operator+(string<L2>) {
+  char value[1];
+  S{value};
+}
+static_assert(string<"a">{} == string<"a">{});
diff --git a/gcc/testsuite/g++.dg/other/gc7.C b/gcc/testsuite/g++.dg/other/gc7.C
new file mode 100644
index 00000000000..ab436bac72f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/gc7.C
@@ -0,0 +1,16 @@
+// PR c++/91416 - GC during late parsing collects live data.
+// { dg-do compile }
+// { dg-options "--param ggc-min-heapsize=0 --param ggc-min-expand=0" }
+
+__attribute__ ((unused)) struct S {
+  S() { }
+} s;
+
+__attribute__ ((unused)) struct X {
+  void fn ()
+  {
+    __attribute__ ((unused)) struct N {
+	N() { }
+    } n;
+  }
+} x;
diff --git a/gcc/testsuite/g++.dg/pr100253.C b/gcc/testsuite/g++.dg/pr100253.C
new file mode 100644
index 00000000000..0102caa7df8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr100253.C
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-bit-ccp -ftree-slp-vectorize" } */
+
+#include <vector>
+
+struct T
+{
+};
+
+struct S
+{
+  std::vector < std::vector < T > > v;
+  char x;
+  char y[16];
+  char z[16];
+};
+
+S s, g[1];
+
+void
+foo (char *buf)
+{
+  s = g[*buf];
+}
+
+char c;
+
+int
+main ()
+{
+  foo (&c);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/pr98032.C b/gcc/testsuite/g++.dg/pr98032.C
new file mode 100644
index 00000000000..d7eef276668
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr98032.C
@@ -0,0 +1,20 @@
+// { dg-do compile }
+
+namespace osl {
+class Thread {
+public:
+  virtual ~Thread();
+  virtual void join();
+};
+} // namespace osl
+class SimpleReferenceObject {
+protected:
+  virtual ~SimpleReferenceObject();
+};
+class Thread : SimpleReferenceObject, osl::Thread {
+public:
+  using osl::Thread::join;
+};
+class RenderThread : Thread {
+  RenderThread() { join(); }
+};
diff --git a/gcc/testsuite/g++.dg/pr98136.C b/gcc/testsuite/g++.dg/pr98136.C
new file mode 100644
index 00000000000..f3c27f6b09f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr98136.C
@@ -0,0 +1,26 @@
+// { dg-do compile { target { ilp32 || lp64 } } }
+
+struct AddIn
+{
+    virtual ~AddIn() {}
+    virtual void AddInCall()=0;
+};
+
+struct Base
+{
+    char b[32*1024*1024];   // Anything bigger than 16mb causes internal compiler error
+    virtual ~Base() {}
+};
+
+struct Deriv : public Base,
+                    public AddIn
+{
+    void AddInCall() {}
+};
+
+int main (int argc, char **argv)
+{
+    Deriv deriv;
+    deriv.AddInCall();
+    return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/friend70.C b/gcc/testsuite/g++.dg/template/friend70.C
new file mode 100644
index 00000000000..54965486f79
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend70.C
@@ -0,0 +1,9 @@
+// PR c++/52625
+
+template<class>
+class base {};
+
+class derived : public base<derived>
+{
+  template<class> friend class base;
+};
diff --git a/gcc/testsuite/g++.dg/template/friend71.C b/gcc/testsuite/g++.dg/template/friend71.C
new file mode 100644
index 00000000000..939ea6b5264
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend71.C
@@ -0,0 +1,8 @@
+// PR c++/41723
+
+template<class T>
+class C {
+  template <class U> class D {};
+
+  friend class C::D<int>;
+};
diff --git a/gcc/testsuite/g++.dg/template/ref11.C b/gcc/testsuite/g++.dg/template/ref11.C
new file mode 100644
index 00000000000..c43c67edf70
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/ref11.C
@@ -0,0 +1,9 @@
+// PR c++/83476
+
+int n;
+template <int& V> struct A {};
+template <int& V> void f(A<V>);
+int main() {
+  A<n> a;
+  f(a);
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr102505.C b/gcc/testsuite/g++.dg/torture/pr102505.C
new file mode 100644
index 00000000000..a846751a0d6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr102505.C
@@ -0,0 +1,15 @@
+struct D  { int i;  int pad alignas(16); };
+struct B : virtual D
+{
+  int j =84;
+  int k =84;
+};
+
+struct C: B { };
+
+int main()
+{
+  C c;
+  if (c.j != 84 || c.k != 84)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wconversion5.C b/gcc/testsuite/g++.dg/warn/Wconversion5.C
new file mode 100644
index 00000000000..f5ae6312bc5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wconversion5.C
@@ -0,0 +1,19 @@
+// PR c++/99331
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wconversion" }
+// Don't issue -Wconversion warnings for value-dependent expressions.
+
+template <int> struct X {};
+template <signed char> struct Y {};
+template <typename T> X<sizeof(T)> foo();
+template <typename T> X<alignof(T)> foo2();
+template<int I> Y<I> foo3();
+template<int> Y<1024> foo4(); // { dg-error "narrowing conversion" }
+template<int> Y<1u> foo5();
+template<int> X<__INT_MAX__ + 1U> foo6(); // { dg-error "narrowing conversion" }
+
+template <typename T>
+struct S {
+  using t = X<sizeof(T)>;
+  using u = X<alignof(T)>;
+};
diff --git a/gcc/testsuite/g++.dg/warn/Wshadow-17.C b/gcc/testsuite/g++.dg/warn/Wshadow-17.C
new file mode 100644
index 00000000000..0dee397796f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wshadow-17.C
@@ -0,0 +1,11 @@
+// PR c++/99120
+// { dg-options "-Wshadow" }
+
+struct S {
+  void X();
+
+  template<typename T>
+  void fn () {
+    enum { X };
+  }
+};
diff --git a/gcc/testsuite/g++.target/aarch64/sve/pr99216.C b/gcc/testsuite/g++.target/aarch64/sve/pr99216.C
new file mode 100644
index 00000000000..61a58a7fcf4
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/sve/pr99216.C
@@ -0,0 +1,5 @@
+/* { dg-do link { target aarch64_asm_sve_ok } } */
+/* { dg-additional-options "-flto" } */
+#include <arm_sve.h>
+bool a;
+int main() { a = svaddv(svptrue_b8(), svdup_s8(0)); }
diff --git a/gcc/testsuite/g++.target/arm/pr102842.C b/gcc/testsuite/g++.target/arm/pr102842.C
new file mode 100644
index 00000000000..a2bac66091a
--- /dev/null
+++ b/gcc/testsuite/g++.target/arm/pr102842.C
@@ -0,0 +1,30 @@
+/* PR rtl-optimization/102842 */
+/* { dg-do compile } */
+/* { dg-options "-fPIC  -O2 -fno-omit-frame-pointer -mthumb -march=armv7-a+fp" } */
+
+struct Plane {
+  using T = float;
+  T *Row();
+};
+using ImageF = Plane;
+long long Mirror_x;
+struct EnsurePaddingInPlaceRowByRow {
+  void Process() {
+    switch (strategy_) {
+    case kSlow:
+      float *row = img_.Row();
+      long long xsize = x1_;
+      while (Mirror_x >= xsize)
+        if (Mirror_x)
+          Mirror_x = 2 * xsize - 1;
+      *row = Mirror_x;
+    }
+  }
+  ImageF img_;
+  unsigned x1_;
+  enum { kSlow } strategy_;
+};
+void FinalizeImageRect() {
+  EnsurePaddingInPlaceRowByRow ensure_padding;
+  ensure_padding.Process();
+}
diff --git a/gcc/testsuite/g++.target/powerpc/pr99842.C b/gcc/testsuite/g++.target/powerpc/pr99842.C
new file mode 100644
index 00000000000..922450e2c21
--- /dev/null
+++ b/gcc/testsuite/g++.target/powerpc/pr99842.C
@@ -0,0 +1,188 @@
+/* PR target/99842 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O3 -mdejagnu-cpu=power10 -Wno-return-type" } */
+
+/* Verify we do not ICE on the following noisy creduced test case.  */
+
+enum { a, b, c, d };
+template <typename> struct e;
+template <typename g, typename h, typename k> struct e<g(h, k)> {
+  typedef h f;
+};
+template <typename> struct ac;
+template <typename ab> struct ac<const ab> : ac<ab> {};
+template <typename> struct l;
+template <typename, int, int m, int = 0, int = a, int = m> class n;
+template <typename> class o;
+template <typename, typename, typename> class ag;
+template <typename, typename, int = c> class af;
+template <typename> struct ad;
+template <typename ab> struct an {
+  typedef n<typename ab ::ah, ac<ab>::ai, ac<ab>::aj> f;
+};
+template <typename al> struct am { typedef o<al> f; };
+template <typename al, typename = typename ac<al>::ao,
+          typename = typename ac<al>::av>
+struct ak;
+template <typename al, typename ao> struct ak<al, ao, int> {
+  typedef typename am<al>::f f;
+};
+template <typename, typename, typename> struct aq;
+template <typename ar, typename as> struct aq<ar, ar, as> { typedef ar at; };
+template <typename ap> ap bf(const typename ad<ap>::f *);
+template <typename ap, int> ap aw(typename ad<ap>::f *ax) { return bf<ap>(ax); }
+typedef __attribute__((altivec(vector__))) double au;
+template <> struct ad<au> { typedef double f; };
+template <> au bf(const double *ax) { return __builtin_vec_vsx_ld(0, ax); }
+template <typename> struct az {};
+template <typename al> class o : public l<al> {
+public:
+  typedef typename ac<al>::ah ah;
+  template <typename ay> al &operator+=(const o<ay> &);
+};
+template <typename> struct l {};
+template <typename ba, typename bb, int bd> struct ac<af<ba, bb, bd>> {
+  typedef typename ba::ah ah;
+  enum { ai, aj };
+};
+template <typename, typename, int bd>
+class af
+    : public ak<
+          af<ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,
+             n<double, -1, 1, 3>, bd>,
+          int, int>::f {};
+template <typename, typename, typename> struct be;
+template <typename bj, typename bg, typename g> void bi(bj, bg bm, g) {
+  typename an<bg>::f bk(bm);
+}
+template <typename bj, typename bg, typename g> void bl(bj, bg bm, g bp) {
+  be<bj, bg, g>::bn(a, bm, bp);
+}
+template <typename, typename, typename, typename> struct bo;
+class bs {
+public:
+  bs(double *, int);
+  double &operator()(int, int) { return bq[br]; }
+  template <typename bw, int> bw bt(int i, int j) {
+    double &bu = operator()(i, j);
+    return aw<bw, b>(&bu);
+  }
+  double *bq;
+  int br;
+};
+class ca : public bs {
+public:
+  ca(double *by, int bz) : bs(by, bz) {}
+};
+template <typename al> class ce : public am<al>::f {
+protected:
+  template <typename ay> void cb(l<ay>) {
+    af<ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,
+       n<double, -1, 1, 3>>
+        cc;
+    bl(0, cc, az<typename ay::ah>());
+  }
+  template <typename> void ch(long);
+  template <typename ay> void ch(l<ay> cf) { cb(cf); }
+};
+template <typename cg, int aa, int m, int cl, int ci, int cj>
+struct ac<n<cg, aa, m, cl, ci, cj>> {
+  typedef cg ah;
+  typedef int av;
+};
+template <typename cg, int, int m, int, int, int>
+class n : public ce<n<cg, m, c>> {
+public:
+  template <typename ab> n(ab p) { n::template ch<ab>(p); }
+};
+template <typename bc, typename ba, typename bb> struct ac<ag<bc, ba, bb>> {
+  typedef ba ao;
+  typedef typename e<bc(typename ba::ah, typename bb::ah)>::f ah;
+  typedef typename aq<typename ac<ba>::av, typename ac<bb>::av, bc>::at av;
+};
+template <typename> class cm;
+template <typename, typename r, typename cs>
+class ag
+    : public cm<typename aq<typename ac<r>::av, typename ac<cs>::av, int>::at> {
+};
+template <typename>
+class cm : public ak<ag<int, n<double, 1, 1>, n<double, 1, 1>>>::f {};
+template <typename al>
+template <typename ay>
+al &o<al>::operator+=(const o<ay> &) {
+  af<ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,
+     n<double, -1, 1, 3>>
+      co;
+  bi(0, co, int());
+}
+enum { cp };
+template <int> struct cq;
+template <typename> struct cr {
+  enum { q };
+  enum { ae = cq<q>::at };
+};
+template <> struct cq<cp> {
+  enum { at = d };
+};
+struct t {
+  template <typename ba, typename bb, typename s> static void bn(ba, bb, s) {
+    typedef typename bb::ah x;
+    x u;
+    bo<long, ca, x, ca>::bn(0, 0, ca(0, 0), ca(&u, 1), 0, 0, 0);
+  }
+};
+template <typename, typename bb, int = cr<bb>::ae> struct cu;
+template <typename cd, typename ba, typename bb, int ct, typename ah>
+struct be<cd, af<ba, bb, ct>, az<ah>> {
+  static void bn(cd, af<ba, bb> bm, az<ah>) {
+    ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>> da;
+    cu<ba, bb>::cv(c, da, bm);
+  }
+};
+template <typename al> struct cw {
+  template <typename bj>
+  static void
+  cv(bj, ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,
+     n<double, -1, 1, 3> bx) {
+    double alpha;
+    ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>> bh;
+    al::cx(c, bh, bx, alpha);
+  }
+};
+template <typename ba, typename bb> struct cu<ba, bb, d> : cw<cu<ba, bb>> {
+  template <typename s> static void cx(s, ba, bb bx, typename af<ba, bb>::ah) {
+    ba cz;
+    t::bn(cz, bx, c);
+  }
+};
+template <typename dj, typename, bool>
+void db(__vector_quad *, __vector_pair &, dj);
+template <typename, typename, typename, typename, typename, typename, int>
+void dc(ca alhs) {
+  typedef au dj;
+  typedef au dd;
+  ca bh(alhs);
+  enum { de };
+  __vector_quad df, dg;
+  int j;
+  dd v;
+  __vector_pair dh;
+  __builtin_mma_assemble_pair(
+      &dh, (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j),
+      (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j));
+  db<dj, dd, true>(&df, dh, v);
+  __vector_pair di;
+  __builtin_mma_assemble_pair(
+      &di, (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j),
+      (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j));
+  db<dj, dd, true>(&dg, di, v);
+}
+template <typename bv, typename w, typename cy> struct bo<bv, w, double, cy> {
+  static void bn(bv, bv, w bh, cy, double, bv, double) {
+    dc<bv, double, w, double, cy, double, d>(bh);
+  }
+};
+void dm() {
+  n<double, 1, 1> dk(1), y(0);
+  y += dk;
+}
diff --git a/gcc/testsuite/g++.target/s390/pr98722.C b/gcc/testsuite/g++.target/s390/pr98722.C
new file mode 100644
index 00000000000..64edaf3de21
--- /dev/null
+++ b/gcc/testsuite/g++.target/s390/pr98722.C
@@ -0,0 +1,12 @@
+// { dg-do compile }
+// { dg-options "-Og -fno-tree-fre -fno-split-wide-types" }
+struct B {
+  virtual void Method();
+};
+typedef void (B::*fn_type_a)();
+
+int main() {
+  fn_type_a f(&B::Method);
+  B b;
+  (b.*f)();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr100305.c b/gcc/testsuite/gcc.c-torture/compile/pr100305.c
new file mode 100644
index 00000000000..43d78bf6542
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr100305.c
@@ -0,0 +1,13 @@
+/* PR target/100305 */
+
+typedef double v2df __attribute__((vector_size(16)));
+
+#define N 4096
+void consume (void *);
+v2df
+foo (void)
+{
+  double x[N+2];
+  consume (x);
+  return (v2df) { x[N], x[N + 1] };
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr96796.c b/gcc/testsuite/gcc.c-torture/compile/pr96796.c
new file mode 100644
index 00000000000..8808e62fe77
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr96796.c
@@ -0,0 +1,55 @@
+/* { dg-additional-options "-fcommon" } */
+
+struct S0 {
+  signed f0 : 8;
+  unsigned f1;
+  unsigned f4;
+};
+struct S1 {
+  long f3;
+  char f4;
+} g_3_4;
+
+int g_5, func_1_l_32, func_50___trans_tmp_31;
+static struct S0 g_144, g_834, g_1255, g_1261;
+
+int g_273[120] = {};
+int *g_555;
+char **g_979;
+static int g_1092_0;
+static int g_1193;
+int safe_mul_func_int16_t_s_s(int si1, int si2) { return si1 * si2; }
+static struct S0 *func_50();
+int func_1() { func_50(g_3_4, g_5, func_1_l_32, 8, 3); }
+void safe_div_func_int64_t_s_s(int *);
+void safe_mod_func_uint32_t_u_u(struct S0);
+struct S0 *func_50(int p_51, struct S0 p_52, struct S1 p_53, int p_54,
+                   int p_55) {
+  int __trans_tmp_30;
+  char __trans_tmp_22;
+  short __trans_tmp_19;
+  long l_985_1;
+  long l_1191[8];
+  safe_div_func_int64_t_s_s(g_273);
+  __builtin_printf((char*)g_1261.f4);
+  safe_mod_func_uint32_t_u_u(g_834);
+  g_144.f0 += 1;
+  for (;;) {
+    struct S1 l_1350 = {&l_1350};
+    for (; p_53.f3; p_53.f3 -= 1)
+      for (; g_1193 <= 2; g_1193 += 1) {
+        __trans_tmp_19 = safe_mul_func_int16_t_s_s(l_1191[l_985_1 + p_53.f3],
+                                                   p_55 % (**g_979 = 10));
+        __trans_tmp_22 = g_1255.f1 * p_53.f4;
+        __trans_tmp_30 = __trans_tmp_19 + __trans_tmp_22;
+        if (__trans_tmp_30)
+          g_1261.f0 = p_51;
+        else {
+          g_1255.f0 = p_53.f3;
+          int *l_1422 = g_834.f0 = g_144.f4 != (*l_1422)++ > 0 < 0 ^ 51;
+          g_555 = ~0;
+          g_1092_0 |= func_50___trans_tmp_31;
+        }
+      }
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr97141.c b/gcc/testsuite/gcc.c-torture/compile/pr97141.c
new file mode 100644
index 00000000000..1a9ff830a22
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr97141.c
@@ -0,0 +1,8 @@
+int a;
+short b, c;
+short d(short e, short f) { return e + f; }
+void g(void) {
+  a = -9;
+  for (; a != 51; a = d(a, 5))
+    b |= c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr98726.c b/gcc/testsuite/gcc.c-torture/compile/pr98726.c
new file mode 100644
index 00000000000..ce24b18ce55
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr98726.c
@@ -0,0 +1,7 @@
+int a, c;
+char b;
+int d() {
+  a = 0;
+  for (; a <= 21; a = (short)a + 1)
+    b &= c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr99647.c b/gcc/testsuite/gcc.c-torture/compile/pr99647.c
new file mode 100644
index 00000000000..701155dd856
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr99647.c
@@ -0,0 +1,5 @@
+/* { dg-do assemble } */
+typedef int __attribute((vector_size(16))) V;
+V f(void) {
+  return (V){ (int)f, (int)f, (int)f, (int)f };
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20210505-1.c b/gcc/testsuite/gcc.c-torture/execute/20210505-1.c
new file mode 100644
index 00000000000..10a2de07921
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20210505-1.c
@@ -0,0 +1,31 @@
+/* PR target/100402 */
+/* Testcase by Hannes Domani <ssbssa@yahoo.de> */
+
+/* { dg-require-effective-target indirect_jumps } */
+
+#include <setjmp.h>
+#include <stdbool.h>
+
+static jmp_buf buf;
+static _Bool stop = false;
+
+void call_func (void(*func)(void))
+{
+  func ();
+}
+
+void func (void)
+{
+  stop = true;
+  longjmp (buf, 1);
+}
+
+int main (void)
+{
+  setjmp (buf);
+
+  while (!stop)
+    call_func (func);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c b/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c
new file mode 100644
index 00000000000..bdbf5733ce7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c
@@ -0,0 +1,24 @@
+/* PR tree-optimization/102622 */
+/* Wrong code introduced due to phi-opt
+   introducing undefined signed interger overflow
+   with one bit signed integer negation. */
+
+struct f{signed t:1;};
+int g(struct f *a, int t) __attribute__((noipa));
+int g(struct f *a, int t)
+{
+    if (t)
+      a->t = -1;
+    else
+      a->t = 0;
+    int t1 = a->t;
+    if (t1) return 1;
+    return t1;
+}
+
+int main(void)
+{
+    struct f a;
+    if (!g(&a, 1))  __builtin_abort();
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr103052.c b/gcc/testsuite/gcc.c-torture/execute/pr103052.c
new file mode 100644
index 00000000000..bef8674a43c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr103052.c
@@ -0,0 +1,35 @@
+static void js_error(void);
+static int top;
+static void js_throw(void)
+{
+	__builtin_exit(0);
+}
+
+// LOCATION A -- if js_pop is here, the bug is present
+static void js_pop(void)
+{
+	if (++top > 100)
+		js_error();
+}
+
+static void jsC_error(const char *v)
+{
+	if (v[0] == 0)
+		js_error();
+	js_throw();
+}
+static void checkfutureword(const char *exp)
+{
+	if (!__builtin_strcmp(exp, "const"))
+		jsC_error("boom");
+}
+static void js_error(void) {
+	checkfutureword("foo");
+	checkfutureword("bar");
+	js_pop();
+}
+int main(void)
+{
+	checkfutureword("const");
+	__builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr98736.c b/gcc/testsuite/gcc.c-torture/execute/pr98736.c
new file mode 100644
index 00000000000..c066abcd86a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr98736.c
@@ -0,0 +1,14 @@
+/* PR tree-optimization/98736 */
+
+int a[6];
+char b, c;
+int main() {
+  int d[4] = {0, 0, 0, 0};
+  for (c = 0; c <= 5; c++) {
+    for (b = 2; b != 0; b++)
+      a[c] = 8;
+    a[c] = d[3];
+  }
+  if (a[0] != 0)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.dg/Wstringop-overflow-67.c b/gcc/testsuite/gcc.dg/Wstringop-overflow-67.c
new file mode 100644
index 00000000000..7b8f3f014c6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wstringop-overflow-67.c
@@ -0,0 +1,92 @@
+/* PR middle-end/100571 - bogus -Wstringop-overflow with VLA of elements
+   larger than byte
+   { dg-do compile }
+   { dg-options "-O2 -Wall" } */
+
+__attribute__ ((access (read_only, 1, 2))) void fro (int *, int);
+__attribute__ ((access (write_only, 1, 2))) void fwo (int *, int);
+__attribute__ ((access (read_write, 1, 2))) void frw (int *, int);
+
+extern __SIZE_TYPE__ n;
+
+void alloca_ro (void)
+{
+  int *a = __builtin_alloca (n * sizeof *a);
+  a[0] = 0;
+  fro (a, n);
+}
+
+void alloca_wo (void)
+{
+  int *a = __builtin_alloca (n * sizeof *a);
+  fwo (a, n);
+}
+
+void alloca_rw (void)
+{
+  int *a = __builtin_alloca (n * sizeof *a);
+  a[0] = 0;
+  frw (a, n);
+}
+
+
+void calloc_ro (void)
+{
+  int *a = __builtin_calloc (n, sizeof *a);
+  fro (a, n);
+}
+
+void calloc_wo (void)
+{
+  int *a = __builtin_calloc (n, sizeof *a);
+  fwo (a, n);
+}
+
+void calloc_rw (void)
+{
+  int *a = __builtin_calloc (n, sizeof *a);
+  a[0] = 0;
+  frw (a, n);
+}
+
+
+void malloc_ro (void)
+{
+  int *a = __builtin_malloc (n * sizeof *a);
+  a[0] = 0;
+  fro (a, n);
+}
+
+void malloc_wo (void)
+{
+  int *a = __builtin_malloc (n * sizeof *a);
+  fwo (a, n);
+}
+
+void malloc_rw (void)
+{
+  int *a = __builtin_malloc (n * sizeof *a);
+  a[0] = 0;
+  frw (a, n);
+}
+
+
+void vla_ro (void)
+{
+  int a[n];
+  a[0] = 0;
+  fro (a, n);
+}
+
+void vla_wo (void)
+{
+  int a[n];
+  fwo (a, n);
+}
+
+void vla_rw (void)
+{
+  int a[n];
+  a[0] = 0;
+  frw (a, n);
+}
diff --git a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
index 75e902cd1f4..35dff89c377 100644
--- a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
+++ b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
@@ -1280,6 +1280,8 @@ subvalues (struct entry *e, char *p, char *letter)
       if (e[0].len != 0)
 	output_FNB ('B', e);
       return 1;
+    default:
+      return 0;
     }
 }
 
diff --git a/gcc/testsuite/gcc.dg/goacc/tile-1.c b/gcc/testsuite/gcc.dg/goacc/tile-1.c
new file mode 100644
index 00000000000..6898397ad5e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/goacc/tile-1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+
+/* PR c/97880 */
+
+void f ()
+{
+  #pragma acc parallel loop tile(2, 3)
+  for (int i = 0; i < 8; i++)
+    for (long j = 0; j < 8; j++);
+}
diff --git a/gcc/testsuite/gcc.dg/ipa/pr101066.c b/gcc/testsuite/gcc.dg/ipa/pr101066.c
new file mode 100644
index 00000000000..1ceb6e43136
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/pr101066.c
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+/* { dg-options "-Os -fno-ipa-cp -fno-inline" } */
+
+int a = 1, c, d, e;
+int *b = &a;
+static int g(int *h) {
+  c = *h;
+  return d;
+}
+static void f(int *h) {
+  e = *h;
+  *b = 0;
+  g(h);
+}
+int main() {
+  f(b);
+  if (c)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/ipa/pr102714.c b/gcc/testsuite/gcc.dg/ipa/pr102714.c
new file mode 100644
index 00000000000..65dd86f5c15
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/pr102714.c
@@ -0,0 +1,117 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-strict-aliasing -fdump-ipa-sra-details -fdump-tree-optimized" } */
+
+typedef _Bool bool;
+
+enum {
+ false = 0,
+ true = 1
+};
+
+struct xarray {
+ unsigned int xa_lock;
+ unsigned int xa_flags;
+ void * xa_head;
+
+};
+
+struct list_head {
+ struct list_head *next, *prev;
+};
+
+struct callback_head {
+ struct callback_head *next;
+ void (*func)(struct callback_head *head);
+} __attribute__((aligned(sizeof(void *))));
+
+struct xa_node {
+ unsigned char shift;
+ unsigned char offset;
+ unsigned char count;
+ unsigned char nr_values;
+ struct xa_node *parent;
+ struct xarray *array;
+ union {
+  struct list_head private_list;
+  struct callback_head callback_head;
+ };
+ void *slots[(1UL << (0 ? 4 : 6))];
+ union {
+  unsigned long tags[3][((((1UL << (0 ? 4 : 6))) + (64) - 1) / (64))];
+  unsigned long marks[3][((((1UL << (0 ? 4 : 6))) + (64) - 1) / (64))];
+ };
+};
+
+static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) unsigned long shift_maxindex(unsigned int shift)
+{
+ return ((1UL << (0 ? 4 : 6)) << shift) - 1;
+}
+
+static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) unsigned long node_maxindex(const struct xa_node *node)
+{
+ return shift_maxindex(node->shift);
+}
+
+static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) struct xa_node *entry_to_node(void *ptr)
+{
+ return (void *)((unsigned long)ptr & ~2UL);
+}
+
+static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) bool radix_tree_is_internal_node(void *ptr)
+{
+ return ((unsigned long)ptr & 3UL) ==
+    2UL;
+}
+
+static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) void *xa_mk_internal(unsigned long v)
+{
+ return (void *)((v << 2) | 2);
+}
+
+static unsigned radix_tree_load_root(const struct xarray *root,
+  struct xa_node **nodep, unsigned long *maxindex)
+{
+ struct xa_node *node =
+ ({
+    typeof(root->xa_head) ________p1 = ({(*(const volatile typeof(root->xa_head) *)&(root->xa_head)); });
+    ((typeof(*root->xa_head) *)(________p1));
+ });
+
+ *nodep = node;
+
+ if (__builtin_expect(!!(radix_tree_is_internal_node(node)), 1)) {
+  node = entry_to_node(node);
+  *maxindex = node_maxindex(node);
+  return node->shift + (0 ? 4 : 6);
+ }
+
+ *maxindex = 0;
+ return 0;
+}
+
+void *__radix_tree_lookup(const struct xarray *root,
+     unsigned long index, struct xa_node **nodep,
+     void ***slotp)
+{
+ struct xa_node *node, *parent;
+ unsigned long maxindex;
+
+ restart:
+ parent = ((void *)0);
+ radix_tree_load_root(root, &node, &maxindex);
+ while (radix_tree_is_internal_node(node)) {
+
+  parent = entry_to_node(node);
+  if (node == xa_mk_internal(256))
+   goto restart;
+  if (parent->shift == 0)
+   break;
+ }
+ if (nodep)
+  *nodep = parent;
+
+ return node;
+}
+
+/* { dg-final { scan-ipa-dump-not "IPA_PARAM_OP_SPLIT" "sra" } } */
+/* { dg-final { scan-tree-dump " ={v} " "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_0.c b/gcc/testsuite/gcc.dg/lto/pr101868_0.c
new file mode 100644
index 00000000000..c84d19b0267
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_0.c
@@ -0,0 +1,33 @@
+/* { dg-lto-do run } */
+/* { dg-lto-options { "-O2 -fno-strict-aliasing -flto" } } */
+
+typedef unsigned long VALUE;
+
+__attribute__ ((cold))
+void rb_check_type(VALUE, int);
+
+static VALUE
+repro(VALUE dummy, VALUE hash)
+{
+    if (hash == 0) {
+        rb_check_type(hash, 1);
+    }
+    else if (*(long *)hash) {
+        rb_check_type(hash, 1);
+    }
+
+
+    return *(long *)hash;
+}
+
+static VALUE (*that)(VALUE dummy, VALUE hash) = repro;
+
+int
+main(int argc, char **argv)
+{
+        argc--;
+        that(0, argc);
+
+        rb_check_type(argc, argc);
+
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_1.c b/gcc/testsuite/gcc.dg/lto/pr101868_1.c
new file mode 100644
index 00000000000..146c14abc76
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_1.c
@@ -0,0 +1,23 @@
+typedef unsigned long VALUE;
+
+
+__attribute__ ((noreturn)) void rexc_raise(VALUE mesg);
+
+VALUE rb_donothing(VALUE klass);
+
+static void
+funexpected_type(VALUE x, int xt, int t)
+{
+    rexc_raise(rb_donothing(0));
+}
+
+__attribute__ ((cold))
+void
+rb_check_type(VALUE x, int t)
+{
+    int xt;
+
+    if (x == 0) {
+        funexpected_type(x, xt, t);
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_2.c b/gcc/testsuite/gcc.dg/lto/pr101868_2.c
new file mode 100644
index 00000000000..e6f01b23f45
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_2.c
@@ -0,0 +1,11 @@
+typedef unsigned long VALUE;
+
+static void thing(void) {}
+static void (*ptr)(void) = &thing;
+
+VALUE
+rb_donothing(VALUE klass)
+{
+        ptr();
+        return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_3.c b/gcc/testsuite/gcc.dg/lto/pr101868_3.c
new file mode 100644
index 00000000000..61217625be7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_3.c
@@ -0,0 +1,8 @@
+typedef unsigned long VALUE;
+
+__attribute__((noreturn))
+void
+rexc_raise(VALUE mesg)
+{
+        __builtin_exit(0);
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr99849_0.c b/gcc/testsuite/gcc.dg/lto/pr99849_0.c
new file mode 100644
index 00000000000..d489cee0f52
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr99849_0.c
@@ -0,0 +1,23 @@
+/* PR lto/99849 */
+/* { dg-lto-do link } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target shared } */
+/* { dg-extra-ld-options { -shared } } */
+/* { dg-lto-options { { -flto -flto-partition=1to1 -O2 -Wno-incompatible-pointer-types -Wno-discarded-qualifiers -fPIC } } } */
+
+struct { struct A *a; } *b;
+struct B { int *b; };
+struct C { int *c; };
+const struct D { struct C d; } d;
+struct A { struct { struct C e; }; };
+struct E { void *e; } e = { &( &(const struct D) { (void *) &d })->d };
+struct C f = { &( &(const struct D) { (void *) &d })->d };
+struct A g[] = { &e, &f };
+void foo () { b->a = g; }
+struct E h = { foo };
+void bar ();
+int baz () { bar (h); }
+struct B i = { (int *) baz };
+void qux ();
+void corge () { qux (i); }
+void *j __attribute__((__used__)) = corge;
diff --git a/gcc/testsuite/gcc.dg/pr100225.c b/gcc/testsuite/gcc.dg/pr100225.c
new file mode 100644
index 00000000000..b32163441a3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100225.c
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/100225 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fmodulo-sched" } */
+
+void
+vorbis_synthesis_lapout (void);
+
+void
+ov_info (int **lappcm, int ov_info_i)
+{
+  while (ov_info_i < 1)
+    lappcm[ov_info_i++] = __builtin_alloca (1);
+
+  vorbis_synthesis_lapout ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr100509.c b/gcc/testsuite/gcc.dg/pr100509.c
new file mode 100644
index 00000000000..9405e2a27df
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100509.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct X {
+  int a;
+};
+const int a = 0;
+static struct X A __attribute__((alias("a")));
+void foo() { struct X b = A; }
diff --git a/gcc/testsuite/gcc.dg/pr100563.c b/gcc/testsuite/gcc.dg/pr100563.c
new file mode 100644
index 00000000000..f6a5fcd3a47
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100563.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-Og -Wno-pointer-to-int-cast" } */
+unsigned long long e(void);
+void f(int);
+void a() {
+  short b = -1, c = (int)&b;
+  unsigned long long d = e();
+  f(b >= d);
+}
diff --git a/gcc/testsuite/gcc.dg/pr100788.c b/gcc/testsuite/gcc.dg/pr100788.c
new file mode 100644
index 00000000000..5d54329f752
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100788.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "--coverage" } */
+
+void
+foo()
+{
+#line 1
+}
+
+int main()
+{
+  foo ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr100791.c b/gcc/testsuite/gcc.dg/pr100791.c
new file mode 100644
index 00000000000..96cf34f14a4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100791.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+static inline int __attribute__((__always_inline__))
+foo ()
+{
+  return log_bad_request(0, __builtin_va_arg_pack()); /* { dg-warning "implicit" } */
+}
+void log_bad_request() { foo (0); } /* { dg-warning "conflicting types" } */
diff --git a/gcc/testsuite/gcc.dg/pr78213.c b/gcc/testsuite/gcc.dg/pr78213.c
index ebc2cce78f4..04bf0381f76 100644
--- a/gcc/testsuite/gcc.dg/pr78213.c
+++ b/gcc/testsuite/gcc.dg/pr78213.c
@@ -1,12 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-fself-test" } */
-
-/* When this test was written -fself-test took no argument, but it
-   has subsequently gained a mandatory argument, giving the path
-   to selftest support files (within the srcdir).
-   It's not clear how to provide this path sanely from
-   within DejaGnu, so for now, this test is disabled.  */
-/* { dg-skip-if "" { *-*-* } } */
+/* { dg-options "-fself-test=$srcdir/selftests" } */
 
 /* Verify that -fself-test does not fail on a non empty source.  */
 
@@ -15,4 +8,5 @@ int i;
   while (i--)
     bar();
 }
-/* { dg-message "fself\-test: " "-fself-test" { target *-*-* } 0 } */
+
+/* { dg-regexp {^-fself-test: [0-9]+ pass\(es\) in [.0-9]+ seconds$|.*: note: self-tests are not enabled in this build$} } */
diff --git a/gcc/testsuite/gcc.dg/pr91441.c b/gcc/testsuite/gcc.dg/pr91441.c
index 4f7a8fbec5e..4c785f61e59 100644
--- a/gcc/testsuite/gcc.dg/pr91441.c
+++ b/gcc/testsuite/gcc.dg/pr91441.c
@@ -1,11 +1,11 @@
 /* PR target/91441 */
 /* { dg-do compile  } */
-/* { dg-require-effective-target no_fsanitize_address }*/
 /* { dg-options "--param asan-stack=1 -fsanitize=kernel-address" } */
+/* { dg-skip-if "no address sanitizer" { no_fsanitize_address } } */
 
 int *bar(int *);
 int *f( int a)
 {
   return bar(&a);
 }
-/* { dg-warning ".'-fsanitize=kernel-address' with stack protection is not supported without '-fasan-shadow-offset=' for this target" "" { target *-*-* } 0 } */
+/* { dg-warning ".'-fsanitize=kernel-address' with stack protection is not supported without '-fasan-shadow-offset=' for this target" "" { target riscv*-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/pr96260.c b/gcc/testsuite/gcc.dg/pr96260.c
index 734832f021e..587afb76116 100644
--- a/gcc/testsuite/gcc.dg/pr96260.c
+++ b/gcc/testsuite/gcc.dg/pr96260.c
@@ -1,7 +1,7 @@
 /* PR target/96260 */
 /* { dg-do compile } */
-/* { dg-require-effective-target no_fsanitize_address }*/
 /* { dg-options "--param asan-stack=1 -fsanitize=kernel-address -fasan-shadow-offset=0x100000" } */
+/* { dg-skip-if "no address sanitizer" { no_fsanitize_address } } */
 
 int *bar(int *);
 int *f( int a)
diff --git a/gcc/testsuite/gcc.dg/pr96307.c b/gcc/testsuite/gcc.dg/pr96307.c
index cd1c17c9661..89002b85c8e 100644
--- a/gcc/testsuite/gcc.dg/pr96307.c
+++ b/gcc/testsuite/gcc.dg/pr96307.c
@@ -1,7 +1,7 @@
 /* PR target/96307 */
 /* { dg-do compile } */
-/* { dg-require-effective-target no_fsanitize_address }*/
 /* { dg-additional-options "-fsanitize=kernel-address --param=asan-instrumentation-with-call-threshold=8" } */
+/* { dg-skip-if "no address sanitizer" { no_fsanitize_address } } */
 
 #include <limits.h>
 enum a {test1, test2, test3=INT_MAX};
diff --git a/gcc/testsuite/gcc.dg/pr97953.c b/gcc/testsuite/gcc.dg/pr97953.c
new file mode 100644
index 00000000000..6219619d67b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr97953.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-fre" } */
+
+int __attribute__((noipa))
+foo (int flag, int *p)
+{
+  int val = *p;
+  if (flag)
+    {
+      if (val != 1)
+        __builtin_unreachable ();
+      return 0;
+    }
+  int val2 = *p;
+  return val2 == 2;
+}
+
+int main()
+{
+  int i = 2;
+  if (foo (0, &i) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr99830.c b/gcc/testsuite/gcc.dg/pr99830.c
new file mode 100644
index 00000000000..75226f5c3a9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr99830.c
@@ -0,0 +1,10 @@
+/* PR debug/99830 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O2 -fno-expensive-optimizations -fno-split-wide-types -g" } */
+
+int foo (long a, __int128 b, short c, int d, unsigned e, __int128 f)
+{
+  __builtin_memmove (2 + (char *) &f, foo, 1);
+  c >>= (char) f;
+  return c;
+}
diff --git a/gcc/testsuite/gcc.dg/pr99990.c b/gcc/testsuite/gcc.dg/pr99990.c
new file mode 100644
index 00000000000..6878b00ce0d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr99990.c
@@ -0,0 +1,12 @@
+/* PR c/99990 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#include <stdarg.h>
+
+void
+foo ()
+{
+  va_arg (0, long);	/* { dg-error "first argument to 'va_arg' not of type 'va_list'" } */
+  void *b[] = 0;	/* { dg-error "invalid initializer" } */
+}
diff --git a/gcc/testsuite/gcc.dg/sso-16.c b/gcc/testsuite/gcc.dg/sso-16.c
new file mode 100644
index 00000000000..7bf89385ec6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/sso-16.c
@@ -0,0 +1,100 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+/* { dg-options "-O3" } */
+
+typedef __INT32_TYPE__ int32_t;
+
+#define BIG_ENDIAN   __attribute__((scalar_storage_order("big-endian")))
+
+/* host order version (little endian)*/
+struct _ip6_addr {
+    union {
+        char addr8[16];
+        int32_t  addr32[4];
+    } u;
+};
+
+typedef struct _ip6_addr t_ip6_addr;
+
+struct _net_addr {
+    char is_v4;
+    union {
+        int32_t        addr;
+        t_ip6_addr addr6;
+    } u;
+};
+
+typedef struct _net_addr t_net_addr;
+
+/* big endian version */
+struct _be_ip6_addr {
+    union {
+        char addr8[16];
+    } BIG_ENDIAN u;
+} BIG_ENDIAN;
+
+typedef struct _be_ip6_addr t_be_ip6_addr;
+
+struct _be_net_addr {
+    char is_v4;
+    union {
+        t_be_ip6_addr addr6;
+        int32_t           addr;
+    } BIG_ENDIAN u;
+} BIG_ENDIAN;
+
+typedef struct _be_net_addr t_be_net_addr;
+
+/* convert */
+t_be_ip6_addr be_ip6_addr(const t_ip6_addr ip6)
+{
+    t_be_ip6_addr rc = {
+        .u.addr8[0] = ip6.u.addr8[0],
+        .u.addr8[1] = ip6.u.addr8[1],
+        .u.addr8[2] = ip6.u.addr8[2],
+        .u.addr8[3] = ip6.u.addr8[3],
+        .u.addr8[4] = ip6.u.addr8[4],
+        .u.addr8[5] = ip6.u.addr8[5],
+        .u.addr8[6] = ip6.u.addr8[6],
+        .u.addr8[7] = ip6.u.addr8[7],
+        .u.addr8[8] = ip6.u.addr8[8],
+        .u.addr8[9] = ip6.u.addr8[9],
+        .u.addr8[10] = ip6.u.addr8[10],
+        .u.addr8[11] = ip6.u.addr8[11],
+        .u.addr8[12] = ip6.u.addr8[12],
+        .u.addr8[13] = ip6.u.addr8[13],
+        .u.addr8[14] = ip6.u.addr8[14],
+        .u.addr8[15] = ip6.u.addr8[15],
+    };
+    return rc;
+}
+
+t_be_net_addr __attribute__((noipa)) be_net_addr(const t_net_addr ip)
+{
+    t_be_net_addr rc = {.is_v4 = ip.is_v4 };
+    if (ip.is_v4) {
+        rc.u.addr = ip.u.addr;
+    } else {
+        rc.u.addr6 = be_ip6_addr(ip.u.addr6);
+    }
+    return rc;
+}
+
+int main(void)
+{
+    t_be_net_addr out = { };
+
+    t_net_addr in = {
+        .is_v4 = 0,
+        .u.addr6.u.addr8 =
+            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }
+    };
+
+    out = be_net_addr(in);
+
+    // actually first 4 bytes are swapped
+    if (in.u.addr6.u.addr8[0] != out.u.addr6.u.addr8[0])
+        __builtin_abort();
+
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/20200727-0.c b/gcc/testsuite/gcc.dg/torture/20200727-0.c
new file mode 100644
index 00000000000..ab915687b30
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/20200727-0.c
@@ -0,0 +1,82 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-g" } */
+
+typedef long unsigned int size_t;
+typedef signed int __int32_t;
+typedef __int32_t int32_t;
+typedef long int ptrdiff_t;
+typedef enum {
+  BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,   BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,   BT_ASSUMED, BT_UNION, BT_BOZ } bt;
+typedef int32_t GFC_INTEGER_4;
+typedef ptrdiff_t index_type;
+typedef size_t gfc_charlen_type;
+typedef struct descriptor_dimension {
+    index_type _stride;
+    index_type lower_bound;
+  } descriptor_dimension;
+typedef struct {
+  descriptor_dimension dim[15];
+ } gfc_full_array_i4;
+typedef void (*formatted_dtio)(void *, GFC_INTEGER_4 *, char *,           gfc_full_array_i4 *,           GFC_INTEGER_4 *, char *,           gfc_charlen_type, gfc_charlen_type);
+typedef enum { DECIMAL_POINT, DECIMAL_COMMA, DECIMAL_UNSPECIFIED } unit_decimal;
+typedef struct st_parameter_dt {
+      union     {
+	  struct  {
+	      struct gfc_unit *current_unit;
+	      unsigned namelist_mode : 1;
+	      unsigned unit_is_internal : 1;
+	      formatted_dtio fdtio_ptr;
+	  } p;
+      } u;
+  } st_parameter_dt;
+typedef struct gfc_unit {
+    int unit_number;
+    unit_decimal decimal_status;
+    int (*next_char_fn_ptr) (st_parameter_dt *);
+    void (*push_char_fn_ptr) (st_parameter_dt *, int);
+  } gfc_unit;
+void read_real (st_parameter_dt *dtp)
+{
+  int c;
+  int seen_dp;
+  seen_dp = 0;
+  for (;;)
+    {
+      c = ((dtp)->u.p.current_unit->next_char_fn_ptr (dtp));
+      if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)
+	c = '.';
+      switch (c)  {
+	case '.':
+	  if (seen_dp)      goto bad_real;
+	  seen_dp = 1;
+	  ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, c));
+	  goto real_loop;
+	case 'E':
+	case 'e':
+	case 'D':
+	case 'd':
+	case 'Q':
+	case 'q':
+	     goto exp1;
+	case '+':
+	case '-':
+	     ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, 'e'));
+	     goto got_repeat;
+      }
+    }
+got_repeat:
+real_loop:
+  for (;;)
+    {
+      c = ((dtp)->u.p.current_unit->next_char_fn_ptr (dtp));
+      switch (c)  {
+	case '.':
+	  if (seen_dp)      goto bad_real;
+	  seen_dp = 1;
+	  ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, c));
+      }
+    }
+exp1:
+bad_real:
+  return;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100053.c b/gcc/testsuite/gcc.dg/torture/pr100053.c
new file mode 100644
index 00000000000..3d1767513f3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100053.c
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+
+int __attribute__((returns_twice,noipa)) x() { return 0; }
+void __attribute__((noipa)) ar() {}
+void __attribute__((noipa)) as() { __builtin_abort (); }
+int a1, a2, a3;
+void __attribute__((noipa)) v(int init)
+{
+  if (!init) {
+    as();
+    if (a1)
+      goto aq;
+    x ();
+  }
+  ar();
+aq:
+  if (!init)
+    as();
+}
+
+int main()
+{
+  v(1);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100492.c b/gcc/testsuite/gcc.dg/torture/pr100492.c
new file mode 100644
index 00000000000..75229c8813b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100492.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-additional-options "-ftree-loop-distribution" } */
+
+extern void abort (void);
+
+signed char a, c;
+int b, d, *e = &d, g;
+signed static char f;
+int main() {
+  int h = 0;
+  int a_ = a;
+  for (; a_ < 1; a = ++a_) {
+    int *i[5], **j = &i[4], ***k[3][2] = {{&j}}, ****l = &k[2][1], *****m = &l;
+    char *n = &c;
+    f = *e = g = 0;
+    for (; g < 2; g++) {
+      for (b = 0; b < 3; b++)
+        h = (h && (*n = 0)) == 0;
+      if (g)
+        break;
+    }
+  }
+  if (f != 0)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100566.c b/gcc/testsuite/gcc.dg/torture/pr100566.c
new file mode 100644
index 00000000000..ed856913639
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100566.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+
+volatile int s, c;
+
+__attribute__((noipa)) void
+foo (void)
+{
+  if (c++ > 1)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int i = 0, j = s;
+  if (j == 0)
+    goto lab;
+  for (i = 0; i < j; i++)
+    {
+    lab:
+      foo ();
+      if (!j)
+        goto lab;
+    }
+  return 0;
+}
+
+int
+main ()
+{
+  s = 1;
+  bar ();
+  if (c != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100672.c b/gcc/testsuite/gcc.dg/torture/pr100672.c
new file mode 100644
index 00000000000..cc62e71f9a3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100672.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-options "-w -Wno-psabi" } */
+
+typedef long long __attribute__((__vector_size__ (4 * sizeof (long long)))) V;
+
+V
+foo (V v)
+{
+  return -(v >> 1);
+}
+
+int
+main (void)
+{
+  V v = foo ((V) { -2, -4, -6, -8 });
+  if (v[0] != 1 || v[1] != 2 || v[2] != 3 || v[3] != 4)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100934.c b/gcc/testsuite/gcc.dg/torture/pr100934.c
new file mode 100644
index 00000000000..43b78849895
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100934.c
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+
+int a, b, c, d, e;
+int main()
+{
+  int f = 0, g = 0;
+  for (; f < 2; f++)
+    {
+      int h, i;
+      for (h = 0; h < 2; h++)
+	{
+	  b = e = g ? a % g : 0;
+	  c = d;
+	  for (i = 0; i < 1; i++)
+	    g = 0;
+	  for (; g < 2; g++)
+	    ;
+	}
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101009.c b/gcc/testsuite/gcc.dg/torture/pr101009.c
new file mode 100644
index 00000000000..2bbed1dfc2c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101009.c
@@ -0,0 +1,17 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fno-tree-sra -fno-tree-pre -ftree-loop-distribution" } */
+
+struct a {
+  unsigned b;
+  unsigned c;
+} e, *f = &e;
+int d = 1;
+int main() {
+  for (; d; d--) {
+    struct a g[] = {{2, 1}, {2, 1}};
+    *f = g[1];
+  }
+  if (e.c != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101105.c b/gcc/testsuite/gcc.dg/torture/pr101105.c
new file mode 100644
index 00000000000..9222351683d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101105.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+
+short a;
+int b[5][4] = {2, 2};
+int d;
+short e(int f) { return f == 0 || a && f == 1 ? 0 : a; }
+int main() {
+  int g, h;
+  g = 3;
+  for (; g >= 0; g--) {
+    h = 3;
+    for (; h >= 0; h--)
+      b[g][h] = b[0][1] && e(1);
+  }
+  d = b[0][1];
+  if (d != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101173.c b/gcc/testsuite/gcc.dg/torture/pr101173.c
new file mode 100644
index 00000000000..0c9090d6686
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101173.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-additional-options "-floop-interchange" } */
+
+int a[6][9];
+int main()
+{
+  a[1][3] = 8;
+  for (int b = 1; b <= 5; b++)
+    for (int d = 0; d <= 5; d++)
+#pragma GCC unroll 0
+      for (int c = 0; c <= 5; c++)
+        a[b][c] = a[b][c + 2] & 216;
+  for (int e = 0; e < 6; e++)
+    for (int f = 0; f < 9; f++)
+      if (a[e][f] != 0)
+        __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101394.c b/gcc/testsuite/gcc.dg/torture/pr101394.c
new file mode 100644
index 00000000000..87fbdadc152
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101394.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+
+int a, b, c, d;
+void h();
+int e() __attribute__((returns_twice));
+void f() {
+  int *g = (int *)(__INTPTR_TYPE__)c;
+  if (b) {
+    h();
+    g--;
+    if (a)
+      if (d)
+        h();
+  }
+  if (g++)
+    e();
+  c = (__INTPTR_TYPE__)g;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr96513.c b/gcc/testsuite/gcc.dg/torture/pr96513.c
new file mode 100644
index 00000000000..5ee040e96c8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr96513.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+
+typedef struct {
+  short a;
+  short b;
+} c;
+c *d;
+int e, f, i, j, k, l, m, n, o, p;
+c g, h;
+void q() {
+  do {
+    if (o) {
+      (*d).a = (*d).b = d[e].a = d[e].a * 3 + 1 >> 15;
+      d[e].b = d[e].b * 3 + 1 >> 15;
+    }
+    n = -(d[e].b * g.b) >> 5;
+    m = d[e].b * g.a + 1 >> 5;
+    l = d[f].a * -d[f].b * h.b + 1 >> 5;
+    k = d[f].a * h.b + d[f].b * h.a + 1 >> 5;
+    j = n + l;
+    i = m - k;
+    (*d).a += j;
+    d[e].a -= i;
+    ++d;
+  } while (--p);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr98601.c b/gcc/testsuite/gcc.dg/torture/pr98601.c
new file mode 100644
index 00000000000..ee9d076c02d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr98601.c
@@ -0,0 +1,14 @@
+/* PR rtl-optimization/98601 */
+/* { dg-do compile } */
+
+void
+foo (void *p)
+{
+  asm ("" : "=m" (*p));			/* { dg-warning "dereferencing 'void \\*' pointer" } */
+}
+
+void
+bar (void *p)
+{
+  asm volatile ("" : : "m" (*p));	/* { dg-warning "dereferencing 'void \\*' pointer" } */
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr98786.c b/gcc/testsuite/gcc.dg/torture/pr98786.c
new file mode 100644
index 00000000000..ea364717af2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr98786.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fno-tree-dce" } */
+
+void
+func_30 (void);
+
+int __attribute__ ((pure, returns_twice))
+func_38 (int g_15, int p_39)
+{
+  return !!g_15 ? p_39 : 0;
+}
+
+void
+func_26 (int func_26___trans_tmp_1)
+{
+  long int l_37 = 0;
+  int __trans_tmp_1;
+
+  func_26___trans_tmp_1 = func_38 (func_26___trans_tmp_1, 1);
+  __trans_tmp_1 = func_38 (func_26___trans_tmp_1, l_37);
+  l_37 = 1;
+  func_30 ();
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr99880.c b/gcc/testsuite/gcc.dg/torture/pr99880.c
new file mode 100644
index 00000000000..7e0989987d7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr99880.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-ftree-vectorize" } */
+
+unsigned a;
+int b, c, d, e;
+void f() {
+  b = 5;
+  for (; b <= 51; b++)
+    ;
+  unsigned int g = -8;
+  while (g) {
+    g += 5;
+    int h = 10;
+    do {
+      h -= a = 1;
+      for (; a; a++)
+        ;
+      c *= c >= d >= b;
+    } while (h);
+    c -= e;
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr99954.c b/gcc/testsuite/gcc.dg/torture/pr99954.c
new file mode 100644
index 00000000000..7d447035912
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr99954.c
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+
+#include <assert.h>
+
+#define CONTAINER_KIND union
+
+typedef CONTAINER_KIND container { int value; } container;
+
+void move(container* end, container* start) {
+    container* p;
+    for (p = end; p > start; p--) {
+	(p)->value = (p-1)->value;
+    }
+}
+
+#define N 100
+
+int main(int argc, char* argv[]) {
+    container vals[N];
+    int i;
+    for (i=0; i<N; i++) {
+        vals[i].value = argc + i;
+    }
+    move(&vals[N-1], &vals[0]);
+    assert(vals[0].value == argc + 0);
+    for (i=1; i<N; i++) {
+        assert(vals[i].value == argc + i - 1);
+    }
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c b/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c
new file mode 100644
index 00000000000..781555e085d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c
@@ -0,0 +1,22 @@
+/* PR/101280 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-linterchange-details" } */
+
+void dummy (double *, double *);
+#define LEN_2D 32
+double aa[LEN_2D][LEN_2D], bb[LEN_2D][LEN_2D];
+double s231(int iterations)
+{
+//    loop interchange
+//    loop with data dependency
+    for (int nl = 0; nl < 100*(iterations/LEN_2D); nl++) {
+        for (int i = 0; i < LEN_2D; ++i) {
+            for (int j = 1; j < LEN_2D; j++) {
+                aa[j][i] = aa[j - 1][i] + bb[j][i];
+            }
+        }
+        dummy(aa[0],bb[0]);
+    }
+}
+
+/* { dg-final { scan-tree-dump "loops interchanged" "linterchange" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr100278.c b/gcc/testsuite/gcc.dg/tree-ssa/pr100278.c
new file mode 100644
index 00000000000..8d702284c3a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr100278.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void a()
+{
+#if defined __s390__
+  register int b asm("r5");
+#elif defined __x86_64__
+  register int b asm("eax");
+#else
+  volatile int b;
+#endif
+  if (b)
+    b = 1;
+  for (; b;)
+    ;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c b/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c
new file mode 100644
index 00000000000..d5987e14360
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-pcom-details -fdump-tree-optimized" } */
+
+int main()
+{
+  volatile int y;
+  void bar()
+    {
+      __builtin_printf ("%d", y);
+    }
+  while (y)
+    ;
+  return 0;
+}
+
+/* Make sure the load from y is correctly interpreted as volatile, even
+   when going through FRAME.  */
+/* { dg-final { scan-tree-dump-not "Executing predictive commoning" "pcom" } } */
+/* { dg-final { scan-tree-dump " ={v} FRAME" "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-93.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-93.c
new file mode 100644
index 00000000000..7f66b7ee3f4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-93.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fdump-tree-fre1" } */
+
+void bar ();
+void foo (int pred, int *other)
+{
+  *other = 0;
+  if (*other)
+    goto cnt;
+  if (pred)
+    {
+      *other = 1;
+cnt:
+      if (!pred)
+        bar ();
+    }
+}
+
+/* The first VN pass should figure that if (!pred) is false because
+   if (*other) is and thus the predicate test is redundant.  */
+/* { dg-final { scan-tree-dump-not "bar" "fre1" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr102046.c b/gcc/testsuite/gcc.dg/vect/pr102046.c
new file mode 100644
index 00000000000..ae48b497dc0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr102046.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O3 -fvect-cost-model=dynamic" } */
+/* { dg-additional-options "-march=btver2" { target x86_64-*-* i?86-*-* } } */
+
+struct S
+{
+  unsigned a, b;
+};
+
+struct S g;
+
+void
+foo (struct S *o)
+{
+  struct S s = g;
+  s.b *= 3;
+  s.a -= s.a / 2;
+  *o = s;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr99767.c b/gcc/testsuite/gcc.target/aarch64/pr99767.c
new file mode 100644
index 00000000000..5bbfcbdcd69
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr99767.c
@@ -0,0 +1,16 @@
+/* PR target/99767 */
+/* { dg-do compile } */
+/* { dg-options " -O1 -fopenmp-simd -fno-tree-dce -march=armv8-a+sve" } */
+
+int a[1024], b[1024];
+
+void
+foo (void)
+{
+  #pragma omp simd
+  for (int i = 0; i < 1024; i++)
+    if (b[i] > 23) {
+      a[i] = b[i] + 1;
+      int v = 1 / 0;	/* { dg-warning "division by zero" } */
+    }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr99988.c b/gcc/testsuite/gcc.target/aarch64/pr99988.c
new file mode 100644
index 00000000000..7cca4962944
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr99988.c
@@ -0,0 +1,66 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -mbranch-protection=standard" } */
+/* { dg-final { scan-assembler-times {bti j} 13 } } */
+int a;
+int c();
+int d();
+int e();
+int f();
+int g();
+void h() {
+  switch (a) {
+  case 0:
+  case 56:
+  case 57:
+    break;
+  case 58:
+  case 59:
+  case 61:
+  case 62:
+    c();
+  case 64:
+  case 63:
+    d();
+  case 66:
+  case 65:
+    d();
+  case 68:
+  case 67:
+    d();
+  case 69:
+  case 70:
+    d();
+  case 71:
+  case 72:
+  case 88:
+  case 87:
+    d();
+  case 90:
+  case 89:
+    d();
+  case 92:
+  case 1:
+    d();
+  case 93:
+  case 73:
+  case 4:
+    e();
+  case 76:
+  case 5:
+    f();
+  case 7:
+  case 8:
+  case 84:
+  case 85:
+    break;
+  case 6:
+  case 299:
+  case 9:
+  case 80:
+  case 2:
+  case 3:
+    e();
+  default:
+    g();
+  }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr99246.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr99246.c
new file mode 100644
index 00000000000..7f1079c1bd6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr99246.c
@@ -0,0 +1,17 @@
+/* { dg-options "-Os" } */
+
+#include <arm_sve.h>
+extern char b[];
+int x;
+void f() {
+  while (x) {
+    x = svaddv(
+        svnot_z(svnot_z(svptrue_pat_b8(SV_VL6),
+                        svmov_z(svptrue_pat_b8(SV_VL1),
+                                svptrue_pat_b16(SV_VL3))),
+                svptrue_pat_b64(SV_VL2)),
+        svdup_s32(8193));
+    for (int j = x; j; j++)
+      b[j] = 0;
+  }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr100048.c b/gcc/testsuite/gcc.target/aarch64/sve/pr100048.c
new file mode 100644
index 00000000000..525933863f7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr100048.c
@@ -0,0 +1,25 @@
+/* { dg-additional-options "-O2 -fno-schedule-insns" } */
+/* { dg-final { check-function-bodies "**" "" "-DCHECK_ASM" } } */
+
+#include "arm_sve.h"
+
+/*
+** foo:
+**        ptrue   (p[0-7])\.d, all
+**        pfalse  (p[0-7])\.b
+**        ptrue   (p[0-7])\.s, all
+**        trn1    (p[0-7])\.d, \2\.d, \3\.d
+**        trn1    \2\.d, \1\.d, \3\.d
+**        faddv   (h[0-31]), \4\, (z[0-31]).h
+**        faddv   (h[0-31]), \2\, \6\.h
+**        str     \5, [x0]
+**        str     \7, [x0, 2]
+**        ret
+*/
+void foo(svfloat16_t in, float16_t *dst) {
+  const svbool_t pg_q0 = svdupq_n_b16(1, 0, 1, 0, 0, 0, 0, 0);
+  const svbool_t pg_f0 = svdupq_n_b16(1, 0, 0, 0, 0, 0, 0, 0);
+  dst[0] = svaddv_f16(pg_f0, in);
+  dst[1] = svaddv_f16(pg_q0, in);
+}
+
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr97141.c b/gcc/testsuite/gcc.target/aarch64/sve/pr97141.c
new file mode 100644
index 00000000000..942e4a48d91
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr97141.c
@@ -0,0 +1,10 @@
+/* { dg-options "-O3" } */
+
+int a;
+short b, c;
+short d(short e, short f) { return e + f; }
+void g(void) {
+  a = -9;
+  for (; a != 51; a = d(a, 5))
+    b |= c;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98119.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98119.c
new file mode 100644
index 00000000000..da6208c2ce3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98119.c
@@ -0,0 +1,13 @@
+/* { dg-options "-O3 -msve-vector-bits=512 -mtune=thunderx" } */
+
+void
+f (unsigned short *x)
+{
+  for (int i = 0; i < 1000; ++i)
+    x[i] += x[i - 16];
+}
+
+/* { dg-final { scan-assembler-not {\tubfx\t[wx][0-9]+, [wx][0-9]+, #?1, #?5\n} } } */
+/* { dg-final { scan-assembler-not {\tand\tx[0-9]+, x[0-9]+, #?-63\n} } } */
+/* { dg-final { scan-assembler {\tubfx\t[wx][0-9]+, [wx][0-9]+, #?1, #?4\n} } } */
+/* { dg-final { scan-assembler {\tand\tx[0-9]+, x[0-9]+, #?-31\n} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98268-1.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-1.c
new file mode 100644
index 00000000000..fdbe55e0b4e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-1.c
@@ -0,0 +1,11 @@
+/* { dg-do link } */
+/* { dg-options "-flto -O -ftree-vectorize --param=aarch64-autovec-preference=3" } */
+/* { dg-additional-sources "pr98268-2.c" } */
+
+short d, e;
+void f(char, long*);
+int main() {
+  long x;
+  f(-114, &x);
+  return d == e;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98268-2.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-2.c
new file mode 100644
index 00000000000..de3b05d5e15
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-2.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O -ftree-vectorize --param=aarch64-autovec-preference=3" } */
+
+extern short d[], e[];
+void f(char a, long *b) {
+  for (int c = 0; c < a - 12; c++) {
+    d[c] = b[c];
+    e[c] = 0;
+  }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98726.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98726.c
new file mode 100644
index 00000000000..2395cab57e5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98726.c
@@ -0,0 +1,9 @@
+/* { dg-options "-O3" } */
+
+int a, c;
+char b;
+int d() {
+  a = 0;
+  for (; a <= 21; a = (short)a + 1)
+    b &= c;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr99929_1.c b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_1.c
new file mode 100644
index 00000000000..1fe18136e28
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_1.c
@@ -0,0 +1,16 @@
+/* { dg-do run { target aarch64_sve_hw } } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+
+#include <arm_sve.h>
+
+static void e(short *g, short p2) { *g ^= p2; }
+static short m[23];
+int main() {
+  for (unsigned i = 0; i < 23; ++i)
+    m[i] = 4;
+  if (svaddv(svptrue_pat_b32(SV_VL1), svdup_u32(1)) != 1)
+    __builtin_abort();
+  for (unsigned i = 0; i < 3; ++i)
+    e(m, m[i]);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr99929_2.c b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_2.c
new file mode 100644
index 00000000000..50d432db9b8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_2.c
@@ -0,0 +1,5 @@
+/* { dg-options "-O2 -ftree-vectorize" } */
+
+#include "pr99929_1.c"
+
+/* { dg-final { scan-assembler {\tptrue\tp[0-7].[bhsd], vl1\n} } } */
diff --git a/gcc/testsuite/gcc.target/arm/acle/pr100856.c b/gcc/testsuite/gcc.target/arm/acle/pr100856.c
new file mode 100644
index 00000000000..5bc030e2e46
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/acle/pr100856.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_v8_1m_main_cde_mve_ok } */
+/* { dg-add-options arm_v8_1m_main_cde_mve } */
+
+#include "arm_cde.h"
+
+int main()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon.c b/gcc/testsuite/gcc.target/arm/attr-neon.c
index 225fb8dc3db..e8e3086247d 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon.c
@@ -1,7 +1,10 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-O2 -ftree-vectorize" } */
-/* { dg-add-options arm_neon arm_v8_vfp } */ /* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any -mfpu= option set by arm_neon, thus ensuring that the attributes below really are checked for correct fpu selection.  */
+/* { dg-add-options arm_neon arm_v8_vfp } */
+/* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any
+   -mfpu= option set by arm_neon, thus ensuring that the attributes below
+   really are checked for correct fpu selection.  */
 
 /* Verify that neon instructions are emitted once.  */
 void __attribute__ ((target("fpu=neon")))
@@ -18,6 +21,6 @@ f3(int n, int x[], int y[]) {
     y[i] = x[i] << 3;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
+/* { dg-final { scan-assembler-times "\.fpu\\s+vfp\n" 1 } } */
+/* { dg-final { scan-assembler-times "\.fpu\\s+neon\n" 1 } } */
 /* { dg-final { scan-assembler-times "vshl" 1 } } */
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon2.c b/gcc/testsuite/gcc.target/arm/attr-neon2.c
index 29668256cf5..a7a72dac379 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon2.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon2.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_neon_ok } */
 /* { dg-require-effective-target arm_fp_ok } */
-/* { dg-options "-O2" } */
+/* { dg-options "-Ofast" } */
 /* { dg-add-options arm_fp } */
 
 /* Reset fpu to a value compatible with the next pragmas.  */
@@ -12,23 +12,36 @@
 #include <arm_neon.h>
 
 /* Check that pragma target is used.  */
-int8x8_t 
-my (int8x8_t __a, int8x8_t __b)
+/*
+**my:
+**	...
+**	vadd.f32	d[0-9]+, d[0-9]+, d[0-9]+
+**	...
+**	bx	lr
+*/
+float32x2_t
+my (float32x2_t __a, float32x2_t __b)
 {
   return __a + __b;
 }
 
 #pragma GCC pop_options
 
-/* Check that command line option is restored.  */
-int8x8_t 
-my1 (int8x8_t __a, int8x8_t __b)
+/* Check that fpu=vfp is restored.  */
+/*
+**my1:
+**	...
+**	vadd.f32	s[0-9]+, s[0-9]+, s[0-9]+
+**	vadd.f32	s[0-9]+, s[0-9]+, s[0-9]+
+**	...
+**	bx	lr
+*/
+float32x2_t
+my1 (float32x2_t __a, float32x2_t __b)
 {
   return __a + __b;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
-/* { dg-final { scan-assembler "vadd" } } */
-
-
+/* { dg-final { scan-assembler "\.fpu\\s+vfp\n" } } */
+/* { dg-final { scan-assembler "\.fpu\\s+neon\n" } } */
+/* { dg-final { check-function-bodies "**" "" } } */
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon3.c b/gcc/testsuite/gcc.target/arm/attr-neon3.c
index 17e429ad739..b6171e72d89 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon3.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon3.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_crypto_ok } */
 /* { dg-require-effective-target arm_fp_ok } */
-/* { dg-options "-O2" } */
+/* { dg-options "-Ofast" } */
 /* { dg-add-options arm_fp } */
 
 /* Reset fpu to a value compatible with the next pragmas.  */
@@ -11,28 +11,54 @@
 #include <arm_neon.h>
 
 /* Check that neon is used.  */
-int8x8_t __attribute__ ((target("fpu=neon")))
-my (int8x8_t __a, int8x8_t __b)
+/*
+**my:
+**	...
+**	vadd.f32	d[0-9]+, d[0-9]+, d[0-9]+
+**	...
+**	bx	lr
+*/
+float32x2_t __attribute__ ((target("fpu=neon")))
+my (float32x2_t __a, float32x2_t __b)
 {
   return __a + __b;
 }
 
 /* Check that crypto builtins are recognized.  */
+/*
+**foo:
+**	...
+** (
+**	vld1.64	{d[0-9]+-d[0-9]+}, \[r[0-9]+:64\]
+** |
+**	vld1.64	{d[0-9]+}, \[r[0-9]+:64\]!
+**	vld1.64	{d[0-9]+}, \[r[0-9]+:64\]
+** )
+**	...
+**	bx	lr
+*/
+
 poly128_t __attribute__ ((target("fpu=crypto-neon-fp-armv8")))
 foo (poly128_t* ptr)
 {
   return vldrq_p128 (ptr);
 }
 
-/* Check that default mode is restored.  */
-int8x8_t
-my1 (int8x8_t __a, int8x8_t __b)
+/* Check that fpu=vfp is restored.  */
+/*
+**my1:
+**	...
+**	vadd.f32	s[0-9]+, s[0-9]+, s[0-9]+
+**	vadd.f32	s[0-9]+, s[0-9]+, s[0-9]+
+**	...
+**	bx	lr
+*/float32x2_t
+my1 (float32x2_t __a, float32x2_t __b)
 {
   return __a + __b;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu crypto-neon-fp-armv8" 1 } } */
-/* { dg-final { scan-assembler-times "vld1" 1 } } */
-/* { dg-final { scan-assembler-times "vadd" 1} } */
+/* { dg-final { scan-assembler "\.fpu\\s+vfp\n" } } */
+/* { dg-final { scan-assembler "\.fpu\\s+neon\n" } } */
+/* { dg-final { scan-assembler "\.fpu\\s+crypto-neon-fp-armv8\n" } } */
+/* { dg-final { check-function-bodies "**" "" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-18.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-18.c
index e1ff09257b7..db7d975a90e 100644
--- a/gcc/testsuite/gcc.target/arm/cmse/cmse-18.c
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-18.c
@@ -8,4 +8,5 @@ void bar(f func, int a)
   func(a);
 }
 
-/* { dg-final { scan-rtl-dump "call unspec\\\[\\\[r4:SI\\\]\\\]" "final" } } */
+/* { dg-final { scan-rtl-dump "call unspec\\\[\\\[r4:SI\\\]\\\]" "final" { target { ! arm_v8_1m_mve_ok } } } } */
+/* { dg-final { scan-rtl-dump "call unspec\\\[\\\[r\[0-7\]:SI\\\]\\\]" "final" { target { arm_v8_1m_mve_ok } } } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-20.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-20.c
new file mode 100644
index 00000000000..08e89bff637
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-20.c
@@ -0,0 +1,28 @@
+/* This test is executed only if the execution engine supports CMSE instructions.  */
+/* { dg-options "--save-temps -mcmse -Wl,--section-start,.gnu.sgstubs=0x00400000" } */
+
+#include <arm_cmse.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+void __attribute__((cmse_nonsecure_entry))
+secure_fun (int a, int *p)
+{
+  void *b = cmse_check_address_range ((void *)p, a, 1);
+
+  if (b == NULL)
+   __builtin_abort ();
+  printf("%d", *((int *)b));
+}
+
+int
+main (void)
+{
+  int *ptr;
+  int size = 1;
+  ptr = (int *) calloc (1, sizeof(int *));
+  *ptr = 1315852292;
+  secure_fun (size, ptr);
+  free (ptr);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13a.c
new file mode 100644
index 00000000000..553cc7837e1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13a.c
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=soft -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+
+#include "../../../cmse-13.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[1,4-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[1,4-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler-not "mov\tr0, r4" } } */
+/* { dg-final { scan-assembler-not "mov\tr2, r4" } } */
+/* { dg-final { scan-assembler-not "mov\tr3, r4" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r1, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[1,4-9\]|r10|fp|ip), ){9}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[1,4-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler-not "vmov" } } */
+/* { dg-final { scan-assembler-not "vmsr" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7a.c
new file mode 100644
index 00000000000..ce02fdea643
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7a.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=soft -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+
+#include "../../../cmse-7.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[0-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[0-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[0-9\]|r10|fp|ip), ){12}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[0-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler-not "vmov" } } */
+/* { dg-final { scan-assembler-not "vmsr" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8a.c
new file mode 100644
index 00000000000..75e161152aa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8a.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=soft -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+
+#include "../../../cmse-8.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[2-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[2-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler-not "mov\tr0, r4" } } */
+/* { dg-final { scan-assembler-not "mov\tr1, r4" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[2-9\]|r10|fp|ip), ){10}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[2-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler-not "vmov" } } */
+/* { dg-final { scan-assembler-not "vmsr" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7a.c
new file mode 100644
index 00000000000..dad72660d87
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7a.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=softfp -mfpu=fpv5-sp-d16 -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=softfp" } } */
+/* { dg-skip-if "Skip these if testing double precision" {*-*-*} {"-mfpu=fpv[4-5]-d16"} {""} } */
+
+#include "../../../cmse-7.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[0-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[0-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[0-9\]|r10|fp|ip), ){12}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[0-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8a.c
new file mode 100644
index 00000000000..faa04481372
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8a.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=softfp -mfpu=fpv5-sp-d16 -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=softfp" } } */
+/* { dg-skip-if "Skip these if testing double precision" {*-*-*} {"-mfpu=fpv[4-5]-d16"} {""} } */
+
+#include "../../../cmse-8.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[2-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[2-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler-not "mov\tr0, r4" } } */
+/* { dg-final { scan-assembler-not "mov\tr1, r4" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[2-9\]|r10|fp|ip), ){10}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[2-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13a.c
new file mode 100644
index 00000000000..bceba44e496
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13a.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16 -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=softfp" } } */
+/* { dg-skip-if "Skip these if testing single precision" {*-*-*} {"-mfpu=*-sp-*"} {""} } */
+
+#include "../../../cmse-13.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[1,4-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[1,4-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler-not "mov\tr0, r4" } } */
+/* { dg-final { scan-assembler-not "mov\tr2, r4" } } */
+/* { dg-final { scan-assembler-not "mov\tr3, r4" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r1, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[1,4-9\]|r10|fp|ip), ){9}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[1,4-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7a.c
new file mode 100644
index 00000000000..c74ebbdc231
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7a.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16 -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=softfp" } } */
+/* { dg-skip-if "Skip these if testing single precision" {*-*-*} {"-mfpu=*-sp-*"} {""} } */
+
+#include "../../../cmse-7.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[0-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[0-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[0-9\]|r10|fp|ip), ){12}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[0-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8a.c b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8a.c
new file mode 100644
index 00000000000..ffb67a777fd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8a.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16 -mfix-cmse-cve-2021-35465" }  */
+/* { dg-skip-if "Incompatible float ABI" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=softfp" } } */
+/* { dg-skip-if "Skip these if testing single precision" {*-*-*} {"-mfpu=*-sp-*"} {""} } */
+
+#include "../../../cmse-8.x"
+
+/* Checks for saving and clearing prior to function call.  */
+/* Shift on the same register as blxns.  */
+/* { dg-final { scan-assembler "lsrs\t(r\[2-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler "lsls\t(r\[2-9\]|r10|fp|ip), \\1, #1.*blxns\t\\1" } } */
+/* { dg-final { scan-assembler-not "mov\tr0, r4" } } */
+/* { dg-final { scan-assembler-not "mov\tr1, r4" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+/* { dg-final { scan-assembler "vlstm\tsp" } } */
+/* Check the right registers are cleared and none appears twice.  */
+/* { dg-final { scan-assembler "clrm\t\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\}" } } */
+/* Check that the right number of registers is cleared and thus only one
+   register is missing.  */
+/* { dg-final { scan-assembler "clrm\t\{((r\[2-9\]|r10|fp|ip), ){10}APSR\}" } } */
+/* Check that no cleared register is used for blxns.  */
+/* { dg-final { scan-assembler-not "clrm\t\{\[^\}\]\+(r\[2-9\]|r10|fp|ip),\[^\}\]\+\}.*blxns\t\\1" } } */
+/* Check for v8.1-m variant of erratum work-around.  */
+/* { dg-final { scan-assembler "vscclrm\t\{vpr\}" } } */
+/* { dg-final { scan-assembler "vlldm\tsp" } } */
+/* { dg-final { scan-assembler "pop\t\{r4, r5, r6, r7, r8, r9, r10, fp\}" } } */
+
+/* Now we check that we use the correct intrinsic to call.  */
+/* { dg-final { scan-assembler "blxns" } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/pr100333.c b/gcc/testsuite/gcc.target/arm/cmse/pr100333.c
new file mode 100644
index 00000000000..d8e3d809f73
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/pr100333.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-mcmse" } */
+typedef void __attribute__((cmse_nonsecure_call)) t(void);
+t g;
+void f() {
+  g();
+}
diff --git a/gcc/testsuite/gcc.target/arm/cmse/pr99725.c b/gcc/testsuite/gcc.target/arm/cmse/pr99725.c
new file mode 100644
index 00000000000..284da184f96
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/pr99725.c
@@ -0,0 +1,5 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-mcmse -g" } */
+typedef int __attribute__((cmse_nonsecure_call)) (*t)();
+t f;
+void g() { f(); }
diff --git a/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-hard.c b/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-hard.c
index da1cc25e83b..e0fb307ac30 100644
--- a/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-hard.c
+++ b/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-hard.c
@@ -1,12 +1,12 @@
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */
-/* { dg-additional-options "-mcpu=cortex-m55+nofp -mfloat-abi=hard -mfpu=auto --save-temps" } */
+/* { dg-additional-options "-mcpu=cortex-m55+nofp -mthumb -mfloat-abi=hard -mfpu=auto --save-temps" } */
+/* { dg-final { scan-assembler "\.fpu softvfp" } } */
 /* { dg-final { scan-assembler "\.arch_extension mve" } } */
 /* { dg-final { scan-assembler "\.arch_extension dsp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension fp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension fp.dp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension mve.fp" } } */
-/* { dg-final { scan-assembler-not "\.fpu" } } */
 
 int
 f ()
diff --git a/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-softfp.c b/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-softfp.c
index 0a4fb14bd9b..50645e8cd0f 100644
--- a/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-softfp.c
+++ b/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-softfp.c
@@ -1,12 +1,12 @@
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */
-/* { dg-additional-options "-mcpu=cortex-m55+nofp -mfloat-abi=softfp -mfpu=auto --save-temps" } */
+/* { dg-additional-options "-mcpu=cortex-m55+nofp -mthumb -mfloat-abi=softfp -mfpu=auto --save-temps" } */
+/* { dg-final { scan-assembler "\.fpu softvfp" } } */
 /* { dg-final { scan-assembler "\.arch_extension mve" } } */
 /* { dg-final { scan-assembler "\.arch_extension dsp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension fp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension fp.dp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension mve.fp" } } */
-/* { dg-final { scan-assembler-not "\.fpu" } } */
 
 int
 f ()
diff --git a/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-nomve-flag-softfp.c b/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-nomve-flag-softfp.c
index 2ae7f34d456..948f622633c 100644
--- a/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-nomve-flag-softfp.c
+++ b/gcc/testsuite/gcc.target/arm/cortex-m55-nofp-nomve-flag-softfp.c
@@ -1,12 +1,12 @@
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */
-/* { dg-additional-options "-mcpu=cortex-m55+nomve+nofp -mfloat-abi=softfp -mfpu=auto --save-temps" } */
+/* { dg-additional-options "-mcpu=cortex-m55+nomve+nofp -mthumb -mfloat-abi=softfp -mfpu=auto --save-temps" } */
+/* { dg-final { scan-assembler "\.fpu softvfp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension mve" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension mve.fp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension fp" } } */
 /* { dg-final { scan-assembler-not "\.arch_extension fp.dp" } } */
 /* { dg-final { scan-assembler "\.arch_extension dsp" } } */
-/* { dg-final { scan-assembler-not "\.fpu" } } */
 
 int
 f ()
diff --git a/gcc/testsuite/gcc.target/arm/multilib.exp b/gcc/testsuite/gcc.target/arm/multilib.exp
index 6aba29ede95..82355464839 100644
--- a/gcc/testsuite/gcc.target/arm/multilib.exp
+++ b/gcc/testsuite/gcc.target/arm/multilib.exp
@@ -840,6 +840,119 @@ if {[multilib_config "rmprofile"] } {
 	{-mcpu=cortex-m55+nomve+nofp -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main/nofp"
 	{-mcpu=cortex-m55+nodsp+nofp -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
 	{-mcpu=cortex-m55+nodsp+nofp -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+cdecp0 -mfpu=vfpv3xd -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+cdecp0 -mfpu=vfpv3xd -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8-m.main+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main/nofp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+cdecp0 -mfpu=vfpv3xd -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=vfpv3xd -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=vfpv3xd-fp16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv4-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv5-sp-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp.dp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp+dsp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8-m.main+fp.dp+dsp+cdecp0 -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8.1-m.main+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+dsp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+dsp+fp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+dsp+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+dsp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+dsp+fp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8.1-m.main+dsp+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8.1-m.main+dsp+fp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8.1-m.main+dsp+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8.1-m.main+mve+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+mve.fp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+mve+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+mve.fp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8.1-m.main+mve+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8.1-m.main+mve/hard"
+	{-march=armv8.1-m.main+mve+fp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8.1-m.main+mve+fp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+fp/softfp"
+	{-march=armv8.1-m.main+mve.fp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+fp/hard"
+	{-march=armv8.1-m.main+mve+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+mve.fp+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=soft} "thumb/v8-m.main/nofp"
+	{-march=armv8.1-m.main+mve+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8.1-m.main+mve.fp+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv8.1-m.main+mve+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
+	{-march=armv8.1-m.main+mve.fp+fp.dp+cdecp0 -mfpu=auto -mfloat-abi=hard} "thumb/v8-m.main+dp/hard"
     } {
 	check_multi_dir $opts $dir
     }
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu1.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu1.c
index 611097ec956..c5acdb5e4e5 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu1.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu1.c
@@ -1,3 +1,4 @@
+/* { dg-do assemble } */
 /* { dg-require-effective-target arm_v8_1m_mve_ok } */
 /* { dg-require-effective-target arm_hard_ok } */
 /* { dg-add-options arm_v8_1m_mve } */
@@ -8,8 +9,6 @@
 int8x16_t
 foo1 (int8x16_t value)
 {
-  int8x16_t b = value;
+  int8x16_t b = -value;
   return b;
 }
-
-/* { dg-final { scan-assembler-not "\.fpu softvfp" }  } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu2.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu2.c
index b8e105111de..907db5e1572 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu2.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu2.c
@@ -1,3 +1,4 @@
+/* { dg-do assemble } */
 /* { dg-require-effective-target arm_v8_1m_mve_ok } */
 /* { dg-require-effective-target arm_softfp_ok } */
 /* { dg-add-options arm_v8_1m_mve } */
@@ -8,8 +9,6 @@
 int8x16_t
 foo1 (int8x16_t value)
 {
-  int8x16_t b = value;
+  int8x16_t b = -value;
   return b;
 }
-
-/* { dg-final { scan-assembler-not "\.fpu softvfp" }  } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/pr101016.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/pr101016.c
new file mode 100644
index 00000000000..b12786d04f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/pr101016.c
@@ -0,0 +1,136 @@
+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */
+/* { dg-add-options arm_v8_1m_mve_fp } */
+
+#include "arm_mve.h"
+
+void
+foo (void)
+{
+  mve_pred16_t p;
+  int8x16_t a;
+  int8_t a1[10];
+  int16x8_t b;
+  int16_t b1[10];
+  int32x4_t c;
+  int32_t c1[10];
+  uint8x16_t ua;
+  uint8_t ua1[10];
+  uint16x8_t ub;
+  uint16_t ub1[10];
+  uint32x4_t uc;
+  uint32_t uc1[10];
+  float16x8_t fb;
+  float16_t fb1[10];
+  float32x4_t fc;
+  float32_t fc1[10];
+
+  fb = vld1q (fb1);
+  fc = vld1q (fc1);
+  b = vld1q (b1);
+  c = vld1q (c1);
+  a = vld1q (a1);
+  ub = vld1q (ub1);
+  uc = vld1q (uc1);
+  ua = vld1q (ua1);
+  fb = vld1q_z (fb1, p);
+  fc = vld1q_z (fc1, p);
+  b = vld1q_z (b1, p);
+  c = vld1q_z (c1, p);
+  a = vld1q_z (a1, p);
+  ub = vld1q_z (ub1, p);
+  uc = vld1q_z (uc1, p);
+  ua = vld1q_z (ua1, p);
+}
+
+void
+foo1 (void)
+{
+  mve_pred16_t p;
+  int8x16x2_t a;
+  int8_t a1[10];
+  int16x8x2_t b;
+  int16_t b1[10];
+  int32x4x2_t c;
+  int32_t c1[10];
+  uint8x16x2_t ua;
+  uint8_t ua1[10];
+  uint16x8x2_t ub;
+  uint16_t ub1[10];
+  uint32x4x2_t uc;
+  uint32_t uc1[10];
+  float16x8x2_t fb;
+  float16_t fb1[10];
+  float32x4x2_t fc;
+  float32_t fc1[10];
+
+  fb = vld2q (fb1);
+  fc = vld2q (fc1);
+  b = vld2q (b1);
+  c = vld2q (c1);
+  a = vld2q (a1);
+  ub = vld2q (ub1);
+  uc = vld2q (uc1);
+  ua = vld2q (ua1);
+}
+
+void
+foo2 (void)
+{
+  mve_pred16_t p;
+  int8x16x4_t a;
+  int8_t a1[10];
+  int16x8x4_t b;
+  int16_t b1[10];
+  int32x4x4_t c;
+  int32_t c1[10];
+  uint8x16x4_t ua;
+  uint8_t ua1[10];
+  uint16x8x4_t ub;
+  uint16_t ub1[10];
+  uint32x4x4_t uc;
+  uint32_t uc1[10];
+  float16x8x4_t fb;
+  float16_t fb1[10];
+  float32x4x4_t fc;
+  float32_t fc1[10];
+
+  fb = vld4q (fb1);
+  fc = vld4q (fc1);
+  b = vld4q (b1);
+  c = vld4q (c1);
+  a = vld4q (a1);
+  ub = vld4q (ub1);
+  uc = vld4q (uc1);
+  ua = vld4q (ua1);
+}
+
+void
+foo3 (void)
+{
+  mve_pred16_t p;
+  int16x8_t a;
+  uint16x8_t ua;
+  int8_t a1[10];
+  uint8_t ua1[10];
+  uint16x8_t offset_a;
+  int8x16_t b;
+  uint8x16_t ub;
+  uint8x16_t offset_b;
+  int32x4_t c;
+  uint32x4_t uc;
+  uint32x4_t offset_c;
+
+  a = vldrbq_gather_offset (a1, offset_a);
+  ua = vldrbq_gather_offset (ua1, offset_a);
+  b = vldrbq_gather_offset (a1, offset_b);
+  ub = vldrbq_gather_offset (ua1, offset_b);
+  c = vldrbq_gather_offset (a1, offset_c);
+  uc = vldrbq_gather_offset (ua1, offset_c);
+  a = vldrbq_gather_offset_z (a1, offset_a, p);
+  ua = vldrbq_gather_offset_z (ua1, offset_a, p);
+  b = vldrbq_gather_offset_z (a1, offset_b, p);
+  ub = vldrbq_gather_offset_z (ua1, offset_b, p);
+  c = vldrbq_gather_offset_z (a1, offset_c, p);
+  uc = vldrbq_gather_offset_z (ua1, offset_c, p);
+}
+/* { dg-final { scan-assembler-not "__ARM_undef" } } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_s64.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_s64.c
index 7420d0198e7..a9b1f81b62d 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_s64.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_s64.c
@@ -11,6 +11,6 @@ foo (uint64x2_t * addr)
 }
 
 /* { dg-final { scan-assembler "vldrd.64\tq\[0-9\]+, \\\[q\[0-9\]+, #\[0-9\]+\\\]!" } } */
-/* { dg-final { scan-assembler-times "vldr.64" 1 } } */
-/* { dg-final { scan-assembler-times "vstr.64" 1 } } */
+/* { dg-final { scan-assembler-times "vldrw.u32" 1 } } */
+/* { dg-final { scan-assembler-times "vstrw.32" 1 } } */
 /* { dg-final { scan-assembler-not "__ARM_undef" } } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_u64.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_u64.c
index ebe5b2fd70c..e32a06695ae 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_u64.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_u64.c
@@ -11,6 +11,6 @@ foo (uint64x2_t * addr)
 }
 
 /* { dg-final { scan-assembler "vldrd.64\tq\[0-9\]+, \\\[q\[0-9\]+, #\[0-9\]+\\\]!" } } */
-/* { dg-final { scan-assembler-times "vldr.64" 1 } } */
-/* { dg-final { scan-assembler-times "vstr.64" 1 } } */
+/* { dg-final { scan-assembler-times "vldrw.u32" 1 } } */
+/* { dg-final { scan-assembler-times "vstrw.32" 1 } } */
 /* { dg-final { scan-assembler-not "__ARM_undef" } } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_s64.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_s64.c
index 231a24a1e55..bb06cf88e32 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_s64.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_s64.c
@@ -10,6 +10,6 @@ int64x2_t foo (uint64x2_t * addr, mve_pred16_t p)
 
 /* { dg-final { scan-assembler "vpst" } } */
 /* { dg-final { scan-assembler "vldrdt.u64\tq\[0-9\]+, \\\[q\[0-9\]+, #\[0-9\]+\\\]!" } } */
-/* { dg-final { scan-assembler-times "vldr.64" 1 } } */
-/* { dg-final { scan-assembler-times "vstr.64" 1 } } */
+/* { dg-final { scan-assembler-times "vldrw.u32" 1 } } */
+/* { dg-final { scan-assembler-times "vstrw.32" 1 } } */
 /* { dg-final { scan-assembler-not "__ARM_undef" } } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_u64.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_u64.c
index b8d9b5c1391..558115d49ef 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_u64.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldrdq_gather_base_wb_z_u64.c
@@ -10,6 +10,6 @@ uint64x2_t foo (uint64x2_t * addr, mve_pred16_t p)
 
 /* { dg-final { scan-assembler "vpst" } } */
 /* { dg-final { scan-assembler "vldrdt.u64\tq\[0-9\]+, \\\[q\[0-9\]+, #\[0-9\]+\\\]!" } } */
-/* { dg-final { scan-assembler-times "vldr.64" 1 } } */
-/* { dg-final { scan-assembler-times "vstr.64" 1 } } */
+/* { dg-final { scan-assembler-times "vldrw.u32" 1 } } */
+/* { dg-final { scan-assembler-times "vstrw.32" 1 } } */
 /* { dg-final { scan-assembler-not "__ARM_undef" } } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int.c
index bf6692fe573..cc5e6358bee 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int.c
@@ -27,6 +27,5 @@ foo ()
 
 /* { dg-final { scan-assembler-times "vstrb.8" 2 } } */
 /* { dg-final { scan-assembler-times "vstrh.16" 2 } } */
-/* { dg-final { scan-assembler-times "vstrw.32" 2 } } */
-/* { dg-final { scan-assembler-times "vstr.64" 2 } } */
+/* { dg-final { scan-assembler-times "vstrw.32" 4 } } */
 /* { dg-final { scan-assembler-not "__ARM_undef" } } */
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int1.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int1.c
index 4f66a07ac29..bfeb52b4dd6 100644
--- a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int1.c
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vuninitializedq_int1.c
@@ -28,6 +28,5 @@ foo ()
 
 /* { dg-final { scan-assembler-times "vstrb.8" 2 } } */
 /* { dg-final { scan-assembler-times "vstrh.16" 2 } } */
-/* { dg-final { scan-assembler-times "vstrw.32" 2 } } */
-/* { dg-final { scan-assembler-times "vstr.64" 2 } } */
+/* { dg-final { scan-assembler-times "vstrw.32" 4 } } */
 /* { dg-final { scan-assembler-not "__ARM_undef" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr69245.c b/gcc/testsuite/gcc.target/arm/pr69245.c
index bd505187728..58a6104e8f6 100644
--- a/gcc/testsuite/gcc.target/arm/pr69245.c
+++ b/gcc/testsuite/gcc.target/arm/pr69245.c
@@ -12,7 +12,7 @@
 #pragma GCC target "fpu=neon-vfpv4"
 int a, c, d;
 float b;
-static int fn1 ()
+ int fn1 ()
 {
   return 0;
 }
@@ -23,4 +23,8 @@ void fn2 ()
   d = b * c + a;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
+/* Because we don't know the exact command-line options used to invoke the test
+   we cannot expect these tests to match exactly once.  But they must appear at
+   least once.  */
+/* { dg-final { scan-assembler "\.fpu\\s+vfp\n" } } */
+/* { dg-final { scan-assembler "\.fpu\\s+neon-vfpv4\n" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr95646.c b/gcc/testsuite/gcc.target/arm/pr95646.c
new file mode 100644
index 00000000000..cde1b2d9d36
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr95646.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8m_base_ok } */
+/* { dg-add-options arm_arch_v8m_base } */
+/* { dg-additional-options "-mcmse -Os" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+int __attribute__ ((cmse_nonsecure_entry))
+foo (void)
+{
+  return 1;
+}
+/* { { dg-final { scan-assembler-not "mov\tr9, r0" } } */
+
+/*
+** __acle_se_bar:
+**	mov	(r[0-3]), r9
+**	push	{\1}
+** ...
+**	pop	{(r[0-3])}
+**	mov	r9, \2
+** ...
+**	bxns	lr
+*/
+int __attribute__ ((cmse_nonsecure_entry))
+bar (void)
+{
+  __asm__ ("" : : : "r9");
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr97969.c b/gcc/testsuite/gcc.target/arm/pr97969.c
new file mode 100644
index 00000000000..714a1d18870
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr97969.c
@@ -0,0 +1,54 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c99 -fno-omit-frame-pointer -mthumb -w -Os" } */
+
+typedef a[23];
+enum { b };
+typedef struct {
+  int c;
+  char *e;
+  char f
+} d;
+typedef enum { g = 1 } h;
+typedef struct {
+  h i;
+  int j
+} k;
+typedef struct {
+  a l;
+  int a;
+  int m;
+  int n;
+  int o;
+  short p;
+  int q;
+  k r;
+  char e;
+  char *s;
+  d t;
+  d *u;
+  short v;
+  int w
+} aa;
+c(char x, int y, char z, int ab) {
+  aa ac;
+  ac.r.i = 0;
+  d ad;
+  ac.t = ad;
+  ac.u = 0;
+  ae(&ac.v, 0, 0);
+  ac.w = 0;
+  af(&ac, x + y, z, z + ab);
+  if (ag(0))
+    return 0;
+  if (x)
+    ac.s = z + ab;
+  else
+    ac.s = x + y;
+  ac.o |= g;
+  if (!setjmp()) {
+    ah(ac);
+    ai(b);
+    ac.e = z + ab;
+    aj(ac);
+  }
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr99977.c b/gcc/testsuite/gcc.target/arm/pr99977.c
new file mode 100644
index 00000000000..db330e4a4a3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr99977.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8m_base_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8m_base } */
+_Bool f1(int *p) { return __sync_bool_compare_and_swap (p, -1, 2); }
+_Bool f2(int *p) { return __sync_bool_compare_and_swap (p, -8, 2); }
+int g1(int *p) { return __sync_val_compare_and_swap (p, -1, 2); }
+int g2(int *p) { return __sync_val_compare_and_swap (p, -8, 3); }
diff --git a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
index 174be85f3f7..7e63cf53013 100644
--- a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
+++ b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
@@ -22,5 +22,8 @@ uint32_t restored ()
   return bar();
 }
 
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv4} 1 } } */
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv3-d16} 1 } } */
+/* We can't tell exactly how many times the following tests will match because
+   command-line options may cause additional instances to be generated, but
+   each must be present at least once.  */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv4\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv3-d16\n} } } */
diff --git a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
index add40ddc6b8..398d8fff35c 100644
--- a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
+++ b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
@@ -25,5 +25,8 @@ uint32_t restored ()
   return bar();
 }
 
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv4} 1 } } */
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv3-d16} 1 } } */
+/* We can't tell exactly how many times the following tests will match because
+   command-line options may cause additional instances to be generated, but
+   each must be present at least once.  */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv4\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv3-d16\n} } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c b/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c
new file mode 100644
index 00000000000..4a0057b241e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-mavx512dq -O0" } */
+/* { dg-require-effective-target avx512dq } */
+
+#include "avx512f-check.h"
+
+static void
+avx512f_test (void)
+{
+  __m512 x = {
+      1, 1, 1, 1,
+      1, 1, 1, 1,
+      0, 0, 0, 0,
+      0, 0, 0, 0,  };
+  int ret = _mm512_fpclass_ps_mask(x, 0x26);
+  if (ret != 65280)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr101472.c b/gcc/testsuite/gcc.target/i386/avx512f-pr101472.c
new file mode 100644
index 00000000000..89c6603c2ff
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr101472.c
@@ -0,0 +1,49 @@
+/* PR target/101472 */
+/* { dg-do compile } */
+/* { dg-options "-mavx512f -O2" } */
+/* { dg-final { scan-assembler-times "vpscatterqd\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*zmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterdd\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*zmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterqq\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*zmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterdq\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterqps\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*zmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterdps\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*zmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterqpd\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*zmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterdpd\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+
+#include <immintrin.h>
+
+void two_scatters_epi32(void* addr, __mmask8 k1, __mmask8 k2, __m512i vindex, 
+			 __m256i a, __m512i b)
+{
+    _mm512_mask_i64scatter_epi32(addr, k1, vindex, a, 1);
+    _mm512_mask_i64scatter_epi32(addr, k2, vindex, a, 1);
+    _mm512_mask_i32scatter_epi32(addr, k1, vindex, b, 1);
+    _mm512_mask_i32scatter_epi32(addr, k2, vindex, b, 1);
+}
+
+void two_scatters_epi64(void* addr, __mmask8 k1, __mmask8 k2, __m512i vindex, 
+			 __m256i idx, __m512i a)
+{
+    _mm512_mask_i64scatter_epi64(addr, k1, vindex, a, 1);
+    _mm512_mask_i64scatter_epi64(addr, k2, vindex, a, 1);
+    _mm512_mask_i32scatter_epi64(addr, k1, idx, a, 1);
+    _mm512_mask_i32scatter_epi64(addr, k2, idx, a, 1);
+}
+
+void two_scatters_ps(void* addr, __mmask8 k1, __mmask8 k2, __m512i vindex, 
+		      __m256 a, __m512 b)
+{
+    _mm512_mask_i64scatter_ps(addr, k1, vindex, a, 1);
+    _mm512_mask_i64scatter_ps(addr, k2, vindex, a, 1);
+    _mm512_mask_i32scatter_ps(addr, k1, vindex, b, 1);
+    _mm512_mask_i32scatter_ps(addr, k2, vindex, b, 1);
+}
+
+void two_scatters_pd(void* addr, __mmask8 k1, __mmask8 k2, __m512i vindex, 
+		      __m256i idx, __m512d a)
+{
+    _mm512_mask_i64scatter_pd(addr, k1, vindex, a, 1);
+    _mm512_mask_i64scatter_pd(addr, k2, vindex, a, 1);
+    _mm512_mask_i32scatter_pd(addr, k1, idx, a, 1);
+    _mm512_mask_i32scatter_pd(addr, k2, idx, a, 1);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr101472.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr101472.c
new file mode 100644
index 00000000000..6df59a2eb7f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr101472.c
@@ -0,0 +1,79 @@
+/* PR target/101472 */
+/* { dg-do compile } */
+/* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpscatterqd\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterqd\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterdd\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterdd\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterqq\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterqq\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterdq\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vpscatterdq\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterqps\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterqps\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterdps\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterdps\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterqpd\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterqpd\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*ymm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterdpd\[ \\t\]+\[^\{\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+/* { dg-final { scan-assembler-times "vscatterdpd\[ \\t\]+\[^\{\n\]*ymm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*{%k\[1-7\]}(?:\n|\[ \\t\]+#)" 2 } } */
+
+
+#include <immintrin.h>
+
+void two_scatters_epi32(void* addr, __mmask8 k1, __mmask8 k2, __m128i vindex1, 
+			 __m256i vindex2, __m128i src_epi32, 
+		         __m256i src_i32_epi32)
+{
+    _mm_mask_i64scatter_epi32(addr, k1, vindex1, src_epi32, 1);
+    _mm_mask_i64scatter_epi32(addr, k2, vindex1, src_epi32, 1);
+    _mm256_mask_i64scatter_epi32(addr, k1, vindex2, src_epi32, 1);
+    _mm256_mask_i64scatter_epi32(addr, k2, vindex2, src_epi32, 1);
+
+    _mm_mask_i32scatter_epi32(addr, k1, vindex1, src_epi32, 1);
+    _mm_mask_i32scatter_epi32(addr, k2, vindex1, src_epi32, 1);
+    _mm256_mask_i32scatter_epi32(addr, k1, vindex2, src_i32_epi32, 1);
+    _mm256_mask_i32scatter_epi32(addr, k2, vindex2, src_i32_epi32, 1);
+}
+
+void two_scatters_epi64(void* addr, __mmask8 k1, __mmask8 k2, __m128i vindex1, 
+		         __m256i vindex2, __m128i src_epi64_mm, 
+			 __m256i src_epi64)
+{
+    _mm_mask_i64scatter_epi64(addr, k1, vindex1, src_epi64_mm, 1);
+    _mm_mask_i64scatter_epi64(addr, k2, vindex1, src_epi64_mm, 1);
+    _mm256_mask_i64scatter_epi64(addr, k1, vindex2, src_epi64, 1);
+    _mm256_mask_i64scatter_epi64(addr, k2, vindex2, src_epi64, 1);
+
+    _mm_mask_i32scatter_epi64(addr, k1, vindex1, src_epi64_mm, 8);
+    _mm_mask_i32scatter_epi64(addr, k2, vindex1, src_epi64_mm, 8);
+    _mm256_mask_i32scatter_epi64(addr, k1, vindex1, src_epi64, 1);
+    _mm256_mask_i32scatter_epi64(addr, k2, vindex1, src_epi64, 1);
+}
+void two_scatters_ps(void* addr, __mmask8 k1, __mmask8 k2, __m128i vindex1, 
+		      __m256i vindex2, __m128 src_ps, __m256 src_i32_ps)
+{
+    _mm_mask_i64scatter_ps(addr, k1, vindex1, src_ps, 1);
+    _mm_mask_i64scatter_ps(addr, k2, vindex1, src_ps, 1);
+    _mm256_mask_i64scatter_ps(addr, k1, vindex2, src_ps, 1);
+    _mm256_mask_i64scatter_ps(addr, k2, vindex2, src_ps, 1);
+
+    _mm_mask_i32scatter_ps(addr, k1, vindex1, src_ps, 8);
+    _mm_mask_i32scatter_ps(addr, k2, vindex1, src_ps, 8);
+    _mm256_mask_i32scatter_ps(addr, k1, vindex2, src_i32_ps, 1);
+    _mm256_mask_i32scatter_ps(addr, k2, vindex2, src_i32_ps, 1);
+}
+
+void two_scatters_pd(void* addr, __mmask8 k1, __mmask8 k2,  __m128i vindex1,
+		      __m256i vindex2, __m128d src_pd_mm, __m256d src_pd)
+{
+    _mm_mask_i64scatter_pd(addr, k1, vindex1, src_pd_mm, 1);
+    _mm_mask_i64scatter_pd(addr, k2, vindex1, src_pd_mm, 1);
+    _mm256_mask_i64scatter_pd(addr, k1, vindex2, src_pd, 1);
+    _mm256_mask_i64scatter_pd(addr, k2, vindex2, src_pd, 1);
+
+    _mm_mask_i32scatter_pd(addr, k1, vindex1, src_pd_mm, 8);
+    _mm_mask_i32scatter_pd(addr, k2, vindex1, src_pd_mm, 8);
+    _mm256_mask_i32scatter_pd(addr, k1, vindex1, src_pd, 1);
+    _mm256_mask_i32scatter_pd(addr, k2, vindex1, src_pd, 1);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr100182.c b/gcc/testsuite/gcc.target/i386/pr100182.c
new file mode 100644
index 00000000000..2f92a04db73
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr100182.c
@@ -0,0 +1,30 @@
+/* { dg-do run { target ia32 } } */
+/* { dg-options "-O2 -march=i686" } */
+
+struct S { double _M_fp; };
+union U { double d; unsigned long long int l; };
+
+void
+__attribute__((noipa))
+foo (void)
+{
+  struct S a0, a1;
+  union U u;
+  double d0, d1;
+  a0._M_fp = 0.0;
+  a1._M_fp = 1.0;
+  __atomic_store_8 (&a0._M_fp, __atomic_load_8 (&a1._M_fp, __ATOMIC_SEQ_CST), __ATOMIC_SEQ_CST);
+  u.l = __atomic_load_8 (&a0._M_fp, __ATOMIC_SEQ_CST);
+  d0 = u.d;
+  u.l = __atomic_load_8 (&a1._M_fp, __ATOMIC_SEQ_CST);
+  d1 = u.d;
+  if (d0 != d1)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr101175.c b/gcc/testsuite/gcc.target/i386/pr101175.c
new file mode 100644
index 00000000000..ed7a08110a5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr101175.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -mlzcnt" } */
+/* { dg-require-effective-target lzcnt } */
+
+#include "lzcnt-check.h"
+
+static int
+foo (unsigned int v)
+{
+  return v ? __builtin_clz (v) : 32;
+}
+
+/* returns -1 if x == 0 */
+int
+__attribute__ ((noinline, noclone))
+bar (unsigned int x)
+{
+  return 31 - foo (x);
+}
+
+static void
+lzcnt_test ()
+{
+  int r = bar (0);
+
+  if (r != -1)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr102761.c b/gcc/testsuite/gcc.target/i386/pr102761.c
new file mode 100644
index 00000000000..58ff27e4bcc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr102761.c
@@ -0,0 +1,11 @@
+/* PR target/102761 */
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+int foo (void);
+
+void
+bar (void)
+{
+  asm volatile ("%a0" : : "X"(foo () ? 2 : 1)); /* { dg-error "invalid constraints for operand" } */
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr71245-1.c b/gcc/testsuite/gcc.target/i386/pr71245-1.c
deleted file mode 100644
index be0b7602a8c..00000000000
--- a/gcc/testsuite/gcc.target/i386/pr71245-1.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* PR target/71245 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=pentium -mno-sse -mfpmath=387" } */
-
-typedef union
-{
-  unsigned long long ll;
-  double d;
-} u_t;
-
-u_t d = { .d = 5.0 };
-
-void foo_d (void)
-{
-  u_t tmp;
-  
-  tmp.ll = __atomic_load_n (&d.ll, __ATOMIC_SEQ_CST);
-  tmp.d += 1.0;
-  __atomic_store_n (&d.ll, tmp.ll, __ATOMIC_SEQ_CST);
-}
-
-/* { dg-final { scan-assembler-not "(fistp|fild)" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr71245-2.c b/gcc/testsuite/gcc.target/i386/pr71245-2.c
deleted file mode 100644
index 65c139849d5..00000000000
--- a/gcc/testsuite/gcc.target/i386/pr71245-2.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* PR target/71245 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=pentium -msse -mno-sse2 -mfpmath=387" } */
-
-typedef union
-{
-  unsigned long long ll;
-  double d;
-} u_t;
-
-u_t d = { .d = 5.0 };
-
-void foo_d (void)
-{
-  u_t tmp;
-  
-  tmp.ll = __atomic_load_n (&d.ll, __ATOMIC_SEQ_CST);
-  tmp.d += 1.0;
-  __atomic_store_n (&d.ll, tmp.ll, __ATOMIC_SEQ_CST);
-}
-
-/* { dg-final { scan-assembler-not "movlps" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr99726.c b/gcc/testsuite/gcc.target/i386/pr99726.c
new file mode 100644
index 00000000000..98ccce6a979
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr99726.c
@@ -0,0 +1,16 @@
+/* { dg-options "-flive-patching=inline-clone -mavx512f -O2 -ftree-loop-vectorize -ftrapv" } */
+/* { dg-additional-options "-floop-nest-optimize" { target fgraphite } } */
+
+extern int a[256][1024];
+int b;
+long c, d;
+unsigned int e;
+
+int
+main ()
+{
+  for (; e < d; e++)
+    for (unsigned j = 1; j < c; j++)
+      a[e][j] = b * a[e - 1][j + 1];
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr99863.c b/gcc/testsuite/gcc.target/i386/pr99863.c
new file mode 100644
index 00000000000..3d9d405391e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr99863.c
@@ -0,0 +1,33 @@
+/* PR rtl-optimization/99863 */
+/* { dg-do run } */
+/* { dg-options "-O -fno-tree-forwprop -mno-sse2 -Wno-psabi" } */
+
+typedef unsigned char __attribute__((__vector_size__ (8))) A;
+typedef unsigned char __attribute__((__vector_size__ (32))) B;
+typedef unsigned char __attribute__((__vector_size__ (64))) C;
+typedef unsigned int __attribute__((__vector_size__ (32))) D;
+typedef unsigned int __attribute__((__vector_size__ (64))) E;
+typedef unsigned long long F;
+
+D a;
+A b;
+
+A
+foo (E x, F y)
+{
+  D c = (y <= 0) * a;
+  x *= (0 < y);
+  C d = (C) x;
+  B e = ((union { C a; B b[2];}) d).b[0] + (B) c;
+  A f = ((union { B a; A b[4];}) e).b[0] + (A) b;
+  return f;
+}
+
+int
+main ()
+{
+  F x = (F) foo ((E) { 3 }, 5);
+  if (x != 3)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr99905.c b/gcc/testsuite/gcc.target/i386/pr99905.c
new file mode 100644
index 00000000000..6d1b2305a76
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr99905.c
@@ -0,0 +1,33 @@
+/* PR rtl-optimization/99905 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-Os -mno-mmx -mno-sse" } */
+
+typedef unsigned char U;
+typedef unsigned char __attribute__((__vector_size__ (8))) A;
+typedef unsigned char __attribute__((__vector_size__ (16))) B;
+typedef unsigned char __attribute__((__vector_size__ (32))) C;
+typedef unsigned int __attribute__((__vector_size__ (8))) D;
+typedef unsigned long long __attribute__((__vector_size__ (8))) E;
+typedef unsigned __int128 I;
+typedef unsigned long long L;
+
+D gv;
+I gi;
+
+L __attribute__((__noipa__))
+foo (int ua, int ub, int uc, int ud, E ue, I i)
+{
+  D d = (U) __builtin_bswap16 (i >> 63) + gv;
+  B y = ((union { C a; B b[2];}) (C){ }).b[0] + (B) gi;
+  A z = ((union { B a; A b[2];}) y).b[0] + (A) d;
+  return (L)z;
+}
+
+int
+main ()
+{
+  L x = foo (0, 0, 0, 0, (E) { }, (I) 0x100 << 63);
+  if (x != 0x100000001)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/mma-builtin-4.c b/gcc/testsuite/gcc.target/powerpc/mma-builtin-4.c
index 3bedf531de0..a9fb0107d12 100644
--- a/gcc/testsuite/gcc.target/powerpc/mma-builtin-4.c
+++ b/gcc/testsuite/gcc.target/powerpc/mma-builtin-4.c
@@ -20,6 +20,14 @@ foo2 (__vector_pair *dst, vec_t *src)
   *dst = pair;
 }
 
+void
+foo3 (__vector_pair *dst, vec_t *src)
+{
+  __vector_pair pair;
+  __builtin_vsx_build_pair (&pair, src[4], src[0]);
+  *dst = pair;
+}
+
 void
 bar (vec_t *dst, __vector_pair *src)
 {
@@ -54,8 +62,12 @@ bar2 (vec_t *dst, __vector_pair *src)
 #  error "__has_builtin (__builtin_mma_disassemble_pair) failed"
 #endif
 
-/* { dg-final { scan-assembler-times {\mlxv\M} 4 } } */
+#if !__has_builtin (__builtin_vsx_build_pair)
+#  error "__has_builtin (__builtin_vsx_build_pair) failed"
+#endif
+
+/* { dg-final { scan-assembler-times {\mlxv\M} 6 } } */
 /* { dg-final { scan-assembler-times {\mlxvp\M} 2 } } */
 /* { dg-final { scan-assembler-times {\mstxv\M} 4 } } */
-/* { dg-final { scan-assembler-times {\mstxvp\M} 2 } } */
+/* { dg-final { scan-assembler-times {\mstxvp\M} 3 } } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/mma-builtin-5.c b/gcc/testsuite/gcc.target/powerpc/mma-builtin-5.c
index 43b6d3ac91e..00503b7343d 100644
--- a/gcc/testsuite/gcc.target/powerpc/mma-builtin-5.c
+++ b/gcc/testsuite/gcc.target/powerpc/mma-builtin-5.c
@@ -12,6 +12,14 @@ foo (__vector_quad *dst, vec_t *src)
   *dst = acc;
 }
 
+void
+foo2 (__vector_quad *dst, vec_t *src)
+{
+  __vector_quad acc;
+  __builtin_mma_build_acc (&acc, src[12], src[8], src[4], src[0]);
+  *dst = acc;
+}
+
 void
 bar (vec_t *dst, __vector_quad *src)
 {
@@ -23,9 +31,17 @@ bar (vec_t *dst, __vector_quad *src)
   dst[12] = res[3];
 }
 
-/* { dg-final { scan-assembler-times {\mlxv\M} 4 } } */
+#if !__has_builtin (__builtin_mma_assemble_acc)
+#  error "__has_builtin (__builtin_mma_assemble_acc) failed"
+#endif
+
+#if !__has_builtin (__builtin_mma_build_acc)
+#  error "__has_builtin (__builtin_mma_build_acc) failed"
+#endif
+
+/* { dg-final { scan-assembler-times {\mlxv\M} 8 } } */
 /* { dg-final { scan-assembler-times {\mlxvp\M} 2 } } */
 /* { dg-final { scan-assembler-times {\mstxv\M} 4 } } */
-/* { dg-final { scan-assembler-times {\mstxvp\M} 2 } } */
-/* { dg-final { scan-assembler-times {\mxxmfacc\M} 2 } } */
-/* { dg-final { scan-assembler-times {\mxxmtacc\M} 2 } } */
+/* { dg-final { scan-assembler-times {\mstxvp\M} 4 } } */
+/* { dg-final { scan-assembler-times {\mxxmfacc\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mxxmtacc\M} 3 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/mma-builtin-7.c b/gcc/testsuite/gcc.target/powerpc/mma-builtin-7.c
new file mode 100644
index 00000000000..c661a4b84bc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/mma-builtin-7.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-mdejagnu-cpu=power10 -O2" } */
+
+void
+foo (__vector_pair *dst, __vector_pair *src, long idx)
+{
+  dst[0] = __builtin_vsx_lxvp (0, src);
+  dst[2] = __builtin_vsx_lxvp (32, src);
+  dst[4] = __builtin_vsx_lxvp (64, src);
+  /* Non-constant offset should generate a lxvpx.  */
+  dst[6] = __builtin_vsx_lxvp (idx, src);
+  /* Non-aligned offset should generate a plxvp.  */
+  dst[8] = __builtin_vsx_lxvp (257, src);
+}
+
+#if !__has_builtin (__builtin_vsx_lxvp)
+#  error "__has_builtin (__builtin_vsx_lxvp) failed"
+#endif
+
+/* { dg-final { scan-assembler-not {\mlxv\M} } } */
+/* { dg-final { scan-assembler-not {\mstxv\M} } } */
+/* { dg-final { scan-assembler-times {\mlxvp\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mlxvpx\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mplxvp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mstxvp\M} 5 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/mma-builtin-8.c b/gcc/testsuite/gcc.target/powerpc/mma-builtin-8.c
new file mode 100644
index 00000000000..af29e479f83
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/mma-builtin-8.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-mdejagnu-cpu=power10 -O2" } */
+
+void
+foo (__vector_pair *dst, __vector_pair *src, long idx)
+{
+  __vector_pair pair = *src;
+  __builtin_vsx_stxvp (pair, 0, dst);
+  __builtin_vsx_stxvp (pair, 32, dst);
+  __builtin_vsx_stxvp (pair, 64, dst);
+  /* Non-constant offset should generate a stxvpx.  */
+  __builtin_vsx_stxvp (pair, idx, dst);
+  /* Non-aligned offset should generate a pstxvp.  */
+  __builtin_vsx_stxvp (pair, 257, dst);
+}
+
+#if !__has_builtin (__builtin_vsx_stxvp)
+#  error "__has_builtin (__builtin_vsx_stxvp) failed"
+#endif
+
+/* { dg-final { scan-assembler-not {\mlxv\M} } } */
+/* { dg-final { scan-assembler-not {\mstxv\M} } } */
+/* { dg-final { scan-assembler-times {\mlxvp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mstxvp\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mstxvpx\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mpstxvp\M} 1 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr100777.c b/gcc/testsuite/gcc.target/powerpc/pr100777.c
new file mode 100644
index 00000000000..15742f67d8c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr100777.c
@@ -0,0 +1,24 @@
+/* PR target/100777 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-require-effective-target fopenmp } */
+/* { dg-options "-O1 -mdejagnu-cpu=power10 -fopenmp" } */
+
+/* Verify we do not ICE on the following.  */
+
+void
+foo (__vector_quad *dst)
+{
+#pragma omp parallel
+  {
+    __builtin_mma_xxsetaccz (dst);
+  }
+}
+
+void
+bar (__vector_quad *dst, __vector_quad *src)
+{
+#pragma omp parallel
+  {
+    __builtin_mma_disassemble_acc (dst, src);
+  }
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101129.c b/gcc/testsuite/gcc.target/powerpc/pr101129.c
new file mode 100644
index 00000000000..6b8e5a9b597
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101129.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-require-effective-target int128 } */
+/* { dg-options "-mdejagnu-cpu=power8 -O " } */
+
+/* PR101129: The swaps pass was turning a mult-lopart into a mult-hipart.
+   Make sure we aren't doing that anymore.  */
+
+typedef unsigned char u8;
+typedef unsigned char __attribute__((__vector_size__ (8))) U;
+typedef unsigned char __attribute__((__vector_size__ (16))) V;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+typedef __int128 u128;
+
+u8 g;
+U u;
+
+void
+foo0 (u32 u32_0, U *ret)
+{
+  u128 u128_2 = u32_0 * (u128)((V){ 5 } > (u32_0 & 4));
+  u64 u64_r = u128_2 >> 64;
+  u8 u8_r = u64_r + g;
+  *ret = u + u8_r;
+}
+
+int
+main (void)
+{
+  U x;
+  foo0 (7, &x);
+  for (unsigned i = 0; i < sizeof (x); i++)
+    if (x[i] != 0) __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101849.c b/gcc/testsuite/gcc.target/powerpc/pr101849.c
new file mode 100644
index 00000000000..823fbfe9647
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101849.c
@@ -0,0 +1,22 @@
+/* PR target/101849 */
+/* { dg-do compile } */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Verify we do not ICE on the tests below.  */
+
+void
+foo (__vector_pair *dst, double *x, long offset)
+{
+  dst[0] = __builtin_vsx_lxvp (0, (__vector_pair *)(void *)x);
+  dst[1] = __builtin_vsx_lxvp (32, (__vector_pair *)(void *)x);
+  dst[2] = __builtin_vsx_lxvp (offset, (__vector_pair *)(void *)x);
+}
+
+void
+bar (__vector_pair *src, double *x, long offset)
+{
+  __builtin_vsx_stxvp (src[0], 0, (__vector_pair *)(void *)x);
+  __builtin_vsx_stxvp (src[1], 32, (__vector_pair *)(void *)x);
+  __builtin_vsx_stxvp (src[2], offset, (__vector_pair *)(void *)x);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101985-1.c b/gcc/testsuite/gcc.target/powerpc/pr101985-1.c
new file mode 100644
index 00000000000..b4753ab83d7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101985-1.c
@@ -0,0 +1,18 @@
+/* PR target/101985 */
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#include <altivec.h>
+
+int
+main (void)
+{
+  vector float a = {  1,  2, - 3, - 4};
+  vector float b = {-10, 20, -30,  40};
+  vector float c = { 10, 20, -30, -40};
+  a = vec_cpsgn (a, b);
+  if (! vec_all_eq (a, c))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101985-2.c b/gcc/testsuite/gcc.target/powerpc/pr101985-2.c
new file mode 100644
index 00000000000..148ad657366
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101985-2.c
@@ -0,0 +1,18 @@
+/* PR target/101985 */
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#include <altivec.h>
+
+int
+main (void)
+{
+  vector double a = {   1,  -4};
+  vector double b = { -10,  40};
+  vector double c = {  10, -40};
+  a = vec_cpsgn (a, b);
+  if (! vec_all_eq (a, c))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr102347.c b/gcc/testsuite/gcc.target/powerpc/pr102347.c
new file mode 100644
index 00000000000..05c439a8dac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr102347.c
@@ -0,0 +1,15 @@
+/* { dg-do link } */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-require-effective-target lto } */
+/* { dg-options "-flto -mdejagnu-cpu=power9" } */
+
+/* Verify there are no error messages in LTO mode.  */
+
+#pragma GCC target "cpu=power10"
+int main ()
+{
+  float *b;
+  __vector_quad c;
+  __builtin_mma_disassemble_acc (b, &c);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr97142.c b/gcc/testsuite/gcc.target/powerpc/pr97142.c
new file mode 100644
index 00000000000..0e5f1c1f61b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr97142.c
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+/* { dg-options "-Ofast" } */
+
+#include <math.h>
+
+float test1 (float x, float y)
+{
+  return fmodf (x, y);
+}
+
+double test2 (double x, double y)
+{
+  return fmod (x, y);
+}
+
+float test3 (float x, float y)
+{
+  return remainderf (x, y);
+}
+
+double test4 (double x, double y)
+{
+  return remainder (x, y);
+}
+
+/* { dg-final { scan-assembler-not {(?n)\mb.*fmod} } } */
+/* { dg-final { scan-assembler-not {(?n)\mb.*fmodf} } } */
+/* { dg-final { scan-assembler-not {(?n)\mb.*remainder} } } */
+/* { dg-final { scan-assembler-not {(?n)\mb.*remainderf} } } */
+/* { dg-final { scan-assembler-times {\mfdiv\M} 2 } } */
+/* { dg-final { scan-assembler-times {\mfdivs\M} 2 } } */
+/* { dg-final { scan-assembler-times {\mfnmsub\M} 2 } } */
+/* { dg-final { scan-assembler-times {\mfnmsubs\M} 2 } } */
+/* { dg-final { scan-assembler-times {\mfriz\M} 2 } } */
+/* { dg-final { scan-assembler-times {\mfrin\M} 2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr98952.c b/gcc/testsuite/gcc.target/powerpc/pr98952.c
new file mode 100644
index 00000000000..c487fbc403e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr98952.c
@@ -0,0 +1,28 @@
+/* { dg-do run { target { powerpc*-*-linux* && ilp32 } } } */
+/* { dg-options "-O2" } */
+
+/* PR 96983 reported that the test in libgcc's tramp.S was backwards and it
+   would abort if the trampoline size passed to the function was greater than
+   the size the runtime was expecting (40).  It should abort if the size is less
+   than 40, not greater than 40.  This test creates a call to __trampoline_setup
+   with a much larger buffer to make sure the function does not abort.
+
+   We do not run this test on 64-bit since __trampoline_setup is not present in
+   64-bit systems.
+
+   We only run the test under Linux in case the other systems have some
+   different variant for __trampoline_setup.  */
+
+#ifndef SIZE
+#define SIZE 100
+#endif
+
+extern void __trampoline_setup (int *, unsigned, void *, void *);
+
+int main (void)
+{
+  int tramp[SIZE / sizeof (int)];
+
+  __trampoline_setup (tramp, SIZE, 0, 0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/riscv/pr98777.c b/gcc/testsuite/gcc.target/riscv/pr98777.c
new file mode 100644
index 00000000000..ea2c2f9ca64
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr98777.c
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-fstrict-aliasing -O" } */
+
+typedef struct {
+  _Complex e;
+  _Complex f;
+  _Complex g;
+  _Complex h;
+  _Complex i;
+  _Complex j;
+  _Complex k;
+  _Complex l;
+  _Complex m;
+  _Complex n;
+  _Complex o;
+  _Complex p;
+} Scl16;
+
+Scl16 g1sScl16, g2sScl16, g3sScl16, g4sScl16, g5sScl16, g6sScl16, g7sScl16,
+    g8sScl16, g9sScl16, g10sScl16, g11sScl16, g12sScl16, g13sScl16, g14sScl16,
+    g15sScl16, g16sScl16;
+
+void testvaScl16();
+
+void
+testitScl16() {
+  testvaScl16(g10sScl16, g11sScl16, g12sScl16, g13sScl16, g14sScl16, g1sScl16,
+              g2sScl16, g3sScl16, g4sScl16, g5sScl16, g6sScl16, g7sScl16,
+              g8sScl16, g9sScl16, g10sScl16, g11sScl16, g12sScl16, g13sScl16,
+              g14sScl16, g15sScl16, g16sScl16);
+}
diff --git a/gcc/testsuite/gcc.target/s390/20211119.c b/gcc/testsuite/gcc.target/s390/20211119.c
new file mode 100644
index 00000000000..b9d216389f4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/20211119.c
@@ -0,0 +1,12 @@
+/* { dg-do run { target { s390_useable_hw } } } */
+/* { dg-options "-Os -march=z10" } */
+signed char a;
+int b = -925974181, c;
+unsigned *d = &b;
+int *e = &c;
+int main() {
+  *e = ((217 ^ a) > 585) < *d;
+  if (c != 1)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20210917-1.c b/gcc/testsuite/gcc.target/sparc/20210917-1.c
new file mode 100644
index 00000000000..03e8bc58db9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20210917-1.c
@@ -0,0 +1,19 @@
+/* PR rtl-optimization/102306 */
+/* Reported by Daniel Cederman <cederman@gaisler.com> */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O -mcpu=v8" } */
+
+extern void foo (void);
+
+void test (volatile unsigned char *a) 
+{ 
+  char b = *a;
+  if (!b)
+    return;
+  if (b & 2)
+    foo ();
+}
+
+/* { dg-final { scan-assembler-times "ldub" 1 } } */
diff --git a/gcc/testsuite/gdc.dg/pr100882a.d b/gcc/testsuite/gdc.dg/pr100882a.d
new file mode 100644
index 00000000000..d94baff97ac
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882a.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-additional-options "-fmain" }
+// { dg-do run }
+
+__gshared int counter = 0;
+struct S100882
+{
+    this(int) { counter++; }
+    ~this() { counter++; }
+}
+static S100882 s;
+static this()
+{
+    s = cast(shared) S100882(0);
+    assert(counter == 2);
+}
+
+auto test100882()
+{
+    return cast(shared) S100882(0);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882b.d b/gcc/testsuite/gdc.dg/pr100882b.d
new file mode 100644
index 00000000000..de92ab3bef1
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882b.d
@@ -0,0 +1,35 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct AllocatorList(Factory)
+{
+    Factory factory;
+    auto make(size_t n) { return factory(n); }
+    this(Factory plant)
+    {
+        factory = plant;
+    }
+}
+
+struct Region
+{
+    ~this()
+    {
+    }
+}
+
+auto mmapRegionList()
+{
+    struct Factory
+    {
+        this(size_t )
+        {
+        }
+        auto opCall(size_t )
+        {
+            return Region();
+        }
+    }
+    auto shop = Factory();
+    AllocatorList!Factory(shop);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882c.d b/gcc/testsuite/gdc.dg/pr100882c.d
new file mode 100644
index 00000000000..deaa4b44a16
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882c.d
@@ -0,0 +1,19 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+auto iota(int, int)
+{
+    struct Result
+    {
+        this(int)
+        {
+        }
+    }
+    return Result();
+}
+
+auto iota(int end)
+{
+    int begin;
+    return iota(begin, end);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882d.d b/gcc/testsuite/gdc.dg/pr100882d.d
new file mode 100644
index 00000000000..f4e6e4d3651
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882d.d
@@ -0,0 +1,25 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct CowArray
+{
+    this(this)
+    {
+    }
+}
+
+struct Tuple
+{
+    CowArray expand;
+}
+
+auto tuple(CowArray)
+{
+    return Tuple();
+}
+
+auto parseCharTerm()
+{
+    CowArray set;
+    return tuple(set);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100967.d b/gcc/testsuite/gdc.dg/pr100967.d
new file mode 100644
index 00000000000..582ad582676
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100967.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100967
+// { dg-do compile }
+
+module object; // { dg-error "class object.TypeInfo missing or corrupt object.d" }
+
+extern(C) int main()
+{
+    int[int] aa;
+    aa[0] = 1;  // { dg-error ".object.TypeInfo. could not be found, but is implicitly used" }
+    return 0;
+}
diff --git a/gcc/testsuite/gdc.dg/pr101127a.d b/gcc/testsuite/gdc.dg/pr101127a.d
new file mode 100644
index 00000000000..b56398e1929
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127a.d
@@ -0,0 +1,8 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+// { dg-additional-options "-mavx" }
+
+import gcc.builtins;
+
+static assert(__traits(compiles, __builtin_ia32_andps256));
+static assert(__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101127b.d b/gcc/testsuite/gdc.dg/pr101127b.d
new file mode 100644
index 00000000000..b462d75c424
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127b.d
@@ -0,0 +1,7 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+
+import gcc.builtins;
+
+static assert(!__traits(compiles, __builtin_ia32_andps256));
+static assert(!__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101490.d b/gcc/testsuite/gdc.dg/pr101490.d
new file mode 100644
index 00000000000..6929d406863
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101490.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101490
+// { dg-do compile }
+
+struct S101490
+{
+    int[0] arr;
+}
+
+void main()
+{
+    S101490* t;
+    auto a = cast(typeof(t.arr)[0])t.arr;
+    write(a);
+}
+
+void write(S)(S args)
+{
+    foreach (arg; args)
+    {
+    }
+}
diff --git a/gcc/testsuite/gdc.dg/pr101640.d b/gcc/testsuite/gdc.dg/pr101640.d
new file mode 100644
index 00000000000..68de4088512
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101640.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101640
+// { dg-do compile }
+// { dg-options "-fdump-tree-original" }
+
+int fun101640(ref int);
+
+int test101640(int val)
+{
+    // { dg-final { scan-tree-dump "= val \\\+ fun101640 \\\(\\\(int &\\\) &val\\\);" "original" } }
+    return val + fun101640(val);
+}
diff --git a/gcc/testsuite/gdc.dg/pr96435.d b/gcc/testsuite/gdc.dg/pr96435.d
new file mode 100644
index 00000000000..c6d8785ec5b
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr96435.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96435
+// { dg-do run }
+
+@safe bool test96435()
+{
+    int[2] array = [16, 678];
+    union U { int i; bool b; }
+    U u;
+    u.i = 0xDEADBEEF;
+    assert(array[u.b] == 678);
+    return u.b;
+}
+
+@safe void main()
+{
+    auto b = test96435();
+    if (b)
+        assert(true);
+    if (!b)
+        assert(false);
+}
diff --git a/gcc/testsuite/gdc.dg/pr98457.d b/gcc/testsuite/gdc.dg/pr98457.d
new file mode 100644
index 00000000000..bc0d8af5d4a
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr98457.d
@@ -0,0 +1,9 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98457
+// { dg-do compile }
+
+void main()
+{
+    writef!"%s";    // { dg-error "template instance writef!\"%s\" template .writef. is not defined" }
+    writef!"`%s";   // { dg-error "template instance writef!\"`%s\" template .writef. is not defined" }
+    writef!"%%s`";  // { dg-error "template instance writef!\"%%s`\" template .writef. is not defined" }
+}
diff --git a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
index bf602ff31a4..0c727e2fec5 100644
--- a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
+++ b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
@@ -27,6 +27,26 @@ static assert(C2.int1.offsetof == payloadOffset + 8);
 static assert(C2.alignof == size_t.sizeof);
 static assert(__traits(classInstanceSize, C2) == payloadOffset + 12);
 
+align(8) struct PaddedStruct
+{
+    bool flag;
+    align(2) S1 s1;
+}
+
+static assert(PaddedStruct.s1.offsetof == 2);
+static assert(PaddedStruct.alignof == 8);
+static assert(PaddedStruct.sizeof == 16);
+
+align(1) struct UglyStruct
+{
+    bool flag;
+    int i;
+    ubyte u;
+}
+
+static assert(UglyStruct.i.offsetof == 4);
+static assert(UglyStruct.alignof == 1);
+static assert(UglyStruct.sizeof == 9);
 
 /***************************************************/
 // https://issues.dlang.org/show_bug.cgi?id=19914
diff --git a/gcc/testsuite/gdc.test/compilable/b19002.d b/gcc/testsuite/gdc.test/compilable/b19002.d
new file mode 100644
index 00000000000..fd8e6d18b37
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/b19002.d
@@ -0,0 +1,12 @@
+module b19002;
+
+void printf(scope const char* format){}
+
+void main()
+{
+    printf(__FILE__);
+    printf(__FILE_FULL_PATH__);
+    printf(__FUNCTION__);
+    printf(__PRETTY_FUNCTION__);
+    printf(__MODULE__);
+}
diff --git a/gcc/testsuite/gdc.test/compilable/betterCarray.d b/gcc/testsuite/gdc.test/compilable/betterCarray.d
index 74c80be3b95..3f48b042bde 100644
--- a/gcc/testsuite/gdc.test/compilable/betterCarray.d
+++ b/gcc/testsuite/gdc.test/compilable/betterCarray.d
@@ -15,3 +15,13 @@ int foo(int[] a, int i)
 {
     return a[i];
 }
+
+/**********************************************/
+// https://issues.dlang.org/show_bug.cgi?id=19234
+void issue19234()
+{
+    static struct A {}
+    A[10] a;
+    A[10] b;
+    b[] = a[];
+}
diff --git a/gcc/testsuite/gdc.test/compilable/extra-files/minimal/object.d b/gcc/testsuite/gdc.test/compilable/extra-files/minimal/object.d
new file mode 100644
index 00000000000..c7060b0d96c
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/extra-files/minimal/object.d
@@ -0,0 +1 @@
+module object;
diff --git a/gcc/testsuite/gdc.test/compilable/interpret5.d b/gcc/testsuite/gdc.test/compilable/interpret5.d
new file mode 100644
index 00000000000..ce13a5ab182
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/interpret5.d
@@ -0,0 +1,30 @@
+// https://issues.dlang.org/show_bug.cgi?id=21927
+/*
+TEST_OUTPUT:
+---
+T1(Args...)
+T1!()
+T2(Args2...)
+T2!()
+this.T2(Args2...)
+this.T2!()
+---
+*/
+template T1(Args...) {}
+
+pragma(msg, T1);    // TOK.template_
+pragma(msg, T1!()); // TOK.scope_
+
+struct S
+{
+    template T2(Args2...) {}
+
+    pragma(msg, S.T2);    // TOK.template_
+    pragma(msg, S.T2!()); // TOK.scope_
+
+    void fun()
+    {
+        pragma(msg, this.T2);    // TOK.dotTemplateDeclaration
+        pragma(msg, this.T2!()); // TOK.dot
+    }
+}
diff --git a/gcc/testsuite/gdc.test/compilable/minimal3.d b/gcc/testsuite/gdc.test/compilable/minimal3.d
new file mode 100644
index 00000000000..e8106b62003
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/minimal3.d
@@ -0,0 +1,36 @@
+// DFLAGS:
+// REQUIRED_ARGS: -defaultlib=
+// EXTRA_SOURCES: extra-files/minimal/object.d
+
+/**********************************************/
+// https://issues.dlang.org/show_bug.cgi?id=19234
+void issue19234()
+{
+    static struct A {}
+    A[10] a;
+    A[10] b;
+    b[] = a[];
+}
+
+/**********************************************/
+// https://issues.dlang.org/show_bug.cgi?id=22005
+void issue22005()
+{
+    enum int[4] foo = [1,2,3,4];
+    static foreach (i, e; foo)
+    {
+    }
+}
+
+/**********************************************/
+// https://issues.dlang.org/show_bug.cgi?id=22006
+void issue22006()
+{
+    alias size_t = typeof(int.sizeof);
+    alias AliasSeq(T...) = T;
+
+    foreach (size_t i, e; [0, 1, 2, 3]) { }
+    static foreach (size_t i, e; [0, 1, 2, 3]) { }
+    foreach (size_t i, e; AliasSeq!(0, 1, 2, 3)) { }
+    static foreach (size_t i, e; AliasSeq!(0, 1, 2, 3)) { }
+}
diff --git a/gcc/testsuite/gdc.test/compilable/staticforeach.d b/gcc/testsuite/gdc.test/compilable/staticforeach.d
index 48d06b418d3..8a54f32de57 100644
--- a/gcc/testsuite/gdc.test/compilable/staticforeach.d
+++ b/gcc/testsuite/gdc.test/compilable/staticforeach.d
@@ -115,6 +115,8 @@ bug17688
 T
 foo2
 T2
+TestStaticForeach2
+issue22007
 1 2 '3'
 2 3 '4'
 0 1
@@ -840,3 +842,39 @@ struct T2{
         struct S{}
 }
 static assert(is(__traits(parent,T2.S)==T2));
+
+struct TestStaticForeach2
+{
+static:
+    // StringExp
+    char[] test(string str)()
+    {
+        char[] s;
+        static foreach (c; str)
+        {
+            s ~= c;
+        }
+        return s;
+    }
+    static assert(test!"t—ëst√±" == ['t', '\xd1', '\x91', 's', 't', '\xc3', '\xb1']);
+
+    static foreach (c; "")
+    {
+        static assert(0);
+    }
+
+    // NullExp
+    enum int[] a = null;
+    static foreach (c; a)
+    {
+        static assert(0);
+    }
+}
+
+//https://issues.dlang.org/show_bug.cgi?id=22007
+void issue22007()
+{
+    immutable int[32] array = 1;
+    foreach (size_t a, int b; array) {}
+    static foreach (size_t a, int b; array) { }
+}
diff --git a/gcc/testsuite/gdc.test/compilable/test21742.d b/gcc/testsuite/gdc.test/compilable/test21742.d
new file mode 100644
index 00000000000..b8f5df4b46d
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/test21742.d
@@ -0,0 +1,13 @@
+// https://issues.dlang.org/show_bug.cgi?id=21742
+
+int foo()() { return 0; }
+
+struct B
+{
+    int foo()() { return 0; }
+}
+
+static assert(is(typeof(foo) == void));
+
+// failed, gagged error: expression B().foo()() has no type
+static assert(is(typeof(B().foo) == void));
diff --git a/gcc/testsuite/gdc.test/compilable/test22006.d b/gcc/testsuite/gdc.test/compilable/test22006.d
new file mode 100644
index 00000000000..913dd859012
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/test22006.d
@@ -0,0 +1,14 @@
+// https://issues.dlang.org/show_bug.cgi?id=22006
+void test22006()
+{
+    alias AliasSeq(TList...) = TList;
+    {
+        alias aseq = AliasSeq!(0, 1, 2, 3);
+        static foreach (ubyte i; 0 .. aseq.length) {}
+        static foreach (ubyte i, x; aseq) {}
+    }
+    {
+        static foreach (ubyte i; 0 .. [0, 1, 2, 3].length) {}
+        static foreach (ubyte i, x; [0, 1, 2, 3]) {}
+    }
+}
diff --git a/gcc/testsuite/gdc.test/compilable/test22133.d b/gcc/testsuite/gdc.test/compilable/test22133.d
new file mode 100644
index 00000000000..aff762c7180
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/test22133.d
@@ -0,0 +1,16 @@
+// https://issues.dlang.org/show_bug.cgi?id=22133
+
+struct Slice
+{
+    bool empty() const;
+    int front() const;
+    void popFront()() // note: requires a mutable Slice
+    {}
+}
+
+enum isInputRange1(R) = is(typeof((R r) => r.popFront));
+enum isInputRange2(R) = __traits(compiles, (R r) => r.popFront);
+static assert(isInputRange1!(      Slice) == true);
+static assert(isInputRange1!(const Slice) == false);
+static assert(isInputRange2!(      Slice) == true);
+static assert(isInputRange2!(const Slice) == false);
diff --git a/gcc/testsuite/gdc.test/fail_compilation/b12504.d b/gcc/testsuite/gdc.test/fail_compilation/b12504.d
new file mode 100644
index 00000000000..0bb104eded7
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/b12504.d
@@ -0,0 +1,64 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/b12504.d(26): Error: cannot implicitly convert expression `257$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `ubyte`
+fail_compilation/b12504.d(27): Error: index type `ubyte` cannot cover index range 0..257
+fail_compilation/b12504.d(31): Error: cannot implicitly convert expression `129$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `byte`
+fail_compilation/b12504.d(32): Error: index type `byte` cannot cover index range 0..129
+fail_compilation/b12504.d(36): Error: cannot implicitly convert expression `65537$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `ushort`
+fail_compilation/b12504.d(37): Error: index type `ushort` cannot cover index range 0..65537
+fail_compilation/b12504.d(41): Error: cannot implicitly convert expression `32769$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `short`
+fail_compilation/b12504.d(42): Error: index type `short` cannot cover index range 0..32769
+fail_compilation/b12504.d(46): Error: cannot implicitly convert expression `257$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `ubyte`
+fail_compilation/b12504.d(47): Error: index type `ubyte` cannot cover index range 0..257
+fail_compilation/b12504.d(51): Error: cannot implicitly convert expression `129$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `byte`
+fail_compilation/b12504.d(52): Error: index type `byte` cannot cover index range 0..129
+fail_compilation/b12504.d(56): Error: cannot implicitly convert expression `65537$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `ushort`
+fail_compilation/b12504.d(57): Error: index type `ushort` cannot cover index range 0..65537
+fail_compilation/b12504.d(61): Error: cannot implicitly convert expression `32769$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `short`
+fail_compilation/b12504.d(62): Error: index type `short` cannot cover index range 0..32769
+---
+*/
+void main()
+{
+    {
+        int[0xFF + 2] sta;
+        foreach (ubyte i; 0 .. sta.length) {}
+        foreach (ubyte i, x; sta) {}
+    }
+    {
+        int[0x7F + 2] sta;
+        foreach (byte i; 0 .. sta.length) {}
+        foreach (byte i, x; sta) {}
+    }
+    {
+        int[0xFFFF + 2] sta;
+        foreach (ushort i; 0 .. sta.length) {}
+        foreach (ushort i, x; sta) {}
+    }
+    {
+        int[0x7FFF + 2] sta;
+        foreach (short i; 0 .. sta.length) {}
+        foreach (short i, x; sta) {}
+    }
+    {
+        immutable int[0xFF + 2] sta;
+        static foreach (ubyte i; 0 .. sta.length) {}
+        static foreach (ubyte i, x; sta) {}
+    }
+    {
+        immutable int[0x7F + 2] sta;
+        static foreach (byte i; 0 .. sta.length) {}
+        static foreach (byte i, x; sta) {}
+    }
+    {
+        immutable int[0xFFFF + 2] sta;
+        static foreach (ushort i; 0 .. sta.length) {}
+        static foreach (ushort i, x; sta) {}
+    }
+    {
+        immutable int[0x7FFF + 2] sta;
+        static foreach (short i; 0 .. sta.length) {}
+        static foreach (short i, x; sta) {}
+    }
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/diag16976.d b/gcc/testsuite/gdc.test/fail_compilation/diag16976.d
index ebfb72b493c..1dbacfd3e54 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/diag16976.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/diag16976.d
@@ -1,21 +1,37 @@
 /* TEST_OUTPUT:
 ---
-fail_compilation/diag16976.d(28): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(29): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(30): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(31): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(32): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(33): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(34): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(35): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(36): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(37): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(38): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(39): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(40): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(41): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(42): Error: foreach: key cannot be of non-integral type `float`
-fail_compilation/diag16976.d(43): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(44): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(45): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(46): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(47): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(48): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(49): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(50): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(51): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(52): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(53): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(54): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(55): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(56): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(57): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(58): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(59): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(65): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(66): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(67): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(68): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(69): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(70): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(71): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(72): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(73): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(74): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(75): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(76): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(77): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(78): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(79): Error: foreach: key cannot be of non-integral type `float`
+fail_compilation/diag16976.d(80): Error: foreach: key cannot be of non-integral type `float`
 ---
 */
 
@@ -41,4 +57,25 @@ void main()
     foreach_reverse(float f, dchar i; sta) {}
     foreach_reverse(float f, dchar i; str) {}
     foreach_reverse(float f, dchar i; chr) {}
+
+    immutable int[]  idyn = [1,2,3,4,5];
+    immutable int[5] ista = [1,2,3,4,5];
+    immutable char[]  istr = ['1','2','3','4','5'];
+    immutable char[5] ichr = ['1','2','3','4','5'];
+    static foreach(float f, i; idyn) {}
+    static foreach(float f, i; ista) {}
+    static foreach(float f, i; istr) {}
+    static foreach(float f, i; ichr) {}
+    static foreach(float f, dchar i; idyn) {}
+    static foreach(float f, dchar i; ista) {}
+    static foreach(float f, dchar i; istr) {}
+    static foreach(float f, dchar i; ichr) {}
+    static foreach_reverse(float f, i; idyn) {}
+    static foreach_reverse(float f, i; ista) {}
+    static foreach_reverse(float f, i; istr) {}
+    static foreach_reverse(float f, i; ichr) {}
+    static foreach_reverse(float f, dchar i; idyn) {}
+    static foreach_reverse(float f, dchar i; ista) {}
+    static foreach_reverse(float f, dchar i; istr) {}
+    static foreach_reverse(float f, dchar i; ichr) {}
 }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail117.d b/gcc/testsuite/gdc.test/fail_compilation/fail117.d
index f39a48db67c..9279d54276c 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail117.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail117.d
@@ -1,8 +1,10 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail117.d(35): Error: expression has no value
-fail_compilation/fail117.d(36): Error: expression has no value
+fail_compilation/fail117.d(37): Error: expression `foo.mixin MGettor!(a) geta;
+` is `void` and has no value
+fail_compilation/fail117.d(38): Error: expression `foo.mixin MGettor!(b) getb;
+` is `void` and has no value
 ---
 */
 
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail22006.d b/gcc/testsuite/gdc.test/fail_compilation/fail22006.d
new file mode 100644
index 00000000000..89bbc289414
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail22006.d
@@ -0,0 +1,22 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail22006.d(15): Error: cannot implicitly convert expression `4$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `bool`
+fail_compilation/fail22006.d(16): Error: index type `bool` cannot cover index range 0..4
+fail_compilation/fail22006.d(19): Error: cannot implicitly convert expression `4$?:32=u|64=LU$` of type `$?:32=uint|64=ulong$` to `bool`
+fail_compilation/fail22006.d(20): Error: index type `bool` cannot cover index range 0..4
+---
+*/
+void test22006()
+{
+    alias AliasSeq(TList...) = TList;
+    {
+        alias aseq = AliasSeq!(0, 1, 2, 3);
+        static foreach (bool i; 0 .. aseq.length) {}
+        static foreach (bool i, x; aseq) {}
+    }
+    {
+        static foreach (bool i; 0 .. [0, 1, 2, 3].length) {}
+        static foreach (bool i, x; [0, 1, 2, 3]) {}
+    }
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail22133.d b/gcc/testsuite/gdc.test/fail_compilation/fail22133.d
new file mode 100644
index 00000000000..338d96dc7e1
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail22133.d
@@ -0,0 +1,24 @@
+// https://issues.dlang.org/show_bug.cgi?id=22133
+/*
+TEST_OUTPUT
+---
+fail_compilation/fail22133.d(16): Error: `s.popFront()()` has no effect
+fail_compilation/fail22133.d(17): Error: template `s.popFront()()` has no type
+---
+*/
+struct Slice
+{
+    void popFront()() {}
+}
+
+auto fail22133(const Slice s)
+{
+    s.popFront;
+    return s.popFront;
+}
+
+auto ok22133(Slice s)
+{
+    s.popFront;
+    return s.popFront;
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail22144.d b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
new file mode 100644
index 00000000000..e0fd5b19225
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
@@ -0,0 +1,14 @@
+// https://issues.dlang.org/show_bug.cgi?id=22144
+/* TEST_OUTPUT
+---
+fail_compilation/fail22144.d(12): Error: cannot cast expression `zarray1` of type `int[0]` to `int[0][]` since sizes don't line up
+---
+*/
+void main()
+{
+  int[0] zarray1;
+  int[0][0] zarray2;
+
+  auto zslice1 = cast(int[0][])zarray1; // ICE -> Error
+  auto zslice2 = cast(int[0][])zarray2; // ICE -> OK
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail238_m32.d b/gcc/testsuite/gdc.test/fail_compilation/fail238_m32.d
index cb565ba2d39..a312dc07290 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail238_m32.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail238_m32.d
@@ -3,10 +3,10 @@
 TEST_OUTPUT:
 ---
 fail_compilation/fail238_m32.d(21): Error: cannot implicitly convert expression `"a"` of type `string` to `uint`
-fail_compilation/fail238_m32.d(24): Error: cannot interpret X!() at compile time
-fail_compilation/fail238_m32.d(29): Error: template instance fail238_m32.A!"a" error instantiating
-fail_compilation/fail238_m32.d(35):        instantiated from here: M!(q)
-fail_compilation/fail238_m32.d(35):        while evaluating pragma(msg, M!(q))
+fail_compilation/fail238_m32.d(24): Error: cannot implicitly convert expression `X!()` of type `void` to `const(string)`
+fail_compilation/fail238_m32.d(29): Error: template instance `fail238_m32.A!"a"` error instantiating
+fail_compilation/fail238_m32.d(35):        instantiated from here: `M!(q)`
+fail_compilation/fail238_m32.d(35):        while evaluating `pragma(msg, M!(q))`
 ---
 */
 
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail238_m64.d b/gcc/testsuite/gdc.test/fail_compilation/fail238_m64.d
index 08837b2a554..dc7a50ea546 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail238_m64.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail238_m64.d
@@ -3,10 +3,10 @@
 TEST_OUTPUT:
 ---
 fail_compilation/fail238_m64.d(21): Error: cannot implicitly convert expression `"a"` of type `string` to `ulong`
-fail_compilation/fail238_m64.d(24): Error: cannot interpret X!() at compile time
-fail_compilation/fail238_m64.d(29): Error: template instance fail238_m64.A!"a" error instantiating
-fail_compilation/fail238_m64.d(35):        instantiated from here: M!(q)
-fail_compilation/fail238_m64.d(35):        while evaluating pragma(msg, M!(q))
+fail_compilation/fail238_m64.d(24): Error: cannot implicitly convert expression `X!()` of type `void` to `const(string)`
+fail_compilation/fail238_m64.d(29): Error: template instance `fail238_m64.A!"a"` error instantiating
+fail_compilation/fail238_m64.d(35):        instantiated from here: `M!(q)`
+fail_compilation/fail238_m64.d(35):        while evaluating `pragma(msg, M!(q))`
 ---
 */
 
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d
index d358b60c7db..c3fc3116939 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424b.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424b
 {
     @property int g()() { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d
index c0671786ce5..220c995eedd 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424c.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424c
 {
     @property int g()() { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d
index a981be6a39c..669c9ff6314 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424d.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424d
 {
     @property int g()() immutable { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d
index 4dfda623e3b..18bf414ed3a 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424e.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424e
 {
     @property int g()() immutable { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d
index e72a05b5649..29e0ecc9771 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424f.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424f
 {
     @property int g()() shared { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d
index 059f586a480..b4670de3624 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424g.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424g
 {
     @property int g()() { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d
index fd22b2efde0..b76f5b352e1 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424h.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424g
 {
     @property int g()() { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d
index 2871e932140..887c85970b8 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d
@@ -1,3 +1,9 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail7424i.d(10): Error: template `this.g()()` has no value
+---
+*/
 struct S7424g
 {
     @property int g()() immutable { return 0; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail9766.d b/gcc/testsuite/gdc.test/fail_compilation/fail9766.d
index d75d1bc44e7..58cabe3825b 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail9766.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail9766.d
@@ -1,7 +1,8 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail9766.d(14): Error: cannot interpret Foo!int at compile time
+fail_compilation/fail9766.d(14): Error: integer constant expression expected instead of `Foo!int`
+fail_compilation/fail9766.d(14): Error: alignment must be an integer positive power of 2, not Foo!int
 fail_compilation/fail9766.d(17): Error: alignment must be an integer positive power of 2, not -1
 fail_compilation/fail9766.d(20): Error: alignment must be an integer positive power of 2, not 0
 fail_compilation/fail9766.d(23): Error: alignment must be an integer positive power of 2, not 3
@@ -9,6 +10,7 @@ fail_compilation/fail9766.d(26): Error: alignment must be an integer positive po
 ---
 */
 
+#line 12
 template Foo(T) {}
 
 align(Foo!int)
diff --git a/gcc/testsuite/gdc.test/fail_compilation/ice9406.d b/gcc/testsuite/gdc.test/fail_compilation/ice9406.d
index d8c0837699a..c1807a0f542 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/ice9406.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/ice9406.d
@@ -1,7 +1,8 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/ice9406.d(21): Error: expression has no value
+fail_compilation/ice9406.d(22): Error: `s1.mixin Mixin!() t1;
+` has no effect
 ---
 */
 
diff --git a/gcc/testsuite/gdc.test/fail_compilation/test21927.d b/gcc/testsuite/gdc.test/fail_compilation/test21927.d
new file mode 100644
index 00000000000..fa23285e8b0
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/test21927.d
@@ -0,0 +1,20 @@
+// https://issues.dlang.org/show_bug.cgi?id=21927
+/*
+TEST_OUTPUT:
+---
+fail_compilation/test21927.d(17): Error: invalid `foreach` aggregate `this.T2(Args2...)`
+fail_compilation/test21927.d(18): Error: invalid `foreach` aggregate `this.T2!()`
+---
+*/
+
+struct S
+{
+    template T2(Args2...) {}
+
+    void fun()
+    {
+        // original test case
+        static foreach (p; this.T2) {} // ICE
+        static foreach (p; this.T2!()) {} // ICE
+    }
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/test21939.d b/gcc/testsuite/gdc.test/fail_compilation/test21939.d
new file mode 100644
index 00000000000..cb755ef2679
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/test21939.d
@@ -0,0 +1,9 @@
+// https://issues.dlang.org/show_bug.cgi?id=21939
+/*
+TEST_OUTPUT:
+---
+fail_compilation/test21939.d(9): Error: invalid `foreach` aggregate `Object`, define `opApply()`, range primitives, or use `.tupleof`
+---
+*/
+
+static foreach (a; Object) {}
diff --git a/gcc/testsuite/gfortran.dg/PR82376.f90 b/gcc/testsuite/gfortran.dg/PR82376.f90
new file mode 100644
index 00000000000..07143ab7e82
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR82376.f90
@@ -0,0 +1,59 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original -fcheck=pointer" }
+!
+! Test the fix for PR82376. The pointer check was doubling up the call
+! to new. The fix reduces the count of 'new' from 5 to 4.
+!
+! Contributed by Jos√© Rui Faustino de Sousa  <jrfsousa@gmail.com>
+!
+program main_p
+
+  integer, parameter :: n = 10
+
+  type :: foo_t
+    integer, pointer :: v =>null()
+  end type foo_t
+
+  integer, save :: pcnt = 0
+
+  type(foo_t) :: int
+  integer     :: i
+
+  do i = 1, n
+    call init(int, i)
+    if(.not.associated(int%v)) stop 1
+    if(int%v/=i) stop 2
+    if(pcnt/=i) stop 3
+  end do
+
+contains
+
+  function new(data) result(this)
+    integer, target, intent(in) :: data
+
+    integer, pointer :: this
+
+    nullify(this)
+    this => data
+    pcnt = pcnt + 1
+    return
+  end function new
+
+  subroutine init(this, data)
+    type(foo_t), intent(out) :: this
+    integer,     intent(in)  :: data
+
+    call set(this, new(data))
+    return
+  end subroutine init
+
+  subroutine set(this, that)
+    type(foo_t),     intent(inout) :: this
+    integer, target, intent(in)    :: that
+
+    this%v => that
+    return
+  end subroutine set
+
+end program main_p
+! { dg-final { scan-tree-dump-times "new" 4 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90 b/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90
new file mode 100644
index 00000000000..0fc54d5331c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+!
+! Test the fix for PR99125, where the array reference in the print
+! statement caused an ICE because the gimplifier complained about '0'
+! being used as an lvalue.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      character(:), allocatable :: a(:)
+   end type
+   type(t) :: x
+   character(8) :: c(3) = ['12 45 78','23 56 89','34 67 90']
+   x%a = c
+   if (any (x%a(2:3) .ne. ['23 56 89','34 67 90'])) stop 1
+   if (any (x%a(2:3)(4:5) .ne. ['56','67'])) stop 2 ! Bizarrely this worked.
+end
diff --git a/gcc/testsuite/gfortran.dg/argument_checking_25.f90 b/gcc/testsuite/gfortran.dg/argument_checking_25.f90
new file mode 100644
index 00000000000..e699160fee1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/argument_checking_25.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/100274 - ICE in gfc_conv_procedure_call, at fortran/trans-expr.c:6131
+
+program p
+  call s('y')   ! { dg-warning "Character length of actual argument" }
+contains
+  subroutine s(x)
+    character(8), intent(out) :: x
+  end
+end
+
+! { dg-error "in variable definition context"  " " { target *-*-* } 5 }
diff --git a/gcc/testsuite/gfortran.dg/array_constructor_54.f90 b/gcc/testsuite/gfortran.dg/array_constructor_54.f90
new file mode 100644
index 00000000000..44d2f9fdf42
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/array_constructor_54.f90
@@ -0,0 +1,23 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original -Warray-temporaries" }
+! { dg-final { scan-tree-dump-not "stride" "original" } }
+! Verify that no temporary array is generated for a constant array constructor
+! See e.g. PR fortran/102717, PR fortran/102787
+
+program p
+  integer, parameter :: a(*)   = [1,2,3,4]
+  integer, parameter :: b(2,3) = reshape([1,2,3,4,5,6], shape (b))
+  print *, [a]
+  print *, [a( : ) ]
+  print *, [a( ::1)]
+  print *, [a( ::2)]
+  print *, [a(1:2:1)]
+  print *, [a(4:1:-2)]
+  print *, [a([3,2])]
+  print *, [a,1]
+  print *, [1,a]
+  print *, [a,a]
+  print *, [b(:,3:1:-2)]
+  print *, [1,b(1,[2,1,3])]
+  print *, [a,b]
+end
diff --git a/gcc/testsuite/gfortran.dg/associate_54.f90 b/gcc/testsuite/gfortran.dg/associate_54.f90
new file mode 100644
index 00000000000..003175a47fd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_54.f90
@@ -0,0 +1,34 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+  subroutine test_alter_state1 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    associate (state => obj%state(TEST_STATES)) ! { dg-error "is used as array" }
+!      state = a
+      state(TEST_STATE) = a
+    end associate
+  end subroutine test_alter_state1
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associate_55.f90 b/gcc/testsuite/gfortran.dg/associate_55.f90
new file mode 100644
index 00000000000..2b9e8c727f9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_55.f90
@@ -0,0 +1,35 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+
+  subroutine test_alter_state2 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    associate (state => obj%state(TEST_STATES)) ! { dg-error "no IMPLICIT type" }
+      state = a                                 ! { dg-error "vector-indexed target" }
+!      state(TEST_STATE) = a
+    end associate
+  end subroutine test_alter_state2
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associate_56.f90 b/gcc/testsuite/gfortran.dg/associate_56.f90
new file mode 100644
index 00000000000..429f129da6e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_56.f90
@@ -0,0 +1,36 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+
+  subroutine test_alter_state2 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    integer, dimension(2) :: TEST_STATES = [1,2]
+    associate (state => obj%state(TEST_STATES))
+      state = a                                 ! { dg-error "vector-indexed target" }
+      state(TEST_STATE) = a                     ! { dg-error "vector-indexed target" }
+    end associate
+  end subroutine test_alter_state2
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associated_target_7.f90 b/gcc/testsuite/gfortran.dg/associated_target_7.f90
new file mode 100644
index 00000000000..97f93b3c742
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associated_target_7.f90
@@ -0,0 +1,87 @@
+! { dg-do run }
+!
+! associated_target_7.f90: Test the fix for PR98565.
+!
+! Contributed by Yves Secretan  <yves.secretan@ete.inrs.ca>
+!
+MODULE PS_SN0N_M
+
+   IMPLICIT NONE
+   PRIVATE
+
+   TYPE, PUBLIC :: DT_GRID_T
+       INTEGER :: NNT
+   CONTAINS
+       ! PASS
+   END TYPE DT_GRID_T
+
+   TYPE, PUBLIC :: LM_ELEM_T
+       CLASS(DT_GRID_T), POINTER :: PGRID
+   CONTAINS
+       PROCEDURE, PUBLIC :: REQPGRID => LM_ELEM_REGPGRID
+   END TYPE LM_ELEM_T
+
+   TYPE, PUBLIC :: PS_SN0N_T
+      CLASS(DT_GRID_T), POINTER :: PGRID
+
+   CONTAINS
+      PROCEDURE, PUBLIC :: ASGOELE  => PS_SN0N_ASGOELE
+   END TYPE PS_SN0N_T
+
+
+CONTAINS
+   !------------------------------------------------------------------------
+   !------------------------------------------------------------------------
+   FUNCTION LM_ELEM_REGPGRID(SELF) RESULT(PGRID)
+   CLASS(DT_GRID_T), POINTER :: PGRID
+   CLASS(LM_ELEM_T), INTENT(IN) :: SELF
+   PGRID => SELF%PGRID
+   RETURN
+   END FUNCTION LM_ELEM_REGPGRID
+
+   !------------------------------------------------------------------------
+   !------------------------------------------------------------------------
+   FUNCTION PS_SN0N_ASGOELE(SELF, OELE) RESULT(ERMSG)
+
+   INTEGER :: ERMSG
+   CLASS(PS_SN0N_T), INTENT(IN) :: SELF
+   CLASS(LM_ELEM_T), INTENT(IN) :: OELE
+
+   !CLASS(DT_GRID_T), POINTER :: PGRID
+   LOGICAL :: ISOK
+   !------------------------------------------------------------------------
+
+   ! ASSOCIATED with temp variable compiles
+   !PGRID => OELE%REQPGRID()
+   !ISOK = ASSOCIATED(SELF%PGRID, PGRID)
+
+   ! ASSOCIATE without temp variable crashes with ICE
+   ISOK = ASSOCIATED(SELF%PGRID, OELE%REQPGRID())
+   ERMSG = 0
+   IF (ISOK) ERMSG = 1
+
+   RETURN
+   END FUNCTION PS_SN0N_ASGOELE
+
+END MODULE PS_SN0N_M
+
+
+   USE PS_SN0N_M
+   CLASS(PS_SN0N_T), ALLOCATABLE :: SELF
+   CLASS(LM_ELEM_T), ALLOCATABLE :: OELE
+   TYPE (DT_GRID_T), TARGET :: GRID1 = DT_GRID_T (42)
+   TYPE (DT_GRID_T), TARGET :: GRID2 = DT_GRID_T (84)
+
+   ALLOCATE (PS_SN0N_T :: SELF)
+   ALLOCATE (LM_ELEM_T :: OELE)
+   SELF%PGRID => GRID1
+
+   OELE%PGRID => NULL ()
+   IF (SELF%ASGOELE (OELE) .NE. 0) STOP 1
+
+   OELE%PGRID => GRID2
+   IF (SELF%ASGOELE (OELE) .NE. 0) STOP 2
+
+   OELE%PGRID => GRID1
+   IF (SELF%ASGOELE (OELE) .NE. 1) STOP 3
+END
diff --git a/gcc/testsuite/gfortran.dg/bound_simplification_7.f90 b/gcc/testsuite/gfortran.dg/bound_simplification_7.f90
new file mode 100644
index 00000000000..3efecdff769
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bound_simplification_7.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR fortran/103392 - ICE in simplify_bound
+
+program p
+  integer, allocatable :: a(1:1) ! { dg-error "deferred shape or assumed rank" }
+  integer :: b(1) = lbound(a)    ! { dg-error "does not reduce" }
+  integer :: c(1) = ubound(a)    ! { dg-error "does not reduce" }
+end
+
+subroutine s(x, y)
+  type t
+     integer :: i(3)
+  end type t
+  type(t), pointer     :: x(:)
+  type(t), allocatable :: y(:)
+  integer, parameter   :: m(1) = ubound (x(1)% i)
+  integer              :: n(1) = ubound (y(1)% i)
+end subroutine s
diff --git a/gcc/testsuite/gfortran.dg/bounds_check_23.f90 b/gcc/testsuite/gfortran.dg/bounds_check_23.f90
new file mode 100644
index 00000000000..8de90c77c01
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bounds_check_23.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+! { dg-options "-fcheck=bounds -fdump-tree-original" }
+! PR fortran/98490 - out of bounds in array constructor with implied do loop
+
+program test
+  implicit none
+  call sub('Lorem ipsum')
+contains
+  subroutine sub( text )
+    character(len=*), intent(in)  :: text
+    character(len=1), allocatable :: c(:)
+    integer :: i
+    c = [ ( text(i:i), i = 1, len(text) ) ]
+    if (c(1) /= 'L') stop 1
+  end subroutine sub
+end program test
+
+! { dg-final { scan-tree-dump-times "Substring out of bounds:" 2 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/class_dummy_6.f90 b/gcc/testsuite/gfortran.dg/class_dummy_6.f90
new file mode 100644
index 00000000000..79f6e86daa7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_dummy_6.f90
@@ -0,0 +1,65 @@
+! { dg-do run }
+!
+! Test the fix for PR99819 - explicit shape class arrays in different
+! procedures caused an ICE.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      integer :: i
+   end type
+   class(t), allocatable :: dum1(:), dum2(:), dum3(:,:)
+
+   allocate (t :: dum1(3), dum2(10), dum3(2,5))
+   dum2%i = [1,2,3,4,5,6,7,8,9,10]
+   dum3%i = reshape ([1,2,3,4,5,6,7,8,9,10],[2,5])
+
+! Somewhat elaborated versions of the PR procedures.
+   if (f (dum1, dum2, dum3) .ne. 10) stop 1
+   if (g (dum1) .ne. 3) stop 2
+
+! Test the original versions of the procedures.
+   if (f_original (dum1, dum2) .ne. 3) stop 3
+   if (g_original (dum2) .ne. 10) stop 4
+
+contains
+   integer function f(x, y, z)
+      class(t) :: x(:)
+      class(t) :: y(size( x))
+      class(t) :: z(2,*)
+      if (size (y) .ne. 3) stop 5
+      if (size (z) .ne. 0) stop 6
+      select type (y)
+        type is (t)
+          f = 1
+          if (any (y%i .ne. [1,2,3])) stop 7
+        class default
+          f = 0
+      end select
+      select type (z)
+        type is (t)
+          f = f*10
+          if (any (z(1,1:4)%i .ne. [1,3,5,7])) stop 8
+        class default
+          f = 0
+      end select
+   end
+   integer function g(z)
+      class(t) :: z(:)
+      type(t) :: u(size(z))
+      g = size (u)
+   end
+
+   integer function f_original(x, y)
+      class(t) :: x(:)
+      class(*) :: y(size (x))
+      f_original = size (y)
+   end
+
+   integer function g_original(z)
+      class(*) :: z(:)
+      type(t) :: u(size(z))
+      g_original = size (u)
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/class_dummy_7.f90 b/gcc/testsuite/gfortran.dg/class_dummy_7.f90
new file mode 100644
index 00000000000..913426804f3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_dummy_7.f90
@@ -0,0 +1,60 @@
+! { dg-do run }
+!
+! Test the fix for PR46691 - enable class assumed size arrays
+!
+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>
+! from http://j3-fortran.org/pipermail/j3/2010-December/004084.html
+! submitted by Robert Corbett.
+!
+       MODULE TYPES
+         PRIVATE
+         PUBLIC REC, REC2
+
+         TYPE REC
+           INTEGER A
+         END TYPE
+
+         TYPE, EXTENDS(REC) :: REC2
+           INTEGER B
+         END TYPE
+       END
+
+       SUBROUTINE SUB1(A, N)
+         USE TYPES
+         CLASS(REC), INTENT(IN) :: A(*)
+         INTERFACE
+           SUBROUTINE SUB2(A, N, IARRAY)
+             USE TYPES
+             TYPE(REC) A(*)
+             INTEGER :: N, IARRAY(N)
+           END
+         END INTERFACE
+
+         CALL SUB2(A, N,[1,2,2,3,3,4,4,5,5,6])
+         select type (B => A(1:N))
+             type is (REC2)
+                 call SUB2(B%REC,N,[1,2,3,4,5,6,7,8,9,10])
+         end select
+
+       END
+
+       SUBROUTINE SUB2(A, N, IARRAY)
+         USE TYPES
+         TYPE(REC) A(*)
+         INTEGER :: N, IARRAY(N)
+         if (any (A(:N)%A .ne. IARRAY(:N))) stop 1
+       END
+
+       PROGRAM MAIN
+         USE TYPES
+         CLASS(REC), ALLOCATABLE :: A(:)
+         INTERFACE
+           SUBROUTINE SUB1(A, N)
+             USE TYPES
+             CLASS(REC), INTENT(IN) :: A(*)
+           END SUBROUTINE
+         END INTERFACE
+
+         A = [ (REC2(I, I+1), I = 1, 10) ]
+         CALL SUB1(A, 10)
+       END
diff --git a/gcc/testsuite/gfortran.dg/coarray/dummy_2.f90 b/gcc/testsuite/gfortran.dg/coarray/dummy_2.f90
new file mode 100644
index 00000000000..35263745bb8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray/dummy_2.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+!
+! PR fortran/99817
+!
+! Contributed by G. Steinmetz
+!
+subroutine s1 (x)
+   character(*) :: x(*)[*]
+end
+
+subroutine s2 (x)
+   character(*), dimension(*), codimension[*] :: x
+   integer :: i
+   i = len(x)
+end
+
+subroutine s3 (x, y)
+   character(*), dimension(:) :: x[*]
+   character(*) :: y
+end
+
+subroutine s4 (x, y, z)
+   character(*), dimension(:) :: x[2, *]
+   character(*), dimension(*) :: y
+   character(*) :: z
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray_48.f90 b/gcc/testsuite/gfortran.dg/coarray_48.f90
new file mode 100644
index 00000000000..adec014995f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_48.f90
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+!
+! Fix for P99818 in which wrong code caused an ICE.
+!
+! Contributed by Gerhard Steinmetz <gscfq@t-online.de>
+!
+module m
+   type t
+      integer :: a
+   contains
+      procedure :: s
+   end type
+contains
+   subroutine s(x)
+      class(t) :: x[*]
+   end
+end
+program p
+   use m
+   associate (y => t(1))
+      call y%s           ! { dg-error "must be a coarray" }
+   end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/dec_math_5.f90 b/gcc/testsuite/gfortran.dg/dec_math_5.f90
new file mode 100644
index 00000000000..dee2de4e06b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_math_5.f90
@@ -0,0 +1,104 @@
+! { dg-do run }
+! { dg-additional-options "-std=gnu" }
+! { dg-require-effective-target fortran_real_10 }
+! { dg-require-effective-target fortran_real_16 }
+
+program p
+  implicit none
+  integer, parameter :: ep = selected_real_kind (17) ! real(10)
+  real(4)  :: a1, e1 = 1.e-5
+  real(8)  :: b1, e2 = 1.e-14
+  real(ep) :: c1, e3 = 1.e-17
+  real(16) :: d1, e4 = 1.e-30
+
+  a1 = 1; a1 = atand(a1)
+  b1 = 1; b1 = atand(b1)
+  c1 = 1; c1 = atand(c1)
+  d1 = 1; d1 = atand(d1)
+! print '(4(F15.11))', a1, b1, c1, d1
+  if (abs(a1 - 45) > e1) stop 1
+  if (abs(b1 - 45) > e2) stop 2
+  if (abs(c1 - 45) > e3) stop 3
+  if (abs(d1 - 45) > e4) stop 4
+
+  a1 = 0.5; a1 = asind(a1)
+  b1 = 0.5; b1 = asind(b1)
+  c1 = 0.5; c1 = asind(c1)
+  d1 = 0.5; d1 = asind(d1)
+  if (abs(a1 - 30) > e1) stop 5
+  if (abs(b1 - 30) > e2) stop 6
+  if (abs(c1 - 30) > e3) stop 7
+  if (abs(d1 - 30) > e4) stop 8
+
+  a1 = 0.5; a1 = acosd(a1)
+  b1 = 0.5; b1 = acosd(b1)
+  c1 = 0.5; c1 = acosd(c1)
+  d1 = 0.5; d1 = acosd(d1)
+  if (abs(a1 - 60) > e1) stop 9
+  if (abs(b1 - 60) > e2) stop 10
+  if (abs(c1 - 60) > e3) stop 11
+  if (abs(d1 - 60) > e4) stop 12
+
+  a1 = 45; a1 = tand(a1)
+  b1 = 45; b1 = tand(b1)
+  c1 = 45; c1 = tand(c1)
+  d1 = 45; d1 = tand(d1)
+  if (abs(a1 - 1) > e1) stop 13
+  if (abs(b1 - 1) > e2) stop 14
+  if (abs(c1 - 1) > e3) stop 15
+  if (abs(d1 - 1) > e4) stop 16
+
+  a1 = 60; a1 = tand(a1)
+  b1 = 60; b1 = tand(b1)
+  c1 = 60; c1 = tand(c1)
+  d1 = 60; d1 = tand(d1)
+  if (abs(a1 - sqrt (3._4) ) > e1) stop 17
+  if (abs(b1 - sqrt (3._8) ) > e2) stop 18
+  if (abs(c1 - sqrt (3._ep)) > e3) stop 19
+  if (abs(d1 - sqrt (3._16)) > e4) stop 20
+
+  a1 = 45; a1 = cotand(a1)
+  b1 = 45; b1 = cotand(b1)
+  c1 = 45; c1 = cotand(c1)
+  d1 = 45; d1 = cotand(d1)
+  if (abs(a1 - 1) > e1) stop 21
+  if (abs(b1 - 1) > e2) stop 22
+  if (abs(c1 - 1) > e3) stop 23
+  if (abs(d1 - 1) > e4) stop 24
+
+  a1 = 30; a1 = cotand(a1)
+  b1 = 30; b1 = cotand(b1)
+  c1 = 30; c1 = cotand(c1)
+  d1 = 30; d1 = cotand(d1)
+  if (abs(a1 - sqrt (3._4) ) > e1) stop 25
+  if (abs(b1 - sqrt (3._8) ) > e2) stop 26
+  if (abs(c1 - sqrt (3._ep)) > e3) stop 27
+  if (abs(d1 - sqrt (3._16)) > e4) stop 28
+
+  a1 = 1; a1 = atan2d(a1, a1)
+  b1 = 1; b1 = atan2d(b1, b1)
+  c1 = 1; c1 = atan2d(c1, c1)
+  d1 = 1; d1 = atan2d(d1, d1)
+  if (abs(a1 - 45) > e1) stop 29
+  if (abs(b1 - 45) > e2) stop 30
+  if (abs(c1 - 45) > e3) stop 31
+  if (abs(d1 - 45) > e4) stop 32
+
+  a1 = 30; a1 = sind(a1)
+  b1 = 30; b1 = sind(b1)
+  c1 = 30; c1 = sind(c1)
+  d1 = 30; d1 = sind(d1)
+  if (abs(a1 - 0.5) > e1) stop 33
+  if (abs(b1 - 0.5) > e2) stop 34
+  if (abs(c1 - 0.5) > e3) stop 35
+  if (abs(d1 - 0.5) > e4) stop 36
+
+  a1 = 60; a1 = cosd(a1)
+  b1 = 60; b1 = cosd(b1)
+  c1 = 60; c1 = cosd(c1)
+  d1 = 60; d1 = cosd(d1)
+  if (abs(a1 - 0.5) > e1) stop 37
+  if (abs(b1 - 0.5) > e2) stop 38
+  if (abs(c1 - 0.5) > e3) stop 39
+  if (abs(d1 - 0.5) > e4) stop 40
+end program p
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_35.f90 b/gcc/testsuite/gfortran.dg/deferred_character_35.f90
new file mode 100644
index 00000000000..c28f52f79ff
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_35.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+!
+! Test the fix for PR93794, where the ASSOCIATE statement ICED on the
+! deferred character length, pointer component.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      character(:), pointer :: a
+   end type
+   type(t) :: z
+   character(4), target :: c = 'abcd'
+   z%a => c
+   associate (y => z%a)
+      print *, y
+   end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/derived_constructor_char_1.f90 b/gcc/testsuite/gfortran.dg/derived_constructor_char_1.f90
index 892a9c9f4c1..91fc4c902d8 100644
--- a/gcc/testsuite/gfortran.dg/derived_constructor_char_1.f90
+++ b/gcc/testsuite/gfortran.dg/derived_constructor_char_1.f90
@@ -5,7 +5,7 @@
 !
 !
   Type :: t5
-    character (len=5) :: txt(4)
+    character (len=5) :: txt(2)
   End Type t5
 
   character (len=3), parameter :: str3(2) = [ "ABC", "ZYX" ]
diff --git a/gcc/testsuite/gfortran.dg/do_check_19.f90 b/gcc/testsuite/gfortran.dg/do_check_19.f90
new file mode 100644
index 00000000000..1373a7374ce
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/do_check_19.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+! { dg-prune-output "Obsolescent feature: Alternate-return argument" }
+! PR fortran/103717 - ICE in doloop_code
+! Contributed by G.Steinmetz
+
+program p
+  integer :: i
+  do i = 1, 2
+     call s(i) ! { dg-error "Missing alternate return specifier" }
+  end do
+contains
+  subroutine s(*)
+  end
+end
+
+recursive subroutine s(*)
+  integer :: i
+  do i = 1, 2
+     call s(i) ! { dg-error "Missing alternate return specifier" }
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/elemental_function_5.f90 b/gcc/testsuite/gfortran.dg/elemental_function_5.f90
new file mode 100644
index 00000000000..315ff9162b3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/elemental_function_5.f90
@@ -0,0 +1,46 @@
+! { dg-do compile }
+!
+! Test the fix for PR98472.
+!
+! Contributed by Rui Coelho  <ruicoelhopedro@hotmail.com>
+!
+module a
+        type, abstract :: base
+        contains
+                procedure(elem_func), deferred, nopass :: add
+        end type base
+
+        type, extends(base) :: derived
+        contains
+                procedure, nopass :: add => add_derived
+        end type derived
+
+        abstract interface
+                elemental function elem_func(x, y) result(out)
+                        integer, intent(in) :: x, y
+                        integer :: out
+                end function elem_func
+        end interface
+
+contains
+        elemental function add_derived(x, y) result(out)
+                integer, intent(in) :: x, y
+                integer :: out
+                out = x + y
+        end function add_derived
+end module a
+
+program main
+        use a
+        call foo
+contains
+        subroutine foo
+               integer, dimension(:), allocatable :: vec
+               class(base), allocatable :: instance
+               allocate(derived :: instance)
+               allocate(vec, source=instance%add([1, 2], [1, 2])) ! ICE here
+               if (any (vec .ne. [2, 4])) stop 1
+        end
+end program main
+
+
diff --git a/gcc/testsuite/gfortran.dg/fmt_nonchar_3.f90 b/gcc/testsuite/gfortran.dg/fmt_nonchar_3.f90
new file mode 100644
index 00000000000..3b3c260ef7f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_nonchar_3.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/101084
+
+program p
+  integer, parameter :: a(0) = 1
+  print int(a) ! { dg-error "Non-character non-Hollerith in FORMAT tag" }
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/map-5.f90 b/gcc/testsuite/gfortran.dg/gomp/map-5.f90
new file mode 100644
index 00000000000..5e9d5b214b2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/map-5.f90
@@ -0,0 +1,12 @@
+implicit none
+type t
+  integer :: b(5)
+end type t
+integer :: a(5), x, y(5)
+type(t) :: b
+!$omp target enter data map( to: a (:) )
+!$omp target enter data map( to: a(:) )
+!$omp target depend(out: y (2)) nowait
+!$omp end target
+
+end
diff --git a/gcc/testsuite/gfortran.dg/illegal_boz_arg_2.f90 b/gcc/testsuite/gfortran.dg/illegal_boz_arg_2.f90
new file mode 100644
index 00000000000..3e5f6b6d1d4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/illegal_boz_arg_2.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/103412
+
+program p
+  integer, parameter :: a = sizeof(z'1') ! { dg-error "cannot be an actual" }
+end
diff --git a/gcc/testsuite/gfortran.dg/illegal_boz_arg_3.f90 b/gcc/testsuite/gfortran.dg/illegal_boz_arg_3.f90
new file mode 100644
index 00000000000..59fefa90971
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/illegal_boz_arg_3.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/103778
+
+program p
+  use iso_c_binding, only : c_sizeof
+  integer, parameter :: a = c_sizeof(z'1') ! { dg-error "cannot appear" }
+end
diff --git a/gcc/testsuite/gfortran.dg/implied_do_io_7.f90 b/gcc/testsuite/gfortran.dg/implied_do_io_7.f90
new file mode 100644
index 00000000000..63927aafea9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implied_do_io_7.f90
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR 100227 - this was falsely optimized, leading to nonsense  results.
+! Original test case by "Mathieu".
+
+program p
+  implicit none
+  integer, parameter :: nbmode = 3
+  integer :: k
+  real    :: mass(nbmode*2)
+  character (len=80) :: line
+  do k = 1, nbmode*2
+     mass(k) = k
+  end do
+  write (unit=line,fmt='(*(F6.2))') (mass(k+k), k=1,nbmode)
+  if (line /= '  2.00  4.00  6.00') stop 1
+end program
diff --git a/gcc/testsuite/gfortran.dg/inline_matmul_25.f90 b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
new file mode 100644
index 00000000000..df8ad06c123
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-ffrontend-optimize" }
+! PR fortran/99839 - ICE in inline_matmul_assign
+
+program p
+  real :: x(3, 3) = 1.0
+  class(*), allocatable :: z(:, :)
+  z = matmul(x, x)
+end
diff --git a/gcc/testsuite/gfortran.dg/intent_out_14.f90 b/gcc/testsuite/gfortran.dg/intent_out_14.f90
new file mode 100644
index 00000000000..e5994635008
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_out_14.f90
@@ -0,0 +1,24 @@
+! { dg-do run }
+! PR fortran/102287 - optional allocatable DT array arguments (intent out)
+
+module m
+  type t
+     integer, allocatable :: a
+  end type t
+contains
+  subroutine a (x, v)
+    type(t), optional, allocatable, intent(out) :: x(:)
+    type(t), optional,              intent(out) :: v(:)
+    call b (x, v)
+  end subroutine a
+
+  subroutine b (y, w)
+    type(t), optional, allocatable, intent(out) :: y(:)
+    type(t), optional,              intent(out) :: w(:)
+  end subroutine b
+end module m
+
+program p
+  use m
+  call a ()
+end
diff --git a/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90 b/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90
new file mode 100644
index 00000000000..917944d8846
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90
@@ -0,0 +1,57 @@
+! { dg-do run }
+! PR libfortran/103634 - Runtime crash with PACK on zero-sized arrays
+! Exercise PACK intrinsic for cases when it calls pack_internal
+
+program p
+  implicit none
+  type t
+     real :: r(24) = -99.
+  end type
+  type(t), allocatable :: new(:), old(:), vec(:)
+  logical, allocatable :: mask(:)
+  integer              :: n, m
+! m = 1    ! works
+  m = 0    ! failed with SIGSEGV in pack_internal
+  do m = 0, 2
+     print *, m
+     allocate (old(m), mask(m), vec(m))
+     if (m > 0) vec(m)% r(1) = 42
+     mask(:) = .true.
+     n = count (mask)
+     allocate (new(n))
+
+     mask(:) = .false.
+     if (size (pack (old, mask)) /= 0) stop 1
+     mask(:) = .true.
+     if (size (pack (old, mask)) /= m) stop 2
+     new(:) = pack (old, mask)              ! this used to segfault for m=0
+
+     mask(:) = .false.
+     if (size (pack (old, mask, vector=vec)) /= m) stop 3
+     new(:) = t()
+     new(:) = pack (old, mask, vector=vec)  ! this used to segfault for m=0
+     if (m > 0) then
+        if (     new( m  )% r(1) /=  42)  stop 4
+        if (any (new(:m-1)% r(1) /= -99)) stop 5
+     end if
+
+     if (m > 0) mask(m) = .true.
+     if (size (pack (old, mask, vector=vec)) /= m) stop 6
+     new(:) = t()
+     new(:) = pack (old, mask, vector=vec)  ! this used to segfault for m=0
+     if (m > 0) then
+        if (new(1)% r(1) /= -99) stop 7
+     end if
+     if (m > 1) then
+        if (new(m)% r(1) /=  42) stop 8
+     end if
+
+     if (size (pack (old(:0), mask(:0), vector=vec)) /= m) stop 9
+     new(:) = t()
+     new(:) = pack (old(:0), mask(:0), vector=vec) ! did segfault for m=0
+     if (m > 0) then
+        if (new(m)% r(1) /= 42) stop 10
+     end if
+     deallocate (old, mask, new, vec)
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/move_alloc_8.f90 b/gcc/testsuite/gfortran.dg/move_alloc_8.f90
index f624b703cc9..d968ea0e5cd 100644
--- a/gcc/testsuite/gfortran.dg/move_alloc_8.f90
+++ b/gcc/testsuite/gfortran.dg/move_alloc_8.f90
@@ -60,7 +60,7 @@ subroutine test2 (x, px)
   integer, allocatable :: a
   type(t2), pointer :: ta
 
-  call move_alloc (px, ta)      ! { dg-error "cannot be INTENT.IN." }
+  call move_alloc (px, ta)      ! { dg-error "must be ALLOCATABLE" }
   call move_alloc (x%a, a)      ! { dg-error "cannot be INTENT.IN." }
   call move_alloc (x%ptr%a, a)  ! OK (3)
   call move_alloc (px%a, a)     ! OK (4)
@@ -84,7 +84,7 @@ subroutine test3 (x, px)
   integer, allocatable :: a
   class(t2), pointer :: ta
 
-  call move_alloc (px, ta)      ! { dg-error "cannot be INTENT.IN." }
+  call move_alloc (px, ta)      ! { dg-error "must be ALLOCATABLE" }
   call move_alloc (x%a, a)      ! { dg-error "cannot be INTENT.IN." }
   call move_alloc (x%ptr%a, a)  ! OK (6)
   call move_alloc (px%a, a)     ! OK (7)
diff --git a/gcc/testsuite/gfortran.dg/parameter_array_init_8.f90 b/gcc/testsuite/gfortran.dg/parameter_array_init_8.f90
new file mode 100644
index 00000000000..2e5f7694d3a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/parameter_array_init_8.f90
@@ -0,0 +1,25 @@
+! { dg-do run }
+! PR fortran/99348
+! PR fortran/102521
+! Check simplifications for initialization of DT parameter arrays
+
+program p
+  type t
+     integer :: n
+  end type
+  type(t), parameter :: a(4)   = t(1)
+  type(t), parameter :: d(*)   = a
+  type(t), parameter :: b(2,2) = reshape(d, [2,2])
+  integer, parameter :: nn     = b(2,2)% n
+  type u
+     character(3) :: c
+  end type
+  type(u),      parameter :: x(2,3) = u('ab')
+  type(u),      parameter :: y(*,*) = transpose (x)
+  character(*), parameter :: c      = y(3,2)% c
+  integer,      parameter :: lc     = c% len
+  integer,      parameter :: lyc    = len (y(3,2)% c)
+! integer,      parameter :: lxc    = x(1,1)% c% len    ! fails (pr101735?)
+  if (nn /= 1) stop 1
+  if (lc /= 3 .or. lyc /= 3 .or. c /= "ab ") stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/pdt_26.f03 b/gcc/testsuite/gfortran.dg/pdt_26.f03
index bf1273743d3..59ddcfb6cc4 100644
--- a/gcc/testsuite/gfortran.dg/pdt_26.f03
+++ b/gcc/testsuite/gfortran.dg/pdt_26.f03
@@ -2,7 +2,7 @@
 ! { dg-options "-fdump-tree-original" }
 !
 ! Test the fix for PR83567 in which the parameterized component 'foo' was
-! being deallocated before return from 'addw', with consequent segfault in 
+! being deallocated before return from 'addw', with consequent segfault in
 ! the main program.
 !
 ! Contributed by Berke Durak  <berke.durak@gmail.com>
@@ -43,4 +43,4 @@ program test_pdt
   if (any (c(1)%foo .ne. [13,15,17])) STOP 2
 end program test_pdt
 ! { dg-final { scan-tree-dump-times "__builtin_free" 8 "original" } }
-! { dg-final { scan-tree-dump-times "__builtin_malloc" 9 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_malloc" 8 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pdt_31.f03 b/gcc/testsuite/gfortran.dg/pdt_31.f03
new file mode 100644
index 00000000000..708c9454217
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pdt_31.f03
@@ -0,0 +1,26 @@
+! { dg-do run }
+!
+! Test the fix for PR100110, in which 'obj' was not being initialized.
+!
+! Contributed by Xiao Liu  <xiao.liu@compiler-dev.com>
+!
+program p
+  implicit none
+  type t(n)
+    integer, len :: n
+    integer :: arr(n, n)
+  end type
+
+  type(t(2)) :: obj
+
+  obj%arr = reshape ([1,2,3,4],[2,2])
+  if (obj%n .ne. 2) stop 1
+  if (any (shape(obj%arr) .ne. [2,2])) stop 2
+  call test()
+contains
+  subroutine test()
+    if (obj%n .ne. 2) stop 3
+    if (any (shape(obj%arr) .ne. [2,2])) stop 4
+    if (any (reshape (obj%arr, [4]) .ne. [1,2,3,4])) stop 5
+  end subroutine
+end program
diff --git a/gcc/testsuite/gfortran.dg/pointer_intent_9.f90 b/gcc/testsuite/gfortran.dg/pointer_intent_9.f90
new file mode 100644
index 00000000000..30ddd028359
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pointer_intent_9.f90
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! PR fortran/103418
+! Validate checks for dummy arguments with INTENT(IN), pointer attribute
+
+module m
+  type t
+     real, pointer :: a, b(:)
+  end type t
+contains
+  subroutine s1 (a, b, c, d, e)
+    real,    pointer, intent(in) :: a, b(:)
+    type(t),          intent(in) :: c
+    class(t),         intent(in) :: d
+    type(t), pointer, intent(in) :: e
+    real, pointer :: pa, pb(:)
+    call random_number (a)    ! legal
+    call random_number (b)
+    call cpu_time      (a)
+    call system_clock  (count_rate=a)
+    call random_number (c% a)
+    call random_number (c% b)
+    call random_number (d% a)
+    call random_number (d% b)
+    call random_number (e% a)
+    call random_number (e% b)
+    call move_alloc (a, pa)   ! { dg-error "must be ALLOCATABLE" }
+    call move_alloc (b, pb)   ! { dg-error "must be ALLOCATABLE" }
+    allocate (a)              ! { dg-error "pointer association context" }
+    allocate (b(10))          ! { dg-error "pointer association context" }
+    allocate (c% a)           ! { dg-error "pointer association context" }
+    allocate (c% b(10))       ! { dg-error "pointer association context" }
+  end subroutine s1
+end module
diff --git a/gcc/testsuite/gfortran.dg/pr100154.f90 b/gcc/testsuite/gfortran.dg/pr100154.f90
new file mode 100644
index 00000000000..3a1489aaab8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr100154.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! PR100154 - ICE in gfc_conv_procedure_call, at fortran/trans-expr.c:6131
+
+program p
+  implicit none
+  integer           :: n
+  character, target :: c
+  character(len=0)  :: c0
+  character(len=:), allocatable :: cc
+  n = fget(cc)
+  n = fget('a')       ! { dg-error "must be a variable" }
+  n = fget(c0)        ! { dg-error "must have length at least 1" }
+  call fget('x')      ! { dg-error "must be a variable" }
+  n = fgetc(5,'a')    ! { dg-error "must be a variable" }
+  call fgetc(5,c0)    ! { dg-error "must have length at least 1" }
+  call fgetc(5,c,1)   ! { dg-error "must be a variable" }
+  call fputc(5,'x',1) ! { dg-error "must be a variable" }
+  n = fget (ptr_returning_func())
+  print *, c
+contains
+  function ptr_returning_func () result (res)
+    character, pointer :: res
+    res => c
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr100551.f90 b/gcc/testsuite/gfortran.dg/pr100551.f90
new file mode 100644
index 00000000000..f82f505e734
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr100551.f90
@@ -0,0 +1,30 @@
+! { dg-do run }
+! PR fortran/100551 - Passing return value to class(*) dummy argument
+
+program p
+  implicit none
+  integer :: result
+  result = 1
+  result = test (    (result)) ! works
+  if (result /= 1) stop 1
+  result = test (int (result)) ! issue 1
+! write(*,*) result
+  if (result /= 1) stop 2
+  result = test (f   (result)) ! issue 2
+! write(*,*) result
+  if (result /= 2) stop 3
+contains
+  integer function test(x)
+    class(*), intent(in) :: x
+    select type (x)
+    type is (integer)
+       test = x
+    class default
+       test = -1
+    end select
+  end function test
+  integer function f(x)
+    integer, intent(in) :: x
+    f = 2*x
+  end function f
+end program
diff --git a/gcc/testsuite/gfortran.dg/pr100949.f90 b/gcc/testsuite/gfortran.dg/pr100949.f90
new file mode 100644
index 00000000000..6c736fd7f72
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr100949.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/100949 - ICE in gfc_conv_expr_present, at fortran/trans-expr.c:1975
+
+subroutine s
+entry f
+  type t
+  end type
+  class(t), allocatable :: y, z
+  allocate (z, mold=y)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr101327.f90 b/gcc/testsuite/gfortran.dg/pr101327.f90
new file mode 100644
index 00000000000..f4377aabe7a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101327.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/101327 - ICE in find_array_element, at fortran/expr.c:1355
+
+subroutine s
+  integer, parameter :: n([2]) = [1, 2] ! { dg-error "must be scalar" }
+  type t
+     integer :: a(n(1):n(2))
+  end type
+end
+
+! { dg-error "cannot be automatic or of deferred shape" " " { target *-*-* } 5 }
diff --git a/gcc/testsuite/gfortran.dg/pr101329.f90 b/gcc/testsuite/gfortran.dg/pr101329.f90
new file mode 100644
index 00000000000..b82210d4e28
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101329.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/101329 - ICE: Invalid expression in gfc_element_size
+
+program p
+  use iso_c_binding
+  implicit none
+  integer(c_int),     pointer :: ip4
+  integer(c_int64_t), pointer :: ip8
+  print *, c_sizeof (c_null_ptr) ! valid
+  print *, c_sizeof (null ())    ! { dg-error "is not interoperable" }
+  print *, c_sizeof (null (ip4)) ! { dg-error "is not interoperable" }
+  print *, c_sizeof (null (ip8)) ! { dg-error "is not interoperable" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr101514.f90 b/gcc/testsuite/gfortran.dg/pr101514.f90
new file mode 100644
index 00000000000..51fbf8a7e85
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101514.f90
@@ -0,0 +1,35 @@
+! { dg-do compile }
+! PR fortran/101514 - ICE: out of memory allocating ... bytes
+
+subroutine s
+  type t1
+     integer :: a(..) ! { dg-error "must have an explicit shape" }
+  end type
+  type t2
+     integer :: a(*)  ! { dg-error "must have an explicit shape" }
+  end type
+  type t3
+     integer :: a(:)  ! { dg-error "must have an explicit shape" }
+  end type
+  type t4
+     integer :: a(0:) ! { dg-error "must have an explicit shape" }
+  end type
+  type t5
+     integer, allocatable :: a(:)
+  end type
+  type t6
+     integer, pointer     :: a(:)
+  end type
+  type(t1) :: a1
+  type(t2) :: a2
+  type(t3) :: a3
+  type(t4) :: a4
+  type(t5) :: a5
+  type(t6) :: a6
+  a1 = transfer(1, a1)
+  a2 = transfer(1, a2)
+  a3 = transfer(1, a3)
+  a4 = transfer(1, a4)
+  a5 = transfer(1, a5)
+  a6 = transfer(1, a6)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr101536.f90 b/gcc/testsuite/gfortran.dg/pr101536.f90
new file mode 100644
index 00000000000..b16af00d919
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101536.f90
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! PR fortran/101536 - ICE in gfc_conv_expr_descriptor
+
+program p
+  type s
+     class(*), allocatable :: c
+  end type
+  type t
+     class(*), allocatable :: c(:)
+  end type t
+  type u
+     integer :: c(2)
+  end type
+  type(t) :: x
+  x%c = [1,2,3,4]
+!  print *, size (x)
+  print *, size (x%c)
+  print *, size (x%c(1)) ! { dg-error "must be an array" }
+contains
+  integer function f(x, y, z)
+    class(t), allocatable :: x(:)
+    class(u)              :: y(:)
+    class(s)              :: z
+    f = size (x)
+    f = size (x(1))      ! { dg-error "must be an array" }
+    f = size (y)
+    f = size (y%c(1))
+    f = size (y(2)%c)
+    f = size (y(2)%c(1)) ! { dg-error "must be an array" }
+    f = size (z)         ! { dg-error "must be an array" }
+    f = size (z% c)      ! { dg-error "must be an array" }
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102366.f90 b/gcc/testsuite/gfortran.dg/pr102366.f90
new file mode 100644
index 00000000000..d002f64a8ae
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102366.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original -Wall" }
+! { dg-final { scan-tree-dump-times "static real" 1 "original" } }
+! PR fortran/102366 - large arrays no longer become static
+
+program p
+  real(kind=4) :: a(16776325)
+  a=1.0
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102458.f90 b/gcc/testsuite/gfortran.dg/pr102458.f90
new file mode 100644
index 00000000000..555e4978fdb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102458.f90
@@ -0,0 +1,42 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+! PR fortran/102458 - standard intrinsics excluded in constant expressions
+
+subroutine s1
+  integer :: a(command_argument_count()) = 1 ! { dg-error "Automatic array" }
+  print *, a
+end
+
+program p
+  block
+    integer :: a(get_team()) = 1 ! { dg-error "Automatic array" }
+    print *, a
+  end block
+end
+
+subroutine s2
+  integer :: a(num_images()) = 1 ! { dg-error "Automatic array" }
+  print *, a
+end
+
+function f()
+  block
+    integer :: a(team_number()) = 0 ! { dg-error "Automatic array" }
+    a = 1
+  end block
+end
+
+subroutine s3
+  integer :: a(this_image()) = 1 ! { dg-error "Automatic array" }
+  print *, a
+end
+
+subroutine s4
+  integer, parameter :: n = 4
+  integer, parameter :: x(transfer(n, n)) = 1 ! legal
+  integer            :: y(transfer(n, n)) = 2 ! legal
+  integer, parameter :: k = size (x)          ! ok
+! integer, parameter :: m = size (y)          ! fails, tracked separately
+  print *, k, x, y
+  if (k /= size (y)) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102458b.f90 b/gcc/testsuite/gfortran.dg/pr102458b.f90
new file mode 100644
index 00000000000..3e1026e635a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102458b.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! { dg-final { scan-tree-dump-times "_gfortran_stop_numeric" 0 "original" } }
+! PR fortran/102458
+
+subroutine s4
+  integer, parameter :: n = 4
+  integer            :: w(transfer(n, n)) = 1
+  integer            :: x(transfer(n, n))
+  integer            :: y(2*int(n) - n)
+  type t
+     integer         :: z(int(n))
+  end type t
+  type(t)            :: tt, uu(3)
+  integer, parameter :: i = size (w)
+  integer, parameter :: k = size (x)
+  integer, parameter :: m = size (y)
+  integer, parameter :: j = size (tt% z)
+  integer, parameter :: l = size (uu(2)% z)
+  if (i /= n .or. k /= n .or. m /= n .or. j /= n .or. l /= n) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102520.f90 b/gcc/testsuite/gfortran.dg/pr102520.f90
new file mode 100644
index 00000000000..1c98c185c17
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102520.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/102520 - ICE in expand_constructor, at fortran/array.c:1802
+
+program p
+  type t
+  end type
+  type(t), parameter :: a(4)   = shape(1)         ! { dg-error "Incompatible" }
+  type(t), parameter :: b(2,2) = reshape(a,[2,2]) ! { dg-error "Incompatible" }
+  type(t), parameter :: c(2,2) = transpose(b)     ! { dg-error "Unclassifiable" }
+end
+
+! { dg-error "Different shape for array assignment" " " { target *-*-* } 7 }
diff --git a/gcc/testsuite/gfortran.dg/pr102685.f90 b/gcc/testsuite/gfortran.dg/pr102685.f90
new file mode 100644
index 00000000000..d325c27b32a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102685.f90
@@ -0,0 +1,30 @@
+! { dg-do compile }
+! PR fortran/102685
+
+program p
+  type t
+     integer :: a(2)
+  end type
+  type(t), parameter :: x0    = t([2])         ! { dg-error "shape of component" }
+  type(t), parameter :: x1(2) = t([2])         ! { dg-error "shape of component" }
+  type(t), parameter :: x(2)  = t([integer::]) ! { dg-error "shape of component" }
+
+  type u
+     integer :: a
+     integer :: b(0)
+  end type
+  type(u), parameter :: z0(2) = u(1, [integer::]) ! valid
+  type(u), parameter :: z1    = u(1,  2 )         ! valid
+  type(u), parameter :: z2(2) = u(1,  2 )         ! valid
+  type(u), parameter :: z3    = u(1, [2])         ! { dg-error "shape of component" }
+  type(u), parameter :: z4(2) = u(1, [2])         ! { dg-error "shape of component" }
+
+  type v
+     integer :: a(2,1)
+  end type
+  type(v), parameter :: y0   = v(reshape([1,2],[2,1])) ! valid
+  type(v), parameter :: y1   = v(reshape([1,2],[1,2])) ! { dg-error "shape of component" }
+  type(v), parameter :: y(1) = v(reshape([1,2],[1,2])) ! { dg-error "shape of component" }
+
+  print *, x0,x,x1,y0,y1,y,z0,z1,z2,z3,z4
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102715.f90 b/gcc/testsuite/gfortran.dg/pr102715.f90
new file mode 100644
index 00000000000..7b29a1c05a6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102715.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/102715 - ICE in gfc_simplify_transpose
+
+program p
+  type t
+  end type
+  type(t), parameter :: a(4)   = t()
+  type(t), parameter :: b(2,2) = reshape(a, [2]) ! { dg-error "Rank mismatch" }
+  type(t), parameter :: c(2,2) = transpose(b)    ! { dg-error "must be of rank 2" }
+  type(t), parameter :: s2(*)  = b(2,:)          ! { dg-error "Syntax error" }
+  type(t), parameter :: x(*,*) = reshape(a, [2]) ! { dg-error "Rank mismatch" }
+  type(t), parameter :: s3(*)  = x(2,:)          ! { dg-error "Syntax error" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102816.f90 b/gcc/testsuite/gfortran.dg/pr102816.f90
new file mode 100644
index 00000000000..46831743b2b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102816.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/102816
+
+program p
+  type t
+     integer :: a([2])     ! { dg-error "must be scalar" }
+  end type
+  type(t) :: x = t([3, 4]) ! { dg-error "Bad array spec of component" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102817.f90 b/gcc/testsuite/gfortran.dg/pr102817.f90
new file mode 100644
index 00000000000..c081a69f0ea
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102817.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! PR fortran/102817 - ICE in gfc_clear_shape
+
+program test
+  type t
+     integer :: a(1,2) = 3
+  end type t
+  type(t), parameter :: u    = t(4)
+  type(t), parameter :: x(1) = t(4)
+  integer, parameter :: p(1,2) = (x(1)%a)
+  integer            :: z(1,2) = (x(1)%a) 
+  integer            :: y(1,2), v(1,2), w(1,2)
+  v = (u   %a)
+  w =  x(1)%a
+  y = (x(1)%a)
+  print *, v, w, y, z, p
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103505.f90 b/gcc/testsuite/gfortran.dg/pr103505.f90
new file mode 100644
index 00000000000..522e53efcb2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103505.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/103505 - this used to ICE in compare_bound_mpz_t
+! Testcase by G.Steinmetz
+
+program p
+  integer, parameter :: a((2.))   = [4,8] ! { dg-error "scalar INTEGER" }
+  integer, parameter :: z(1:(2.)) = [4,8] ! { dg-error "scalar INTEGER" }
+  print *, a(1:1)                         ! { dg-error "Syntax error" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103588.f90 b/gcc/testsuite/gfortran.dg/pr103588.f90
new file mode 100644
index 00000000000..198e1766cd2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103588.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/103588 - ICE: Simplification error in gfc_ref_dimen_size
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1,2] ! { dg-error "cannot be automatic or of deferred shape" }
+  integer :: b(2) = a(::a(1))        ! { dg-error "Invalid" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103606.f90 b/gcc/testsuite/gfortran.dg/pr103606.f90
new file mode 100644
index 00000000000..43283184e89
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103606.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/103606 -  ICE in resolve_fl_procedure
+! Contributed by G.Steinmetz
+
+program p
+  type t
+  end type
+contains
+  elemental function f() result(z) ! { dg-error "CLASS variable" }
+    class(t) :: z
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103607.f90 b/gcc/testsuite/gfortran.dg/pr103607.f90
new file mode 100644
index 00000000000..a6a2c4fdfd0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103607.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/103607 - ICE in do_subscript, at fortran/frontend-passes.c:2927
+! Contributed by G.Steinmetz
+
+program p
+  integer :: i, x(abs(2.)) ! { dg-error "must be of INTEGER type" }
+  do i = 1, 2
+     x(i) = 0
+  end do
+end
+
+! { dg-prune-output "must have constant shape" }
diff --git a/gcc/testsuite/gfortran.dg/pr63797.f90 b/gcc/testsuite/gfortran.dg/pr63797.f90
new file mode 100644
index 00000000000..1131e8167b1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr63797.f90
@@ -0,0 +1,60 @@
+! { dg-do compile }
+! PR63797 - Bogus ambiguous reference to 'sqrt'
+
+module mod1
+  implicit none
+  real, parameter :: z = sqrt (0.0)
+  real            :: w = sqrt (1.0)
+  interface
+     pure real function sqrt_ifc (x)
+       real, intent(in) :: x
+     end function sqrt_ifc
+  end interface
+contains
+  pure function myroot () result (f)
+    procedure(sqrt_ifc), pointer :: f
+    intrinsic :: sqrt
+    f => sqrt
+  end function myroot
+end module mod1
+
+module mod2
+  implicit none
+  type t
+     real :: a = 0.
+  end type
+  interface sqrt
+     module procedure sqrt
+  end interface
+contains
+  elemental function sqrt (a)
+    type(t), intent(in) :: a
+    type(t)             :: sqrt
+    sqrt% a = a% a
+  end function sqrt
+end module mod2
+
+module mod3
+  implicit none
+  abstract interface
+     function real_func (x)
+       real              :: real_func
+       real, intent (in) :: x
+     end function real_func
+  end interface
+  intrinsic :: sqrt
+  procedure(real_func), pointer :: real_root => sqrt
+end module mod3
+
+program test
+  use mod1
+  use mod2
+  use mod3
+  implicit none
+  type(t) :: x, y
+  procedure(sqrt_ifc), pointer :: root
+  root => myroot ()
+  y    = sqrt (x)
+  y% a = sqrt (x% a) + z - w + root (x% a)
+  y% a = real_root (x% a)
+end program test
diff --git a/gcc/testsuite/gfortran.dg/pr68019.f90 b/gcc/testsuite/gfortran.dg/pr68019.f90
index 2e304c3a260..77fd55bd331 100644
--- a/gcc/testsuite/gfortran.dg/pr68019.f90
+++ b/gcc/testsuite/gfortran.dg/pr68019.f90
@@ -9,5 +9,5 @@ program p
       integer :: n
    end type
    type(t), parameter :: vec(*) = [(t(i), i = 1, 4)]
-   type(t), parameter :: arr(*) = reshape(vec, [2, 2])   ! { dg-error "ranks 1 and 2 in assignment" }
+   type(t), parameter :: arr(*) = reshape(vec, [2, 2])   ! { dg-error "Rank mismatch" }
 end
diff --git a/gcc/testsuite/gfortran.dg/pr68153.f90 b/gcc/testsuite/gfortran.dg/pr68153.f90
index 1a360f80cd6..46a3bc029d7 100644
--- a/gcc/testsuite/gfortran.dg/pr68153.f90
+++ b/gcc/testsuite/gfortran.dg/pr68153.f90
@@ -5,5 +5,5 @@
 !
 program foo
    integer, parameter :: a(2) = [2, -2]
-   integer, parameter :: b(2,2) = reshape([1, 2, 3, 4], a) ! { dg-error "cannot be negative" }
+   integer, parameter :: b(2,2) = reshape([1, 2, 3, 4], a) ! { dg-error "negative" }
 end program foo
diff --git a/gcc/testsuite/gfortran.dg/pr70931.f90 b/gcc/testsuite/gfortran.dg/pr70931.f90
index 08ecd687752..4444b5eec3b 100644
--- a/gcc/testsuite/gfortran.dg/pr70931.f90
+++ b/gcc/testsuite/gfortran.dg/pr70931.f90
@@ -5,6 +5,7 @@ program p
       integer :: a
       integer :: b(0)
    end type
-   type(t), parameter :: z = t(1, [2])
+!  type(t), parameter :: z = t(1, [2])         ! original invalid code
+   type(t), parameter :: z = t(1, [integer::])
    print *, z
 end
diff --git a/gcc/testsuite/gfortran.dg/pr82314.f90 b/gcc/testsuite/gfortran.dg/pr82314.f90
new file mode 100644
index 00000000000..3a147e22711
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr82314.f90
@@ -0,0 +1,11 @@
+! { dg-do run }
+! PR fortran/82314 - ICE in gfc_conv_expr_descriptor
+
+program p
+  implicit none
+  integer, parameter :: karray(merge(3,7,.true.):merge(3,7,.false.)) = 1
+  integer, parameter :: i = size   (karray)
+  integer, parameter :: l = lbound (karray,1)
+  integer, parameter :: u = ubound (karray,1)
+  if (l /= 3 .or. u /= 7 .or. i /= 5) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95502.f90 b/gcc/testsuite/gfortran.dg/pr95502.f90
new file mode 100644
index 00000000000..d40fd9a5508
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95502.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/95502 - ICE in gfc_check_do_variable, at fortran/parse.c:4446
+
+program p
+  integer, pointer :: z
+  nullify (z%kind)  ! { dg-error "in variable definition context" }
+  z%kind => NULL()  ! { dg-error "constant expression" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr98411.f90 b/gcc/testsuite/gfortran.dg/pr98411.f90
new file mode 100644
index 00000000000..7c906a96f60
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr98411.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-std=f2008 -Wall -fautomatic -fmax-stack-var-size=100" }
+! PR fortran/98411 - Pointless warning for static variables 
+
+module try
+  implicit none
+  integer, save :: a(1000)
+contains
+  subroutine initmodule
+    real, save :: b(1000)
+    logical    :: c(1000) ! { dg-warning "moved from stack to static storage" }
+    integer    :: e(1000) = 1
+    a(1) = 42
+    b(2) = 3.14
+    c(3) = .true.
+    e(5) = -1
+  end subroutine initmodule
+end module try
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_52.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_52.f90
new file mode 100644
index 00000000000..cb7cf7040a9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/proc_ptr_52.f90
@@ -0,0 +1,72 @@
+! { dg-do run }
+!
+! Test the fix for PRs93924 & 93925.
+!
+! Contributed by Martin Stein  <mscfd@gmx.net>
+!
+module cs
+
+implicit none
+
+integer, target :: integer_target
+
+abstract interface
+   function classStar_map_ifc(x) result(y)
+      class(*), pointer            :: y
+      class(*), target, intent(in) :: x
+   end function classStar_map_ifc
+end interface
+
+contains
+
+   function fun(x) result(y)
+      class(*), pointer            :: y
+      class(*), target, intent(in) :: x
+      select type (x)
+      type is (integer)
+         integer_target = x        ! Deals with dangling target.
+         y => integer_target
+      class default
+         y => null()
+      end select
+   end function fun
+
+   function apply(f, x) result(y)
+      procedure(classStar_map_ifc) :: f
+      integer, intent(in) :: x
+      integer :: y
+      class(*), pointer :: p
+      y = 0                        ! Get rid of 'y' undefined warning
+      p => f (x)
+      select type (p)
+      type is (integer)
+         y = p
+      end select
+   end function apply
+
+   function selector() result(f)
+      procedure(classStar_map_ifc), pointer :: f
+      f => fun
+   end function selector
+
+end module cs
+
+
+program classStar_map
+
+use cs
+implicit none
+
+integer :: x, y
+procedure(classStar_map_ifc), pointer :: f
+
+x = 123654
+f => selector ()               ! Fixed by second chunk in patch
+y = apply (f, x)               ! Fixed by first chunk in patch
+if (x .ne. y) stop 1
+
+x = 2 * x
+y = apply (fun, x)             ! PR93925; fixed as above
+if (x .ne. y) stop 2
+
+end program classStar_map
diff --git a/gcc/testsuite/gfortran.dg/reshape_7.f90 b/gcc/testsuite/gfortran.dg/reshape_7.f90
index d752650aa4e..4216cb60cbb 100644
--- a/gcc/testsuite/gfortran.dg/reshape_7.f90
+++ b/gcc/testsuite/gfortran.dg/reshape_7.f90
@@ -4,7 +4,7 @@
 subroutine p0
    integer, parameter :: sh(2) = [2, 3]
    integer, parameter :: &
-   & a(2,2) = reshape([1, 2, 3, 4], sh)   ! { dg-error "Different shape" }
+   & a(2,2) = reshape([1, 2, 3, 4], sh)   ! { dg-error "not enough elements" }
    if (a(1,1) /= 0) STOP 1
 end subroutine p0
 
diff --git a/gcc/testsuite/gfortran.dg/reshape_9.f90 b/gcc/testsuite/gfortran.dg/reshape_9.f90
new file mode 100644
index 00000000000..dc52e26cc86
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/reshape_9.f90
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/103411 - ICE in gfc_conv_array_initializer
+! Based on testcase by G. Steinmetz
+! Test simplifications for checks of shape argument to reshape intrinsic
+
+program p
+  integer :: i
+  integer, parameter :: a(2) = [2,2]
+  integer, parameter :: u(5) = [1,2,2,42,2]
+  integer, parameter :: v(1,3) = 2
+  integer, parameter :: d(2,2) = reshape([1,2,3,4,5], a)
+  integer, parameter :: c(2,2) = reshape([1,2,3,4], a)
+  integer, parameter :: b(2,2) = &
+           reshape([1,2,3], a) ! { dg-error "not enough elements" }
+  print *, reshape([1,2,3], a) ! { dg-error "not enough elements" }
+  print *, reshape([1,2,3,4], a)
+  print *, reshape([1,2,3,4,5], a)
+  print *, b, c, d
+  print *, reshape([1,2,3], [(u(i),i=1,2)])
+  print *, reshape([1,2,3], [(u(i),i=2,3)]) ! { dg-error "not enough elements" }
+  print *, reshape([1,2,3],              &
+                   [(u(i)*(-1)**i,i=2,3)]) ! { dg-error "has negative element" }
+  print *, reshape([1,2,3,4], u(5:3:-2))
+  print *, reshape([1,2,3],   u(5:3:-2))  ! { dg-error "not enough elements" }
+  print *, reshape([1,2,3,4], u([5,3]))
+  print *, reshape([1,2,3]  , u([5,3]))   ! { dg-error "not enough elements" }
+  print *, reshape([1,2,3,4], v(1,2:))
+  print *, reshape([1,2,3],   v(1,2:))    ! { dg-error "not enough elements" }
+  print *, reshape([1,2,3,4], v(1,[2,1]))
+  print *, reshape([1,2,3] ,  v(1,[2,1])) ! { dg-error "not enough elements" }
+end
diff --git a/gcc/testsuite/gfortran.dg/reshape_shape_2.f90 b/gcc/testsuite/gfortran.dg/reshape_shape_2.f90
new file mode 100644
index 00000000000..8f1757687bc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/reshape_shape_2.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/102717
+
+program p
+  integer, parameter :: a(1) = 2
+  integer, parameter :: b(2) = reshape([3,4], -[a]) ! { dg-error "negative" }
+end
diff --git a/gcc/testsuite/gfortran.dg/select_rank_5.f90 b/gcc/testsuite/gfortran.dg/select_rank_5.f90
new file mode 100644
index 00000000000..55aa9e1b9bf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_rank_5.f90
@@ -0,0 +1,44 @@
+! { dg-do run }
+!
+! Test the fixes for PR97723 and PR97694.
+!
+! Contributed by Martin  <mscfd@gmx.net>
+!
+module mod
+   implicit none
+   private
+   public cssel
+
+contains
+
+function cssel(x) result(s)
+   character(len=:), allocatable :: s
+   class(*), dimension(..), optional, intent(in) :: x
+   if (present(x)) then
+      select rank (x)
+      rank (0)
+         s = '0' ! PR97723: ‚Äòassign‚Äô at (1) is not a function
+                 ! PR97694: ICE in trans-stmt.c(trans_associate_var)
+      rank (1)
+         s = '1' ! PR97723: ‚Äòassign‚Äô at (1) is not a function
+      rank default
+         s = '?' ! PR97723: ‚Äòassign‚Äô at (1) is not a function
+      end select
+   else
+      s = '-'
+   end if
+end function cssel
+
+end module mod
+
+program classstar_rank
+   use mod
+   implicit none
+
+   integer :: x
+   real, dimension(1:3) :: y
+   logical, dimension(1:2,1:2) :: z
+
+   if (any ([cssel(x),cssel(y),cssel(z),cssel()] .ne. ['0','1','?','-'])) stop 1
+
+end program classstar_rank
diff --git a/gcc/testsuite/gfortran.dg/shape_10.f90 b/gcc/testsuite/gfortran.dg/shape_10.f90
new file mode 100644
index 00000000000..4943c21b1d2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/shape_10.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/102716
+
+program p
+  integer, parameter :: a(1) = shape([2], [1]) ! { dg-error "must be a scalar" }
+end
diff --git a/gcc/testsuite/gfortran.dg/shape_11.f90 b/gcc/testsuite/gfortran.dg/shape_11.f90
new file mode 100644
index 00000000000..127d221e710
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/shape_11.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/103610 - ICE while simplifying SHAPE
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(-1) = 1
+  integer, parameter :: b(1)  = maskl(shape(a))
+  integer, parameter :: c(1)  = shape(a)
+  integer, parameter :: d(1)  = maskr(shape(a))
+  if (b(1) /= 0) stop 1
+  if (c(1) /= 0) stop 2
+  if (d(1) /= 0) stop 3
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/structure_constructor_17.f90 b/gcc/testsuite/gfortran.dg/structure_constructor_17.f90
new file mode 100644
index 00000000000..8b8230c6f7e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/structure_constructor_17.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! Test the fix for PR97612.
+!
+! Contributed by Martin Stein  <mscfd@gmx.net>
+!
+program constructor_allocatable
+  implicit none
+
+  type :: s
+    integer, dimension(:), allocatable :: u
+  end type s
+
+  type :: t
+    type(s), dimension(:), allocatable :: x
+  end type t
+
+  type(t) :: a = t()
+  if (allocated (a%x)) stop 1
+
+end program constructor_allocatable
diff --git a/gcc/testsuite/gfortran.dg/substr_6.f90 b/gcc/testsuite/gfortran.dg/substr_6.f90
index 0d5e3d75e88..83e788a55a6 100644
--- a/gcc/testsuite/gfortran.dg/substr_6.f90
+++ b/gcc/testsuite/gfortran.dg/substr_6.f90
@@ -6,6 +6,8 @@ CHARACTER(5), parameter :: c0(1) = (/ "123" // ACHAR(0) // "5" /)
 CHARACTER*5 c(1)
 CHARACTER(1), parameter :: c1(5) = (/ "1", "2", "3", ACHAR(0), "5" /)
 
+c = c0(1)(-5:-8)
+if (c(1) /= "     ") STOP 1
 c = (/ c0(1)(1:5) /)
 do i=1,5
    if (c(1)(i:i) /= c1(i)) STOP 2
diff --git a/gcc/testsuite/gfortran.dg/transfer_simplify_2.f90 b/gcc/testsuite/gfortran.dg/transfer_simplify_2.f90
index e0f3f94c4ca..b428fa64b56 100644
--- a/gcc/testsuite/gfortran.dg/transfer_simplify_2.f90
+++ b/gcc/testsuite/gfortran.dg/transfer_simplify_2.f90
@@ -145,7 +145,7 @@ contains
       real(4) :: x(2)
     end type mytype
 
-    type (mytype), parameter :: dt1(2) = transfer (c1, mytype ((/1.0,2.0,3.0,4.0/)), 2)
+    type (mytype), parameter :: dt1(2) = transfer (c1, mytype ((/1.0,2.0/)), 2)
     type (mytype)            :: dt2(2)
 
     dt2 = transfer (c2, dt2);
diff --git a/gcc/testsuite/gnat.dg/derived_type7.adb b/gcc/testsuite/gnat.dg/derived_type7.adb
new file mode 100644
index 00000000000..61e7abaa1d7
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/derived_type7.adb
@@ -0,0 +1,9 @@
+package body Derived_Type7 is
+
+  procedure Proc (Size : Natural) is
+    type Sar_Six_Bit_Arr is new Six_Bit_Data_Array_Type (1 .. Size);
+  begin
+    null;
+  end;
+
+end Derived_Type7;
diff --git a/gcc/testsuite/gnat.dg/derived_type7.ads b/gcc/testsuite/gnat.dg/derived_type7.ads
new file mode 100644
index 00000000000..2b1427af3c6
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/derived_type7.ads
@@ -0,0 +1,13 @@
+-- { dg-do compile }
+
+package Derived_Type7 is
+
+  type Six_Bit_Data_Type is range 0 .. 63;
+  for Six_Bit_Data_Type'Size use 6;
+
+  type Six_Bit_Data_Array_Type is array (Integer range <>) of Six_Bit_Data_Type;
+  for Six_Bit_Data_Array_Type'Component_Size use 6;
+
+  procedure Proc (Size : Natural);
+
+end Derived_Type7;
diff --git a/gcc/testsuite/gnat.dg/opt92.adb b/gcc/testsuite/gnat.dg/opt92.adb
new file mode 100644
index 00000000000..f6eb6a034ec
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt92.adb
@@ -0,0 +1,38 @@
+-- { dg-do compile { target { lp64 || llp64 } } }
+-- { dg-options "-O2 -gnatws" }
+
+procedure Main is
+
+   subtype Int64 is Long_Long_Integer;
+
+   type Arr is array (Int64 range <>) of Boolean;
+
+   Pow : constant := 10;
+
+   procedure Compute (B : in out Arr) is
+      Factor : Int64 := 3;
+      Num    : Int64;
+   begin
+      while Factor <= 10 ** (Pow / 2) loop
+         Num := Factor;
+         while Num < 10 ** Pow loop
+            if B (Num) then
+               Factor := Num;
+               exit;
+            end if;
+            Num := Num + 2;
+         end loop;
+         Num := Factor * Factor;
+         while Num < 10 ** Pow loop
+            B (Num) := False;
+            Num        := Num + Factor * 2;
+         end loop;
+         Factor := Factor + 2;
+      end loop;
+   end;
+
+   B : Arr (1 .. 10 ** Pow) := (others => True);
+
+begin
+   Compute (B);   
+end;
diff --git a/gcc/testsuite/gnat.dg/unchecked_convert5.adb b/gcc/testsuite/gnat.dg/unchecked_convert5.adb
index e3e4312d731..9c24d669063 100644
--- a/gcc/testsuite/gnat.dg/unchecked_convert5.adb
+++ b/gcc/testsuite/gnat.dg/unchecked_convert5.adb
@@ -1,4 +1,4 @@
--- { dg-do run { target hppa*-*-* sparc*-*-* powerpc*-*-* } }
+-- { dg-do run { target hppa*-*-* sparc*-*-* powerpc-*-* powerpc64-*-* } }
 
 with Unchecked_Conversion;
 
diff --git a/gcc/testsuite/gnat.dg/unchecked_convert6.adb b/gcc/testsuite/gnat.dg/unchecked_convert6.adb
index a26a6a9b762..ce8cc10b93b 100644
--- a/gcc/testsuite/gnat.dg/unchecked_convert6.adb
+++ b/gcc/testsuite/gnat.dg/unchecked_convert6.adb
@@ -1,4 +1,4 @@
--- { dg-do run { target hppa*-*-* sparc*-*-* powerpc*-*-* } }
+-- { dg-do run { target hppa*-*-* sparc*-*-* powerpc-*-* powerpc64-*-* } }
 
 with Unchecked_Conversion;
 
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index bd62a0d9e79..2749afe4741 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -4671,6 +4671,23 @@ proc check_effective_target_arm_cmse_ok {} {
     } "-mcmse"];
 }
 
+# Return 1 if the target supports executing CMSE instructions, 0
+# otherwise.  Cache the result.
+
+proc check_effective_target_arm_cmse_hw { } {
+    return [check_runtime arm_cmse_hw_available {
+	int main (void)
+	{
+	    unsigned id_pfr1;
+	    asm ("ldr\t%0, =0xe000ed44\n" \
+		 "ldr\t%0, [%0]\n" \
+		 "sg" : "=l" (id_pfr1));
+	    /* Exit with code 0 iff security extension is available.  */
+	    return !(id_pfr1 & 0xf0);
+	}
+    } "-mcmse"]
+}
+
 # Return 1 if the target supports executing MVE instructions, 0
 # otherwise.
 
@@ -10352,13 +10369,14 @@ proc check_effective_target_tune_cortex_a76 { } {
     return [check_configured_with "with-tune=cortex-a76"]
 }
 
-# Return 1 if target is not support address sanitize, 1 otherwise.
+# Return 1 if the target does not support address sanitizer, 0 otherwise
 
 proc check_effective_target_no_fsanitize_address {} {
     if ![check_no_compiler_messages fsanitize_address executable {
 	int main (void) { return 0; }
-    }] {
+    } "-fsanitize=address" ] {
 	return 1;
     }
+
     return 0;
 }
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
index 2cb54def860..a0613ed83eb 100644
--- a/gcc/tree-data-ref.c
+++ b/gcc/tree-data-ref.c
@@ -1891,8 +1891,8 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,
 
   bool waw_or_war_p = (alias_pair.flags & ~(DR_ALIAS_WAR | DR_ALIAS_WAW)) == 0;
 
-  unsigned int i;
-  for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)
+  int found = -1;
+  for (unsigned int i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)
     {
       tree access1 = DR_ACCESS_FN (dr_a.dr, i);
       tree access2 = DR_ACCESS_FN (dr_b.dr, i);
@@ -1908,155 +1908,166 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,
 
 	  return false;
 	}
-      /* The two indices must have the same step.  */
-      if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))
+      if (found >= 0)
 	return false;
+      found = i;
+    }
 
-      tree idx_step = CHREC_RIGHT (access1);
-      /* Index must have const step, otherwise DR_STEP won't be constant.  */
-      gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);
-      /* Index must evaluate in the same direction as DR.  */
-      gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);
+  /* Ought not to happen in practice, since if all accesses are equal then the
+     alias should be decidable at compile time.  */
+  if (found < 0)
+    return false;
 
-      tree min1 = CHREC_LEFT (access1);
-      tree min2 = CHREC_LEFT (access2);
-      if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))
-	return false;
+  /* The two indices must have the same step.  */
+  tree access1 = DR_ACCESS_FN (dr_a.dr, found);
+  tree access2 = DR_ACCESS_FN (dr_b.dr, found);
+  if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))
+    return false;
 
-      /* Ideally, alias can be checked against loop's control IV, but we
-	 need to prove linear mapping between control IV and reference
-	 index.  Although that should be true, we check against (array)
-	 index of data reference.  Like segment length, index length is
-	 linear function of the number of iterations with index_step as
-	 the coefficient, i.e, niter_len * idx_step.  */
-      offset_int abs_idx_step = offset_int::from (wi::to_wide (idx_step),
-						  SIGNED);
-      if (neg_step)
-	abs_idx_step = -abs_idx_step;
-      poly_offset_int idx_len1 = abs_idx_step * niter_len1;
-      poly_offset_int idx_len2 = abs_idx_step * niter_len2;
-      poly_offset_int idx_access1 = abs_idx_step * niter_access1;
-      poly_offset_int idx_access2 = abs_idx_step * niter_access2;
+  tree idx_step = CHREC_RIGHT (access1);
+  /* Index must have const step, otherwise DR_STEP won't be constant.  */
+  gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);
+  /* Index must evaluate in the same direction as DR.  */
+  gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);
 
-      gcc_assert (known_ge (idx_len1, 0)
-		  && known_ge (idx_len2, 0)
-		  && known_ge (idx_access1, 0)
-		  && known_ge (idx_access2, 0));
+  tree min1 = CHREC_LEFT (access1);
+  tree min2 = CHREC_LEFT (access2);
+  if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))
+    return false;
 
-      /* Each access has the following pattern, with lengths measured
-	 in units of INDEX:
+  /* Ideally, alias can be checked against loop's control IV, but we
+     need to prove linear mapping between control IV and reference
+     index.  Although that should be true, we check against (array)
+     index of data reference.  Like segment length, index length is
+     linear function of the number of iterations with index_step as
+     the coefficient, i.e, niter_len * idx_step.  */
+  offset_int abs_idx_step = offset_int::from (wi::to_wide (idx_step),
+					      SIGNED);
+  if (neg_step)
+    abs_idx_step = -abs_idx_step;
+  poly_offset_int idx_len1 = abs_idx_step * niter_len1;
+  poly_offset_int idx_len2 = abs_idx_step * niter_len2;
+  poly_offset_int idx_access1 = abs_idx_step * niter_access1;
+  poly_offset_int idx_access2 = abs_idx_step * niter_access2;
 
-	      <-- idx_len -->
-	      <--- A: -ve step --->
-	      +-----+-------+-----+-------+-----+
-	      | n-1 | ..... |  0  | ..... | n-1 |
-	      +-----+-------+-----+-------+-----+
-			    <--- B: +ve step --->
-			    <-- idx_len -->
-			    |
-			   min
+  gcc_assert (known_ge (idx_len1, 0)
+	      && known_ge (idx_len2, 0)
+	      && known_ge (idx_access1, 0)
+	      && known_ge (idx_access2, 0));
 
-	 where "n" is the number of scalar iterations covered by the segment
-	 and where each access spans idx_access units.
+  /* Each access has the following pattern, with lengths measured
+     in units of INDEX:
 
-	 A is the range of bytes accessed when the step is negative,
-	 B is the range when the step is positive.
+	  <-- idx_len -->
+	  <--- A: -ve step --->
+	  +-----+-------+-----+-------+-----+
+	  | n-1 | ..... |  0  | ..... | n-1 |
+	  +-----+-------+-----+-------+-----+
+			<--- B: +ve step --->
+			<-- idx_len -->
+			|
+		       min
 
-	 When checking for general overlap, we need to test whether
-	 the range:
+     where "n" is the number of scalar iterations covered by the segment
+     and where each access spans idx_access units.
 
-	   [min1 + low_offset1, min2 + high_offset1 + idx_access1 - 1]
+     A is the range of bytes accessed when the step is negative,
+     B is the range when the step is positive.
 
-	 overlaps:
+     When checking for general overlap, we need to test whether
+     the range:
 
-	   [min2 + low_offset2, min2 + high_offset2 + idx_access2 - 1]
+       [min1 + low_offset1, min1 + high_offset1 + idx_access1 - 1]
 
-	 where:
+     overlaps:
 
-	    low_offsetN = +ve step ? 0 : -idx_lenN;
-	   high_offsetN = +ve step ? idx_lenN : 0;
+       [min2 + low_offset2, min2 + high_offset2 + idx_access2 - 1]
 
-	 This is equivalent to testing whether:
+     where:
 
-	   min1 + low_offset1 <= min2 + high_offset2 + idx_access2 - 1
-	   && min2 + low_offset2 <= min1 + high_offset1 + idx_access1 - 1
+	low_offsetN = +ve step ? 0 : -idx_lenN;
+       high_offsetN = +ve step ? idx_lenN : 0;
 
-	 Converting this into a single test, there is an overlap if:
+     This is equivalent to testing whether:
 
-	   0 <= min2 - min1 + bias <= limit
+       min1 + low_offset1 <= min2 + high_offset2 + idx_access2 - 1
+       && min2 + low_offset2 <= min1 + high_offset1 + idx_access1 - 1
 
-	 where  bias = high_offset2 + idx_access2 - 1 - low_offset1
-	       limit = (high_offset1 - low_offset1 + idx_access1 - 1)
-		     + (high_offset2 - low_offset2 + idx_access2 - 1)
-	  i.e. limit = idx_len1 + idx_access1 - 1 + idx_len2 + idx_access2 - 1
+     Converting this into a single test, there is an overlap if:
 
-	 Combining the tests requires limit to be computable in an unsigned
-	 form of the index type; if it isn't, we fall back to the usual
-	 pointer-based checks.
+       0 <= min2 - min1 + bias <= limit
 
-	 We can do better if DR_B is a write and if DR_A and DR_B are
-	 well-ordered in both the original and the new code (see the
-	 comment above the DR_ALIAS_* flags for details).  In this case
-	 we know that for each i in [0, n-1], the write performed by
-	 access i of DR_B occurs after access numbers j<=i of DR_A in
-	 both the original and the new code.  Any write or anti
-	 dependencies wrt those DR_A accesses are therefore maintained.
+     where  bias = high_offset2 + idx_access2 - 1 - low_offset1
+	   limit = (high_offset1 - low_offset1 + idx_access1 - 1)
+		 + (high_offset2 - low_offset2 + idx_access2 - 1)
+      i.e. limit = idx_len1 + idx_access1 - 1 + idx_len2 + idx_access2 - 1
 
-	 We just need to make sure that each individual write in DR_B does not
-	 overlap any higher-indexed access in DR_A; such DR_A accesses happen
-	 after the DR_B access in the original code but happen before it in
-	 the new code.
+     Combining the tests requires limit to be computable in an unsigned
+     form of the index type; if it isn't, we fall back to the usual
+     pointer-based checks.
 
-	 We know the steps for both accesses are equal, so by induction, we
-	 just need to test whether the first write of DR_B overlaps a later
-	 access of DR_A.  In other words, we need to move min1 along by
-	 one iteration:
+     We can do better if DR_B is a write and if DR_A and DR_B are
+     well-ordered in both the original and the new code (see the
+     comment above the DR_ALIAS_* flags for details).  In this case
+     we know that for each i in [0, n-1], the write performed by
+     access i of DR_B occurs after access numbers j<=i of DR_A in
+     both the original and the new code.  Any write or anti
+     dependencies wrt those DR_A accesses are therefore maintained.
 
-	   min1' = min1 + idx_step
+     We just need to make sure that each individual write in DR_B does not
+     overlap any higher-indexed access in DR_A; such DR_A accesses happen
+     after the DR_B access in the original code but happen before it in
+     the new code.
 
-	 and use the ranges:
+     We know the steps for both accesses are equal, so by induction, we
+     just need to test whether the first write of DR_B overlaps a later
+     access of DR_A.  In other words, we need to move min1 along by
+     one iteration:
 
-	   [min1' + low_offset1', min1' + high_offset1' + idx_access1 - 1]
+       min1' = min1 + idx_step
 
-	 and:
+     and use the ranges:
 
-	   [min2, min2 + idx_access2 - 1]
+       [min1' + low_offset1', min1' + high_offset1' + idx_access1 - 1]
 
-	 where:
+     and:
 
-	    low_offset1' = +ve step ? 0 : -(idx_len1 - |idx_step|)
-	   high_offset1' = +ve_step ? idx_len1 - |idx_step| : 0.  */
-      if (waw_or_war_p)
-	idx_len1 -= abs_idx_step;
+       [min2, min2 + idx_access2 - 1]
 
-      poly_offset_int limit = idx_len1 + idx_access1 - 1 + idx_access2 - 1;
-      if (!waw_or_war_p)
-	limit += idx_len2;
+     where:
 
-      tree utype = unsigned_type_for (TREE_TYPE (min1));
-      if (!wi::fits_to_tree_p (limit, utype))
-	return false;
+	low_offset1' = +ve step ? 0 : -(idx_len1 - |idx_step|)
+       high_offset1' = +ve_step ? idx_len1 - |idx_step| : 0.  */
+  if (waw_or_war_p)
+    idx_len1 -= abs_idx_step;
 
-      poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;
-      poly_offset_int high_offset2 = neg_step || waw_or_war_p ? 0 : idx_len2;
-      poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;
-      /* Equivalent to adding IDX_STEP to MIN1.  */
-      if (waw_or_war_p)
-	bias -= wi::to_offset (idx_step);
-
-      tree subject = fold_build2 (MINUS_EXPR, utype,
-				  fold_convert (utype, min2),
-				  fold_convert (utype, min1));
-      subject = fold_build2 (PLUS_EXPR, utype, subject,
-			     wide_int_to_tree (utype, bias));
-      tree part_cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject,
-					 wide_int_to_tree (utype, limit));
-      if (*cond_expr)
-	*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
-				  *cond_expr, part_cond_expr);
-      else
-	*cond_expr = part_cond_expr;
-    }
+  poly_offset_int limit = idx_len1 + idx_access1 - 1 + idx_access2 - 1;
+  if (!waw_or_war_p)
+    limit += idx_len2;
+
+  tree utype = unsigned_type_for (TREE_TYPE (min1));
+  if (!wi::fits_to_tree_p (limit, utype))
+    return false;
+
+  poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;
+  poly_offset_int high_offset2 = neg_step || waw_or_war_p ? 0 : idx_len2;
+  poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;
+  /* Equivalent to adding IDX_STEP to MIN1.  */
+  if (waw_or_war_p)
+    bias -= wi::to_offset (idx_step);
+
+  tree subject = fold_build2 (MINUS_EXPR, utype,
+			      fold_convert (utype, min2),
+			      fold_convert (utype, min1));
+  subject = fold_build2 (PLUS_EXPR, utype, subject,
+			 wide_int_to_tree (utype, bias));
+  tree part_cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject,
+				     wide_int_to_tree (utype, limit));
+  if (*cond_expr)
+    *cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
+			      *cond_expr, part_cond_expr);
+  else
+    *cond_expr = part_cond_expr;
   if (dump_enabled_p ())
     {
       if (waw_or_war_p)
@@ -4816,6 +4827,8 @@ build_classic_dist_vector_1 (struct data_dependence_relation *ddr,
 	  non_affine_dependence_relation (ddr);
 	  return false;
 	}
+      else
+	*init_b = true;
     }
 
   return true;
@@ -5311,9 +5324,13 @@ compute_affine_dependence (struct data_dependence_relation *ddr,
   if (dump_file && (dump_flags & TDF_DETAILS))
     {
       fprintf (dump_file, "(compute_affine_dependence\n");
-      fprintf (dump_file, "  stmt_a: ");
+      fprintf (dump_file, "  ref_a: ");
+      print_generic_expr (dump_file, DR_REF (dra));
+      fprintf (dump_file, ", stmt_a: ");
       print_gimple_stmt (dump_file, DR_STMT (dra), 0, TDF_SLIM);
-      fprintf (dump_file, "  stmt_b: ");
+      fprintf (dump_file, "  ref_b: ");
+      print_generic_expr (dump_file, DR_REF (drb));
+      fprintf (dump_file, ", stmt_b: ");
       print_gimple_stmt (dump_file, DR_STMT (drb), 0, TDF_SLIM);
     }
 
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index efde5d15872..9c6f61a583a 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -2132,6 +2132,7 @@ copy_bb (copy_body_data *id, basic_block bb,
 		 GF_CALL_VA_ARG_PACK.  */
 	      gimple_call_copy_flags (new_call, call_stmt);
 	      gimple_call_set_va_arg_pack (new_call, false);
+	      gimple_call_set_fntype (new_call, gimple_call_fntype (call_stmt));
 	      /* location includes block.  */
 	      gimple_set_location (new_call, gimple_location (stmt));
 	      gimple_call_set_lhs (new_call, gimple_call_lhs (call_stmt));
diff --git a/gcc/tree-loop-distribution.c b/gcc/tree-loop-distribution.c
index 888af48946f..3a5f03b3e54 100644
--- a/gcc/tree-loop-distribution.c
+++ b/gcc/tree-loop-distribution.c
@@ -115,6 +115,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-vectorizer.h"
 #include "tree-eh.h"
 #include "gimple-fold.h"
+#include "tree-affine.h"
 
 
 #define MAX_DATAREFS_NUM \
@@ -1212,6 +1213,18 @@ generate_memcpy_builtin (class loop *loop, partition *partition)
     kind = BUILT_IN_MEMCPY;
   else
     kind = BUILT_IN_MEMMOVE;
+  /* Try harder if we're copying a constant size.  */
+  if (kind == BUILT_IN_MEMMOVE && poly_int_tree_p (nb_bytes))
+    {
+      aff_tree asrc, adest;
+      tree_to_aff_combination (src, ptr_type_node, &asrc);
+      tree_to_aff_combination (dest, ptr_type_node, &adest);
+      aff_combination_scale (&adest, -1);
+      aff_combination_add (&asrc, &adest);
+      if (aff_comb_cannot_overlap_p (&asrc, wi::to_poly_widest (nb_bytes),
+				     wi::to_poly_widest (nb_bytes)))
+	kind = BUILT_IN_MEMCPY;
+    }
 
   dest = force_gimple_operand_gsi (&gsi, dest, true, NULL_TREE,
 				   false, GSI_CONTINUE_LINKING);
@@ -1759,11 +1772,11 @@ loop_distribution::classify_builtin_ldst (loop_p loop, struct graph *rdg,
   /* Now check that if there is a dependence.  */
   ddr_p ddr = get_data_dependence (rdg, src_dr, dst_dr);
 
-  /* Classify as memcpy if no dependence between load and store.  */
+  /* Classify as memmove if no dependence between load and store.  */
   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)
     {
       partition->builtin = alloc_builtin (dst_dr, src_dr, base, src_base, size);
-      partition->kind = PKIND_MEMCPY;
+      partition->kind = PKIND_MEMMOVE;
       return;
     }
 
@@ -3151,11 +3164,19 @@ loop_distribution::distribute_loop (class loop *loop, vec<gimple *> stmts,
 void loop_distribution::bb_top_order_init (void)
 {
   int rpo_num;
-  int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));
+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);
+  edge entry = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));
+  bitmap exit_bbs = BITMAP_ALLOC (NULL);
 
   bb_top_order_index = XNEWVEC (int, last_basic_block_for_fn (cfun));
   bb_top_order_index_size = last_basic_block_for_fn (cfun);
-  rpo_num = pre_and_rev_post_order_compute_fn (cfun, NULL, rpo, true);
+
+  entry->flags &= ~EDGE_DFS_BACK;
+  bitmap_set_bit (exit_bbs, EXIT_BLOCK);
+  rpo_num = rev_post_order_and_mark_dfs_back_seme (cfun, entry, exit_bbs, true,
+						   rpo, NULL);
+  BITMAP_FREE (exit_bbs);
+
   for (int i = 0; i < rpo_num; i++)
     bb_top_order_index[rpo[i]] = i;
 
@@ -3181,6 +3202,16 @@ find_seed_stmts_for_distribution (class loop *loop, vec<gimple *> *work_list)
   /* Initialize the worklist with stmts we seed the partitions with.  */
   for (unsigned i = 0; i < loop->num_nodes; ++i)
     {
+      /* In irreducible sub-regions we don't know how to redirect
+	 conditions, so fail.  See PR100492.  */
+      if (bbs[i]->flags & BB_IRREDUCIBLE_LOOP)
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, "loop %d contains an irreducible region.\n",
+		     loop->num);
+	  work_list->truncate (0);
+	  break;
+	}
       for (gphi_iterator gsi = gsi_start_phis (bbs[i]);
 	   !gsi_end_p (gsi); gsi_next (&gsi))
 	{
diff --git a/gcc/tree-nested.c b/gcc/tree-nested.c
index 0507d9afaf4..0337fbe3787 100644
--- a/gcc/tree-nested.c
+++ b/gcc/tree-nested.c
@@ -933,6 +933,7 @@ get_frame_field (struct nesting_info *info, tree target_context,
     }
 
   x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);
+  TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (field);
   return x;
 }
 
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 85b9cc9ed7f..09d951a261b 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -3265,6 +3265,8 @@ totally_scalarize_subtree (struct access *root)
 	      continue;
 
 	    HOST_WIDE_INT pos = root->offset + int_bit_position (fld);
+	    if (pos + fsize > root->offset + root->size)
+	      return false;
 	    enum total_sra_field_state
 	      state = total_should_skip_creating_access (root,
 							 &last_seen_sibling,
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index 864c984f636..c0d77b5f46c 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -695,7 +695,8 @@ pass_dominator::execute (function *fun)
      gcc.dg/tree-ssa/pr21417.c can't be threaded if loop preheader is
      missing.  We should improve jump threading in future then
      LOOPS_HAVE_PREHEADERS won't be needed here.  */
-  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);
+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES
+		       | LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS);
 
   /* Initialize the value-handle array.  */
   threadedge_initialize_values ();
diff --git a/gcc/tree-ssa-phiopt.c b/gcc/tree-ssa-phiopt.c
index b1e0dce93d8..a6c197defea 100644
--- a/gcc/tree-ssa-phiopt.c
+++ b/gcc/tree-ssa-phiopt.c
@@ -465,6 +465,9 @@ factor_out_conditional_conversion (edge e0, edge e1, gphi *phi,
       if (!is_gimple_reg_type (TREE_TYPE (new_arg0)))
 	return NULL;
     }
+  if (TREE_CODE (new_arg0) == SSA_NAME
+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_arg0))
+    return NULL;
 
   if (TREE_CODE (arg1) == SSA_NAME)
     {
@@ -479,6 +482,9 @@ factor_out_conditional_conversion (edge e0, edge e1, gphi *phi,
       new_arg1 = gimple_assign_rhs1 (arg1_def_stmt);
       if (convert_code == VIEW_CONVERT_EXPR)
 	new_arg1 = TREE_OPERAND (new_arg1, 0);
+      if (TREE_CODE (new_arg1) == SSA_NAME
+	  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_arg1))
+	return NULL;
     }
   else
     {
@@ -764,9 +770,12 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,
   if ((integer_zerop (arg0) && integer_onep (arg1))
       || (integer_zerop (arg1) && integer_onep (arg0)))
     neg = false;
+  /* For signed one bit types, the negation is not needed and
+     should be avoided and is the same as 1 case for non-signed
+     one bit types.  */
   else if ((integer_zerop (arg0) && integer_all_onesp (arg1))
 	   || (integer_zerop (arg1) && integer_all_onesp (arg0)))
-    neg = true;
+    neg = TYPE_PRECISION (TREE_TYPE (arg0)) != 1;
   else
     return false;
 
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 465f843fdc0..fbe0a7decfa 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -1980,6 +1980,13 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)
 			  && value_dies_in_block_x (expr, block))))
 		to_remove = i;
 	    }
+	  /* If the REFERENCE may trap make sure the block does not contain
+	     a possible exit point.
+	     ???  This is overly conservative if we translate AVAIL_OUT
+	     as the available expression might be after the exit point.  */
+	  if (BB_MAY_NOTRETURN (block)
+	      && vn_reference_may_trap (ref))
+	    to_remove = i;
 	}
       else if (expr->kind == NARY)
 	{
@@ -3312,7 +3319,11 @@ do_pre_regular_insertion (basic_block block, basic_block dom)
 	  /* If all edges produce the same value and that value is
 	     an invariant, then the PHI has the same value on all
 	     edges.  Note this.  */
-	  else if (!cant_insert && all_same)
+	  else if (!cant_insert
+		   && all_same
+		   && (edoubleprime->kind != NAME
+		       || !SSA_NAME_OCCURS_IN_ABNORMAL_PHI
+			     (PRE_EXPR_NAME (edoubleprime))))
 	    {
 	      gcc_assert (edoubleprime->kind == CONSTANT
 			  || edoubleprime->kind == NAME);
@@ -4034,6 +4045,16 @@ compute_avail (void)
 		      if (ref->set == set
 			  || alias_set_subset_of (set, ref->set))
 			;
+		      else if (ref1->opcode != ref2->opcode
+			       || (ref1->opcode != MEM_REF
+				   && ref1->opcode != TARGET_MEM_REF))
+			{
+			  /* With mismatching base opcodes or bases
+			     other than MEM_REF or TARGET_MEM_REF we
+			     can't do any easy TBAA adjustment.  */
+			  operands.release ();
+			  continue;
+			}
 		      else if (alias_set_subset_of (ref->set, set))
 			{
 			  ref->set = set;
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index 926b4a976ae..273bf84c298 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -738,6 +738,7 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)
       vn_reference_op_t vro1, vro2;
       vn_reference_op_s tem1, tem2;
       bool deref1 = false, deref2 = false;
+      bool reverse1 = false, reverse2 = false;
       for (; vr1->operands.iterate (i, &vro1); i++)
 	{
 	  if (vro1->opcode == MEM_REF)
@@ -745,6 +746,7 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)
 	  /* Do not look through a storage order barrier.  */
 	  else if (vro1->opcode == VIEW_CONVERT_EXPR && vro1->reverse)
 	    return false;
+	  reverse1 |= vro1->reverse;
 	  if (known_eq (vro1->off, -1))
 	    break;
 	  off1 += vro1->off;
@@ -756,11 +758,12 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)
 	  /* Do not look through a storage order barrier.  */
 	  else if (vro2->opcode == VIEW_CONVERT_EXPR && vro2->reverse)
 	    return false;
+	  reverse2 |= vro2->reverse;
 	  if (known_eq (vro2->off, -1))
 	    break;
 	  off2 += vro2->off;
 	}
-      if (maybe_ne (off1, off2))
+      if (maybe_ne (off1, off2) || reverse1 != reverse2)
 	return false;
       if (deref1 && vro1->opcode == ADDR_EXPR)
 	{
@@ -857,6 +860,9 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)
 	  temp.type = NULL_TREE;
 	  temp.op0 = TREE_OPERAND (ref, 1);
 	  temp.op1 = TREE_OPERAND (ref, 2);
+	  temp.reverse = (AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (ref, 0)))
+			  && TYPE_REVERSE_STORAGE_ORDER
+			       (TREE_TYPE (TREE_OPERAND (ref, 0))));
 	  {
 	    tree this_offset = component_ref_field_offset (ref);
 	    if (this_offset
@@ -905,6 +911,9 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)
 				       * vn_ref_op_align_unit (&temp));
 		off.to_shwi (&temp.off);
 	      }
+	    temp.reverse = (AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (ref, 0)))
+			    && TYPE_REVERSE_STORAGE_ORDER
+				 (TREE_TYPE (TREE_OPERAND (ref, 0))));
 	  }
 	  break;
 	case VAR_DECL:
@@ -1518,6 +1527,26 @@ contains_storage_order_barrier_p (vec<vn_reference_op_s> ops)
   return false;
 }
 
+/* Return true if OPS represent an access with reverse storage order.  */
+
+static bool
+reverse_storage_order_for_component_p (vec<vn_reference_op_s> ops)
+{
+  unsigned i = 0;
+  if (ops[i].opcode == REALPART_EXPR || ops[i].opcode == IMAGPART_EXPR)
+    ++i;
+  switch (ops[i].opcode)
+    {
+    case ARRAY_REF:
+    case COMPONENT_REF:
+    case BIT_FIELD_REF:
+    case MEM_REF:
+      return ops[i].reverse;
+    default:
+      return false;
+    }
+}
+
 /* Transform any SSA_NAME's in a vector of vn_reference_op_s
    structures into their value numbers.  This is done in-place, and
    the vector passed in is returned.  *VALUEIZED_ANYTHING will specify
@@ -2835,6 +2864,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
      routines to extract the assigned bits.  */
   else if (known_eq (ref->size, maxsize)
 	   && is_gimple_reg_type (vr->type)
+	   && !reverse_storage_order_for_component_p (vr->operands)
 	   && !contains_storage_order_barrier_p (vr->operands)
 	   && gimple_assign_single_p (def_stmt)
 	   && CHAR_BIT == 8
@@ -2986,6 +3016,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
      to access pieces from or we can combine to a larger entity.  */
   else if (known_eq (ref->size, maxsize)
 	   && is_gimple_reg_type (vr->type)
+	   && !reverse_storage_order_for_component_p (vr->operands)
 	   && !contains_storage_order_barrier_p (vr->operands)
 	   && gimple_assign_single_p (def_stmt)
 	   && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)
@@ -4105,7 +4136,7 @@ vn_nary_op_insert_pieces_predicated (unsigned int length, enum tree_code code,
 }
 
 static bool
-dominated_by_p_w_unex (basic_block bb1, basic_block bb2);
+dominated_by_p_w_unex (basic_block bb1, basic_block bb2, bool);
 
 static tree
 vn_nary_op_get_predicated_value (vn_nary_op_t vno, basic_block bb)
@@ -4114,9 +4145,12 @@ vn_nary_op_get_predicated_value (vn_nary_op_t vno, basic_block bb)
     return vno->u.result;
   for (vn_pval *val = vno->u.values; val; val = val->next)
     for (unsigned i = 0; i < val->n; ++i)
-      if (dominated_by_p_w_unex (bb,
-			  BASIC_BLOCK_FOR_FN
-			    (cfun, val->valid_dominated_by_p[i])))
+      /* Do not handle backedge executability optimistically since
+	 when figuring out whether to iterate we do not consider
+	 changed predication.  */
+      if (dominated_by_p_w_unex
+	    (bb, BASIC_BLOCK_FOR_FN (cfun, val->valid_dominated_by_p[i]),
+	     false))
 	return val->result;
   return NULL_TREE;
 }
@@ -4401,10 +4435,11 @@ vn_phi_insert (gimple *phi, tree result, bool backedges_varying_p)
 
 
 /* Return true if BB1 is dominated by BB2 taking into account edges
-   that are not executable.  */
+   that are not executable.  When ALLOW_BACK is false consider not
+   executable backedges as executable.  */
 
 static bool
-dominated_by_p_w_unex (basic_block bb1, basic_block bb2)
+dominated_by_p_w_unex (basic_block bb1, basic_block bb2, bool allow_back)
 {
   edge_iterator ei;
   edge e;
@@ -4421,7 +4456,8 @@ dominated_by_p_w_unex (basic_block bb1, basic_block bb2)
     {
       edge prede = NULL;
       FOR_EACH_EDGE (e, ei, bb1->preds)
-	if (e->flags & EDGE_EXECUTABLE)
+	if ((e->flags & EDGE_EXECUTABLE)
+	    || (!allow_back && (e->flags & EDGE_DFS_BACK)))
 	  {
 	    if (prede)
 	      {
@@ -4443,7 +4479,8 @@ dominated_by_p_w_unex (basic_block bb1, basic_block bb2)
   /* Iterate to the single executable bb2 successor.  */
   edge succe = NULL;
   FOR_EACH_EDGE (e, ei, bb2->succs)
-    if (e->flags & EDGE_EXECUTABLE)
+    if ((e->flags & EDGE_EXECUTABLE)
+	|| (!allow_back && (e->flags & EDGE_DFS_BACK)))
       {
 	if (succe)
 	  {
@@ -4461,7 +4498,8 @@ dominated_by_p_w_unex (basic_block bb1, basic_block bb2)
 	{
 	  FOR_EACH_EDGE (e, ei, succe->dest->preds)
 	    if (e != succe
-		&& (e->flags & EDGE_EXECUTABLE))
+		&& ((e->flags & EDGE_EXECUTABLE)
+		    || (!allow_back && (e->flags & EDGE_DFS_BACK))))
 	      {
 		succe = NULL;
 		break;
@@ -6758,7 +6796,7 @@ rpo_elim::eliminate_avail (basic_block bb, tree op)
 	     may also be able to "pre-compute" (bits of) the next immediate
 	     (non-)dominator during the RPO walk when marking edges as
 	     executable.  */
-	  if (dominated_by_p_w_unex (bb, abb))
+	  if (dominated_by_p_w_unex (bb, abb, true))
 	    {
 	      tree leader = ssa_name (av->leader);
 	      /* Prevent eliminations that break loop-closed SSA.  */
@@ -7351,11 +7389,9 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,
     e->flags &= ~EDGE_DFS_BACK;
 
   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fn) - NUM_FIXED_BLOCKS);
+  auto_vec<std::pair<int, int> > toplevel_scc_extents;
   int n = rev_post_order_and_mark_dfs_back_seme
-    (fn, entry, exit_bbs, !loops_state_satisfies_p (LOOPS_NEED_FIXUP), rpo);
-  /* rev_post_order_and_mark_dfs_back_seme fills RPO in reverse order.  */
-  for (int i = 0; i < n / 2; ++i)
-    std::swap (rpo[i], rpo[n-i-1]);
+    (fn, entry, exit_bbs, true, rpo, !iterate ? &toplevel_scc_extents : NULL);
 
   if (!do_region)
     BITMAP_FREE (exit_bbs);
@@ -7433,12 +7469,20 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,
   vn_valueize = rpo_vn_valueize;
 
   /* Initialize the unwind state and edge/BB executable state.  */
-  bool need_max_rpo_iterate = false;
+  unsigned curr_scc = 0;
   for (int i = 0; i < n; ++i)
     {
       basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);
       rpo_state[i].visited = 0;
       rpo_state[i].max_rpo = i;
+      if (!iterate && curr_scc < toplevel_scc_extents.length ())
+	{
+	  if (i >= toplevel_scc_extents[curr_scc].first
+	      && i <= toplevel_scc_extents[curr_scc].second)
+	    rpo_state[i].max_rpo = toplevel_scc_extents[curr_scc].second;
+	  if (i == toplevel_scc_extents[curr_scc].second)
+	    curr_scc++;
+	}
       bb->flags &= ~BB_EXECUTABLE;
       bool has_backedges = false;
       edge e;
@@ -7450,51 +7494,12 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,
 	  e->flags &= ~EDGE_EXECUTABLE;
 	  if (iterate || e == entry || (skip_entry_phis && bb == entry->dest))
 	    continue;
-	  if (bb_to_rpo[e->src->index] > i)
-	    {
-	      rpo_state[i].max_rpo = MAX (rpo_state[i].max_rpo,
-					  bb_to_rpo[e->src->index]);
-	      need_max_rpo_iterate = true;
-	    }
-	  else
-	    rpo_state[i].max_rpo
-	      = MAX (rpo_state[i].max_rpo,
-		     rpo_state[bb_to_rpo[e->src->index]].max_rpo);
 	}
       rpo_state[i].iterate = iterate && has_backedges;
     }
   entry->flags |= EDGE_EXECUTABLE;
   entry->dest->flags |= BB_EXECUTABLE;
 
-  /* When there are irreducible regions the simplistic max_rpo computation
-     above for the case of backedges doesn't work and we need to iterate
-     until there are no more changes.  */
-  unsigned nit = 0;
-  while (need_max_rpo_iterate)
-    {
-      nit++;
-      need_max_rpo_iterate = false;
-      for (int i = 0; i < n; ++i)
-	{
-	  basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);
-	  edge e;
-	  edge_iterator ei;
-	  FOR_EACH_EDGE (e, ei, bb->preds)
-	    {
-	      if (e == entry || (skip_entry_phis && bb == entry->dest))
-		continue;
-	      int max_rpo = MAX (rpo_state[i].max_rpo,
-				 rpo_state[bb_to_rpo[e->src->index]].max_rpo);
-	      if (rpo_state[i].max_rpo != max_rpo)
-		{
-		  rpo_state[i].max_rpo = max_rpo;
-		  need_max_rpo_iterate = true;
-		}
-	    }
-	}
-    }
-  statistics_histogram_event (cfun, "RPO max_rpo iterations", nit);
-
   /* As heuristic to improve compile-time we handle only the N innermost
      loops and the outermost one optimistically.  */
   if (iterate)
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index 40171d53d0a..5bf4738b526 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -8134,10 +8134,12 @@ ipa_pta_execute (void)
   FOR_EACH_DEFINED_FUNCTION (node)
     {
       varinfo_t vi;
-      /* Nodes without a body are not interesting.  Especially do not
-         visit clones at this point for now - we get duplicate decls
-	 there for inline clones at least.  */
-      if (!node->has_gimple_body_p () || node->inlined_to)
+      /* Nodes without a body in this partition are not interesting.
+	 Especially do not visit clones at this point for now - we
+	 get duplicate decls there for inline clones at least.  */
+      if (!node->has_gimple_body_p ()
+	  || node->in_other_partition
+	  || node->inlined_to)
 	continue;
       node->get_body ();
 
@@ -8215,8 +8217,10 @@ ipa_pta_execute (void)
       struct function *func;
       basic_block bb;
 
-      /* Nodes without a body are not interesting.  */
-      if (!node->has_gimple_body_p () || node->clone_of)
+      /* Nodes without a body in this partition are not interesting.  */
+      if (!node->has_gimple_body_p ()
+	  || node->in_other_partition
+	  || node->clone_of)
 	continue;
 
       if (dump_file)
@@ -8345,8 +8349,10 @@ ipa_pta_execute (void)
       unsigned i;
       basic_block bb;
 
-      /* Nodes without a body are not interesting.  */
-      if (!node->has_gimple_body_p () || node->clone_of)
+      /* Nodes without a body in this partition are not interesting.  */
+      if (!node->has_gimple_body_p ()
+	  || node->in_other_partition
+	  || node->clone_of)
 	continue;
 
       fn = DECL_STRUCT_FUNCTION (node->decl);
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index fcc0726bdbe..dd89436c44b 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -3457,9 +3457,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
   /* Step values are irrelevant for aliasing if the number of vector
      iterations is equal to the number of scalar iterations (which can
      happen for fully-SLP loops).  */
-  bool ignore_step_p = known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U);
+  bool vf_one_p = known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U);
 
-  if (!ignore_step_p)
+  if (!vf_one_p)
     {
       /* Convert the checks for nonzero steps into bound tests.  */
       tree value;
@@ -3512,6 +3512,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
 
       bool preserves_scalar_order_p
 	= vect_preserves_scalar_order_p (dr_info_a, dr_info_b);
+      bool ignore_step_p
+	  = (vf_one_p
+	     && (preserves_scalar_order_p
+		 || operand_equal_p (DR_STEP (dr_info_a->dr),
+				     DR_STEP (dr_info_b->dr))));
 
       /* Skip the pair if inter-iteration dependencies are irrelevant
 	 and intra-iteration dependencies are guaranteed to be honored.  */
diff --git a/gcc/tree-vect-loop-manip.c b/gcc/tree-vect-loop-manip.c
index df37aead882..639d8ceabf0 100644
--- a/gcc/tree-vect-loop-manip.c
+++ b/gcc/tree-vect-loop-manip.c
@@ -1760,7 +1760,8 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,
   FOR_EACH_VEC_ELT (datarefs, i, dr)
     {
       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);
-      if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt))
+      if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt)
+	  && !STMT_VINFO_SIMD_LANE_ACCESS_P (dr_info->stmt))
 	vect_update_init_of_dr (dr_info, niters, code);
     }
 }
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 899b5608745..d9e7d04d9ea 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -8415,6 +8415,7 @@ maybe_set_vectorized_backedge_value (loop_vec_info loop_vinfo,
     if (gphi *phi = dyn_cast <gphi *> (USE_STMT (use_p)))
       if (gimple_bb (phi)->loop_father->header == gimple_bb (phi)
 	  && (phi_info = loop_vinfo->lookup_stmt (phi))
+	  && STMT_VINFO_RELEVANT_P (phi_info)
 	  && VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (phi_info))
 	  && STMT_VINFO_REDUC_TYPE (phi_info) != FOLD_LEFT_REDUCTION
 	  && STMT_VINFO_REDUC_TYPE (phi_info) != EXTRACT_LAST_REDUCTION)
@@ -8936,7 +8937,10 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)
 	   !gsi_end_p (gsi); gsi_next (&gsi))
 	{
 	  gcall *call = dyn_cast <gcall *> (gsi_stmt (gsi));
-	  if (call && gimple_call_internal_p (call, IFN_MASK_LOAD))
+	  if (!call || !gimple_call_internal_p (call))
+	    continue;
+	  internal_fn ifn = gimple_call_internal_fn (call);
+	  if (ifn == IFN_MASK_LOAD)
 	    {
 	      tree lhs = gimple_get_lhs (call);
 	      if (!VECTOR_TYPE_P (TREE_TYPE (lhs)))
@@ -8946,6 +8950,17 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)
 		  gsi_replace (&gsi, new_stmt, true);
 		}
 	    }
+	  else if (conditional_internal_fn_code (ifn) != ERROR_MARK)
+	    {
+	      tree lhs = gimple_get_lhs (call);
+	      if (!VECTOR_TYPE_P (TREE_TYPE (lhs)))
+		{
+		  tree else_arg
+		    = gimple_call_arg (call, gimple_call_num_args (call) - 1);
+		  gimple *new_stmt = gimple_build_assign (lhs, else_arg);
+		  gsi_replace (&gsi, new_stmt, true);
+		}
+	    }
 	}
     }				/* BBs in loop */
 
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
index adc579ff544..aa3087fe3a4 100644
--- a/gcc/tree-vect-slp.c
+++ b/gcc/tree-vect-slp.c
@@ -1515,6 +1515,10 @@ vect_build_slp_tree_2 (vec_info *vinfo,
 	      }
 	  if (dump_enabled_p ())
 	    dump_printf (MSG_NOTE, "\n");
+	  /* After swapping some operands we lost track whether an
+	     operand has any pattern defs so be conservative here.  */
+	  if (oprnds_info[0]->any_pattern || oprnds_info[1]->any_pattern)
+	    oprnds_info[0]->any_pattern = oprnds_info[1]->any_pattern = true;
 	  /* And try again with scratch 'matches' ... */
 	  bool *tem = XALLOCAVEC (bool, group_size);
 	  if ((child = vect_build_slp_tree (vinfo, oprnd_info->def_stmts,
@@ -2566,139 +2570,62 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)
 }
 
 
-/* Find stmts that must be both vectorized and SLPed (since they feed stmts that
-   can't be SLPed) in the tree rooted at NODE.  Mark such stmts as HYBRID.  */
-
-static void
-vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype,
-			      hash_map<slp_tree, unsigned> &visited)
+/* Private data for vect_detect_hybrid_slp.  */
+struct vdhs_data
 {
-  stmt_vec_info stmt_vinfo = SLP_TREE_SCALAR_STMTS (node)[i];
-  imm_use_iterator imm_iter;
-  gimple *use_stmt;
-  stmt_vec_info use_vinfo;
-  slp_tree child;
-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);
-  int j;
-
-  /* We need to union stype over the incoming graph edges but we still
-     want to limit recursion to stay O(N+E).  */
-  unsigned visited_cnt = ++visited.get_or_insert (node);
-  gcc_assert (visited_cnt <= node->refcnt);
-  bool only_edge = (visited_cnt != node->refcnt);
-
-  /* Propagate hybrid down the SLP tree.  */
-  if (stype == hybrid)
-    ;
-  else if (HYBRID_SLP_STMT (stmt_vinfo))
-    stype = hybrid;
-  else if (!only_edge)
-    {
-      /* Check if a pure SLP stmt has uses in non-SLP stmts.  */
-      gcc_checking_assert (PURE_SLP_STMT (stmt_vinfo));
-      /* If we get a pattern stmt here we have to use the LHS of the
-         original stmt for immediate uses.  */
-      gimple *stmt = vect_orig_stmt (stmt_vinfo)->stmt;
-      tree def;
-      if (gimple_code (stmt) == GIMPLE_PHI)
-	def = gimple_phi_result (stmt);
-      else
-	def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);
-      if (def)
-	FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)
-	  {
-	    use_vinfo = loop_vinfo->lookup_stmt (use_stmt);
-	    if (!use_vinfo)
-	      continue;
-	    use_vinfo = vect_stmt_to_vectorize (use_vinfo);
-	    if (!STMT_SLP_TYPE (use_vinfo)
-		&& (STMT_VINFO_RELEVANT (use_vinfo)
-		    || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (use_vinfo)))
-		&& !(gimple_code (use_stmt) == GIMPLE_PHI
-		     && STMT_VINFO_DEF_TYPE (use_vinfo) == vect_reduction_def))
-	      {
-		if (dump_enabled_p ())
-		  dump_printf_loc (MSG_NOTE, vect_location, "use of SLP "
-				   "def in non-SLP stmt: %G", use_stmt);
-		stype = hybrid;
-	      }
-	  }
-    }
-
-  if (stype == hybrid
-      && !HYBRID_SLP_STMT (stmt_vinfo))
-    {
-      if (dump_enabled_p ())
-	dump_printf_loc (MSG_NOTE, vect_location, "marking hybrid: %G",
-			 stmt_vinfo->stmt);
-      STMT_SLP_TYPE (stmt_vinfo) = hybrid;
-    }
-
-  if (!only_edge)
-    FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)
-      if (SLP_TREE_DEF_TYPE (child) != vect_external_def
-	  && SLP_TREE_DEF_TYPE (child) != vect_constant_def)
-	vect_detect_hybrid_slp_stmts (child, i, stype, visited);
-}
+  loop_vec_info loop_vinfo;
+  vec<stmt_vec_info> *worklist;
+};
 
-/* Helpers for vect_detect_hybrid_slp walking pattern stmt uses.  */
+/* Walker for walk_gimple_op.  */
 
 static tree
-vect_detect_hybrid_slp_1 (tree *tp, int *, void *data)
+vect_detect_hybrid_slp (tree *tp, int *, void *data)
 {
   walk_stmt_info *wi = (walk_stmt_info *)data;
-  loop_vec_info loop_vinfo = (loop_vec_info) wi->info;
+  vdhs_data *dat = (vdhs_data *)wi->info;
 
   if (wi->is_lhs)
     return NULL_TREE;
 
-  stmt_vec_info def_stmt_info = loop_vinfo->lookup_def (*tp);
-  if (def_stmt_info && PURE_SLP_STMT (def_stmt_info))
+  stmt_vec_info def_stmt_info = dat->loop_vinfo->lookup_def (*tp);
+  if (!def_stmt_info)
+    return NULL_TREE;
+  def_stmt_info = vect_stmt_to_vectorize (def_stmt_info);
+  if (PURE_SLP_STMT (def_stmt_info))
     {
       if (dump_enabled_p ())
 	dump_printf_loc (MSG_NOTE, vect_location, "marking hybrid: %G",
 			 def_stmt_info->stmt);
       STMT_SLP_TYPE (def_stmt_info) = hybrid;
+      dat->worklist->safe_push (def_stmt_info);
     }
 
   return NULL_TREE;
 }
 
-static tree
-vect_detect_hybrid_slp_2 (gimple_stmt_iterator *gsi, bool *handled,
-			  walk_stmt_info *wi)
-{
-  loop_vec_info loop_vinfo = (loop_vec_info) wi->info;
-  stmt_vec_info use_vinfo = loop_vinfo->lookup_stmt (gsi_stmt (*gsi));
-  /* If the stmt is in a SLP instance then this isn't a reason
-     to mark use definitions in other SLP instances as hybrid.  */
-  if (! STMT_SLP_TYPE (use_vinfo)
-      && (STMT_VINFO_RELEVANT (use_vinfo)
-	  || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (use_vinfo)))
-      && ! (gimple_code (gsi_stmt (*gsi)) == GIMPLE_PHI
-	    && STMT_VINFO_DEF_TYPE (use_vinfo) == vect_reduction_def))
-    ;
-  else
-    *handled = true;
-  return NULL_TREE;
-}
-
 /* Find stmts that must be both vectorized and SLPed.  */
 
 void
 vect_detect_hybrid_slp (loop_vec_info loop_vinfo)
 {
-  unsigned int i;
-  vec<slp_instance> slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);
-  slp_instance instance;
-
   DUMP_VECT_SCOPE ("vect_detect_hybrid_slp");
 
-  /* First walk all pattern stmt in the loop and mark defs of uses as
-     hybrid because immediate uses in them are not recorded.  */
-  for (i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)
+  /* All stmts participating in SLP are marked pure_slp, all other
+     stmts are loop_vect.
+     First collect all loop_vect stmts into a worklist.  */
+  auto_vec<stmt_vec_info> worklist;
+  for (unsigned i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)
     {
       basic_block bb = LOOP_VINFO_BBS (loop_vinfo)[i];
+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gphi *phi = gsi.phi ();
+	  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (phi);
+	  if (!STMT_SLP_TYPE (stmt_info) && STMT_VINFO_RELEVANT (stmt_info))
+	    worklist.safe_push (stmt_info);
+	}
       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
 	   gsi_next (&gsi))
 	{
@@ -2706,36 +2633,40 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)
 	  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);
 	  if (STMT_VINFO_IN_PATTERN_P (stmt_info))
 	    {
-	      walk_stmt_info wi;
-	      memset (&wi, 0, sizeof (wi));
-	      wi.info = loop_vinfo;
-	      gimple_stmt_iterator gsi2
-		= gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info)->stmt);
-	      walk_gimple_stmt (&gsi2, vect_detect_hybrid_slp_2,
-				vect_detect_hybrid_slp_1, &wi);
-	      walk_gimple_seq (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info),
-			       vect_detect_hybrid_slp_2,
-			       vect_detect_hybrid_slp_1, &wi);
+	      for (gimple_stmt_iterator gsi2
+		     = gsi_start (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));
+		   !gsi_end_p (gsi2); gsi_next (&gsi2))
+		{
+		  stmt_vec_info patt_info
+		    = loop_vinfo->lookup_stmt (gsi_stmt (gsi2));
+		  if (!STMT_SLP_TYPE (patt_info)
+		      && STMT_VINFO_RELEVANT (patt_info))
+		    worklist.safe_push (patt_info);
+		}
+	      stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);
 	    }
+	  if (!STMT_SLP_TYPE (stmt_info) && STMT_VINFO_RELEVANT (stmt_info))
+	    worklist.safe_push (stmt_info);
 	}
     }
 
-  /* Then walk the SLP instance trees marking stmts with uses in
-     non-SLP stmts as hybrid, also propagating hybrid down the
-     SLP tree, collecting the above info on-the-fly.  */
-  for (unsigned j = 0;; ++j)
+  /* Now we have a worklist of non-SLP stmts, follow use->def chains and
+     mark any SLP vectorized stmt as hybrid.
+     ???  We're visiting def stmts N times (once for each non-SLP and
+     once for each hybrid-SLP use).  */
+  walk_stmt_info wi;
+  vdhs_data dat;
+  dat.worklist = &worklist;
+  dat.loop_vinfo = loop_vinfo;
+  memset (&wi, 0, sizeof (wi));
+  wi.info = (void *)&dat;
+  while (!worklist.is_empty ())
     {
-      hash_map<slp_tree, unsigned> visited;
-      bool any = false;
-      FOR_EACH_VEC_ELT (slp_instances, i, instance)
-	if (j < SLP_INSTANCE_GROUP_SIZE (instance))
-	  {
-	    any = true;
-	    vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance),
-					  j, pure_slp, visited);
-	  }
-      if (!any)
-	break;
+      stmt_vec_info stmt_info = worklist.pop ();
+      /* Since SSA operands are not set up for pattern stmts we need
+	 to use walk_gimple_op.  */
+      wi.is_lhs = 0;
+      walk_gimple_op (stmt_info->stmt, vect_detect_hybrid_slp, &wi);
     }
 }
 
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 6418edb5204..2ef71ec41c0 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -8368,6 +8368,7 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 		  && TREE_CODE (dataref_ptr) == SSA_NAME)
 		set_ptr_info_alignment (get_ptr_info (dataref_ptr), align,
 					misalign);
+	      align = least_bit_hwi (misalign | align);
 
 	      if (memory_access_type == VMAT_CONTIGUOUS_REVERSE)
 		{
@@ -8389,7 +8390,6 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 	      /* Arguments are ready.  Create the new vector stmt.  */
 	      if (final_mask)
 		{
-		  align = least_bit_hwi (misalign | align);
 		  tree ptr = build_int_cst (ref_type, align * BITS_PER_UNIT);
 		  gcall *call
 		    = gimple_build_call_internal (IFN_MASK_STORE, 4,
@@ -8408,14 +8408,10 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 					  : build_int_cst (ref_type, 0));
 		  if (aligned_access_p (first_dr_info))
 		    ;
-		  else if (DR_MISALIGNMENT (first_dr_info) == -1)
-		    TREE_TYPE (data_ref)
-		      = build_aligned_type (TREE_TYPE (data_ref),
-					    align * BITS_PER_UNIT);
 		  else
 		    TREE_TYPE (data_ref)
 		      = build_aligned_type (TREE_TYPE (data_ref),
-					    TYPE_ALIGN (elem_type));
+					    align * BITS_PER_UNIT);
 		  vect_copy_ref_info (data_ref, DR_REF (first_dr_info->dr));
 		  gassign *new_stmt
 		    = gimple_build_assign (data_ref, vec_oprnd);
@@ -9567,10 +9563,10 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 			&& TREE_CODE (dataref_ptr) == SSA_NAME)
 		      set_ptr_info_alignment (get_ptr_info (dataref_ptr),
 					      align, misalign);
+		    align = least_bit_hwi (misalign | align);
 
 		    if (final_mask)
 		      {
-			align = least_bit_hwi (misalign | align);
 			tree ptr = build_int_cst (ref_type,
 						  align * BITS_PER_UNIT);
 			gcall *call
@@ -9621,14 +9617,10 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 			  = fold_build2 (MEM_REF, ltype, dataref_ptr, offset);
 			if (alignment_support_scheme == dr_aligned)
 			  ;
-			else if (DR_MISALIGNMENT (first_dr_info) == -1)
-			  TREE_TYPE (data_ref)
-			    = build_aligned_type (TREE_TYPE (data_ref),
-						  align * BITS_PER_UNIT);
 			else
 			  TREE_TYPE (data_ref)
 			    = build_aligned_type (TREE_TYPE (data_ref),
-						  TYPE_ALIGN (elem_type));
+						  align * BITS_PER_UNIT);
 			if (ltype != vectype)
 			  {
 			    vect_copy_ref_info (data_ref,
diff --git a/gcc/tree.c b/gcc/tree.c
index 3c17694c703..d82c308f14c 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -10982,13 +10982,13 @@ build_opaque_vector_type (tree innertype, poly_int64 nunits)
 
 /* Return the value of element I of VECTOR_CST T as a wide_int.  */
 
-wide_int
+static poly_wide_int
 vector_cst_int_elt (const_tree t, unsigned int i)
 {
   /* First handle elements that are directly encoded.  */
   unsigned int encoded_nelts = vector_cst_encoded_nelts (t);
   if (i < encoded_nelts)
-    return wi::to_wide (VECTOR_CST_ENCODED_ELT (t, i));
+    return wi::to_poly_wide (VECTOR_CST_ENCODED_ELT (t, i));
 
   /* Identify the pattern that contains element I and work out the index of
      the last encoded element for that pattern.  */
@@ -10999,13 +10999,13 @@ vector_cst_int_elt (const_tree t, unsigned int i)
 
   /* If there are no steps, the final encoded value is the right one.  */
   if (!VECTOR_CST_STEPPED_P (t))
-    return wi::to_wide (VECTOR_CST_ENCODED_ELT (t, final_i));
+    return wi::to_poly_wide (VECTOR_CST_ENCODED_ELT (t, final_i));
 
   /* Otherwise work out the value from the last two encoded elements.  */
   tree v1 = VECTOR_CST_ENCODED_ELT (t, final_i - npatterns);
   tree v2 = VECTOR_CST_ENCODED_ELT (t, final_i);
-  wide_int diff = wi::to_wide (v2) - wi::to_wide (v1);
-  return wi::to_wide (v2) + (count - 2) * diff;
+  poly_wide_int diff = wi::to_poly_wide (v2) - wi::to_poly_wide (v1);
+  return wi::to_poly_wide (v2) + (count - 2) * diff;
 }
 
 /* Return the value of element I of VECTOR_CST T.  */
@@ -12191,7 +12191,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	case OMP_CLAUSE_BIND:
 	case OMP_CLAUSE_AUTO:
 	case OMP_CLAUSE_SEQ:
-	case OMP_CLAUSE_TILE:
 	case OMP_CLAUSE__SIMT_:
 	case OMP_CLAUSE_IF_PRESENT:
 	case OMP_CLAUSE_FINALIZE:
@@ -12203,6 +12202,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));
 
 	case OMP_CLAUSE_COLLAPSE:
+	case OMP_CLAUSE_TILE:
 	  {
 	    int i;
 	    for (i = 0; i < 3; i++)
diff --git a/gcc/tree.h b/gcc/tree.h
index 328a2d5d226..bb80e81d389 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -4714,7 +4714,6 @@ extern tree first_field (const_tree);
 extern bool initializer_zerop (const_tree, bool * = NULL);
 extern bool initializer_each_zero_or_onep (const_tree);
 
-extern wide_int vector_cst_int_elt (const_tree, unsigned int);
 extern tree vector_cst_elt (const_tree, unsigned int);
 
 /* Given a vector VEC, return its first element if all elements are
diff --git a/gcc/vmsdbgout.c b/gcc/vmsdbgout.c
index b973102d7de..147051bd97c 100644
--- a/gcc/vmsdbgout.c
+++ b/gcc/vmsdbgout.c
@@ -365,13 +365,13 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];
 #define ASM_OUTPUT_DEBUG_STRING(FILE,P)		\
   do						\
     {						\
-      register int slen = strlen (P);		\
-      register const char *p = (P);		\
-      register int i;				\
+      int slen = strlen (P);			\
+      const char *p = (P);			\
+      int i;					\
       fprintf (FILE, "\t.ascii \"");		\
       for (i = 0; i < slen; i++)		\
 	{					\
-	  register int c = p[i];		\
+	  int c = p[i];				\
 	  if (c == '\"' || c == '\\')		\
 	    putc ('\\', FILE);			\
 	  if (c >= ' ' && c < 0177)		\
@@ -1229,7 +1229,7 @@ vmsdbgout_end_epilogue (unsigned int line, const char *file)
    a lexical block.  */
 
 static void
-vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)
+vmsdbgout_begin_block (unsigned line, unsigned blocknum)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
     (*dwarf2_debug_hooks.begin_block) (line, blocknum);
@@ -1242,7 +1242,7 @@ vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)
    lexical block.  */
 
 static void
-vmsdbgout_end_block (register unsigned line, register unsigned blocknum)
+vmsdbgout_end_block (unsigned line, unsigned blocknum)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
     (*dwarf2_debug_hooks.end_block) (line, blocknum);
@@ -1315,8 +1315,8 @@ static unsigned int
 lookup_filename (const char *file_name)
 {
   static unsigned int last_file_lookup_index = 0;
-  register char *fn;
-  register unsigned i;
+  char *fn;
+  unsigned i;
   const char *fnam;
   long long cdt = 0;
   long ebk = 0;
@@ -1405,8 +1405,8 @@ vmsdbgout_write_source_line (unsigned line, const char *filename,
 }
 
 static void
-vmsdbgout_source_line (register unsigned line, unsigned int column,
-		       register const char *filename,
+vmsdbgout_source_line (unsigned line, unsigned int column,
+		       const char *filename,
                        int discriminator, bool is_stmt)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
diff --git a/intl/ChangeLog b/intl/ChangeLog
index e45e393b790..3c50c7bc259 100644
--- a/intl/ChangeLog
+++ b/intl/ChangeLog
@@ -1,3 +1,13 @@
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR jit/100096
+	* configure.ac: Add --enable-host-shared support.
+	* Makefile.in: Update copyright.  Add @PICFLAG@ to CFLAGS.
+	* configure: Regenerated.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/intl/Makefile.in b/intl/Makefile.in
index 356c8ab9b65..ec8c648b7a9 100644
--- a/intl/Makefile.in
+++ b/intl/Makefile.in
@@ -1,5 +1,5 @@
 # Makefile for directory with message catalog handling library of GNU gettext
-# Copyright (C) 1995-1998, 2000-2003 Free Software Foundation, Inc.
+# Copyright (C) 1995-2021 Free Software Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of the GNU Library General Public License as published
@@ -45,7 +45,7 @@ RANLIB = @RANLIB@
 YACC = @INTLBISON@ -y -d
 YFLAGS = --name-prefix=__gettext
 CPPFLAGS = @CPPFLAGS@
-CFLAGS = @CFLAGS@
+CFLAGS = @CFLAGS@ @PICFLAG@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 DEFS = -DHAVE_CONFIG_H
diff --git a/intl/configure b/intl/configure
index d69767b7d21..1e100395369 100755
--- a/intl/configure
+++ b/intl/configure
@@ -622,6 +622,7 @@ ac_unique_file="gettext.c"
 ac_header_list=
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+PICFLAG
 BISON3_NO
 BISON3_YES
 INCINTL
@@ -726,6 +727,7 @@ with_included_gettext
 with_libintl_prefix
 with_libintl_type
 enable_maintainer_mode
+enable_host_shared
 '
       ac_precious_vars='build_alias
 host_alias
@@ -1350,6 +1352,7 @@ Optional Features:
   --disable-nls           do not use Native Language Support
   --disable-rpath         do not hardcode runtime library paths
   --enable-maintainer-mode enable rules only needed by maintainers
+  --enable-host-shared    build host code as shared libraries
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -6815,6 +6818,15 @@ fi
 
 
 
+# Check whether --enable-host-shared was given.
+if test "${enable_host_shared+set}" = set; then :
+  enableval=$enable_host_shared; PICFLAG=-fPIC
+else
+  PICFLAG=
+fi
+
+
+
 ac_config_files="$ac_config_files Makefile config.intl"
 
 cat >confcache <<\_ACEOF
diff --git a/intl/configure.ac b/intl/configure.ac
index 6363e55e68a..72b145958cf 100644
--- a/intl/configure.ac
+++ b/intl/configure.ac
@@ -69,5 +69,11 @@ fi
 AC_SUBST(BISON3_YES)
 AC_SUBST(BISON3_NO)
 
+AC_ARG_ENABLE(host-shared,
+[AS_HELP_STRING([--enable-host-shared],
+		[build host code as shared libraries])],
+[PICFLAG=-fPIC], [PICFLAG=])
+AC_SUBST(PICFLAG)
+
 AC_CONFIG_FILES(Makefile config.intl)
 AC_OUTPUT
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 0d1120a6dd9..043a6c8f444 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,17 @@
+2021-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/100450
+	* lex.c (cpp_avoid_paste): Handle token1 CPP_PRAGMA like CPP_NAME.
+
+2021-04-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* include/line-map.h (IS_MACRO_LOC): Delete.
+	* line-map.c (linemap_location_from_macro_expansion_p): Test
+	LINEMAPS_MACRO_LOWEST_LOCATION of the linemap.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libcpp/include/line-map.h b/libcpp/include/line-map.h
index dbbc13762e3..916cdebcd6a 100644
--- a/libcpp/include/line-map.h
+++ b/libcpp/include/line-map.h
@@ -561,7 +561,7 @@ struct GTY((tag ("2"))) line_map_macro : public line_map {
 #define linemap_assert_fails(EXPR) (! (EXPR))
 #endif
 
-/* Get whether location LOC is an ad-hoc, ordinary or macro location.  */
+/* Get whether location LOC is an ordinary location.  */
 
 inline bool
 IS_ORDINARY_LOC (location_t loc)
@@ -569,18 +569,14 @@ IS_ORDINARY_LOC (location_t loc)
   return loc < LINE_MAP_MAX_LOCATION;
 }
 
+/* Get whether location LOC is an ad-hoc location.  */
+
 inline bool
 IS_ADHOC_LOC (location_t loc)
 {
   return loc > MAX_LOCATION_T;
 }
 
-inline bool
-IS_MACRO_LOC (location_t loc)
-{
-  return !IS_ORDINARY_LOC (loc) && !IS_ADHOC_LOC (loc);
-}
-
 /* Categorize line map kinds.  */
 
 inline bool
diff --git a/libcpp/lex.c b/libcpp/lex.c
index 665297af776..cd2801ca7b7 100644
--- a/libcpp/lex.c
+++ b/libcpp/lex.c
@@ -3485,6 +3485,7 @@ cpp_avoid_paste (cpp_reader *pfile, const cpp_token *token1,
     case CPP_DEREF:	return c == '*';
     case CPP_DOT:	return c == '.' || c == '%' || b == CPP_NUMBER;
     case CPP_HASH:	return c == '#' || c == '%'; /* Digraph form.  */
+    case CPP_PRAGMA:
     case CPP_NAME:	return ((b == CPP_NUMBER
 				 && name_p (pfile, &token2->val.str))
 				|| b == CPP_NAME
diff --git a/libcpp/line-map.c b/libcpp/line-map.c
index 8a390d0857b..1dce2292522 100644
--- a/libcpp/line-map.c
+++ b/libcpp/line-map.c
@@ -1244,7 +1244,7 @@ linemap_location_from_macro_expansion_p (const class line_maps *set,
   if (IS_ADHOC_LOC (location))
     location = get_location_from_adhoc_loc (set, location);
 
-  return IS_MACRO_LOC (location);
+  return location >= LINEMAPS_MACRO_LOWEST_LOCATION (set);
 }
 
 /* Given two virtual locations *LOC0 and *LOC1, return the first
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index 1f9de3d5091..fb18faf3bc4 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,67 @@
+2021-10-27  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config.host (hppa*64*-*-linux*): Don't add pa/t-linux to
+	tmake_file.
+	* config/pa/linux-atomic.c: Define u8, u16 and u64 types.
+	Use them in FETCH_AND_OP_2, OP_AND_FETCH_2, COMPARE_AND_SWAP_2,
+	SYNC_LOCK_TEST_AND_SET_2 and SYNC_LOCK_RELEASE_1 macros.
+	* config/pa/t-linux64 (LIB1ASMSRC): New define.
+	(LIB1ASMFUNCS): Revise.
+	(HOST_LIBGCC2_CFLAGS): Add "-DLINUX=1".
+
+2021-08-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-08-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/value-unwind.h: Add missing runtime exception
+	paragraph.
+	* config/frv/frv-abi.h: Likewise.
+	* config/i386/value-unwind.h: Likewise.
+	* config/pa/pa64-hpux-lib.h: Likewise.
+
+2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-24  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/102035
+	* config/arm/cmse_nonsecure_call.S (__gnu_cmse_nonsecure_call):
+	Add vlldm erratum work-around.
+
+2021-06-18  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backported from master:
+	2021-06-11  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/99939
+	* config/arm/cmse_nonsecure_call.S: Add	__ARM_FEATURE_MVE
+	macro.
+	* config/arm/t-arm: To link cmse.o and cmse_nonsecure_call.o
+	on passing -mcmse option.
+
+2021-04-27  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/98952
+	* config/rs6000/tramp.S (__trampoline_setup, elfv1 #ifdef): Fix
+	trampoline size comparison in 32-bit by reversing test and
+	combining load immediate with compare.  Fix backported from trunk
+	change on 4/23, 886b6c1e8af502b69e3f318b9830b73b88215878.
+	(__trampoline_setup, elfv2 #ifdef): Fix trampoline size comparison
+	in 32-bit by reversing test and combining load immediate with
+	compare.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/97653
+	* config/rs6000/t-linux (IBM128_STATIC_OBJS): Fix spelling, use
+	$(objext) instead of $(object).  Use _floatunditf instead of
+	_floatunsditf.  Add tf <-> ti conversion objects.
+	(IBM128_SHARED_OBJS): Use proper substitution reference syntax.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libgcc/config.host b/libgcc/config.host
index c529cc40f0c..ab58027e68e 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -627,7 +627,7 @@ h8300-*-linux*)
 	tm_file="$tm_file h8300/h8300-lib.h"
 	;;
 hppa*64*-*-linux*)
-	tmake_file="$tmake_file pa/t-linux pa/t-linux64"
+	tmake_file="$tmake_file pa/t-linux64"
 	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
 	;;
 hppa*-*-linux*)
diff --git a/libgcc/config/aarch64/value-unwind.h b/libgcc/config/aarch64/value-unwind.h
index e8b9d44cc58..bb35f416b94 100644
--- a/libgcc/config/aarch64/value-unwind.h
+++ b/libgcc/config/aarch64/value-unwind.h
@@ -13,6 +13,10 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/arm/cmse_nonsecure_call.S b/libgcc/config/arm/cmse_nonsecure_call.S
index 5ba28692d6b..95f626dd456 100644
--- a/libgcc/config/arm/cmse_nonsecure_call.S
+++ b/libgcc/config/arm/cmse_nonsecure_call.S
@@ -25,7 +25,7 @@
 
 .syntax unified
 #ifdef __ARM_PCS_VFP
-# if __ARM_FP & 0x8
+# if (__ARM_FP & 0x8) || (__ARM_FEATURE_MVE & 1)
 	.fpu fpv5-d16
 # else
 	.fpu fpv4-sp-d16
@@ -59,7 +59,7 @@ vmov	    s24, s25, r5, r5
 vmov	    s26, s27, r5, r5
 vmov	    s28, s29, r5, r5
 vmov	    s30, s31, r5, r5
-#elif __ARM_FP & 0x08
+#elif (__ARM_FP & 0x8) || (__ARM_FEATURE_MVE & 1)
 vmov.f64    d9, d8
 vmov.f64    d10, d8
 vmov.f64    d11, d8
@@ -102,6 +102,11 @@ blxns	    r4
 #ifdef __ARM_PCS_VFP
 vpop.f64    {d8-d15}
 #else
+/* VLLDM erratum mitigation sequence. */
+mrs	    r5, control
+tst	    r5, #8	  /* CONTROL_S.SFPA */
+it	    ne
+.inst.w	    0xeeb00a40	  /* vmovne s0, s0 */
 vlldm	    sp		  /* Lazy restore of d0-d16 and FPSCR.  */
 add	    sp, sp, #0x88 /* Free space used to save floating point registers.  */
 #endif /* __ARM_PCS_VFP */
diff --git a/libgcc/config/arm/t-arm b/libgcc/config/arm/t-arm
index 3625a2590be..c1553d4e5d8 100644
--- a/libgcc/config/arm/t-arm
+++ b/libgcc/config/arm/t-arm
@@ -3,18 +3,17 @@ LIB1ASMFUNCS = _thumb1_case_sqi _thumb1_case_uqi _thumb1_case_shi \
 	_thumb1_case_uhi _thumb1_case_si _speculation_barrier
 
 HAVE_CMSE:=$(findstring __ARM_FEATURE_CMSE,$(shell $(gcc_compile_bare) -dM -E - </dev/null))
-HAVE_V81M:=$(findstring armv8.1-m.main,$(gcc_compile_bare))
 ifeq ($(shell $(gcc_compile_bare) -E -mcmse - </dev/null >/dev/null 2>/dev/null; echo $$?),0)
 CMSE_OPTS:=-mcmse
 endif
 
 ifdef HAVE_CMSE
-ifndef HAVE_V81M
+
 libgcc-objects += cmse.o cmse_nonsecure_call.o
 
 cmse.o: $(srcdir)/config/arm/cmse.c
 	$(gcc_compile) -c $(CMSE_OPTS) $<
+
 cmse_nonsecure_call.o: $(srcdir)/config/arm/cmse_nonsecure_call.S
 		       $(gcc_compile) -c $<
 endif
-endif
diff --git a/libgcc/config/frv/frv-abi.h b/libgcc/config/frv/frv-abi.h
index 1db8b35cfa5..2ba8916db8e 100644
--- a/libgcc/config/frv/frv-abi.h
+++ b/libgcc/config/frv/frv-abi.h
@@ -14,6 +14,10 @@
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/i386/value-unwind.h b/libgcc/config/i386/value-unwind.h
index 367c0dea777..208de15510b 100644
--- a/libgcc/config/i386/value-unwind.h
+++ b/libgcc/config/i386/value-unwind.h
@@ -13,6 +13,10 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/pa/linux-atomic.c b/libgcc/config/pa/linux-atomic.c
index 8eb4b5edb03..9083af18730 100644
--- a/libgcc/config/pa/linux-atomic.c
+++ b/libgcc/config/pa/linux-atomic.c
@@ -28,6 +28,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define EBUSY   16
 #define ENOSYS 251 
 
+typedef unsigned char u8;
+typedef short unsigned int u16;
+#ifdef __LP64__
+typedef long unsigned int u64;
+#else
+typedef long long unsigned int u64;
+#endif
+
 /* PA-RISC 2.0 supports out-of-order execution for loads and stores.
    Thus, we need to synchonize memory accesses.  For more info, see:
    "Advanced Performance Features of the 64-bit PA-8000" by Doug Hunt.
@@ -117,26 +125,26 @@ __kernel_cmpxchg2 (volatile void *mem, const void *oldval, const void *newval,
     return tmp;								\
   }
 
-FETCH_AND_OP_2 (add,   , +, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (sub,   , -, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (or,    , |, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (and,   , &, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (xor,   , ^, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (nand, ~, &, long long unsigned int, 8, 3)
-
-FETCH_AND_OP_2 (add,   , +, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (sub,   , -, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (or,    , |, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (and,   , &, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (xor,   , ^, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (nand, ~, &, short unsigned int, 2, 1)
-
-FETCH_AND_OP_2 (add,   , +, unsigned char, 1, 0)
-FETCH_AND_OP_2 (sub,   , -, unsigned char, 1, 0)
-FETCH_AND_OP_2 (or,    , |, unsigned char, 1, 0)
-FETCH_AND_OP_2 (and,   , &, unsigned char, 1, 0)
-FETCH_AND_OP_2 (xor,   , ^, unsigned char, 1, 0)
-FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
+FETCH_AND_OP_2 (add,   , +, u64, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, u64, 8, 3)
+FETCH_AND_OP_2 (or,    , |, u64, 8, 3)
+FETCH_AND_OP_2 (and,   , &, u64, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, u64, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, u64, 8, 3)
+
+FETCH_AND_OP_2 (add,   , +, u16, 2, 1)
+FETCH_AND_OP_2 (sub,   , -, u16, 2, 1)
+FETCH_AND_OP_2 (or,    , |, u16, 2, 1)
+FETCH_AND_OP_2 (and,   , &, u16, 2, 1)
+FETCH_AND_OP_2 (xor,   , ^, u16, 2, 1)
+FETCH_AND_OP_2 (nand, ~, &, u16, 2, 1)
+
+FETCH_AND_OP_2 (add,   , +, u8, 1, 0)
+FETCH_AND_OP_2 (sub,   , -, u8, 1, 0)
+FETCH_AND_OP_2 (or,    , |, u8, 1, 0)
+FETCH_AND_OP_2 (and,   , &, u8, 1, 0)
+FETCH_AND_OP_2 (xor,   , ^, u8, 1, 0)
+FETCH_AND_OP_2 (nand, ~, &, u8, 1, 0)
 
 #define OP_AND_FETCH_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
@@ -154,26 +162,26 @@ FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
     return PFX_OP (tmp INF_OP val);					\
   }
 
-OP_AND_FETCH_2 (add,   , +, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (sub,   , -, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (or,    , |, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (and,   , &, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (xor,   , ^, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (nand, ~, &, long long unsigned int, 8, 3)
-
-OP_AND_FETCH_2 (add,   , +, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (sub,   , -, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (or,    , |, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (and,   , &, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (xor,   , ^, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (nand, ~, &, short unsigned int, 2, 1)
-
-OP_AND_FETCH_2 (add,   , +, unsigned char, 1, 0)
-OP_AND_FETCH_2 (sub,   , -, unsigned char, 1, 0)
-OP_AND_FETCH_2 (or,    , |, unsigned char, 1, 0)
-OP_AND_FETCH_2 (and,   , &, unsigned char, 1, 0)
-OP_AND_FETCH_2 (xor,   , ^, unsigned char, 1, 0)
-OP_AND_FETCH_2 (nand, ~, &, unsigned char, 1, 0)
+OP_AND_FETCH_2 (add,   , +, u64, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, u64, 8, 3)
+OP_AND_FETCH_2 (or,    , |, u64, 8, 3)
+OP_AND_FETCH_2 (and,   , &, u64, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, u64, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, u64, 8, 3)
+
+OP_AND_FETCH_2 (add,   , +, u16, 2, 1)
+OP_AND_FETCH_2 (sub,   , -, u16, 2, 1)
+OP_AND_FETCH_2 (or,    , |, u16, 2, 1)
+OP_AND_FETCH_2 (and,   , &, u16, 2, 1)
+OP_AND_FETCH_2 (xor,   , ^, u16, 2, 1)
+OP_AND_FETCH_2 (nand, ~, &, u16, 2, 1)
+
+OP_AND_FETCH_2 (add,   , +, u8, 1, 0)
+OP_AND_FETCH_2 (sub,   , -, u8, 1, 0)
+OP_AND_FETCH_2 (or,    , |, u8, 1, 0)
+OP_AND_FETCH_2 (and,   , &, u8, 1, 0)
+OP_AND_FETCH_2 (xor,   , ^, u8, 1, 0)
+OP_AND_FETCH_2 (nand, ~, &, u8, 1, 0)
 
 #define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
   unsigned int HIDDEN							\
@@ -254,9 +262,9 @@ typedef unsigned char bool;
     return (failure == 0);						\
   }
 
-COMPARE_AND_SWAP_2 (long long unsigned int, 8, 3)
-COMPARE_AND_SWAP_2 (short unsigned int, 2, 1)
-COMPARE_AND_SWAP_2 (unsigned char, 1, 0)
+COMPARE_AND_SWAP_2 (u64, 8, 3)
+COMPARE_AND_SWAP_2 (u16, 2, 1)
+COMPARE_AND_SWAP_2 (u8, 1, 0)
 
 unsigned int HIDDEN
 __sync_val_compare_and_swap_4 (volatile void *ptr, unsigned int oldval,
@@ -304,9 +312,9 @@ TYPE HIDDEN								\
     return oldval;							\
   }
 
-SYNC_LOCK_TEST_AND_SET_2 (long long unsigned int, 8, 3)
-SYNC_LOCK_TEST_AND_SET_2 (short unsigned int, 2, 1)
-SYNC_LOCK_TEST_AND_SET_2 (unsigned char, 1, 0)
+SYNC_LOCK_TEST_AND_SET_2 (u64, 8, 3)
+SYNC_LOCK_TEST_AND_SET_2 (u16, 2, 1)
+SYNC_LOCK_TEST_AND_SET_2 (u8, 1, 0)
 
 unsigned int HIDDEN
 __sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
@@ -336,9 +344,9 @@ __sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
     } while (failure != 0);					\
   }
 
-SYNC_LOCK_RELEASE_1 (long long unsigned int, 8, 3)
-SYNC_LOCK_RELEASE_1 (short unsigned int, 2, 1)
-SYNC_LOCK_RELEASE_1 (unsigned char, 1, 0)
+SYNC_LOCK_RELEASE_1 (u64, 8, 3)
+SYNC_LOCK_RELEASE_1 (u16, 2, 1)
+SYNC_LOCK_RELEASE_1 (u8, 1, 0)
 
 void HIDDEN
 __sync_lock_release_4 (volatile void *ptr)
diff --git a/libgcc/config/pa/pa64-hpux-lib.h b/libgcc/config/pa/pa64-hpux-lib.h
index ebe1b51057e..ae1423fcb0e 100644
--- a/libgcc/config/pa/pa64-hpux-lib.h
+++ b/libgcc/config/pa/pa64-hpux-lib.h
@@ -14,8 +14,13 @@ but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
 /* We use DTOR_LIST_BEGIN to carry a bunch of hacks to allow us to use
diff --git a/libgcc/config/pa/t-linux64 b/libgcc/config/pa/t-linux64
index 1d0a6ada1a1..026b48b02e5 100644
--- a/libgcc/config/pa/t-linux64
+++ b/libgcc/config/pa/t-linux64
@@ -1,8 +1,8 @@
 # Plug millicode routines into libgcc.a  We want these on both native and
 # cross compiles.
-# FIXME: Explain.
-LIB1ASMFUNCS := $(filter-out _dyncall, $(LIB1ASMFUNCS))
+LIB1ASMSRC = pa/milli64.S
+LIB1ASMFUNCS = _divI _divU _remI _remU _div_const _mulI
 
-LIB2ADD_ST = $(srcdir)/config/pa/linux-atomic.c
+HOST_LIBGCC2_CFLAGS += -Dpa64=1 -DELF=1 -DLINUX=1
 
-HOST_LIBGCC2_CFLAGS += -Dpa64=1 -DELF=1
+LIB2ADD_ST = $(srcdir)/config/pa/linux-atomic.c
diff --git a/libgcc/config/rs6000/t-linux b/libgcc/config/rs6000/t-linux
index 72e9c2770a6..500210ddaf2 100644
--- a/libgcc/config/rs6000/t-linux
+++ b/libgcc/config/rs6000/t-linux
@@ -11,10 +11,12 @@ HOST_LIBGCC2_CFLAGS += -mno-minimal-toc
 # the IBM extended double format.  Also turn off gnu attributes on the static
 # modules.
 IBM128_STATIC_OBJS	= ibm-ldouble$(objext) _powitf2$(objext) \
-			  ppc64-fp$(objext) _divtc3$(object) _multc3$(object) \
-			  _fixtfdi$(object) _fixunstfdi$(object) \
-	                  _floatditf$(objext) _floatunsditf$(objext)
-IBM128_SHARED_OBJS	= $(IBM128_STATIC_OBJS:$(objext):_s$(objext))
+			  ppc64-fp$(objext) _divtc3$(objext) _multc3$(objext) \
+			  _fixtfdi$(objext) _fixunstfdi$(objext) \
+	                  _floatditf$(objext) _floatunditf$(objext) \
+			  _fixtfti$(objext) _fixunstfti$(objext) \
+	                  _floattitf$(objext) _floatuntitf$(objext)
+IBM128_SHARED_OBJS	= $(IBM128_STATIC_OBJS:$(objext)=_s$(objext))
 IBM128_OBJS		= $(IBM128_STATIC_OBJS) $(IBM128_SHARED_OBJS)
 
 IBM128_CFLAGS		= -Wno-psabi -mabi=ibmlongdouble -mno-gnu-attribute
diff --git a/libgcc/config/rs6000/tramp.S b/libgcc/config/rs6000/tramp.S
index 9b8fcfe34a3..47f97e93e6a 100644
--- a/libgcc/config/rs6000/tramp.S
+++ b/libgcc/config/rs6000/tramp.S
@@ -64,8 +64,7 @@ FUNC_START(__trampoline_setup)
         mflr	r11
         addi	r7,r11,trampoline_initial-4-.LCF0 /* trampoline address -4 */
 
-	li	r8,trampoline_size	/* verify that the trampoline is big enough */
-	cmpw	cr1,r8,r4
+	cmpwi	cr1,r4,trampoline_size	/* verify that the trampoline is big enough */
 	srwi	r4,r4,2		/* # words to move */
 	addi	r9,r3,-4	/* adjust pointer for lwzu */
 	mtctr	r4
@@ -150,8 +149,7 @@ FUNC_START(__trampoline_setup)
 	addis 7,2,.LC0@toc@ha
 	ld 7,.LC0@toc@l(7)	/* trampoline address -8 */
 
-	li	r8,trampoline_size	/* verify that the trampoline is big enough */
-	cmpw	cr1,r8,r4
+	cmpwi	cr1,r4,trampoline_size	/* verify that the trampoline is big enough */
 	srwi	r4,r4,3		/* # doublewords to move */
 	addi	r9,r3,-8	/* adjust pointer for stdu */
 	mtctr	r4
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index 2282350136b..b29c6710987 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,13 @@
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/103634
+	* intrinsics/pack_generic.c (pack_internal): Handle case when the
+	array argument of PACK has one or more extents of size zero to
+	avoid invalid reads.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libgfortran/intrinsics/pack_generic.c b/libgfortran/intrinsics/pack_generic.c
index 9d265f34068..2feaa7730c6 100644
--- a/libgfortran/intrinsics/pack_generic.c
+++ b/libgfortran/intrinsics/pack_generic.c
@@ -85,6 +85,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
 
   index_type count[GFC_MAX_DIMENSIONS];
   index_type extent[GFC_MAX_DIMENSIONS];
+  bool zero_sized;
   index_type n;
   index_type dim;
   index_type nelem;
@@ -114,10 +115,13 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
   else
     runtime_error ("Funny sized logical array");
 
+  zero_sized = false;
   for (n = 0; n < dim; n++)
     {
       count[n] = 0;
       extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);
+      if (extent[n] <= 0)
+	zero_sized = true;
       sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);
       mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);
     }
@@ -126,6 +130,11 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
   if (mstride[0] == 0)
     mstride[0] = mask_kind;
 
+  if (zero_sized)
+    sptr = NULL;
+  else
+    sptr = array->base_addr;
+
   if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))
     {
       /* Count the elements, either for allocating memory or
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index f76d32e398c..d483bb4de8a 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,30 @@
+2021-05-06  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backported from master:
+	2021-04-30  Roman Zhuykov  <zhroma@ispras.ru>
+
+	* testsuite/libgomp.oacc-c-c++-common/atomic_capture-3.c: New test.
+
+2021-04-18  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	Backported from master:
+	2021-04-11  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	PR middle-end/98088
+	* testsuite/libgomp.oacc-c-c++-common/collapse-2.c: Add check
+	for loop with GT/GE condition.
+	* testsuite/libgomp.oacc-c-c++-common/collapse-3.c: Likewise.
+
+2021-04-09  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-04-09  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/84991
+	PR middle-end/84992
+	PR middle-end/90779
+	* testsuite/libgomp.oacc-c-c++-common/static-variable-1.c: New.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_capture-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_capture-3.c
new file mode 100644
index 00000000000..b976094998f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_capture-3.c
@@ -0,0 +1,1627 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fmodulo-sched -fmodulo-sched-allow-regmoves" } */
+
+#include <stdlib.h>
+
+int
+main(int argc, char **argv)
+{
+  int   iexp, igot, imax, imin;
+  long long lexp, lgot;
+  int   N = 32;
+  int	i;
+  int   idata[N];
+  long long ldata[N];
+  float fexp, fgot;
+  float fdata[N];
+
+  igot = 1234;
+  iexp = 31;
+
+  for (i = 0; i < N; i++)
+    idata[i] = i;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { idata[i] = igot; igot = i; }
+  }
+
+  imax = 0;
+  imin = N;
+
+  for (i = 0; i < N; i++)
+    {
+      imax = idata[i] > imax ? idata[i] : imax;
+      imin = idata[i] < imin ? idata[i] : imin;
+    }
+
+  if (imax != 1234 || imin != 0)
+    abort ();
+
+  return 0;
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { idata[i] = igot; igot++; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { idata[i] = igot; ++igot; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { ++igot; idata[i] = igot; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { igot++; idata[i] = igot; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 32;
+  iexp = 0;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { idata[i] = igot; igot--; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 32;
+  iexp = 0;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { idata[i] = igot; --igot; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 32;
+  iexp = 0;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { --igot; idata[i] = igot; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 32;
+  iexp = 0;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+#pragma acc atomic capture
+      { igot--; idata[i] = igot; }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  /* BINOP = + */
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { idata[i] = igot; igot += expr; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { igot += expr; idata[i] = igot; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { idata[i] = igot; igot = igot + expr; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { idata[i] = igot; igot = expr + igot; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { igot = igot + expr; idata[i] = igot; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+
+  igot = 0;
+  iexp = 32;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { igot = expr + igot; idata[i] = igot; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  /* BINOP = * */
+  lgot = 1LL;
+  lexp = 1LL << 32;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = 2LL;
+
+#pragma acc atomic capture
+      { ldata[i] = lgot; lgot *= expr; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << 32;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 2LL;
+
+#pragma acc atomic capture
+        { lgot *= expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << 32;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 2LL;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = lgot * expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << 32;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = 2LL;
+
+#pragma acc atomic capture
+      { ldata[i] = lgot; lgot = expr * lgot; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << 32;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 2LL;
+
+#pragma acc atomic capture
+        { lgot = lgot * expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << 32;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = 2;
+
+#pragma acc atomic capture
+      { lgot = expr * lgot; ldata[i] = lgot; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  /* BINOP = - */
+  igot = 32;
+  iexp = 0;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      int expr = 1;
+
+#pragma acc atomic capture
+      { idata[i] = igot; igot -= expr; }
+    }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 32;
+  iexp = 0;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { igot -= expr; idata[i] = igot; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 32;
+  iexp = 0;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { idata[i] = igot; igot = igot - expr; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 1;
+  iexp = 1;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      int expr = 1;
+
+#pragma acc atomic capture
+      { idata[i] = igot; igot = expr - igot; }
+    }
+  }
+
+  for (i = 0; i < N; i++)
+    if (i % 2 == 0)
+      {
+	if (idata[i] != 1)
+	  abort ();
+      }
+    else
+      {
+	if (idata[i] != 0)
+	  abort ();
+      }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 1;
+  iexp = -31;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { igot = igot - expr; idata[i] = igot; }
+      }
+  }
+
+  if (iexp != igot)
+    abort ();
+
+  igot = 1;
+  iexp = 1;
+
+#pragma acc data copy (igot, idata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        int expr = 1;
+
+#pragma acc atomic capture
+        { igot = expr - igot; idata[i] = igot; }
+      }
+  }
+
+  for (i = 0; i < N; i++)
+    if (i % 2 == 0)
+      {
+	if (idata[i] != 0)
+	  abort ();
+      }
+    else
+      {
+	if (idata[i] != 1)
+	  abort ();
+      }
+
+  if (iexp != igot)
+    abort ();
+
+  /* BINOP = / */
+  lgot = 1LL << 32;
+  lexp = 1LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 2LL;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot /= expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL << 32;
+  lexp = 1LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 2LL;
+
+#pragma acc atomic capture
+        { lgot /= expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL << 32;
+  lexp = 1LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = 2LL;
+
+#pragma acc atomic capture
+      { ldata[i] = lgot; lgot = lgot / expr; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 2LL;
+  lexp = 2LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL << N;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = expr / lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 2LL;
+  lexp = 2LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL << N;
+
+#pragma acc atomic capture
+        { lgot = lgot / expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 2LL;
+  lexp = 2LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL << N;
+
+#pragma acc atomic capture
+        { lgot = expr / lgot; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  /* BINOP = & */
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot &= expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  iexp = 0LL; 
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot &= expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = lgot & expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = expr & lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  iexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot = lgot & expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+      { lgot = expr & lgot; ldata[i] = lgot; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  /* BINOP = ^ */
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = 1 << i;
+
+#pragma acc atomic capture
+      { ldata[i] = lgot; lgot ^= expr; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  iexp = 0LL; 
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot ^= expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = lgot ^ expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+      { ldata[i] = lgot; lgot = expr ^ lgot; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  iexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot = lgot ^ expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = ~0LL;
+  lexp = 0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot = expr ^ lgot; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  /* BINOP = | */
+  lgot = 0LL;
+  lexp = ~0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1 << i;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot |= expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 0LL;
+  iexp = ~0LL; 
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot |= expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 0LL;
+  lexp = ~0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = lgot | expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 0LL;
+  lexp = ~0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = expr | lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 0LL;
+  iexp = ~0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot = lgot | expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 0LL;
+  lexp = ~0LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = ~(1 << i);
+
+#pragma acc atomic capture
+        { lgot = expr | lgot; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  /* BINOP = << */
+  lgot = 1LL;
+  lexp = 1LL << N;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot <<= expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  iexp = 1LL << N; 
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { lgot <<= expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << N;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = lgot << expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 2LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < 1; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = expr << lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 2LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < 1; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { lgot = lgot << expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 2LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < 1; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { lgot = expr << lgot; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  /* BINOP = >> */
+  lgot = 1LL << N;
+  lexp = 1LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL;
+  
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot >>= expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL << N;
+  iexp = 1LL; 
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { lgot >>= expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL << N;
+  lexp = 1LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = lgot >> expr; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << (N - 1);
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < 1; i++)
+      {
+        long long expr = 1LL << N;
+
+#pragma acc atomic capture
+        { ldata[i] = lgot; lgot = expr >> lgot; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL << N;
+  lexp = 1LL;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL;
+
+#pragma acc atomic capture
+        { lgot = lgot >> expr; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << (N - 1);
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < 1; i++)
+      {
+        long long expr = 1LL << N;
+
+#pragma acc atomic capture
+        { lgot = expr >> lgot; ldata[i] = lgot; }
+      }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  // FLOAT FLOAT FLOAT
+
+  /* BINOP = + */
+  fgot = 0.0;
+  fexp = 32.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      float expr = 1.0;
+
+#pragma acc atomic capture
+      { fdata[i] = fgot; fgot += expr; }
+    }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 0.0;
+  fexp = 32.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fgot += expr; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 0.0;
+  fexp = 32.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { idata[i] = fgot; fgot = fgot + expr; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 0.0;
+  fexp = 32.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      float expr = 1.0;
+
+#pragma acc atomic capture
+      { fdata[i] = fgot; fgot = expr + fgot; }
+    }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 0.0;
+  fexp = 32.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fgot = fgot + expr; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 0.0;
+  fexp = 32.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fgot = expr + fgot; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  /* BINOP = * */
+  fgot = 1.0;
+  fexp = 8192.0*8192.0*64.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      float expr = 2.0;
+
+#pragma acc atomic capture
+      { fdata[i] = fgot; fgot *= expr; }
+    }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 1.0;
+  fexp = 8192.0*8192.0*64.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 2.0;
+
+#pragma acc atomic capture
+        { fgot *= expr; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 1.0;
+  fexp = 8192.0*8192.0*64.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 2.0;
+
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot = fgot * expr; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 1.0;
+  fexp = 8192.0*8192.0*64.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 2.0;
+
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot = expr * fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  lgot = 1LL;
+  lexp = 1LL << 32;
+
+#pragma acc data copy (lgot, ldata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      long long expr = 2LL;
+
+#pragma acc atomic capture
+      { lgot = lgot * expr; ldata[i] = lgot; }
+    }
+  }
+
+  if (lexp != lgot)
+    abort ();
+
+  fgot = 1.0;
+  fexp = 8192.0*8192.0*64.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 2;
+
+#pragma acc atomic capture
+        { fgot = expr * fgot; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  /* BINOP = - */
+  fgot = 32.0;
+  fexp = 0.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+  
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot -= expr; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 32.0;
+  fexp = 0.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+      float expr = 1.0;
+
+#pragma acc atomic capture
+      { fgot -= expr; fdata[i] = fgot; }
+    }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 32.0;
+  fexp = 0.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot = fgot - expr; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 1.0;
+  fexp = 1.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot = expr - fgot; }
+      }
+  }
+
+  for (i = 0; i < N; i++)
+    if (i % 2 == 0)
+      {
+	if (fdata[i] != 1.0)
+	  abort ();
+      }
+    else
+      {
+	if (fdata[i] != 0.0)
+	  abort ();
+      }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 1.0;
+  fexp = -31.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fgot = fgot - expr; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 1.0;
+  fexp = 1.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fgot = expr - fgot; fdata[i] = fgot; }
+      }
+  }
+
+  for (i = 0; i < N; i++)
+    if (i % 2 == 0)
+      {
+	if (fdata[i] != 0.0)
+	  abort ();
+      }
+    else
+      {
+	if (fdata[i] != 1.0)
+	  abort ();
+      }
+
+  if (fexp != fgot)
+    abort ();
+
+  /* BINOP = / */
+  fgot = 8192.0*8192.0*64.0;
+  fexp = 1.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 2.0;
+
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot /= expr; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 8192.0*8192.0*64.0;
+  fexp = 1.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 2.0;
+
+#pragma acc atomic capture
+        { fgot /= expr; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 8192.0*8192.0*64.0;
+  fexp = 1.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 2.0;
+
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot = fgot / expr; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 8192.0*8192.0*64.0;
+  fexp = 1.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 1.0;
+
+#pragma acc atomic capture
+        { fdata[i] = fgot; fgot = expr / fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 4.0;
+  fexp = 4.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        long long expr = 1LL << N;
+
+#pragma acc atomic capture
+        { fgot = fgot / expr; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  fgot = 4.0;
+  fexp = 4.0;
+
+#pragma acc data copy (fgot, fdata[0:N])
+  {
+#pragma acc parallel loop
+    for (i = 0; i < N; i++)
+      {
+        float expr = 2.0;
+
+#pragma acc atomic capture
+        { fgot = expr / fgot; fdata[i] = fgot; }
+      }
+  }
+
+  if (fexp != fgot)
+    abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c
index 1ea0a6b846d..7a8cfd2f3d4 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c
@@ -5,7 +5,7 @@
 int
 main (void)
 {
-  int i, j, k, l = 0, f = 0, x = 0;
+  int i, j, k, l = 0, f = 0, x = 0, l2 = 0;
   int m1 = 4, m2 = -5, m3 = 17;
 
 #pragma acc parallel
@@ -20,6 +20,19 @@ main (void)
 	    }
 	}
 
+  /*  Test loop with > condition.  */
+#pragma acc parallel
+  #pragma acc loop seq collapse(3) reduction(+:l2)
+    for (i = -2; i < m1; i++)
+      for (j = -3; j > (m2 - 1); j--)
+	{
+	  for (k = 13; k < m3; k++)
+	    {
+	      if ((i + 2) * 12 + (j + 5) * 4 + (k - 13) !=  9 + f++)
+		l2++;
+	    }
+	}
+
     for (i = -2; i < m1; i++)
       for (j = m2; j < -2; j++)
 	{
@@ -30,7 +43,7 @@ main (void)
 	    }
 	}
 
-  if (l != x)
+  if (l != x || l2 != x)
     abort ();
 
   return 0;
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c
index 680042892e4..50f538d0a32 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c
@@ -7,7 +7,7 @@
 int
 main (void)
 {
-  int i2, l = 0, r = 0;
+  int i2, l = 0, r = 0, l2 = 0;
   int a[3][3][3];
 
   memset (a, '\0', sizeof (a));
@@ -27,13 +27,24 @@ main (void)
 		l += 1;
     }
 
+  /*  Test loop with >= condition.  */
+#pragma acc parallel
+    {
+      #pragma acc loop collapse(2) reduction(|:l2)
+	for (i2 = 0; i2 < 2; i2++)
+	  for (int j = 1; j >= 0; j--)
+	    for (int k = 0; k < 2; k++)
+	      if (a[i2][j][k] != i2 + j * 4 + k * 16)
+		l2 += 1;
+    }
+
     for (i2 = 0; i2 < 2; i2++)
       for (int j = 0; j < 2; j++)
 	for (int k = 0; k < 2; k++)
 	  if (a[i2][j][k] != i2 + j * 4 + k * 16)
 	    r += 1;
 
-  if (l != r)
+  if (l != r || l2 != r)
     abort ();
   return 0;
 }
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/static-variable-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/static-variable-1.c
new file mode 100644
index 00000000000..1d415cdcf76
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/static-variable-1.c
@@ -0,0 +1,460 @@
+/* "Function scope" (top-level block scope) 'static' variables
+
+   ... inside OpenACC compute construct regions as well as OpenACC 'routine'.
+
+   This is to document/verify aspects of GCC's observed behavior, not
+   necessarily as it's (intended to be?) restricted by the OpenACC
+   specification.  See also PR84991, PR84992, PR90779 etc., and
+   <https://github.com/OpenACC/openacc-spec/issues/372> "C/C++ 'static'
+   variables" (only visible to members of the GitHub OpenACC organization).
+*/
+
+
+#undef NDEBUG
+#include <assert.h>
+#include <string.h>
+#include <openacc.h>
+#include <gomp-constants.h>
+
+
+#define IF_DEBUG if (0)
+
+
+/* Without explicit 'num_gangs'.  */
+
+static void t0_c(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 11;
+  const int var_init = 16;
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result = 0;
+      int num_gangs_actual = -1;
+#pragma acc parallel \
+  reduction(max:num_gangs_actual) \
+  reduction(max:result)
+      {
+	num_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);
+
+	static int var = var_init;
+
+#pragma acc atomic capture
+	result = ++var;
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result'.  */
+      }
+      /* Without an explicit 'num_gangs' clause GCC assigns 'num_gangs(1)'
+	 because it doesn't see any use of gang-level parallelism inside the
+	 region.  */
+      assert(num_gangs_actual == 1);
+      assert(result == var_init + num_gangs_actual * (1 + i));
+    }
+}
+
+
+/* Call a gang-level routine.  */
+
+static const int t0_r_var_init = 61;
+
+#pragma acc routine gang
+__attribute__((noinline))
+static int t0_r_r(void)
+{
+  static int var = t0_r_var_init;
+
+  int tmp;
+#pragma acc atomic capture
+  tmp = ++var;
+
+  return tmp;
+}
+
+static void t0_r(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 11;
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result = 0;
+      int num_gangs_actual = -1;
+#pragma acc parallel \
+  reduction(max:num_gangs_actual) \
+  reduction(max:result)
+      {
+	num_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);
+
+	result = t0_r_r();
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result'.  */
+      }
+      /* The number of gangs selected by the implemention ought to but must not
+	 be bigger than one.  */
+      IF_DEBUG
+	__builtin_printf ("%d: num_gangs_actual: %d\n", i, num_gangs_actual);
+      assert(num_gangs_actual >= 1);
+      assert(result == t0_r_var_init + num_gangs_actual * (1 + i));
+    }
+}
+
+
+/* Explicit 'num_gangs'.  */
+
+static void t1_c(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 22;
+  const int num_gangs_request = 444;
+  const int var_init = 5;
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result = 0;
+      int num_gangs_actual = -1;
+#pragma acc parallel \
+  num_gangs(num_gangs_request) \
+  reduction(max:num_gangs_actual) \
+  reduction(max:result)
+      {
+	num_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);
+
+	static int var = var_init;
+
+#pragma acc atomic capture
+	result = ++var;
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result'.  */
+      }
+      if (acc_get_device_type() == acc_device_host)
+	assert(num_gangs_actual == 1);
+      else
+	assert(num_gangs_actual == num_gangs_request);
+      assert(result == var_init + num_gangs_actual * (1 + i));
+    }
+}
+
+
+/* Check the same routine called from two compute constructs.  */
+
+static const int t1_r2_var_init = 166;
+
+#pragma acc routine gang
+__attribute__((noinline))
+static int t1_r2_r(void)
+{
+  static int var = t1_r2_var_init;
+
+  int tmp;
+#pragma acc atomic capture
+  tmp = ++var;
+
+  return tmp;
+}
+
+static void t1_r2(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 71;
+  /* The checking assumes the same 'num_gangs' for all compute constructs.  */
+  const int num_gangs_request = 333;
+  int num_gangs_actual = -1;
+  if (acc_get_device_type() == acc_device_host)
+    num_gangs_actual = 1;
+  else
+    {
+      /* We're assuming that the implementation is able to accomodate the
+	 'num_gangs' requested (which really ought to be true for
+	 'num_gangs').  */
+      num_gangs_actual = num_gangs_request;
+    }
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result_1 = 0;
+#pragma acc parallel \
+  num_gangs(num_gangs_request) \
+  reduction(max:result_1)
+      {
+	result_1 = t1_r2_r();
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result_1'.  */
+      }
+      IF_DEBUG
+	__builtin_printf ("%d: result_1: %d\n", i, result_1);
+      assert(result_1 == t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 0)));
+
+      int result_2 = 0;
+#pragma acc parallel \
+  num_gangs(num_gangs_request) \
+  reduction(max:result_2)
+      {
+	result_2 = t1_r2_r() + t1_r2_r();
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented '2 * num_gangs_actual' times.
+	   However, the order of the two 't1_r2_r' function calls is not
+	   synchronized (between different gang-redundant threads).  We thus
+	   cannot verify the actual 'result_2' values in this case.  */
+      }
+      IF_DEBUG
+	__builtin_printf ("%d: result_2: %d\n", i, result_2);
+      if (num_gangs_actual == 1)
+	/* Per the rationale above, only in this case we can check the actual
+	   result.  */
+	assert(result_2 == (t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 1))
+			    + t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 2))));
+      /* But we can generally check low and high limits.  */
+      {
+	/* Must be bigger than '2 * result_1'.  */
+	int c = 2 * result_1;
+	IF_DEBUG
+	  __builtin_printf ("  > %d\n", c);
+	assert(result_2 > c);
+      }
+      {
+	/* ..., but limited by the base value for next 'i'.  */
+	int c = 2 * (t1_r2_var_init + num_gangs_actual * (0 + ((i + 1) * 3 + 0)));
+	IF_DEBUG
+	  __builtin_printf ("  < %d\n", c);
+	assert(result_2 < c);
+      }
+    }
+}
+
+
+/* Asynchronous execution.  */
+
+static const int t2_var_init_2 = -55;
+
+#pragma acc routine gang
+__attribute__((noinline))
+static int t2_r(void)
+{
+  static int var = t2_var_init_2;
+
+  int tmp;
+#pragma acc atomic capture
+  tmp = ++var;
+
+  return tmp;
+}
+
+static void t2(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 12;
+  const int num_gangs_request_1 = 14;
+  const int var_init_1 = 5;
+  int results_1[i_limit][num_gangs_request_1];
+  memset (results_1, 0, sizeof results_1);
+  const int num_gangs_request_2 = 5;
+  int results_2[i_limit][num_gangs_request_2];
+  memset (results_2, 0, sizeof results_2);
+  const int num_gangs_request_3 = 34;
+  const int var_init_3 = 1250;
+  int results_3[i_limit][num_gangs_request_3];
+  memset (results_3, 0, sizeof results_3);
+
+#pragma acc data \
+  copy(results_1, results_2, results_3)
+  {
+    for (int i = 0; i < i_limit; ++i)
+      {
+	/* The following 'async' clauses effect asynchronous execution, but
+	   using the same async-argument for each compute construct implies that
+	   the respective compute constructs' execution is synchronized with
+	   itself, meaning that all 'i = 0' execution has finished (on the
+	   device) before 'i = 1' is started (on the device), etc.  */
+
+#pragma acc parallel \
+  present(results_1) \
+  num_gangs(num_gangs_request_1) \
+  async(1)
+	{
+	  static int var = var_init_1;
+
+	  int tmp;
+#pragma acc atomic capture
+	  tmp = ++var;
+
+	  results_1[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += tmp;
+	}
+
+#pragma acc parallel \
+  present(results_2) \
+  num_gangs(num_gangs_request_2) \
+  async(2)
+	{
+	  results_2[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += t2_r();
+	}
+
+#pragma acc parallel \
+  present(results_3) \
+  num_gangs(num_gangs_request_3) \
+  async(3)
+	{
+	  static int var = var_init_3;
+
+	  int tmp;
+#pragma acc atomic capture
+	  tmp = ++var;
+
+	  results_3[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += tmp;
+	}
+      }
+#pragma acc wait
+  }
+  int num_gangs_actual_1;
+  int num_gangs_actual_2;
+  int num_gangs_actual_3;
+  if (acc_get_device_type() == acc_device_host)
+    {
+      num_gangs_actual_1 = 1;
+      num_gangs_actual_2 = 1;
+      num_gangs_actual_3 = 1;
+    }
+  else
+    {
+      /* We're assuming that the implementation is able to accomodate the
+	 'num_gangs' requested (which really ought to be true for
+	 'num_gangs').  */
+      num_gangs_actual_1 = num_gangs_request_1;
+      num_gangs_actual_2 = num_gangs_request_2;
+      num_gangs_actual_3 = num_gangs_request_3;
+    }
+
+  /* For 'i = 0', 'results_*[i][0..num_gangs_actual_*]' are expected to each
+     contain one value of '(1 + var_init_*)..(var_init_* + num_gangs_actual_*)',
+     and so on for increasing 'i'.  Their order however is unspecified due to
+     the gang-redundant execution.  (Thus checking that their sums match.)  */
+
+  int result_1 = 0;
+  int result_2 = 0;
+  int result_3 = 0;
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result_1_ = 0;
+      for (int g = 0; g < num_gangs_actual_1; ++g)
+	{
+	  IF_DEBUG
+	    __builtin_printf ("results_1[%d][%d]: %d\n", i, g, results_1[i][g]);
+	  result_1_ += results_1[i][g];
+	}
+      IF_DEBUG
+	__builtin_printf ("%d result_1_: %d\n", i, result_1_);
+      assert (result_1_ == (((var_init_1 + num_gangs_actual_1 * (1 + i)) * (1 + var_init_1 + num_gangs_actual_1 * (1 + i)) / 2)
+			    - ((var_init_1 + num_gangs_actual_1 * (0 + i)) * (1 + var_init_1 + num_gangs_actual_1 * (0 + i)) / 2)));
+      result_1 += result_1_;
+
+      int result_2_ = 0;
+      for (int g = 0; g < num_gangs_actual_2; ++g)
+	{
+	  IF_DEBUG
+	    __builtin_printf ("results_2[%d][%d]: %d\n", i, g, results_2[i][g]);
+	  result_2_ += results_2[i][g];
+	}
+      IF_DEBUG
+	__builtin_printf ("%d result_2_: %d\n", i, result_2_);
+      assert (result_2_ == (((t2_var_init_2 + num_gangs_actual_2 * (1 + i)) * (1 + t2_var_init_2 + num_gangs_actual_2 * (1 + i)) / 2)
+			    - ((t2_var_init_2 + num_gangs_actual_2 * (0 + i)) * (1 + t2_var_init_2 + num_gangs_actual_2 * (0 + i)) / 2)));
+      result_2 += result_2_;
+
+      int result_3_ = 0;
+      for (int g = 0; g < num_gangs_actual_3; ++g)
+	{
+	  IF_DEBUG
+	    __builtin_printf ("results_3[%d][%d]: %d\n", i, g, results_3[i][g]);
+	  result_3_ += results_3[i][g];
+	}
+      IF_DEBUG
+	__builtin_printf ("%d result_3_: %d\n", i, result_3_);
+      assert (result_3_ == (((var_init_3 + num_gangs_actual_3 * (1 + i)) * (1 + var_init_3 + num_gangs_actual_3 * (1 + i)) / 2)
+			    - ((var_init_3 + num_gangs_actual_3 * (0 + i)) * (1 + var_init_3 + num_gangs_actual_3 * (0 + i)) / 2)));
+      result_3 += result_3_;
+    }
+  IF_DEBUG
+    __builtin_printf ("result_1: %d\n", result_1);
+  assert (result_1 == (((var_init_1 + num_gangs_actual_1 * i_limit) * (1 + var_init_1 + num_gangs_actual_1 * i_limit) / 2)
+		       - (var_init_1 * (var_init_1 + 1) / 2)));
+  IF_DEBUG
+    __builtin_printf ("result_2: %d\n", result_2);
+  assert (result_2 == (((t2_var_init_2 + num_gangs_actual_2 * i_limit) * (1 + t2_var_init_2 + num_gangs_actual_2 * i_limit) / 2)
+		       - (t2_var_init_2 * (t2_var_init_2 + 1) / 2)));
+  IF_DEBUG
+    __builtin_printf ("result_3: %d\n", result_3);
+  assert (result_3 == (((var_init_3 + num_gangs_actual_3 * i_limit) * (1 + var_init_3 + num_gangs_actual_3 * i_limit) / 2)
+		       - (var_init_3 * (var_init_3 + 1) / 2)));
+}
+
+
+#pragma acc routine seq
+__attribute__((noinline))
+static int pr84991_1_r_s(int n)
+{
+  static const int test[] = {1,2,3,4};
+  return test[n];
+}
+
+static void pr84991_1(void)
+{
+  int n[1];
+  n[0] = 3;
+#pragma acc parallel copy(n)
+  {
+    n[0] = pr84991_1_r_s(n[0]);
+  }
+  assert(n[0] == 4);
+}
+
+
+static void pr84992_1(void)
+{
+  int n[1];
+  n[0] = 3;
+#pragma acc parallel copy(n)
+  {
+    static const int test[] = {1,2,3,4};
+    n[0] = test[n[0]];
+  }
+  assert(n[0] == 4);
+}
+
+
+int main(void)
+{
+  t0_c();
+
+  t0_r();
+
+  t1_c();
+
+  t1_r2();
+
+  t2();
+
+  pr84991_1();
+
+  pr84992_1();
+
+  return 0;
+}
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index 97ead0843e9..3be0ec8af29 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,11 @@
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* testsuite/libitm.c++/libstdc++-pr91488.C: New test.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libitm/testsuite/libitm.c++/libstdc++-pr91488.C b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
new file mode 100644
index 00000000000..e9e82bd1ce2
--- /dev/null
+++ b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
@@ -0,0 +1,9 @@
+// PR libstdc++/91488 "inlining failed in call to always_inline"
+// { dg-do run }
+// { dg-additional-options "-O1" }
+
+#include <string>
+
+int main() {
+    return std::char_traits<char>::length("");
+}
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index 053809c0ea7..01d89f1ef97 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,46 @@
+2021-12-21  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-21  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/103604
+	* libdruntime/core/sys/posix/sys/stat.d (struct stat_t): Fix
+	definition for MIPS64.
+
+2021-12-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/core/thread.d (callWithStackShell): Push all callee-save
+	registers on the stack using inline assembly.
+
+2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/core/thread.d (defaultStackPages): New constant.
+	(Fiber.this): Set stack size to be a multiple of defaultStackPages.
+
+2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Don't remove entry
+	from global array.
+	(_d_emutls_destroy): Don't call __gthread_key_delete.
+
+2021-06-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100999
+	* src/std/typecons.d (template Proxy): Check for field or property
+	functions as the else branch.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libphobos/libdruntime/core/sys/posix/sys/stat.d b/libphobos/libdruntime/core/sys/posix/sys/stat.d
index b154e1489a6..6c51144ba9f 100644
--- a/libphobos/libdruntime/core/sys/posix/sys/stat.d
+++ b/libphobos/libdruntime/core/sys/posix/sys/stat.d
@@ -337,26 +337,23 @@ version (CRuntime_Glibc)
             }
             c_long[14]  st_pad5;
         }
+        static if (!__USE_FILE_OFFSET64)
+            static assert(stat_t.sizeof == 144);
+        else
+            static assert(stat_t.sizeof == 160);
     }
     else version (MIPS64)
     {
         struct stat_t
         {
-            c_ulong     st_dev;
+            dev_t       st_dev;
             int[3]      st_pad1;
-            static if (!__USE_FILE_OFFSET64)
-            {
-                ino_t       st_ino;
-            }
-            else
-            {
-                c_ulong     st_ino;
-            }
+            ino_t       st_ino;
             mode_t      st_mode;
             nlink_t     st_nlink;
             uid_t       st_uid;
             gid_t       st_gid;
-            c_ulong     st_rdev;
+            dev_t       st_rdev;
             static if (!__USE_FILE_OFFSET64)
             {
                 uint[2]     st_pad2;
@@ -365,8 +362,8 @@ version (CRuntime_Glibc)
             }
             else
             {
-                c_long[3]   st_pad2;
-                c_long      st_size;
+                uint[3]     st_pad2;
+                off_t       st_size;
             }
             static if (__USE_MISC || __USE_XOPEN2K8)
             {
@@ -391,15 +388,26 @@ version (CRuntime_Glibc)
             }
             blksize_t   st_blksize;
             uint        st_pad4;
+            blkcnt_t    st_blocks;
+            int[14]     st_pad5;
+        }
+        version (MIPS_N32)
+        {
             static if (!__USE_FILE_OFFSET64)
-            {
-                blkcnt_t    st_blocks;
-            }
+                static assert(stat_t.sizeof == 160);
             else
-            {
-                c_long  st_blocks;
-            }
-            c_long[14]  st_pad5;
+                static assert(stat_t.sizeof == 176);
+        }
+        else version (MIPS_O64)
+        {
+            static if (!__USE_FILE_OFFSET64)
+                static assert(stat_t.sizeof == 160);
+            else
+                static assert(stat_t.sizeof == 176);
+        }
+        else
+        {
+            static assert(stat_t.sizeof == 216);
         }
     }
     else version (PPC)
diff --git a/libphobos/libdruntime/core/thread.d b/libphobos/libdruntime/core/thread.d
index e1a68057ca1..3570e3fdc98 100644
--- a/libphobos/libdruntime/core/thread.d
+++ b/libphobos/libdruntime/core/thread.d
@@ -2422,8 +2422,107 @@ body
 
     version (GNU)
     {
-        __builtin_unwind_init();
-        sp = &sp;
+        // The generic solution below using a call to __builtin_unwind_init ()
+        // followed by an assignment to sp has two issues:
+        // 1) On some archs it stores a huge amount of FP and Vector state which
+        //    is not the subject of the scan - and, indeed might produce false
+        //    hits.
+        // 2) Even on archs like X86, where there are no callee-saved FPRs/VRs there
+        //    tend to be 'holes' in the frame allocations (to deal with alignment) which
+        //    also will  contain random data which could produce false positives.
+        // This solution stores only the integer callee-saved registers.
+        version (X86)
+        {
+            void*[3] regs = void;
+            asm pure nothrow @nogc
+            {
+                "movl   %%ebx, %0" : "=m" (regs[0]);
+                "movl   %%esi, %0" : "=m" (regs[1]);
+                "movl   %%edi, %0" : "=m" (regs[2]);
+            }
+            sp = cast(void*)&regs[0];
+        }
+        else version (X86_64)
+        {
+            void*[5] regs = void;
+            asm pure nothrow @nogc
+            {
+                "movq   %%rbx, %0" : "=m" (regs[0]);
+                "movq   %%r12, %0" : "=m" (regs[1]);
+                "movq   %%r13, %0" : "=m" (regs[2]);
+                "movq   %%r14, %0" : "=m" (regs[3]);
+                "movq   %%r15, %0" : "=m" (regs[4]);
+            }
+            sp = cast(void*)&regs[0];
+        }
+        else version (PPC)
+        {
+            void*[19] regs = void;
+            version (Darwin)
+                enum regname = "r";
+            else
+                enum regname = "";
+            static foreach (i; 0 .. regs.length)
+            {{
+                enum int j = 13 + i; // source register
+                asm pure nothrow @nogc
+                {
+                    "stw "~regname~j.stringof~", %0" : "=m" (regs[i]);
+                }
+            }}
+            sp = cast(void*)&regs[0];
+        }
+        else version (PPC64)
+        {
+            void*[19] regs = void;
+            version (Darwin)
+                enum regname = "r";
+            else
+                enum regname = "";
+            static foreach (i; 0 .. regs.length)
+            {{
+                enum int j = 13 + i; // source register
+                asm pure nothrow @nogc
+                {
+                    "std "~regname~j.stringof~", %0" : "=m" (regs[i]);
+                }
+            }}
+            sp = cast(void*)&regs[0];
+        }
+        else version (AArch64)
+        {
+            // Callee-save registers, x19-x28 according to AAPCS64, section
+            // 5.1.1.  Include x29 fp because it optionally can be a callee
+            // saved reg
+            size_t[11] regs = void;
+            // store the registers in pairs
+            asm pure nothrow @nogc
+            {
+                "stp x19, x20, %0" : "=m" (regs[ 0]), "=m" (regs[1]);
+                "stp x21, x22, %0" : "=m" (regs[ 2]), "=m" (regs[3]);
+                "stp x23, x24, %0" : "=m" (regs[ 4]), "=m" (regs[5]);
+                "stp x25, x26, %0" : "=m" (regs[ 6]), "=m" (regs[7]);
+                "stp x27, x28, %0" : "=m" (regs[ 8]), "=m" (regs[9]);
+                "str x29, %0"      : "=m" (regs[10]);
+                "mov %0, sp"       : "=r" (sp);
+            }
+        }
+        else version (ARM)
+        {
+            // Callee-save registers, according to AAPCS, section 5.1.1.
+            // arm and thumb2 instructions
+            size_t[8] regs = void;
+            asm pure nothrow @nogc
+            {
+                "stm %0, {r4-r11}" : : "r" (regs.ptr) : "memory";
+                "mov %0, sp"       : "=r" (sp);
+            }
+        }
+        else
+        {
+            __builtin_unwind_init();
+            sp = &sp;
+        }
     }
     else version (AsmX86_Posix)
     {
@@ -4146,6 +4245,24 @@ class Fiber
     // Initialization
     ///////////////////////////////////////////////////////////////////////////
 
+    version (Windows)
+        // exception handling walks the stack, invoking DbgHelp.dll which
+        // needs up to 16k of stack space depending on the version of DbgHelp.dll,
+        // the existence of debug symbols and other conditions. Avoid causing
+        // stack overflows by defaulting to a larger stack size
+        enum defaultStackPages = 8;
+    else version (OSX)
+    {
+        version (X86_64)
+            // libunwind on macOS 11 now requires more stack space than 16k, so
+            // default to a larger stack size. This is only applied to X86 as
+            // the PAGESIZE is still 4k, however on AArch64 it is 16k.
+            enum defaultStackPages = 8;
+        else
+            enum defaultStackPages = 4;
+    }
+    else
+        enum defaultStackPages = 4;
 
     /**
      * Initializes a fiber object which is associated with a static
@@ -4160,7 +4277,7 @@ class Fiber
      * In:
      *  fn must not be null.
      */
-    this( void function() fn, size_t sz = PAGESIZE*4,
+    this( void function() fn, size_t sz = PAGESIZE * defaultStackPages,
           size_t guardPageSize = PAGESIZE ) nothrow
     in
     {
@@ -4186,7 +4303,7 @@ class Fiber
      * In:
      *  dg must not be null.
      */
-    this( void delegate() dg, size_t sz = PAGESIZE*4,
+    this( void delegate() dg, size_t sz = PAGESIZE * defaultStackPages,
           size_t guardPageSize = PAGESIZE ) nothrow
     in
     {
diff --git a/libphobos/libdruntime/gcc/emutls.d b/libphobos/libdruntime/gcc/emutls.d
index 1436cdb35a5..7e4a1d6f8de 100644
--- a/libphobos/libdruntime/gcc/emutls.d
+++ b/libphobos/libdruntime/gcc/emutls.d
@@ -229,9 +229,6 @@ void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc
 extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
 {
     auto arr = cast(TlsArray*) ptr;
-    emutlsMutex.lock_nothrow();
-    emutlsArrays.remove(arr);
-    emutlsMutex.unlock_nothrow();
 
     foreach (entry; *arr)
     {
@@ -308,9 +305,6 @@ void _d_emutls_scan(scope void delegate(void* pbeg, void* pend) nothrow cb) noth
 // Call this after druntime has been unloaded
 void _d_emutls_destroy() nothrow @nogc
 {
-    if (__gthread_key_delete(emutlsKey) != 0)
-        abort();
-
     (cast(Mutex) _emutlsMutex.ptr).__dtor();
     destroy(emutlsArrays);
 }
diff --git a/libphobos/src/std/typecons.d b/libphobos/src/std/typecons.d
index a63227cee8b..e0a9ad6c519 100644
--- a/libphobos/src/std/typecons.d
+++ b/libphobos/src/std/typecons.d
@@ -5933,13 +5933,7 @@ mixin template Proxy(alias a)
             // built-in type field, manifest constant, and static non-mutable field
             enum opDispatch = mixin("a."~name);
         }
-        else static if (is(typeof(mixin("a."~name))) || __traits(getOverloads, a, name).length != 0)
-        {
-            // field or property function
-            @property auto ref opDispatch(this X)()                { return mixin("a."~name);        }
-            @property auto ref opDispatch(this X, V)(auto ref V v) { return mixin("a."~name~" = v"); }
-        }
-        else
+        else static if (__traits(isTemplate, mixin("a."~name)))
         {
             // member template
             template opDispatch(T...)
@@ -5948,6 +5942,13 @@ mixin template Proxy(alias a)
                 auto ref opDispatch(this X, Args...)(auto ref Args args){ return mixin("a."~name~targs~"(args)"); }
             }
         }
+        else
+        {
+            // field or property function
+            @property auto ref opDispatch(this X)()                { return mixin("a."~name);        }
+            @property auto ref opDispatch(this X, V)(auto ref V v) { return mixin("a."~name~" = v"); }
+        }
+
     }
 
     import std.traits : isArray;
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index ceea82c4f70..400b5b58033 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,31 @@
+2021-08-05  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/101749
+	* sanitizer_common/sanitizer_posix_libcdep.cpp: Prevent
+	generation of dependency on _cxa_guard for static
+	initialization.
+
+2021-05-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2021-05-21  Tamar Christina  <tamar.christina@arm.com>
+
+	PR sanitizer/100379
+	* sanitizer_common/sanitizer_common_interceptors_ioctl.inc: Cherry-pick
+	llvm-project revision f7c5351552387bd43f6ca3631016d7f0dfe0f135.
+	* sanitizer_common/sanitizer_platform_limits_posix.cpp: Likewise.
+	* sanitizer_common/sanitizer_platform_limits_posix.h: Likewise.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/100114
+	* sanitizer_common/sanitizer_posix_libcdep.cpp: Cherry-pick
+	llvm-project revisions 82150606fb11d28813ae6da1101f5bda638165fe
+	and b93629dd335ffee2fc4b9b619bf86c3f9e6b0023.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc b/libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc
index 490a04b2181..42e43a04441 100644
--- a/libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc
+++ b/libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc
@@ -366,15 +366,6 @@ static void ioctl_table_fill() {
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
   // _(SIOCDEVPLIP, WRITE, struct_ifreq_sz); // the same as EQL_ENSLAVE
-  _(CYGETDEFTHRESH, WRITE, sizeof(int));
-  _(CYGETDEFTIMEOUT, WRITE, sizeof(int));
-  _(CYGETMON, WRITE, struct_cyclades_monitor_sz);
-  _(CYGETTHRESH, WRITE, sizeof(int));
-  _(CYGETTIMEOUT, WRITE, sizeof(int));
-  _(CYSETDEFTHRESH, NONE, 0);
-  _(CYSETDEFTIMEOUT, NONE, 0);
-  _(CYSETTHRESH, NONE, 0);
-  _(CYSETTIMEOUT, NONE, 0);
   _(EQL_EMANCIPATE, WRITE, struct_ifreq_sz);
   _(EQL_ENSLAVE, WRITE, struct_ifreq_sz);
   _(EQL_GETMASTRCFG, WRITE, struct_ifreq_sz);
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
index aa845df4dde..badf6a401cc 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
@@ -130,7 +130,6 @@ typedef struct user_fpregs elf_fpregset_t;
 # include <sys/procfs.h>
 #endif
 #include <sys/user.h>
-#include <linux/cyclades.h>
 #include <linux/if_eql.h>
 #include <linux/if_plip.h>
 #include <linux/lp.h>
@@ -443,7 +442,6 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
   unsigned struct_ax25_parms_struct_sz = sizeof(struct ax25_parms_struct);
-  unsigned struct_cyclades_monitor_sz = sizeof(struct cyclades_monitor);
 #if EV_VERSION > (0x010000)
   unsigned struct_input_keymap_entry_sz = sizeof(struct input_keymap_entry);
 #else
@@ -809,15 +807,6 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);
 #endif // SANITIZER_LINUX
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
-  unsigned IOCTL_CYGETDEFTHRESH = CYGETDEFTHRESH;
-  unsigned IOCTL_CYGETDEFTIMEOUT = CYGETDEFTIMEOUT;
-  unsigned IOCTL_CYGETMON = CYGETMON;
-  unsigned IOCTL_CYGETTHRESH = CYGETTHRESH;
-  unsigned IOCTL_CYGETTIMEOUT = CYGETTIMEOUT;
-  unsigned IOCTL_CYSETDEFTHRESH = CYSETDEFTHRESH;
-  unsigned IOCTL_CYSETDEFTIMEOUT = CYSETDEFTIMEOUT;
-  unsigned IOCTL_CYSETTHRESH = CYSETTHRESH;
-  unsigned IOCTL_CYSETTIMEOUT = CYSETTIMEOUT;
   unsigned IOCTL_EQL_EMANCIPATE = EQL_EMANCIPATE;
   unsigned IOCTL_EQL_ENSLAVE = EQL_ENSLAVE;
   unsigned IOCTL_EQL_GETMASTRCFG = EQL_GETMASTRCFG;
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
index d82fd5e4005..dc6423bc297 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
@@ -974,7 +974,6 @@ extern unsigned struct_vt_mode_sz;
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
 extern unsigned struct_ax25_parms_struct_sz;
-extern unsigned struct_cyclades_monitor_sz;
 extern unsigned struct_input_keymap_entry_sz;
 extern unsigned struct_ipx_config_data_sz;
 extern unsigned struct_kbdiacrs_sz;
@@ -1319,15 +1318,6 @@ extern unsigned IOCTL_VT_WAITACTIVE;
 #endif  // SANITIZER_LINUX
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
-extern unsigned IOCTL_CYGETDEFTHRESH;
-extern unsigned IOCTL_CYGETDEFTIMEOUT;
-extern unsigned IOCTL_CYGETMON;
-extern unsigned IOCTL_CYGETTHRESH;
-extern unsigned IOCTL_CYGETTIMEOUT;
-extern unsigned IOCTL_CYSETDEFTHRESH;
-extern unsigned IOCTL_CYSETDEFTIMEOUT;
-extern unsigned IOCTL_CYSETTHRESH;
-extern unsigned IOCTL_CYSETTIMEOUT;
 extern unsigned IOCTL_EQL_EMANCIPATE;
 extern unsigned IOCTL_EQL_ENSLAVE;
 extern unsigned IOCTL_EQL_GETMASTRCFG;
diff --git a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp
index 304b3a01a08..44359b3d1ac 100644
--- a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp
+++ b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp
@@ -169,7 +169,12 @@ bool SupportsColoredOutput(fd_t fd) {
 
 #if !SANITIZER_GO
 // TODO(glider): different tools may require different altstack size.
-static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.
+static uptr GetAltStackSize() {
+  // Note: since GLIBC_2.31, SIGSTKSZ may be a function call, so this may be
+  // more costly that you think. However GetAltStackSize is only call 2-3 times
+  // per thread so don't cache the evaluation.
+  return SIGSTKSZ * 4;
+}
 
 void SetAlternateSignalStack() {
   stack_t altstack, oldstack;
@@ -180,10 +185,9 @@ void SetAlternateSignalStack() {
   // TODO(glider): the mapped stack should have the MAP_STACK flag in the
   // future. It is not required by man 2 sigaltstack now (they're using
   // malloc()).
-  void* base = MmapOrDie(kAltStackSize, __func__);
-  altstack.ss_sp = (char*) base;
+  altstack.ss_size = GetAltStackSize();
+  altstack.ss_sp = (char *)MmapOrDie(altstack.ss_size, __func__);
   altstack.ss_flags = 0;
-  altstack.ss_size = kAltStackSize;
   CHECK_EQ(0, sigaltstack(&altstack, nullptr));
 }
 
@@ -191,7 +195,7 @@ void UnsetAlternateSignalStack() {
   stack_t altstack, oldstack;
   altstack.ss_sp = nullptr;
   altstack.ss_flags = SS_DISABLE;
-  altstack.ss_size = kAltStackSize;  // Some sane value required on Darwin.
+  altstack.ss_size = GetAltStackSize();  // Some sane value required on Darwin.
   CHECK_EQ(0, sigaltstack(&altstack, &oldstack));
   UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);
 }
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index fdd63cbff1a..e4d417d4c71 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,1637 @@
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/char_traits.h (__gnu_cxx::char_traits::move):
+	Do not compare unrelated pointers during constant evaluation.
+	* testsuite/21_strings/char_traits/requirements/constexpr_functions_c++20.cc:
+	Improve tests for char_traits::move.
+
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103877
+	* doc/xml/faq.xml: Add '-x c++' to preprocessor command.
+	* doc/html/faq.html: Regenerate.
+
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103549
+	* include/bits/regex.h (match_results): Give names to template
+	parameters in first declaration.
+	(match_results::_M_begin): Add default member-initializer.
+
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103453
+	* config/allocator/malloc_allocator_base.h
+	(_GLIBCXX_SANITIZE_STD_ALLOCATOR): Define for Clang.
+	* config/allocator/new_allocator_base.h
+	(_GLIBCXX_SANITIZE_STD_ALLOCATOR): Likewise.
+
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (StdErrorCodePrinter): Strip
+	versioned namespace from the type name that is printed.
+
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/alloc_traits.h (allocator_traits): Add explicit
+	specialization for allocator<void>. Improve doxygen comments.
+	* include/bits/allocator.h (allocator<void>): Restore for the
+	versioned namespace.
+	(allocator<void>::construct, allocator<void>::destroy): Remove.
+	* include/ext/extptr_allocator.h (_Extptr_allocator<void>):
+	Add default constructor and converting constructor.
+
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103086
+	* testsuite/libstdc++-prettyprinters/cxx11.cc: Check unique_ptr
+	with non-empty pointer and non-empty deleter.
+
+2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103086
+	* python/libstdcxx/v6/printers.py (_tuple_impl_get): New helper
+	for accessing the tuple element stored in a _Tuple_impl node.
+	(tuple_get): New function for accessing a tuple element.
+	(unique_ptr_get): New function for accessing a unique_ptr.
+	(UniquePointerPrinter, StdPathPrinter): Use unique_ptr_get.
+	* python/libstdcxx/v6/xmethods.py (UniquePtrGetWorker): Cast
+	tuple to its base class before accessing _M_head_impl.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101571
+	* include/bits/ranges_uninitialized.h (_DestroyGuard): Change
+	constructor parameter to reference and use addressof.
+	* testsuite/util/testsuite_iterators.h: Define deleted operator&
+	overloads for test iterators.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101965
+	* include/std/charconv (__to_chars_i): Remove redundant check.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102894
+	* include/std/any (make_any): Add SFINAE constraint.
+	* testsuite/20_util/any/102894.cc: New test.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102270
+	* include/std/tuple (_Head_base, _Tuple_impl): Add
+	_GLIBCXX20_CONSTEXPR to allocator-extended constructors.
+	(tuple<>::swap(tuple&)): Add _GLIBCXX20_CONSTEXPR.
+	* testsuite/20_util/tuple/cons/102270.cc: New test.
+	* testsuite/util/testsuite_allocator.h (SimpleAllocator): Add
+	constexpr to constructor so it can be used for C++20 tests.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/23_containers/unordered_map/cons/default.cc: Add
+	equality comparison operators to allocator.
+	* testsuite/23_containers/unordered_set/cons/default.cc:
+	Likewise.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100863
+	* include/bits/hashtable.h (_Hashtable): Conditionally delete
+	default constructor by deriving from _Enable_default_constructor.
+	Construct that base-class explicitly in all non-forwarding,
+	non-defaulted constructors.
+	* testsuite/23_containers/unordered_map/cons/default.cc: New test.
+	* testsuite/23_containers/unordered_set/cons/default.cc: New test.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100863
+	PR libstdc++/65816
+	* include/bits/hashtable_policy.h (_Hashtable_ebo_helper):
+	Value-initialize subobject.
+	* testsuite/23_containers/unordered_map/allocator/default_init.cc:
+	Remove XFAIL.
+	* testsuite/23_containers/unordered_set/allocator/default_init.cc:
+	Remove XFAIL.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/move.h (forward(remove_reference_t<T>&&)):
+	Improve text of static_assert.
+	* testsuite/20_util/forward/c_neg.cc: Adjust dg-error.
+	* testsuite/20_util/forward/f_neg.cc: Likewise.
+
+2021-11-26  Antony Polukhin  <antoshkka@gmail.com>
+
+	Backported from master:
+	2021-08-17  Antony Polukhin  <antoshkka@gmail.com>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.tcc (seed_seq::seed_seq): Reserve capacity
+	if distance is O(1).
+	* testsuite/26_numerics/random/pr60037-neg.cc: Adjust dg-error
+	line number.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101870
+	* include/c_global/cmath (hypot): Use __promoted_t.
+	(lerp): Add new overload accepting any arithmetic types.
+	* include/ext/type_traits.h (__promoted_t): New alias template.
+	* testsuite/26_numerics/lerp.cc: Moved to...
+	* testsuite/26_numerics/lerp/1.cc: ...here.
+	* testsuite/26_numerics/lerp/constexpr.cc: New test.
+	* testsuite/26_numerics/lerp/version.cc: New test.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/types/1.cc: Add c++11 target selector to
+	warnings.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/headers/memory/synopsis.cc: Define C++98
+	alternative for macro.
+	* testsuite/20_util/shared_ptr/creation/99006.cc: Add effective
+	target keyword.
+	* testsuite/25_algorithms/copy/debug/99402.cc: Avoid C++11
+	syntax.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/23_containers/array/comparison_operators/96851.cc:
+	Skip test in debug mode.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h: Include required header for
+	std::iterator class template and iterator category tags.
+
+2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101608
+	* include/bits/ranges_algobase.h (__fill_n_fn): Check for
+	constant evaluation before using memset.
+	* testsuite/25_algorithms/fill_n/constrained.cc: Check
+	byte-sized values as well.
+
+2021-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103381
+	* include/ext/bitmap_allocator.h: Include <bits/stl_function.h>
+	instead of <functional>.
+
+2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/valarray (begin, end): Remove nodiscard attribute.
+
+2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103022
+	* include/std/valarray (begin, end): Do not dereference an empty
+	valarray. Add noexcept and [[nodiscard]].
+	* testsuite/26_numerics/valarray/range_access.cc: Check empty
+	valarray. Check iterator properties. Run as well as compiling.
+	* testsuite/26_numerics/valarray/range_access2.cc: Likewise.
+	* testsuite/26_numerics/valarray/103022.cc: New test.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/28_regex/match_results/102667.C: Moved to...
+	* testsuite/28_regex/match_results/102667.cc: ...here.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string_view/requirements/trivially_copyable.cc:
+	Use -std=gnu++17 option.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90787
+	* testsuite/27_io/filesystem/iterators/directory_iterator.cc:
+	Use new __gnu_test::permissions_are_testable() function.
+	* testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc:
+	Likewise.
+	* testsuite/27_io/filesystem/operations/exists.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/is_empty.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/remove.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/remove_all.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/status.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/symlink_status.cc:
+	Likewise.
+	* testsuite/27_io/filesystem/operations/temp_directory_path.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/iterators/directory_iterator.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/exists.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/is_empty.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/remove.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/remove_all.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Likewise.
+	* testsuite/util/testsuite_fs.h (__gnu_test::permissions_are_testable):
+	New function to guess whether testing permissions will work.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/operations/remove_all.cc: Remove
+	test directory after making it writable again.
+	* testsuite/experimental/filesystem/operations/remove_all.cc:
+	Likewise.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.h (seed_seq): Constrain initializer-list
+	constructor.
+	* include/bits/random.tcc (seed_seq): Add template parameter.
+	* testsuite/26_numerics/random/seed_seq/cons/default.cc: Check
+	for noexcept.
+	* testsuite/26_numerics/random/seed_seq/cons/initlist.cc: Check
+	constraints.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc:
+	Increase dg-timeout-factor to 4. Fix -Wunused-parameter
+	warnings. Replace bitwise AND with logical AND in loop
+	condition.
+	* testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc:
+	Replace bitwise AND with logical AND in loop condition.
+	* testsuite/util/pstl/test_utils.h: Remove unused parameter
+	names.
+
+2021-10-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100187
+	PR libstdc++/100237
+	PR libstdc++/100249
+	PR libstdc++/100287
+	* include/bits/ranges_algo.h (__search_n_fn::operator()): Give
+	the __value_comp lambda an explicit bool return type.
+	(__is_permutation_fn::operator()): Give the __proj_scan local
+	variable auto&& return type.  Give the __comp_scan lambda an
+	explicit bool return type.
+	(__remove_fn::operator()): Give the __pred lambda an explicit
+	bool return type.
+	(__partition_fn::operator()): Don't std::move __first twice
+	when returning an empty subrange.
+	(__min_fn::operator()): Don't std::move __comp.
+	(__max_fn::operator()): Likewise.
+	(__minmax_fn::operator()): Likewise.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-08-02  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/101599
+	* include/bits/ranges_algo.h (__reverse_copy_fn::operator()):
+	Add missing std::move in return statement.
+	(__partition_copy_fn::operator()): Rename templtae parameter
+	_O2 to _Out2.  Uglify function parameters out_true and out_false.
+	* include/bits/ranges_algobase.h (__copy_or_move): Add missing
+	std::move to recursive call that unwraps a __normal_iterator
+	output iterator.
+	* testsuite/25_algorithms/copy/constrained.cc (test06): New test.
+	* testsuite/25_algorithms/move/constrained.cc (test05): New test.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-08-02  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/101589
+	* include/std/ranges (lazy_split_view::_InnerIter::base): Make
+	the const& overload unconstrained and return a const reference
+	as per LWG 3533.  Make unconditionally noexcept.
+	(elements_view::base): Revert accidental r12-569 change.
+	(elements_view::_Iterator::base): Make the const& overload
+	unconstrained and return a const reference as per LWG 3533.
+	Make unconditionally noexcept.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-08-02  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/101483
+	* include/std/ranges (join_view::_Iterator::_Iterator): Add
+	missing std::move.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-20  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (split_view::_InnerIter::base): Define as
+	per P2210.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-19  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (transform_view::_Iterator::_S_iter_concept):
+	Consider _Base instead of _Vp as per LWG 3555.
+	(elements_view::_Iterator::_S_iter_concept): Likewise.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-19  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (split_view::_OuterIter::value_type::begin):
+	Remove the non-const overload, and remove the copyable constraint
+	on the const overload as per LWG 3553.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-19  Patrick Palka  <ppalka@redhat.com>
+
+	* include/bits/stl_iterator.h
+	(__detail::__common_iter_use_postfix_proxy): Add
+	move_constructible constraint as per LWG 3546.
+	(common_iterator::__postfix_proxy): Adjust initializer of
+	_M_keep as per LWG 3546.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-18  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100387
+	* include/bits/ranges_algo.h (__minmax_fn::operator()): Rewrite
+	to limit comparison complexity to 3*N/2.
+	(__minmax_element_fn::operator()): Likewise.
+	(shift_right): Avoid premature std::move of __result.
+	* testsuite/25_algorithms/minmax/constrained.cc (test04, test05):
+	New tests.
+	* testsuite/25_algorithms/minmax_element/constrained.cc (test02):
+	Likewise.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-18  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/concepts (convertible_to): Just use declval as per
+	LWG 3557.
+
+2021-10-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-21  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100606
+	* include/std/ranges (drop_while_view::begin): Assert the
+	precondition added by LWG 3490.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/tuple/comparison_operators/overloaded.cc:
+	Restore test for operator<.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/basic_filebuf/close/81256.cc: Moved to...
+	* testsuite/27_io/basic_filebuf/close/wchar_t/81256.cc: ...here.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string_view/requirements/trivially_copyable.cc:
+	New test.
+	* testsuite/23_containers/span/trivially_copyable.cc: New test.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/Makefile.am [GLIBCXX_BUILD_DEBUG] (install-data-local):
+	Install another copy of the GDB hook.
+	* python/Makefile.in: Regenerate.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (StdErrorCodePrinter): Define.
+	(build_libstdcxx_dictionary): Register printer for
+	std::error_code and std::error_condition.
+	* testsuite/libstdc++-prettyprinters/cxx11.cc: Test it.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102425
+	* src/c++11/system_error.cc
+	(system_error_category::default_error_condition): Add 0 to
+	switch.
+	* testsuite/19_diagnostics/error_category/102425.cc: New test.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (advance): Remove non-deducible
+	template parameter.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99876
+	* src/c++17/fs_ops.cc (fs::absolute): Call non-throwing form,
+	to avoid unnecessary current_path() call.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/26_numerics/valarray/dr630-3.C: Moved to...
+	* testsuite/26_numerics/valarray/dr630-3.cc: ...here.
+	* testsuite/27_io/basic_iostream/cons/16251.C: Moved to...
+	* testsuite/27_io/basic_iostream/cons/16251.cc: ...here.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102280
+	* include/std/span (span(Range&&)): Add constraint to deduction
+	guide.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/25_algorithms/is_permutation/2.cc: Include <iterator>.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/integer_comparisons/greater.cc: New test.
+
+2021-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102667
+	* include/bits/regex.h (match_result::empty()): Optimize by
+	calling the base function directly.
+	(match_results::end()): Check _Base_type::empty() not empty().
+	* testsuite/28_regex/match_results/102667.C: New test.
+
+2021-08-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/ranges (basic_istream_view): Add default template
+	argument.
+	* testsuite/std/ranges/istream_view.cc: Check it.
+
+2021-08-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100139
+	* doc/xml/manual/status_cxx2020.xml: Add P1739R4 to status table.
+	* doc/html/manual/status.html: Regenerate.
+
+2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* testsuite/lib/libstdc++.exp: Avoid illegal argument to verbose,
+	continued.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101866
+	* testsuite/experimental/random/randint.cc: Loop and retry if
+	reseed() produces the same sequence.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101510
+	* src/c++17/fs_ops.cc (fs::create_directories): Use status
+	instead of symlink_status.
+	* src/filesystem/ops.cc (fs::create_directories): Likewise.
+	* testsuite/27_io/filesystem/operations/create_directories.cc:
+	Check symlink to existing directory.
+	* testsuite/27_io/filesystem/operations/create_directory.cc: Do
+	not test with symlinks on Windows.
+	* testsuite/experimental/filesystem/operations/create_directories.cc:
+	Check symlink to existing directory.
+	* testsuite/experimental/filesystem/operations/create_directory.cc:
+	Do not test with symlinks on Windows.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101510
+	* src/c++17/fs_ops.cc (create_dir): Adjust whitespace.
+	* testsuite/27_io/filesystem/operations/create_directory.cc:
+	Test creating directory with name of existing symlink to
+	directory.
+	* testsuite/experimental/filesystem/operations/create_directory.cc:
+	Likewise.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101056
+	* libsupc++/compare (compare_partial_order_fallback): Add
+	constraint using reversed parameter order, as per LWG 3465.
+	* testsuite/18_support/comparisons/algorithms/fallback.cc:
+	Adjust expected result.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* libsupc++/compare (__decayed_same_as): New helper concept.
+	(strong_order, weak_order, partial_order): Constrain with new
+	concept instead of using static_assert.
+	(compare_strong_order_fallback, compare_weak_order_fallback)
+	(compare_partial_order_fallback): Likewise. Do not deduce return
+	types. Remove redundant if-constexpr checks.
+	* testsuite/18_support/comparisons/algorithms/fallback.cc: New test.
+
+2021-08-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100894
+	* include/std/type_traits (__common_ref_impl<X&, Y&>): Only
+	use the type if it's a reference.
+	* testsuite/20_util/common_reference/100894.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96657
+	* libsupc++/Makefile.am: Add atomicity.cc here.
+	* src/c++98/Makefile.am: Remove it from here.
+	* libsupc++/Makefile.in: Regenerate.
+	* src/c++98/Makefile.in: Regenerate.
+	* testsuite/18_support/exception_ptr/96657.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/98842
+	* include/std/optional (operator<=>(const optional<T>& const U&)):
+	Add missing constraint and add workaround for template
+	recursion.
+	* testsuite/20_util/optional/relops/three_way.cc: Check that
+	type without equality comparison cannot be compared when wrapped
+	in std::optional.
+
+2021-07-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/101361
+	* include/std/string_view (ends_with): Use traits_type::compare
+	directly.
+
+2021-07-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101411
+	* include/std/span (as_writable_bytes): Add requires-clause.
+	* testsuite/23_containers/span/101411.cc: New test.
+
+2021-07-06  Avi Kivity  <avi@scylladb.com>
+
+	Backported from master:
+	2021-06-07  Avi Kivity  <avi@scylladb.com>
+
+	PR libstdc++/100900
+	* include/std/ranges (elements_view::__iter_cat::_S_iter_cat):
+	Add missing typename.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95833
+	* include/std/numeric (reduce(Iter, Iter, T, BinaryOp)): Replace
+	incorrect static_assert with ones matching the 'Mandates'
+	conditions in the standard.
+	* testsuite/26_numerics/reduce/95833.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__same_types, __check_visitor_results):
+	Remove.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/future (promise::set_value): Check for existence
+	of shared state before dereferncing it.
+	(promise::set_exception, promise::set_value_at_thread_exit)
+	(promise::set_exception_at_thread_exit): Likewise.
+	(promise<R&>::set_value, promise<R&>::set_exception)
+	(promise<R&>::set_value_at_thread_exit)
+	(promise<R&>::set_exception_at_thread_exit): Likewise.
+	(promise<void>::set_value, promise<void>::set_exception)
+	(promise<void>::set_value_at_thread_exit)
+	(promise<void>::set_exception_at_thread_exit): Likewise.
+	* testsuite/30_threads/promise/members/at_thread_exit2.cc:
+	Remove unused variable.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/basic_string.h (basic_string(const CharT*, const A&)):
+	Do not do arithmetic on null pointer.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/ext/pb_ds/detail/cc_hash_table_map_/cc_ht_map_.hpp
+	(find_key_pointer(key_const_reference, false_type))
+	(find_key_pointer(key_const_reference, true_type)): Do not
+	dereference null pointer.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/from_chars/3.cc: Use unsigned type to avoid
+	overflow.
+	* testsuite/24_iterators/reverse_iterator/2.cc: Do not add
+	non-zero value to null pointer.
+	* testsuite/25_algorithms/copy_backward/move_iterators/69478.cc:
+	Use past-the-end iterator for result.
+	* testsuite/25_algorithms/move_backward/69478.cc: Likewise.
+	* testsuite/25_algorithms/move_backward/93872.cc: Likewise.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100384
+	* include/std/variant (__get_t): New alias template yielding the
+	return type of std::get<N> on a variant.
+	(__visit_result_t): New alias template yielding the result of
+	std::visit.
+	(__same_types): Move into namespace __detail::__variant.
+	(__check_visitor_results): Likewise. Use __invoke_result_t and
+	__get_t.
+	(__check_visitor_result): Remove.
+	(visit): Use __visit_result_t for return type.
+	* testsuite/20_util/variant/100384.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99006
+	* include/bits/shared_ptr.h (allocate_shared): Assert that _Tp
+	is not an array type.
+	* include/bits/shared_ptr_base.h (__allocate_shared): Likewise.
+	* testsuite/20_util/shared_ptr/creation/99006.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/allocator.h (allocator<void>) [C++20]: Add
+	missing noexcept to constructor. Restore missing POCMA and
+	is_always_equal_traits.
+	* include/bits/memoryfwd.h (allocator_traits): Declare.
+	* include/ext/malloc_allocator.h (malloc_allocator::allocate):
+	Add nodiscard attribute. Add static assertion for LWG 3307.
+	* include/ext/new_allocator.h (new_allocator::allocate): Add
+	static assertion for LWG 3307.
+	* testsuite/20_util/allocator/void.cc: Check that converting
+	constructor is noexcept. Check for propagation traits and
+	size_type and difference_type. Check that pointer and
+	const_pointer are gone in C++20.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/shared_ptr_base.h (__shared_count(unique_ptr&&)):
+	Initialize a non-reference deleter from an rvalue, as per LWG
+	3548.
+	(__shared_ptr::_UniqCompatible): Add missing constraint.
+	* testsuite/20_util/shared_ptr/cons/lwg3548.cc: New test.
+	* testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc: Check
+	constraints.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* include/bits/basic_string.h (__cpp_lib_constexpr_string): Only
+	define C++20 value when std::is_constant_evaluated is available.
+	* include/bits/char_traits.h (__cpp_lib_constexpr_char_traits):
+	Likewise.
+	(__constant_string_p, __constant_array_p): Give external
+	linkage.
+	* include/std/version (__cpp_lib_constexpr_char_traits)
+	(__cpp_lib_constexpr_string): Only define C++20 values when
+	is_constant_evaluated is available.
+
+2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/scoped_allocator/69293_neg.cc: Add dg-error
+	for additional errors in C++20.
+	* testsuite/20_util/uses_allocator/69293_neg.cc: Likewise.
+	* testsuite/20_util/uses_allocator/cons_neg.cc: Likewise.
+
+2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100982
+	* include/std/optional (optional::operator=(const optional<U>&)):
+	Fix value category used in is_assignable check.
+	* testsuite/20_util/optional/assignment/100982.cc: New test.
+
+2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101034
+	* include/std/any (any(in_place_t<T>, initializer_list<U>, A&&...))
+	(any::emplace<T>(initializer_list<U>, A&&...)): Fix constraint
+	to use lvalue.
+	* testsuite/20_util/any/cons/101034.cc: New test.
+
+2021-06-10  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-06-03  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100770
+	* include/bits/ranges_algo.h (__detail::__can_reread_output):
+	Factor out this concept from ...
+	(__unique_copy_fn::operator()): ... here.  Use the concept
+	throughout.
+	* testsuite/std/ranges/range.cc: Remove now ill-formed use
+	of range_value_t on an output_range.
+	* testsuite/util/testsuite_iterators.h (output_iterator_wrapper):
+	Define value_type, pointer and reference member types to void.
+
+2021-06-10  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-21  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100690
+	* include/std/ranges (iota_view::_Sentinel::_M_distance_from):
+	Split out this member function from ...
+	(iota_view::_Sentinel::operator-): ... here, for sake of access
+	control.
+	* testsuite/std/ranges/iota/iota_view.cc (test05): New test.
+
+2021-06-10  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-06  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (filter_view::_Iterator::base): Make the
+	const& overload unconstrained and return a const reference as
+	per LWG 3533.  Make unconditionally noexcept.
+	(transform_view::_Iterator::base): Likewise.
+	(elements_view::_Iterator::base): Likewise.
+
+2021-06-10  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-06  Patrick Palka  <ppalka@redhat.com>
+
+	* include/bits/stl_iterator.h (move_iterator::base): Make the
+	const& overload unconstrained and return a const reference as
+	per LWG 3391.  Make unconditionally noexcept.
+	(counted_iterator::base): Likewise.
+	* testsuite/24_iterators/move_iterator/lwg3391.cc: New test.
+	* testsuite/24_iterators/move_iterator/move_only.cc: Adjust
+	has_member_base concept to decay-copy the result of base().
+
+2021-06-10  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-18  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100631
+	* include/std/ranges (elements_view::_Sentinel::operator-): Use
+	_M_distance_from in the other operator- overload too.
+	* testsuite/std/ranges/adaptors/elements.cc (test06): Augment test.
+
+2021-06-10  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-18  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100631
+	* include/std/ranges (elements_view::_Iterator): Also befriend
+	_Sentinel<!_Const>.
+	(elements_view::_Sentinel::_M_equal): Templatize.
+	(elements_view::_Sentinel::_M_distance_from): Split out from ...
+	(elements_view::_Sentinel::operator-): ... here.  Depend on
+	_Base2 instead of _Base in the return type.
+	* testsuite/std/ranges/adaptors/elements.cc (test06, test07):
+	New tests.
+
+2021-06-10  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-20  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100639
+	* include/bits/stl_iterator.h (reverse_iterator::difference_type):
+	In C++20 mode, define in terms of iter_difference_t as per P0896R4.
+	(reverse_iterator::reference): Likewise, but with iter_reference_t.
+	(reverse_iterator::value_type): Likewise, but with iter_value_t.
+	* testsuite/std/ranges/adaptors/reverse.cc (test08): New test.
+	* testsuite/24_iterators/reverse_iterator/100639.cc: New test.
+
+2021-06-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100833
+	* include/bits/range_access.h (ranges::advance(iter, n, sentinel)):
+	Fix return value for no-op case.
+	* testsuite/24_iterators/range_operations/advance.cc: Test
+	return values of three-argument overload.
+
+2021-06-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100768
+	* include/bits/range_access.h (ranges::advance)
+	(ranges::distance, ranges::next, ranges::prev): Replace
+	function templates with function objects.
+	* testsuite/24_iterators/headers/iterator/synopsis_c++20.cc:
+	Adjust for changes to function objects.
+	* testsuite/std/ranges/adaptors/elements.cc: Add using
+	declarations for names from namespace ranges.
+	* testsuite/std/ranges/adaptors/transform.cc: Likewise.
+	* testsuite/24_iterators/range_operations/100768.cc: New test.
+
+2021-06-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99453
+	* python/Makefile.am: Use archive name for printer hook if no
+	dynamic library name is available.
+	* python/Makefile.in: Regenerate.
+
+2021-06-03  Philippe Blain  <levraiphilippeblain@gmail.com>
+
+	Backported from master:
+	2021-04-21  Philippe Blain  <levraiphilippeblain@gmail.com>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99453
+	* python/Makefile.am: Install libstdc++*-gdb.py more robustly.
+	* python/Makefile.in: Regenerate.
+
+2021-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100630
+	* include/bits/fs_path.h (__is_constructible_from): Test
+	construction from a const lvalue, not an rvalue.
+	* include/experimental/bits/fs_path.h (__is_constructible_from):
+	Likewise.
+	* testsuite/27_io/filesystem/path/construct/100630.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/100630.cc:
+	New test.
+
+2021-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (find_type): Use tag attribute
+	instead of unqualified() method.
+
+2021-05-05  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-05-05  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (transform_view::_Iterator::iter_swap):
+	Remove as per LWG 3520.
+	(join_view::_Iterator::iter_swap): Add indirectly_swappable
+	constraint as per LWG 3517.
+
+2021-05-04  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-30  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (split_view::_InnerIter::operator++):
+	Depend on _Base instead of _Vp directly, as per LWG 3532.
+
+2021-05-04  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/95983
+	* include/bits/stl_iterator.h (__detail::__move_iter_cat):
+	Define.
+	(move_iterator): Derive from the above in C++20 in order to
+	conditionally define iterator_category as per P2259.
+	(move_iterator::__base_cat): No longer used, so remove.
+	(move_iterator::iterator_category): Remove in C++20.
+	(__detail::__common_iter_use_postfix_proxy): Define.
+	(common_iterator::_Proxy): Rename to ...
+	(common_iterator:__arrow_proxy): ... this.
+	(common_iterator::__postfix_proxy): Define as per P2259.
+	(common_iterator::operator->): Adjust.
+	(common_iterator::operator++): Adjust as per P2259.
+	(iterator_traits<common_iterator>::_S_iter_cat): Define.
+	(iterator_traits<common_iterator>::iterator_category): Change as
+	per P2259.
+	(__detail::__counted_iter_value_type): Define.
+	(__detail::__counted_iter_concept): Define.
+	(__detail::__counted_iter_cat): Define.
+	(counted_iterator): Derive from the above three classes in order
+	to conditionally define value_type, iterator_concept and
+	iterator category respectively as per P2259.
+	(counted_iterator::operator->): Define as per P2259.
+	(incrementable_traits<counted_iterator>): Remove as per P2259.
+	(iterator_traits<counted_iterator>): Adjust as per P2259.
+	* include/std/ranges (__detail::__iota_view_iter_cat): Define.
+	(iota_view::_Iterator): Derive from the above in order to
+	conditionally define iterator_category as per P2259.
+	(iota_view::_S_iter_cat): Rename to ...
+	(iota_view::_S_iter_concept): ... this.
+	(iota_view::iterator_concept): Use it to apply LWG 3291 changes.
+	(iota_view::iterator_category): Remove.
+	(__detail::__filter_view_iter_cat): Define.
+	(filter_view::_Iterator): Derive from the above in order to
+	conditionally define iterator_category as per P2259.
+	(filter_view::_Iterator): Move to struct __filter_view_iter_cat.
+	(filter_view::_Iterator::iterator_category): Remove.
+	(transform_view::_Base): Define.
+	(transform_view::__iter_cat): Define.
+	(transform_view::_Iterator): Derive from the above in order to
+	conditionally define iterator_category as per P2259.
+	(transform_view::_Iterator::_Base): Just alias
+	transform_view::_Base.
+	(transform_view::_Iterator::_S_iter_cat): Move to struct
+	transform_view::__iter_cat.
+	(transform_view::_Iterator::iterator_category): Remove.
+	(transform_view::_Sentinel::_Base): Just alias
+	transform_view::_Base.
+	(join_view::_Base): Define.
+	(join_view::_Outer_iter): Define.
+	(join_view::_Inner_iter): Define.
+	(join_view::_S_ref_is_glvalue): Define.
+	(join_view::__iter_cat): Define.
+	(join_view::_Iterator): Derive from it in order to conditionally
+	define iterator_category as per P2259.
+	(join_view::_Iterator::_Base): Just alias join_view::_Base.
+	(join_view::_Iterator::_S_ref_is_glvalue): Just alias
+	join_view::_S_ref_is_glvalue.
+	(join_view::_Iterator::_S_iter_cat): Move to struct
+	transform_view::__iter_cat.
+	(join_view::_Iterator::_Outer_iter): Just alias
+	join_view::_Outer_iter.
+	(join_view::_Iterator::_Inner_iter): Just alias
+	join_view::_Inner_iter.
+	(join_view::_Iterator::iterator_category): Remove.
+	(join_view::_Sentinel::_Base): Just alias join_view::_Base.
+	(__detail::__split_view_outer_iter_cat): Define.
+	(__detail::__split_view_inner_iter_cat): Define.
+	(split_view::_Base): Define.
+	(split_view::_Outer_iter): Derive from __split_view_outer_iter_cat
+	in order to conditionally define iterator_category as per P2259.
+	(split_view::_Outer_iter::iterator_category): Remove.
+	(split_view::_Inner_iter): Derive from __split_view_inner_iter_cat
+	in order to conditionally define iterator_category as per P2259.
+	(split_view::_Inner_iter::_S_iter_cat): Move to
+	__split_view_inner_iter_cat.
+	(split_view::_Inner_iter::iterator_category): Remove.
+	(elements_view::_Base): Define.
+	(elements_view::__iter_cat): Define.
+	(elements_view::_Iterator): Derive from the above in order to
+	conditionall define iterator_category as per P2259.
+	(elements_view::_Iterator::_Base): Just alias
+	elements_view::_Base.
+	(elements_view::_Iterator::_S_iter_concept)
+	(elements_view::_Iterator::iterator_concept): Define as per
+	P2259.
+	(elements_view::_Iterator::iterator_category): Remove.
+	(elements_view::_Sentinel::_Base): Just alias
+	elements_view::_Base.
+	* testsuite/24_iterators/headers/iterator/synopsis_c++20.cc:
+	Adjust constraints on iterator_traits<counted_iterator>.
+	* testsuite/std/ranges/p2259.cc: New test.
+
+2021-05-03  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-27  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/100290
+	* include/std/ranges (join_view::_Iterator::operator++): Correct
+	the return type of the lambda to avoid returning a copy of
+	_M_parent->_M_inner.
+	* testsuite/std/ranges/adaptors/join.cc (test10): New test.
+
+2021-04-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/basic_string.h (__cpp_lib_constexpr_string):
+	Only define for C++17 and later.
+
+2021-04-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100259
+	* include/experimental/internet (net::ip::make_error_code)
+	(net::ip::make_error_condition, net::ip::make_network_v4)
+	(net::ip::operator==(const udp&, const udp&)): Add 'inline'.
+
+2021-04-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/basic_string.h (__cpp_lib_constexpr_string): Define.
+	* include/std/version (__cpp_lib_constexpr_string): Define.
+	* testsuite/21_strings/char_traits/requirements/constexpr_functions_c++17.cc:
+	Check for __cpp_lib_constexpr_string.
+	* testsuite/21_strings/char_traits/requirements/constexpr_functions_c++20.cc:
+	Likewise.
+	* testsuite/21_strings/char_traits/requirements/version.cc: New test.
+
+2021-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100180
+	* testsuite/experimental/net/internet/address/v6/members.cc:
+	Require gthreads.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-08  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (__detail::find): Define.
+	(split_view::_OuterIter::operator++): Apply proposed resolution
+	of LWG 3505.
+	* testsuite/std/ranges/adaptors/split.cc (test10): New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-08  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (__detail::find_if): Simplify.
+	(__detail::find_if_not): Likewise.
+	(__detail::min): Remove.
+	(__detail::mismatch): Simplify.
+	(take_view::size): Use std::min instead of __detail::min.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-08  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (__detail::__returnable_element): New
+	concept.
+	(elements_view): Use this concept in its constraints.  Add
+	missing private access specifier.
+	(elements_view::_S_get_element): Define as per LWG 3502.
+	(elements_view::operator*, elements_view::operator[]): Use
+	_S_get_element.
+	(elements_view::operator++): Remove unnecessary constraint
+	as per LWG 3492.
+	* testsuite/std/ranges/adaptors/elements.cc (test05): New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-31  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/97600
+	* include/std/ranges (basic_istream_view::begin): Initialize
+	_Iterator from 'this' instead of '*this'.
+	(basic_istream_view::_Iterator::_Iterator): Adjust constructor
+	accordingly.
+	(filter_view::_Iterator::_Iterator): Take a filter_view*
+	argument instead of a filter_view& argument.
+	(filter_view::_Sentinel::_Sentinel): Likewise.
+	(filter_view::begin): Initialize _Iterator from 'this' instead
+	of '*this'.
+	(filter_view::end): Likewise.
+	(transform_view::_Iterator::_Iterator): Take a _Parent* instead
+	of a _Parent&.
+	(filter_view::_Iterator::operator+): Adjust accordingly.
+	(filter_view::_Iterator::operator-): Likewise.
+	(filter_view::begin): Initialize _Iterator from 'this' instead
+	of '*this'.
+	(filter_view::end): Likewise.
+	(join_view::_Iterator): Take a _Parent* instead of a _Parent&.
+	(join_view::_Sentinel): Likewise.
+	(join_view::begin): Initialize _Iterator from 'this' instead of
+	'*this'.
+	(join_view::end): Initialize _Sentinel from 'this' instead of
+	'*this'.
+	(split_view::_OuterIter): Take a _Parent& instead of a _Parent*.
+	(split_view::begin): Initialize _OuterIter from 'this' instead
+	of '*this'.
+	(split_view::end): Likewise.
+	* testsuite/std/ranges/97600.cc: New test.
+
+2021-04-19  Fran√ßois Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/99402
+	* include/debug/helper_functions.h (__can_advance(_InputIterator,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	(__can_advance(const _Safe_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	* include/debug/macros.h (__glibcxx_check_can_increment_dist): New,
+	use latter.
+	(__glibcxx_check_can_increment_range): Adapt to use latter.
+	(__glibcxx_check_can_decrement_range): Likewise.
+	* include/debug/safe_iterator.h
+	(_Safe_iterator<>::_M_can_advance(const std::pair<_Diff, _Distance_precision>&,
+	int)): New.
+	(__can_advance(const _Safe_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	* include/debug/safe_iterator.tcc
+	(_Safe_iterator<>::_M_can_advance(const std::pair<_Diff, _Distance_precision>&,
+	int)): New.
+	(_Safe_iterator<>::_M_valid_range(const _Safe_iterator<>&,
+	std::pair<difference_type, _Distance_precision>&, bool)): Adapt for
+	__dp_sign_max_size.
+	(__copy_move_a): Adapt to use __glibcxx_check_can_increment_dist.
+	(__copy_move_backward_a): Likewise.
+	(__equal_aux): Likewise.
+	* include/debug/stl_iterator.h (__can_advance(const std::reverse_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	(__can_advance(const std::move_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	* testsuite/25_algorithms/copy/debug/99402.cc: New test.
+
+2021-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-10-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/97570
+	* libsupc++/new_opa.cc: Declare size_t in global namespace.
+	Remove unused header.
+
+2021-04-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100060
+	* include/std/bit: Only include <ext/numeric_traits.h> for
+	hosted build, use <limits> otherwise.
+
+2021-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100044
+	* include/std/ranges (__detail::__iterator_sentinel_pair):
+	Remove helper concept.
+	(subrange(_Pr), subrange(Pr, __make_unsigned_like<...>)): Remove
+	deduction guides, as per LWG 3404.
+	* testsuite/std/ranges/subrange/lwg3282_neg.cc: Check that class
+	template argument deduction fails.
+
+2021-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/iterator_concepts.h (indirectly_readable): Add
+	partial specializations to resolve ambiguities (LWG 3446).
+	* testsuite/24_iterators/associated_types/readable.traits.cc:
+	Check types with both value_type and element_type.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR bootstrap/99983
+	* include/bits/hashtable.h (_Hashtable): Fix noexcept-speciofier
+	on definition to match the one on the declaration.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99985
+	* include/bits/hashtable.h (_Hashtable::_S_nothrow_move()): Fix
+	to be a valid constexpr function in C++11.
+	* testsuite/23_containers/unordered_set/cons/99985.cc: New test.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_fwd.h: Fix doxygen group command.
+	* include/bits/streambuf_iterator.h: Likewise.
+	* include/std/chrono: Likewise.
+	* include/std/memory: Likewise.
+	* include/std/thread: Likewise.
+	* include/tr1/complex: Likewise.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/basic_string.h: Tweak doxygen comment.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.h: Fix doxygen group commands.
+	* include/bits/regex_constants.h: Likewise.
+	* include/tr1/random.h: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc:
+	Use allocator with the correct value type.
+	* testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc:
+	Likewise.
+
+2021-04-08  Fran√ßois Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-29  Fran√ßois Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/96029
+	* include/bits/hashtable.h
+	(_Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a, true_type)):
+	Add noexcept qualification.
+	(_Hashtable(_Hashtable&&)): Fix noexcept qualification.
+	(_Hashtable(_Hashtable&&, const allocator_type&)): Add noexcept
+	qualification.
+	* include/bits/unordered_map.h
+	(unordered_map(unordered_map&&, const allocator_type&)): Add noexcept
+	qualification.
+	(unordered_multimap(unordered_multimap&&, const allocator_type&)):
+	Likewise.
+	* include/bits/unordered_set.h
+	(unordered_set(unordered_set&&, const allocator_type&)): Likewise.
+	(unordered_multiset(unordered_multiset&&, const allocator_type&)):
+	Likewise.
+	* include/debug/unordered_map
+	(unordered_map(unordered_map&&, const allocator_type&)): Likewise.
+	(unordered_multimap(unordered_multimap&&, const allocator_type&)):
+	Likewise.
+	* include/debug/unordered_set
+	(unordered_set(unordered_set&&, const allocator_type&)): Likewise.
+	(unordered_multiset(unordered_multiset&&, const allocator_type&)):
+	Likewise.
+	* testsuite/23_containers/unordered_map/allocator/default_init.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/modifiers/move_assign.cc:
+	New test.
+	* testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/allocator/default_init.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc:
+	New test.
+
+2021-04-08  Fran√ßois Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-08  Fran√ßois Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/96029
+	* include/bits/stl_tree.h (_Rb_tree_impl(_Rb_tree_impl&&)): Add noexcept
+	qualification based only on _Compare one.
+	* testsuite/23_containers/map/cons/noexcept_move_construct.cc: Add
+	static asserts.
+	* testsuite/23_containers/multimap/cons/noexcept_move_construct.cc:
+	Likewise.
+	* testsuite/23_containers/multiset/cons/noexcept_move_construct.cc:
+	Likewise.
+	* testsuite/23_containers/set/cons/noexcept_move_construct.cc: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99805
+	* src/c++17/fs_path.cc (path::_M_split_cmpts): Do not call
+	non-const member on _M_pathname, to avoid copy-on-write.
+	* testsuite/27_io/filesystem/path/decompose/parent_path.cc:
+	Check construction from strings that might be shared.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Replace Intel parallelstl
+	link with LLVM repo for PSTL.
+	* doc/html/manual/status.html: Regenerate.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/alloc_traits.h: Use markdown for code font.
+	* include/bits/basic_string.h: Fix @param names.
+	* include/bits/regex.h: Fix duplicate @retval names, and rename.
+	* include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp: Add
+	group open to match existing group close.
+	* include/ext/pb_ds/priority_queue.hpp: Add blank line before group
+	open.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/atomic_base.h: Fix doxygen group close.
+	* include/bits/basic_ios.h: Likewise.
+	* include/bits/forward_list.h: Likewise.
+	* include/bits/fs_dir.h: Likewise.
+	* include/bits/fs_ops.h: Likewise.
+	* include/bits/fs_path.h: Likewise.
+	* include/bits/functional_hash.h: Likewise.
+	* include/bits/gslice.h: Likewise.
+	* include/bits/gslice_array.h: Likewise.
+	* include/bits/hashtable_policy.h: Likewise.
+	* include/bits/indirect_array.h: Likewise.
+	* include/bits/locale_classes.h: Likewise.
+	* include/bits/locale_facets.h: Likewise.
+	* include/bits/locale_facets_nonio.h: Likewise.
+	* include/bits/mask_array.h: Likewise.
+	* include/bits/refwrap.h: Likewise.
+	* include/bits/regex.h: Likewise.
+	* include/bits/regex_automaton.h: Likewise.
+	* include/bits/regex_compiler.h: Likewise.
+	* include/bits/regex_constants.h: Likewise.
+	* include/bits/regex_error.h: Likewise.
+	* include/bits/regex_executor.h: Likewise.
+	* include/bits/regex_scanner.h: Likewise.
+	* include/bits/shared_ptr.h: Likewise.
+	* include/bits/shared_ptr_atomic.h: Likewise.
+	* include/bits/shared_ptr_base.h: Likewise.
+	* include/bits/slice_array.h: Likewise.
+	* include/bits/specfun.h: Likewise.
+	* include/bits/std_function.h: Likewise.
+	* include/bits/std_mutex.h: Likewise.
+	* include/bits/stl_deque.h: Likewise.
+	* include/bits/stl_iterator.h: Likewise.
+	* include/bits/stl_iterator_base_types.h: Likewise.
+	* include/bits/stl_map.h: Likewise.
+	* include/bits/stl_multimap.h: Likewise.
+	* include/bits/stl_multiset.h: Likewise.
+	* include/bits/stl_numeric.h: Likewise.
+	* include/bits/stl_pair.h: Likewise.
+	* include/bits/stl_set.h: Likewise.
+	* include/bits/stl_uninitialized.h: Likewise.
+	* include/bits/stream_iterator.h: Likewise.
+	* include/bits/streambuf_iterator.h: Likewise.
+	* include/bits/unique_ptr.h: Likewise.
+	* include/bits/unordered_map.h: Likewise.
+	* include/bits/unordered_set.h: Likewise.
+	* include/decimal/decimal: Likewise.
+	* include/experimental/any: Likewise.
+	* include/experimental/array: Likewise.
+	* include/experimental/bits/fs_dir.h: Likewise.
+	* include/experimental/bits/fs_fwd.h: Likewise.
+	* include/experimental/bits/fs_ops.h: Likewise.
+	* include/experimental/bits/fs_path.h: Likewise.
+	* include/experimental/buffer: Likewise.
+	* include/experimental/internet: Likewise.
+	* include/experimental/optional: Likewise.
+	* include/experimental/propagate_const: Likewise.
+	* include/experimental/socket: Likewise.
+	* include/ext/pb_ds/assoc_container.hpp: Likewise.
+	* include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp:
+	Likewise.
+	* include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp: Likewise.
+	* include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp: Likewise.
+	* include/ext/pb_ds/detail/types_traits.hpp: Likewise.
+	* include/ext/pb_ds/exception.hpp: Likewise.
+	* include/ext/pb_ds/priority_queue.hpp: Likewise.
+	* include/ext/pb_ds/tag_and_trait.hpp: Likewise.
+	* include/ext/random: Likewise.
+	* include/std/any: Likewise.
+	* include/std/atomic: Likewise.
+	* include/std/bitset: Likewise.
+	* include/std/chrono: Likewise.
+	* include/std/complex: Likewise.
+	* include/std/condition_variable: Likewise.
+	* include/std/fstream: Likewise.
+	* include/std/future: Likewise.
+	* include/std/istream: Likewise.
+	* include/std/iostream: Likewise.
+	* include/std/mutex: Likewise.
+	* include/std/numeric: Likewise.
+	* include/std/ostream: Likewise.
+	* include/std/ratio: Likewise.
+	* include/std/shared_mutex: Likewise.
+	* include/std/stdexcept: Likewise.
+	* include/std/streambuf: Likewise.
+	* include/std/system_error: Likewise.
+	* include/std/valarray: Likewise.
+	* include/std/variant: Likewise.
+	* include/tr1/cmath: Likewise.
+	* include/tr1/regex: Likewise.
+	* include/tr2/dynamic_bitset: Likewise.
+	* libsupc++/atomic_lockfree_defines.h: Likewise.
+	* libsupc++/exception: Likewise.
+	* libsupc++/exception.h: Likewise.
+	* libsupc++/exception_ptr.h: Likewise.
+	* libsupc++/nested_exception.h: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/string_view: Adjust Doxygen @file comment.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libstdc++-v3/config/allocator/malloc_allocator_base.h b/libstdc++-v3/config/allocator/malloc_allocator_base.h
index dbe7c761548..692e9d1124b 100644
--- a/libstdc++-v3/config/allocator/malloc_allocator_base.h
+++ b/libstdc++-v3/config/allocator/malloc_allocator_base.h
@@ -52,8 +52,14 @@ namespace std
 # define __allocator_base  __gnu_cxx::malloc_allocator
 #endif
 
-#if defined(__SANITIZE_ADDRESS__) && !defined(_GLIBCXX_SANITIZE_STD_ALLOCATOR)
-# define _GLIBCXX_SANITIZE_STD_ALLOCATOR 1
+#ifndef _GLIBCXX_SANITIZE_STD_ALLOCATOR
+# if defined(__SANITIZE_ADDRESS__)
+#  define _GLIBCXX_SANITIZE_STD_ALLOCATOR 1
+# elif defined __has_feature
+#  if __has_feature(address_sanitizer)
+#   define _GLIBCXX_SANITIZE_STD_ALLOCATOR 1
+#  endif
+# endif
 #endif
 
 #endif
diff --git a/libstdc++-v3/config/allocator/new_allocator_base.h b/libstdc++-v3/config/allocator/new_allocator_base.h
index ea5425545e0..8e64b05a664 100644
--- a/libstdc++-v3/config/allocator/new_allocator_base.h
+++ b/libstdc++-v3/config/allocator/new_allocator_base.h
@@ -52,8 +52,14 @@ namespace std
 # define __allocator_base  __gnu_cxx::new_allocator
 #endif
 
-#if defined(__SANITIZE_ADDRESS__) && !defined(_GLIBCXX_SANITIZE_STD_ALLOCATOR)
-# define _GLIBCXX_SANITIZE_STD_ALLOCATOR 1
+#ifndef _GLIBCXX_SANITIZE_STD_ALLOCATOR
+# if defined(__SANITIZE_ADDRESS__)
+#  define _GLIBCXX_SANITIZE_STD_ALLOCATOR 1
+# elif defined __has_feature
+#  if __has_feature(address_sanitizer)
+#   define _GLIBCXX_SANITIZE_STD_ALLOCATOR 1
+#  endif
+# endif
 #endif
 
 #endif
diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
index 18407225d7a..aa85d85db46 100644
--- a/libstdc++-v3/doc/html/faq.html
+++ b/libstdc++-v3/doc/html/faq.html
@@ -456,7 +456,7 @@
          <code class="varname">CPLUSPLUS_CPP_SPEC</code> in
          the gcc config headers for your target (and try changing them to
          see what happens when building complicated code).  You can also run
-         <span class="command"><strong>g++ -E -dM - &lt; /dev/null"</strong></span> to display
+         <span class="command"><strong>g++ -E -dM -x c++ /dev/null</strong></span> to display
          a list of predefined macros for any particular installation.
       </p><p>This has been discussed on the mailing lists
          <a class="link" href="http://gcc.gnu.org/cgi-bin/htsearch?method=and&amp;format=builtin-long&amp;sort=score&amp;words=_XOPEN_SOURCE+Solaris" target="_top">quite a bit</a>.
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index a956ac2721d..98f86e1ad78 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -932,7 +932,7 @@ since C++14 and the implementation is complete.
 	<span class="emphasis"><em>28</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Algorithms</em></span>
-      </td></tr><tr><td align="left">28.1</td><td align="left">General</td><td align="left">¬†</td><td align="left">¬†</td></tr><tr><td align="left">28.2</td><td align="left">Header <code class="code">&lt;algorithm&gt;</code> synopsis</td><td align="left">¬†</td><td align="left">¬†</td></tr><tr><td align="left">28.3</td><td align="left">Algorithms requirements</td><td align="left">¬†</td><td align="left">¬†</td></tr><tr><td align="left">28.4</td><td align="left">Parallel algorithms</td><td align="left">¬†</td><td align="left">Using <a class="link" href="https://github.com/intel/parallelstl" target="_top">PSTL</a></td></tr><tr><td align="left">28.5</td><td align="left">Non-modifying sequence operations</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">28.6</td><td align="left">Mutating sequence operations</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">28.7</td><td align="left">Sorting and related operations</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">28.8</td><td align="left">C library algorithms</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">28.1</td><td align="left">General</td><td align="left">¬†</td><td align="left">¬†</td></tr><tr><td align="left">28.2</td><td align="left">Header <code class="code">&lt;algorithm&gt;</code> synopsis</td><td align="left">¬†</td><td align="left">¬†</td></tr><tr><td align="left">28.3</td><td align="left">Algorithms requirements</td><td align="left">¬†</td><td align="left">¬†</td></tr><tr><td align="left">28.4</td><td align="left">Parallel algorithms</td><td align="left">¬†</td><td align="left">Using <a class="link" href="https://github.com/llvm/llvm-project/tree/main/pstl" target="_top">PSTL</a></td></tr><tr><td align="left">28.5</td><td align="left">Non-modifying sequence operations</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">28.6</td><td align="left">Mutating sequence operations</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">28.7</td><td align="left">Sorting and related operations</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">28.8</td><td align="left">C library algorithms</td><td align="left">Y</td><td align="left">¬†</td></tr><tr><td align="left">
       <span class="emphasis"><em>29</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Numerics</em></span>
@@ -1285,7 +1285,10 @@ or any notes about the implementation.
       </td><td align="center"> 10.1 </td><td align="left">¬†</td></tr><tr><td align="left"> Ranges Design Cleanup </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1252r2.pdf" target="_top">
         P1252R2 </a>
-      </td><td align="center"> 10.1 </td><td align="left">¬†</td></tr><tr><td colspan="4" align="left">
+      </td><td align="center"> 10.1 </td><td align="left">¬†</td></tr><tr bgcolor="#C8B0B0"><td align="left"> Avoid template bloat for <code class="code">safe_ranges</code> in combination with ‚Äòsubrange-y‚Äô view adaptors.</td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1739r4.html" target="_top">
+        P1739R4 </a>
+      </td><td align="center"> </td><td align="left">¬†</td></tr><tr><td colspan="4" align="left">
         <span class="bold"><strong>Time, dates, calendars, time zones</strong></span>
       </td></tr><tr bgcolor="#C8B0B0"><td align="left">  Extending chrono to Calendars and Time Zones </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0355r7.html" target="_top">
diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
index cf8684e1cea..ef673ef4954 100644
--- a/libstdc++-v3/doc/xml/faq.xml
+++ b/libstdc++-v3/doc/xml/faq.xml
@@ -580,7 +580,7 @@
          <varname>CPLUSPLUS_CPP_SPEC</varname> in
          the gcc config headers for your target (and try changing them to
          see what happens when building complicated code).  You can also run
-         <command>g++ -E -dM - &lt; /dev/null"</command> to display
+         <command>g++ -E -dM -x c++ /dev/null</command> to display
          a list of predefined macros for any particular installation.
       </para>
       <para>This has been discussed on the mailing lists
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
index 0c3c23b4b31..148e3d452a4 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
@@ -1885,7 +1885,7 @@ since C++14 and the implementation is complete.
       <entry>28.4</entry>
       <entry>Parallel algorithms</entry>
       <entry/>
-      <entry>Using <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/intel/parallelstl">PSTL</link></entry>
+      <entry>Using <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/llvm/llvm-project/tree/main/pstl">PSTL</link></entry>
     </row>
     <row>
       <entry>28.5</entry>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
index 1ae177113cb..5fced67db09 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
@@ -548,6 +548,16 @@ or any notes about the implementation.
       <entry />
     </row>
 
+    <row>
+      <?dbhtml bgcolor="#C8B0B0" ?>
+      <entry> Avoid template bloat for <code>safe_ranges</code> in combination with ‚Äòsubrange-y‚Äô view adaptors.</entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1739r4.html">
+        P1739R4 </link>
+      </entry>
+      <entry align="center"> </entry>
+      <entry />
+    </row>
 
 
     <row>
diff --git a/libstdc++-v3/include/bits/alloc_traits.h b/libstdc++-v3/include/bits/alloc_traits.h
index 86d8ed221ff..afc88fdafe9 100644
--- a/libstdc++-v3/include/bits/alloc_traits.h
+++ b/libstdc++-v3/include/bits/alloc_traits.h
@@ -341,7 +341,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { __a.deallocate(__p, __n); }
 
       /**
-       *  @brief  Construct an object of type @a _Tp
+       *  @brief  Construct an object of type `_Tp`
        *  @param  __a  An allocator.
        *  @param  __p  Pointer to memory of suitable size and alignment for Tp
        *  @param  __args Constructor arguments.
@@ -559,6 +559,110 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return __rhs; }
     };
 
+  /// Explicit specialization for std::allocator<void>.
+  template<>
+    struct allocator_traits<allocator<void>>
+    {
+      /// The allocator type
+      using allocator_type = allocator<void>;
+
+      /// The allocated type
+      using value_type = void;
+
+      /// The allocator's pointer type.
+      using pointer = void*;
+
+      /// The allocator's const pointer type.
+      using const_pointer = const void*;
+
+      /// The allocator's void pointer type.
+      using void_pointer = void*;
+
+      /// The allocator's const void pointer type.
+      using const_void_pointer = const void*;
+
+      /// The allocator's difference type
+      using difference_type = std::ptrdiff_t;
+
+      /// The allocator's size type
+      using size_type = std::size_t;
+
+      /// How the allocator is propagated on copy assignment
+      using propagate_on_container_copy_assignment = false_type;
+
+      /// How the allocator is propagated on move assignment
+      using propagate_on_container_move_assignment = true_type;
+
+      /// How the allocator is propagated on swap
+      using propagate_on_container_swap = false_type;
+
+      /// Whether all instances of the allocator type compare equal.
+      using is_always_equal = true_type;
+
+      template<typename _Up>
+	using rebind_alloc = allocator<_Up>;
+
+      template<typename _Up>
+	using rebind_traits = allocator_traits<allocator<_Up>>;
+
+      /// allocate is ill-formed for allocator<void>
+      static void*
+      allocate(allocator_type&, size_type, const void* = nullptr) = delete;
+
+      /// deallocate is ill-formed for allocator<void>
+      static void
+      deallocate(allocator_type&, void*, size_type) = delete;
+
+      /**
+       *  @brief  Construct an object of type `_Up`
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to memory of suitable size and alignment for
+       *	       an object of type `_Up`.
+       *  @param  __args Constructor arguments.
+       *
+       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`
+       *  in C++11, C++14 and C++17. Changed in C++20 to call
+       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.
+      */
+      template<typename _Up, typename... _Args>
+	static _GLIBCXX20_CONSTEXPR void
+	construct(allocator_type&, _Up* __p, _Args&&... __args)
+	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
+	{
+#if __cplusplus <= 201703L
+	  ::new((void *)__p) _Up(std::forward<_Args>(__args)...);
+#else
+	  std::construct_at(__p, std::forward<_Args>(__args)...);
+#endif
+	}
+
+      /**
+       *  @brief  Destroy an object of type `_Up`
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to the object to destroy
+       *
+       *  Invokes the destructor for `*__p`.
+      */
+      template<typename _Up>
+	static _GLIBCXX20_CONSTEXPR void
+	destroy(allocator_type&, _Up* __p)
+	noexcept(is_nothrow_destructible<_Up>::value)
+	{ std::_Destroy(__p); }
+
+      /// max_size is ill-formed for allocator<void>
+      static size_type
+      max_size(const allocator_type&) = delete;
+
+      /**
+       *  @brief  Obtain an allocator to use when copying a container.
+       *  @param  __rhs  An allocator.
+       *  @return `__rhs`
+      */
+      static _GLIBCXX20_CONSTEXPR allocator_type
+      select_on_container_copy_construction(const allocator_type& __rhs)
+      { return __rhs; }
+    };
+
 #if __cplusplus < 201703L
   template<typename _Alloc>
     inline void
diff --git a/libstdc++-v3/include/bits/allocator.h b/libstdc++-v3/include/bits/allocator.h
index d224aa3ec5e..33831936185 100644
--- a/libstdc++-v3/include/bits/allocator.h
+++ b/libstdc++-v3/include/bits/allocator.h
@@ -60,6 +60,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  @{
    */
 
+  // Since C++20 the primary template should be used for allocator<void>,
+  // but then it would have a non-trivial default ctor and dtor for C++20,
+  // but trivial for C++98-17, which would be an ABI incompatibiliy between
+  // different standard dialects. So C++20 still uses the allocator<void>
+  // explicit specialization, with the historical ABI properties, but with
+  // the same members that are present in the primary template.
+
   /// allocator<void> specialization.
   template<>
     class allocator<void>
@@ -68,44 +75,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef void        value_type;
       typedef size_t      size_type;
       typedef ptrdiff_t   difference_type;
+
 #if __cplusplus <= 201703L
+      // These were removed for C++20, allocator_traits does the right thing.
       typedef void*       pointer;
       typedef const void* const_pointer;
 
       template<typename _Tp1>
 	struct rebind
 	{ typedef allocator<_Tp1> other; };
-#else
-      allocator() = default;
-
-      template<typename _Up>
-	constexpr
-	allocator(const allocator<_Up>&) { }
-#endif // ! C++20
+#endif
 
-#if __cplusplus >= 201103L && __cplusplus <= 201703L
+#if __cplusplus >= 201103L
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 2103. std::allocator propagate_on_container_move_assignment
       typedef true_type propagate_on_container_move_assignment;
 
       typedef true_type is_always_equal;
 
-      template<typename _Up, typename... _Args>
-	void
-	construct(_Up* __p, _Args&&... __args)
-	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
-	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
+#if __cplusplus > 201703L
+      // As noted above, these members are present for C++20 to provide the
+      // same API as the primary template, but still trivial as in pre-C++20.
+      allocator() = default;
+      ~allocator() = default;
 
       template<typename _Up>
-	void
-	destroy(_Up* __p)
-	noexcept(std::is_nothrow_destructible<_Up>::value)
-	{ __p->~_Up(); }
-#endif // C++11 to C++17
+	constexpr
+	allocator(const allocator<_Up>&) noexcept { }
+
+      // No allocate member because it's ill-formed by LWG 3307.
+      // No deallocate member because it would be undefined to call it
+      // with any pointer which wasn't obtained from allocate.
+#endif // C++20
+#endif // C++11
     };
 
   /**
-   * @brief  The @a standard allocator, as per [20.4].
+   * @brief  The @a standard allocator, as per C++03 [20.4.1].
    *
    *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
    *  for further details.
@@ -119,7 +125,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef _Tp        value_type;
       typedef size_t     size_type;
       typedef ptrdiff_t  difference_type;
+
 #if __cplusplus <= 201703L
+      // These were removed for C++20.
       typedef _Tp*       pointer;
       typedef const _Tp* const_pointer;
       typedef _Tp&       reference;
@@ -184,7 +192,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    return;
 	  }
 #endif
-	  __allocator_base<_Tp>::deallocate(__p, __n);
+	__allocator_base<_Tp>::deallocate(__p, __n);
       }
 #endif // C++20
 
diff --git a/libstdc++-v3/include/bits/atomic_base.h b/libstdc++-v3/include/bits/atomic_base.h
index 41d5928e482..fe2a2453265 100644
--- a/libstdc++-v3/include/bits/atomic_base.h
+++ b/libstdc++-v3/include/bits/atomic_base.h
@@ -1695,7 +1695,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #endif // C++2a
 
-  // @} group atomics
+  /// @} group atomics
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/basic_ios.h b/libstdc++-v3/include/bits/basic_ios.h
index 2771756bbc9..5b23240573f 100644
--- a/libstdc++-v3/include/bits/basic_ios.h
+++ b/libstdc++-v3/include/bits/basic_ios.h
@@ -67,7 +67,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class basic_ios : public ios_base
     {
     public:
-      //@{
+      ///@{
       /**
        *  These are standard types.  They permit a standardized way of
        *  referring to names of (or names dependent on) the template
@@ -78,9 +78,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename _Traits::pos_type             pos_type;
       typedef typename _Traits::off_type             off_type;
       typedef _Traits                                traits_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  These are non-standard types.
       */
@@ -89,7 +89,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 						     __num_put_type;
       typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
 						     __num_get_type;
-      //@}
+      ///@}
 
       // Data members:
     protected:
@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       const __num_get_type*                          _M_num_get;
 
     public:
-      //@{
+      ///@{
       /**
        *  @brief  The quick-and-easy status check.
        *
@@ -124,7 +124,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool
       operator!() const
       { return this->fail(); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns the error state of the stream buffer.
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 0b893bcea85..03f2f12d6b9 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -48,11 +48,19 @@
 # include <string_view>
 #endif
 
-
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+#ifdef __cpp_lib_is_constant_evaluated
+// Support P1032R1 in C++20 (but not P0980R1 yet).
+# define __cpp_lib_constexpr_string 201811L
+#elif __cplusplus >= 201703L
+// Support P0426R1 changes to char_traits in C++17.
+# define __cpp_lib_constexpr_string 201611L
+#elif __cplusplus > 201703L
+#endif
+
 #if _GLIBCXX_USE_CXX11_ABI
 _GLIBCXX_BEGIN_NAMESPACE_CXX11
   /**
@@ -524,7 +532,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 #endif
       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
       : _M_dataplus(_M_local_data(), __a)
-      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
+      {
+	const _CharT* __end = __s ? __s + traits_type::length(__s)
+	  // We just need a non-null pointer here to get an exception:
+	  : reinterpret_cast<const _CharT*>(__alignof__(_CharT));
+	_M_construct(__s, __end, random_access_iterator_tag());
+      }
 
       /**
        *  @brief  Construct string as multiple characters.
@@ -4672,10 +4685,9 @@ _GLIBCXX_END_NAMESPACE_CXX11
 
       /**
        *  @brief  Insert a string_view.
-       *  @param __pos  Position in string to insert at.
-       *  @param __svt  The object convertible to string_view to insert from.
-       *  @param __pos  Position in string_view to insert
-       *  from.
+       *  @param __pos1  Position in string to insert at.
+       *  @param __svt   The object convertible to string_view to insert from.
+       *  @param __pos2  Position in string_view to insert from.
        *  @param __n    The number of characters to insert.
        *  @return  Reference to this string.
       */
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
index c798f844a73..8570f30ef62 100644
--- a/libstdc++-v3/include/bits/char_traits.h
+++ b/libstdc++-v3/include/bits/char_traits.h
@@ -192,18 +192,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       if (__n == 0)
 	return __s1;
-#ifdef __cpp_lib_is_constant_evaluated
+#if __cpp_lib_is_constant_evaluated
       if (std::is_constant_evaluated())
 	{
-	  if (__s1 > __s2 && __s1 < __s2 + __n)
-	    std::copy_backward(__s2, __s2 + __n, __s1 + __n);
+	  if (__s1 == __s2) // unlikely, but saves a lot of work
+	    return __s1;
+#if __cpp_constexpr_dynamic_alloc
+	  // The overlap detection below fails due to PR c++/89074,
+	  // so use a temporary buffer instead.
+	  char_type* __tmp = new char_type[__n];
+	  copy(__tmp, __s2, __n);
+	  copy(__s1, __tmp, __n);
+	  delete[] __tmp;
+#else
+	  const auto __end = __s2 + __n - 1;
+	  bool __overlap = false;
+	  for (std::size_t __i = 0; __i < __n - 1; ++__i)
+	    {
+	      if (__s1 + __i == __end)
+		{
+		  __overlap = true;
+		  break;
+		}
+	    }
+	  if (__overlap)
+	    {
+	      do
+		{
+		  --__n;
+		  assign(__s1[__n], __s2[__n]);
+		}
+	      while (__n > 0);
+	    }
 	  else
-	    std::copy(__s2, __s2 + __n, __s1);
+	    copy(__s1, __s2, __n);
+#endif
 	  return __s1;
 	}
 #endif
-      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
-						    __n * sizeof(char_type)));
+      __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
+      return __s1;
     }
 
   template<typename _CharT>
@@ -237,12 +265,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus >= 201703L
 
-#if __cplusplus == 201703L
-// Unofficial macro indicating P0426R1 support
-# define __cpp_lib_constexpr_char_traits 201611L
-#else
-// Also support P1032R1 in C++20
+#ifdef __cpp_lib_is_constant_evaluated
+// Unofficial macro indicating P1032R1 support in C++20
 # define __cpp_lib_constexpr_char_traits 201811L
+#else
+// Unofficial macro indicating P0426R1 support in C++17
+# define __cpp_lib_constexpr_char_traits 201611L
 #endif
 
   /**
@@ -253,7 +281,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_string_p(const _CharT* __s)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
@@ -276,7 +304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
diff --git a/libstdc++-v3/include/bits/forward_list.h b/libstdc++-v3/include/bits/forward_list.h
index 49b2a973718..fd08bb83f51 100644
--- a/libstdc++-v3/include/bits/forward_list.h
+++ b/libstdc++-v3/include/bits/forward_list.h
@@ -1152,7 +1152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       splice_after(const_iterator __pos, forward_list&,
 		   const_iterator __before, const_iterator __last) noexcept
       { _M_splice_after(__pos, __before, __last); }
-      // @}
+      /// @}
 
     private:
 #if __cplusplus > 201703L
diff --git a/libstdc++-v3/include/bits/fs_dir.h b/libstdc++-v3/include/bits/fs_dir.h
index 686dfce6e5f..36a50c109c1 100644
--- a/libstdc++-v3/include/bits/fs_dir.h
+++ b/libstdc++-v3/include/bits/fs_dir.h
@@ -455,7 +455,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   inline directory_iterator
   end(directory_iterator) noexcept
   { return directory_iterator(); }
-  // @}
+  /// @}
 
   /// Iterator type for recursively traversing a directory hierarchy.
   class recursive_directory_iterator
@@ -553,11 +553,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   inline recursive_directory_iterator
   end(recursive_directory_iterator) noexcept
   { return recursive_directory_iterator(); }
-  // @}
+  /// @}
 
 _GLIBCXX_END_NAMESPACE_CXX11
 
-  // @} group filesystem
+  /// @} group filesystem
 } // namespace filesystem
 
   // Use explicit instantiations of these types. Any inconsistency in the
diff --git a/libstdc++-v3/include/bits/fs_fwd.h b/libstdc++-v3/include/bits/fs_fwd.h
index d94cc414906..0f8fa92a39a 100644
--- a/libstdc++-v3/include/bits/fs_fwd.h
+++ b/libstdc++-v3/include/bits/fs_fwd.h
@@ -339,7 +339,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   bool is_symlink(file_status) noexcept;
 
 } // namespace filesystem
-// @}
+/// @}
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 #endif // C++17
diff --git a/libstdc++-v3/include/bits/fs_ops.h b/libstdc++-v3/include/bits/fs_ops.h
index 11efdcbb5ba..26a29b25de5 100644
--- a/libstdc++-v3/include/bits/fs_ops.h
+++ b/libstdc++-v3/include/bits/fs_ops.h
@@ -302,7 +302,7 @@ namespace filesystem
   path weakly_canonical(const path& __p);
   path weakly_canonical(const path& __p, error_code& __ec);
 
-  // @} group filesystem
+  /// @} group filesystem
 } // namespace filesystem
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index 0b9911e638a..7b49461794f 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -116,7 +116,7 @@ namespace __detail
 
   template<typename _Source>
     struct __constructible_from<_Source, void>
-    : decltype(__is_path_src(std::declval<_Source>(), 0))
+    : decltype(__is_path_src(std::declval<const _Source&>(), 0))
     { };
 
   template<typename _Tp1, typename _Tp2 = void>
@@ -1340,7 +1340,7 @@ namespace __detail
     return _M_at_end == __rhs._M_at_end;
   }
 
-  // @} group filesystem
+  /// @} group filesystem
 _GLIBCXX_END_NAMESPACE_CXX11
 } // namespace filesystem
 
@@ -1348,7 +1348,7 @@ inline ptrdiff_t
 distance(filesystem::path::iterator __first, filesystem::path::iterator __last)
 { return __path_iter_distance(__first, __last); }
 
-template<typename _InputIterator, typename _Distance>
+template<typename _Distance>
   void
   advance(filesystem::path::iterator& __i, _Distance __n)
   { __path_iter_advance(__i, static_cast<ptrdiff_t>(__n)); }
diff --git a/libstdc++-v3/include/bits/functional_hash.h b/libstdc++-v3/include/bits/functional_hash.h
index 6ca79154fe0..61dd9cc0c84 100644
--- a/libstdc++-v3/include/bits/functional_hash.h
+++ b/libstdc++-v3/include/bits/functional_hash.h
@@ -269,7 +269,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 #endif
 
-  // @} group hashes
+  /// @} group hashes
 
   // Hint about performance of hash functor. If not fast the hash-based
   // containers will cache the hash code.
diff --git a/libstdc++-v3/include/bits/gslice.h b/libstdc++-v3/include/bits/gslice.h
index b252c3c1f0f..a793ea774df 100644
--- a/libstdc++-v3/include/bits/gslice.h
+++ b/libstdc++-v3/include/bits/gslice.h
@@ -177,7 +177,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     return *this;
   }
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/gslice_array.h b/libstdc++-v3/include/bits/gslice_array.h
index 89fdda537a4..da60e3bf3c7 100644
--- a/libstdc++-v3/include/bits/gslice_array.h
+++ b/libstdc++-v3/include/bits/gslice_array.h
@@ -215,7 +215,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/hashtable.h b/libstdc++-v3/include/bits/hashtable.h
index b00319a668b..961e83049a5 100644
--- a/libstdc++-v3/include/bits/hashtable.h
+++ b/libstdc++-v3/include/bits/hashtable.h
@@ -33,6 +33,7 @@
 #pragma GCC system_header
 
 #include <bits/hashtable_policy.h>
+#include <bits/enable_special_members.h>
 #if __cplusplus > 201402L
 # include <bits/node_handle.h>
 #endif
@@ -48,6 +49,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		       // Mandatory to have erase not throwing.
 		       __is_nothrow_invocable<const _Hash&, const _Tp&>>>;
 
+  // Helper to conditionally delete the default constructor.
+  // The _Hash_node_base type is used to distinguish this specialization
+  // from any other potentially-overlapping subobjects of the hashtable.
+  template<typename _Equal, typename _Hash, typename _Allocator>
+    using _Hashtable_enable_default_ctor
+      = _Enable_default_constructor<__and_<is_default_constructible<_Equal>,
+				       is_default_constructible<_Hash>,
+				       is_default_constructible<_Allocator>>{},
+				    __detail::_Hash_node_base>;
+
   /**
    *  Primary class template _Hashtable.
    *
@@ -184,7 +195,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       private __detail::_Hashtable_alloc<
 	__alloc_rebind<_Alloc,
 		       __detail::_Hash_node<_Value,
-					    _Traits::__hash_cached::value>>>
+					    _Traits::__hash_cached::value>>>,
+      private _Hashtable_enable_default_ctor<_Equal, _H1, _Alloc>
     {
       static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value,
 	  "unordered container must have a non-const, non-volatile value_type");
@@ -206,6 +218,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	typename __hashtable_alloc::__node_alloc_traits;
       using __node_base = typename __hashtable_alloc::__node_base;
       using __bucket_type = typename __hashtable_alloc::__bucket_type;
+      using __enable_default_ctor
+	= _Hashtable_enable_default_ctor<_Equal, _H1, _Alloc>;
 
     public:
       typedef _Key						key_type;
@@ -443,9 +457,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		 const _Equal& __eq, const _ExtractKey& __exk,
 		 const allocator_type& __a)
       : __hashtable_base(__exk, __h1, __h2, __h, __eq),
-	__hashtable_alloc(__node_alloc_type(__a))
+	__hashtable_alloc(__node_alloc_type(__a)),
+	__enable_default_ctor(_Enable_default_constructor_tag{})
       { }
 
+      template<bool _No_realloc = true>
+	static constexpr bool
+	_S_nothrow_move()
+	{
+#if __cplusplus <= 201402L
+	  return __and_<__bool_constant<_No_realloc>,
+			is_nothrow_copy_constructible<_H1>,
+			is_nothrow_copy_constructible<_Equal>>::value;
+#else
+	  if constexpr (_No_realloc)
+	    if constexpr (is_nothrow_copy_constructible<_H1>())
+	      return is_nothrow_copy_constructible<_Equal>();
+	  return false;
+#endif
+	}
+
+      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+		 true_type /* alloc always equal */)
+	noexcept(_S_nothrow_move());
+
+      _Hashtable(_Hashtable&&, __node_alloc_type&&,
+		 false_type /* alloc always equal */);
+
+
     public:
       // Constructor, destructor, assignment, swap
       _Hashtable() = default;
@@ -463,16 +502,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       _Hashtable(const _Hashtable&);
 
-      _Hashtable(_Hashtable&&) noexcept;
+      _Hashtable(_Hashtable&& __ht)
+	noexcept(_S_nothrow_move())
+      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
+		   true_type{})
+      { }
 
       _Hashtable(const _Hashtable&, const allocator_type&);
 
-      _Hashtable(_Hashtable&&, const allocator_type&);
+      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
+	noexcept(_S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
+      : _Hashtable(std::move(__ht), __node_alloc_type(__a),
+		   typename __node_alloc_traits::is_always_equal{})
+      { }
 
       // Use delegating constructors.
       explicit
       _Hashtable(const allocator_type& __a)
-      : __hashtable_alloc(__node_alloc_type(__a))
+      : __hashtable_alloc(__node_alloc_type(__a)),
+	__enable_default_ctor(_Enable_default_constructor_tag{})
       { }
 
       explicit
@@ -1270,6 +1318,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __rehash_base(__ht),
       __hashtable_alloc(
 	__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
+      __enable_default_ctor(__ht),
       _M_buckets(nullptr),
       _M_bucket_count(__ht._M_bucket_count),
       _M_element_count(__ht._M_element_count),
@@ -1285,18 +1334,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Traits>
     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
-    _Hashtable(_Hashtable&& __ht) noexcept
+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+	       true_type /* alloc always equal */)
+    noexcept(_S_nothrow_move())
     : __hashtable_base(__ht),
       __map_base(__ht),
       __rehash_base(__ht),
-      __hashtable_alloc(std::move(__ht._M_base_alloc())),
+      __hashtable_alloc(std::move(__a)),
+      __enable_default_ctor(__ht),
       _M_buckets(__ht._M_buckets),
       _M_bucket_count(__ht._M_bucket_count),
       _M_before_begin(__ht._M_before_begin._M_nxt),
       _M_element_count(__ht._M_element_count),
       _M_rehash_policy(__ht._M_rehash_policy)
     {
-      // Update, if necessary, buckets if __ht is using its single bucket.
+      // Update buckets if __ht is using its single bucket.
       if (__ht._M_uses_single_bucket())
 	{
 	  _M_buckets = &_M_single_bucket;
@@ -1322,6 +1374,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __map_base(__ht),
       __rehash_base(__ht),
       __hashtable_alloc(__node_alloc_type(__a)),
+      __enable_default_ctor(__ht),
       _M_buckets(),
       _M_bucket_count(__ht._M_bucket_count),
       _M_element_count(__ht._M_element_count),
@@ -1337,11 +1390,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Traits>
     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
-    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+	       false_type /* alloc always equal */)
     : __hashtable_base(__ht),
       __map_base(__ht),
       __rehash_base(__ht),
-      __hashtable_alloc(__node_alloc_type(__a)),
+      __hashtable_alloc(std::move(__a)),
+      __enable_default_ctor(__ht),
       _M_buckets(nullptr),
       _M_bucket_count(__ht._M_bucket_count),
       _M_element_count(__ht._M_element_count),
diff --git a/libstdc++-v3/include/bits/hashtable_policy.h b/libstdc++-v3/include/bits/hashtable_policy.h
index ef120134914..63958cc1d9c 100644
--- a/libstdc++-v3/include/bits/hashtable_policy.h
+++ b/libstdc++-v3/include/bits/hashtable_policy.h
@@ -1109,7 +1109,7 @@ namespace __detail
     struct _Hashtable_ebo_helper<_Nm, _Tp, true>
     : private _Tp
     {
-      _Hashtable_ebo_helper() = default;
+      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
 
       template<typename _OtherTp>
 	_Hashtable_ebo_helper(_OtherTp&& __tp)
@@ -1135,7 +1135,7 @@ namespace __detail
       _Tp& _M_get() { return _M_tp; }
 
     private:
-      _Tp _M_tp;
+      _Tp _M_tp{};
     };
 
   /**
@@ -1789,6 +1789,7 @@ namespace __detail
 
   protected:
     _Hashtable_base() = default;
+
     _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
 		    const _Hash& __hash, const _Equal& __eq)
     : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
@@ -2099,7 +2100,7 @@ namespace __detail
       __bucket_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
     }
 
- //@} hashtable-detail
+ ///@} hashtable-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/indirect_array.h b/libstdc++-v3/include/bits/indirect_array.h
index 11fac329036..9d75219a741 100644
--- a/libstdc++-v3/include/bits/indirect_array.h
+++ b/libstdc++-v3/include/bits/indirect_array.h
@@ -204,7 +204,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/iterator_concepts.h b/libstdc++-v3/include/bits/iterator_concepts.h
index e2ad37179be..4f118df6b02 100644
--- a/libstdc++-v3/include/bits/iterator_concepts.h
+++ b/libstdc++-v3/include/bits/iterator_concepts.h
@@ -220,6 +220,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Tp> requires is_object_v<_Tp>
       struct __cond_value_type<_Tp>
       { using value_type = remove_cv_t<_Tp>; };
+
+    template<typename _Tp>
+      concept __has_member_value_type
+	= requires { typename _Tp::value_type; };
+
+    template<typename _Tp>
+      concept __has_member_element_type
+	= requires { typename _Tp::element_type; };
+
   } // namespace __detail
 
   template<typename> struct indirectly_readable_traits { };
@@ -238,16 +247,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : indirectly_readable_traits<_Iter>
     { };
 
-  template<typename _Tp> requires requires { typename _Tp::value_type; }
+  template<__detail::__has_member_value_type _Tp>
     struct indirectly_readable_traits<_Tp>
     : __detail::__cond_value_type<typename _Tp::value_type>
     { };
 
-  template<typename _Tp> requires requires { typename _Tp::element_type; }
+  template<__detail::__has_member_element_type _Tp>
     struct indirectly_readable_traits<_Tp>
     : __detail::__cond_value_type<typename _Tp::element_type>
     { };
 
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3446. indirectly_readable_traits ambiguity for types with both [...]
+  template<__detail::__has_member_value_type _Tp>
+    requires __detail::__has_member_element_type<_Tp>
+    && same_as<remove_cv_t<typename _Tp::element_type>,
+	       remove_cv_t<typename _Tp::value_type>>
+    struct indirectly_readable_traits<_Tp>
+    : __detail::__cond_value_type<typename _Tp::value_type>
+    { };
+
+  // LWG 3446 doesn't add this, but it's needed for the case where
+  // value_type and element_type are both present, but not the same type.
+  template<__detail::__has_member_value_type _Tp>
+    requires __detail::__has_member_element_type<_Tp>
+    struct indirectly_readable_traits<_Tp>
+    { };
+
   namespace __detail
   {
     template<typename _Tp>
diff --git a/libstdc++-v3/include/bits/locale_classes.h b/libstdc++-v3/include/bits/locale_classes.h
index ab90682cde2..dc446d71907 100644
--- a/libstdc++-v3/include/bits/locale_classes.h
+++ b/libstdc++-v3/include/bits/locale_classes.h
@@ -85,7 +85,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Cache>
       friend struct __use_cache;
 
-    //@{
+    ///@{
     /**
      *  @brief  Category values.
      *
@@ -104,7 +104,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     static const category messages	= 1L << 5;
     static const category all		= (ctype | numeric | collate |
 					   time  | monetary | messages);
-    //@}
+    ///@}
 
     // Construct/copy/destroy:
 
@@ -645,11 +645,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
     protected:
       // Underlying "C" library locale information saved from
@@ -818,11 +818,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class _GLIBCXX_NAMESPACE_CXX11 collate_byname : public collate<_CharT>
     {
     public:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT               char_type;
       typedef basic_string<_CharT> string_type;
-      //@}
+      ///@}
 
       explicit
       collate_byname(const char* __s, size_t __refs = 0)
diff --git a/libstdc++-v3/include/bits/locale_facets.h b/libstdc++-v3/include/bits/locale_facets.h
index 3e0ae8776c9..7b9a1208798 100644
--- a/libstdc++-v3/include/bits/locale_facets.h
+++ b/libstdc++-v3/include/bits/locale_facets.h
@@ -1671,11 +1671,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
       typedef __numpunct_cache<_CharT>  __cache_type;
 
     protected:
@@ -1953,11 +1953,11 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -2000,7 +2000,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  ios_base::iostate& __err, bool& __v) const
       { return this->do_get(__in, __end, __io, __err, __v); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2063,9 +2063,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  ios_base::iostate& __err, unsigned long long& __v)  const
       { return this->do_get(__in, __end, __io, __err, __v); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2106,7 +2106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       get(iter_type __in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, long double& __v) const
       { return this->do_get(__in, __end, __io, __err, __v); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Numeric parsing.
@@ -2193,7 +2193,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  return __ret;
 	}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2270,7 +2270,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
 	     long double&) const;
 #endif
-      //@}
+      ///@}
     };
 
   template<typename _CharT, typename _InIter>
@@ -2294,11 +2294,11 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT		char_type;
       typedef _OutIter		iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id		id;
@@ -2332,7 +2332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
       { return this->do_put(__s, __io, __fill, __v); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2389,9 +2389,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  unsigned long long __v) const
       { return this->do_put(__s, __io, __fill, __v); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2441,7 +2441,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       put(iter_type __s, ios_base& __io, char_type __fill,
 	  long double __v) const
       { return this->do_put(__s, __io, __fill, __v); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Numeric formatting.
@@ -2492,7 +2492,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       virtual
       ~num_put() { }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2550,7 +2550,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       virtual iter_type
       do_put(iter_type, ios_base&, char_type, long double) const;
 #endif
-      //@}
+      ///@}
     };
 
   template <typename _CharT, typename _OutIter>
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.h b/libstdc++-v3/include/bits/locale_facets_nonio.h
index b76eac435bd..a8dbce2eb9c 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.h
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.h
@@ -369,11 +369,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -798,11 +798,11 @@ _GLIBCXX_END_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _OutIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1025,11 +1025,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
       typedef __moneypunct_cache<_CharT, _Intl>     __cache_type;
 
     private:
@@ -1201,7 +1201,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       frac_digits() const
       { return this->do_frac_digits(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Return pattern for money values.
        *
@@ -1240,7 +1240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       pattern
       neg_format() const
       { return this->do_neg_format(); }
-      //@}
+      ///@}
 
     protected:
       /// Destructor.
@@ -1469,12 +1469,12 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1621,12 +1621,12 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11
     class money_put : public locale::facet
     {
     public:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _OutIter			iter_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1800,11 +1800,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
     protected:
       // Underlying "C" library locale information saved from
diff --git a/libstdc++-v3/include/bits/mask_array.h b/libstdc++-v3/include/bits/mask_array.h
index 579cd59e59a..845a1d6570a 100644
--- a/libstdc++-v3/include/bits/mask_array.h
+++ b/libstdc++-v3/include/bits/mask_array.h
@@ -205,7 +205,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/memoryfwd.h b/libstdc++-v3/include/bits/memoryfwd.h
index af1a1c69c64..8f7a5a96250 100644
--- a/libstdc++-v3/include/bits/memoryfwd.h
+++ b/libstdc++-v3/include/bits/memoryfwd.h
@@ -63,15 +63,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename>
     class allocator;
 
-#if __cplusplus <= 201703L
   template<>
     class allocator<void>;
-#endif
 
 #if __cplusplus >= 201103L
-  /// Declare uses_allocator so it can be specialized in \<queue\> etc.
+  /// Declare uses_allocator so it can be specialized in `<queue>` etc.
   template<typename, typename>
     struct uses_allocator;
+
+  template<typename>
+    struct allocator_traits;
 #endif
 
   /// @} group memory
diff --git a/libstdc++-v3/include/bits/move.h b/libstdc++-v3/include/bits/move.h
index 5a4dbdc823c..b5a4020eeee 100644
--- a/libstdc++-v3/include/bits/move.h
+++ b/libstdc++-v3/include/bits/move.h
@@ -86,8 +86,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     constexpr _Tp&&
     forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
     {
-      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
-		    " substituting _Tp is an lvalue reference type");
+      static_assert(!std::is_lvalue_reference<_Tp>::value,
+	  "std::forward must not be used to convert an rvalue to an lvalue");
       return static_cast<_Tp&&>(__t);
     }
 
diff --git a/libstdc++-v3/include/bits/random.h b/libstdc++-v3/include/bits/random.h
index cba11299360..2bd6bc1e120 100644
--- a/libstdc++-v3/include/bits/random.h
+++ b/libstdc++-v3/include/bits/random.h
@@ -1673,7 +1673,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
   };
 
-  /* @} */ // group random_generators
+  /// @} group random_generators
 
   /**
    * @addtogroup random_distributions Random Number Distributions
@@ -1949,7 +1949,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator>>(std::basic_istream<_CharT, _Traits>&,
 	       std::uniform_real_distribution<_RealType>&);
 
-  /* @} */ // group random_distributions_uniform
+  /// @} group random_distributions_uniform
 
   /**
    * @addtogroup random_distributions_normal Normal Distributions
@@ -3504,7 +3504,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_normal
+  /// @} group random_distributions_normal
 
   /**
    * @addtogroup random_distributions_bernoulli Bernoulli Distributions
@@ -4400,7 +4400,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_bernoulli
+  /// @} group random_distributions_bernoulli
 
   /**
    * @addtogroup random_distributions_poisson Poisson Distributions
@@ -6046,9 +6046,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_poisson
+  /// @} group random_distributions_poisson
 
-  /* @} */ // group random_distributions
+  /// @} *group random_distributions
 
   /**
    * @addtogroup random_utilities Random Number Utilities
@@ -6071,7 +6071,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : _M_v()
     { }
 
-    template<typename _IntType>
+    template<typename _IntType, typename = _Require<is_integral<_IntType>>>
       seed_seq(std::initializer_list<_IntType> __il);
 
     template<typename _InputIterator>
@@ -6099,9 +6099,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     std::vector<result_type> _M_v;
   };
 
-  /* @} */ // group random_utilities
+  /// @} group random_utilities
 
-  /* @} */ // group random
+  /// @} group random
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index a921b9bf815..74ee6ada13a 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -3197,9 +3197,10 @@ namespace __detail
     }
 
 
-  template<typename _IntType>
+  template<typename _IntType, typename>
     seed_seq::seed_seq(std::initializer_list<_IntType> __il)
     {
+      _M_v.reserve(__il.size());
       for (auto __iter = __il.begin(); __iter != __il.end(); ++__iter)
 	_M_v.push_back(__detail::__mod<result_type,
 		       __detail::_Shift<result_type, 32>::__value>(*__iter));
@@ -3208,6 +3209,9 @@ namespace __detail
   template<typename _InputIterator>
     seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
     {
+      if _GLIBCXX17_CONSTEXPR (__is_random_access_iter<_InputIterator>::value)
+	_M_v.reserve(std::distance(__begin, __end));
+
       for (_InputIterator __iter = __begin; __iter != __end; ++__iter)
 	_M_v.push_back(__detail::__mod<result_type,
 		       __detail::_Shift<result_type, 32>::__value>(*__iter));
diff --git a/libstdc++-v3/include/bits/range_access.h b/libstdc++-v3/include/bits/range_access.h
index c93d1e37f34..bf46f366486 100644
--- a/libstdc++-v3/include/bits/range_access.h
+++ b/libstdc++-v3/include/bits/range_access.h
@@ -949,203 +949,224 @@ namespace ranges
 
   // [range.iter.ops] range iterator operations
 
-  template<input_or_output_iterator _It>
-    constexpr void
-    advance(_It& __it, iter_difference_t<_It> __n)
-    {
-      if constexpr (random_access_iterator<_It>)
-	__it += __n;
-      else if constexpr (bidirectional_iterator<_It>)
-	{
-	  if (__n > 0)
-	    {
-	      do
-		{
-		  ++__it;
-		}
-	      while (--__n);
-	    }
-	  else if (__n < 0)
-	    {
-	      do
-		{
-		  --__it;
-		}
-	      while (++__n);
-	    }
-	}
-      else
-	{
+  struct __advance_fn
+  {
+    template<input_or_output_iterator _It>
+      constexpr void
+      operator()(_It& __it, iter_difference_t<_It> __n) const
+      {
+	if constexpr (random_access_iterator<_It>)
+	  __it += __n;
+	else if constexpr (bidirectional_iterator<_It>)
+	  {
+	    if (__n > 0)
+	      {
+		do
+		  {
+		    ++__it;
+		  }
+		while (--__n);
+	      }
+	    else if (__n < 0)
+	      {
+		do
+		  {
+		    --__it;
+		  }
+		while (++__n);
+	      }
+	  }
+	else
+	  {
 #ifdef __cpp_lib_is_constant_evaluated
-	  if (std::is_constant_evaluated() && __n < 0)
-	    throw "attempt to decrement a non-bidirectional iterator";
+	    if (std::is_constant_evaluated() && __n < 0)
+	      throw "attempt to decrement a non-bidirectional iterator";
 #endif
-	  __glibcxx_assert(__n >= 0);
-	  while (__n-- > 0)
-	    ++__it;
-	}
-    }
+	    __glibcxx_assert(__n >= 0);
+	    while (__n-- > 0)
+	      ++__it;
+	  }
+      }
 
-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
-    constexpr void
-    advance(_It& __it, _Sent __bound)
-    {
-      if constexpr (assignable_from<_It&, _Sent>)
-	__it = std::move(__bound);
-      else if constexpr (sized_sentinel_for<_Sent, _It>)
-	ranges::advance(__it, __bound - __it);
-      else
-	{
-	  while (__it != __bound)
-	    ++__it;
-	}
-    }
+    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
+      constexpr void
+      operator()(_It& __it, _Sent __bound) const
+      {
+	if constexpr (assignable_from<_It&, _Sent>)
+	  __it = std::move(__bound);
+	else if constexpr (sized_sentinel_for<_Sent, _It>)
+	  (*this)(__it, __bound - __it);
+	else
+	  {
+	    while (__it != __bound)
+	      ++__it;
+	  }
+      }
+
+    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
+      constexpr iter_difference_t<_It>
+      operator()(_It& __it, iter_difference_t<_It> __n, _Sent __bound) const
+      {
+	if constexpr (sized_sentinel_for<_Sent, _It>)
+	  {
+	    const auto __diff = __bound - __it;
 
-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
-    constexpr iter_difference_t<_It>
-    advance(_It& __it, iter_difference_t<_It> __n, _Sent __bound)
-    {
-      if constexpr (sized_sentinel_for<_Sent, _It>)
-	{
-	  const auto __diff = __bound - __it;
 #ifdef __cpp_lib_is_constant_evaluated
-	  if (std::is_constant_evaluated()
-	      && !(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0)))
-	    throw "inconsistent directions for distance and bound";
+	    if (std::is_constant_evaluated()
+		&& !(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0)))
+	      throw "inconsistent directions for distance and bound";
 #endif
-	  // n and bound must not lead in opposite directions:
-	  __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));
-	  const auto __absdiff = __diff < 0 ? -__diff : __diff;
-	  const auto __absn = __n < 0 ? -__n : __n;;
-	  if (__absn >= __absdiff)
-	    {
-	      ranges::advance(__it, __bound);
-	      return __n - __diff;
-	    }
-	  else
-	    {
-	      ranges::advance(__it, __n);
-	      return 0;
-	    }
-	}
-      else if (__it == __bound || __n == 0)
-	return iter_difference_t<_It>(0);
-      else if (__n > 0)
-	{
-	  iter_difference_t<_It> __m = 0;
-	  do
-	    {
-	      ++__it;
-	      ++__m;
-	    }
-	  while (__m != __n && __it != __bound);
-	  return __n - __m;
-	}
-      else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)
-	{
-	  iter_difference_t<_It> __m = 0;
-	  do
-	    {
-	      --__it;
-	      --__m;
-	    }
-	  while (__m != __n && __it != __bound);
-	  return __n - __m;
-	}
-      else
-	{
+	    // n and bound must not lead in opposite directions:
+	    __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));
+	    const auto __absdiff = __diff < 0 ? -__diff : __diff;
+	    const auto __absn = __n < 0 ? -__n : __n;;
+	    if (__absn >= __absdiff)
+	      {
+		(*this)(__it, __bound);
+		return __n - __diff;
+	      }
+	    else
+	      {
+		(*this)(__it, __n);
+		return 0;
+	      }
+	  }
+	else if (__it == __bound || __n == 0)
+	  return __n;
+	else if (__n > 0)
+	  {
+	    iter_difference_t<_It> __m = 0;
+	    do
+	      {
+		++__it;
+		++__m;
+	      }
+	    while (__m != __n && __it != __bound);
+	    return __n - __m;
+	  }
+	else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)
+	  {
+	    iter_difference_t<_It> __m = 0;
+	    do
+	      {
+		--__it;
+		--__m;
+	      }
+	    while (__m != __n && __it != __bound);
+	    return __n - __m;
+	  }
+	else
+	  {
 #ifdef __cpp_lib_is_constant_evaluated
-	  if (std::is_constant_evaluated() && __n < 0)
-	    throw "attempt to decrement a non-bidirectional iterator";
+	    if (std::is_constant_evaluated() && __n < 0)
+	      throw "attempt to decrement a non-bidirectional iterator";
 #endif
-	  __glibcxx_assert(__n >= 0);
-	  return __n;
-	}
-    }
+	    __glibcxx_assert(__n >= 0);
+	    return __n;
+	  }
+      }
+  };
 
-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
-    constexpr iter_difference_t<_It>
-    distance(_It __first, _Sent __last)
-    {
-      if constexpr (sized_sentinel_for<_Sent, _It>)
-	return __last - __first;
-      else
-	{
-	  iter_difference_t<_It> __n = 0;
-	  while (__first != __last)
-	    {
-	      ++__first;
-	      ++__n;
-	    }
-	  return __n;
-	}
-    }
+  inline constexpr __advance_fn advance{};
 
-  template<range _Range>
-    constexpr range_difference_t<_Range>
-    distance(_Range&& __r)
-    {
-      if constexpr (sized_range<_Range>)
-	return static_cast<range_difference_t<_Range>>(ranges::size(__r));
-      else
-	return ranges::distance(ranges::begin(__r), ranges::end(__r));
-    }
+  struct __distance_fn
+  {
+    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
+      constexpr iter_difference_t<_It>
+      operator()(_It __first, _Sent __last) const
+      {
+	if constexpr (sized_sentinel_for<_Sent, _It>)
+	  return __last - __first;
+	else
+	  {
+	    iter_difference_t<_It> __n = 0;
+	    while (__first != __last)
+	      {
+		++__first;
+		++__n;
+	      }
+	    return __n;
+	  }
+      }
 
-  template<input_or_output_iterator _It>
-    constexpr _It
-    next(_It __x)
-    {
-      ++__x;
-      return __x;
-    }
+    template<range _Range>
+      constexpr range_difference_t<_Range>
+      operator()(_Range&& __r) const
+      {
+	if constexpr (sized_range<_Range>)
+	  return static_cast<range_difference_t<_Range>>(ranges::size(__r));
+	else
+	  return (*this)(ranges::begin(__r), ranges::end(__r));
+      }
+  };
 
-  template<input_or_output_iterator _It>
-    constexpr _It
-    next(_It __x, iter_difference_t<_It> __n)
-    {
-      ranges::advance(__x, __n);
-      return __x;
-    }
+  inline constexpr __distance_fn distance{};
 
-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
-    constexpr _It
-    next(_It __x, _Sent __bound)
-    {
-      ranges::advance(__x, __bound);
-      return __x;
-    }
+  struct __next_fn
+  {
+    template<input_or_output_iterator _It>
+      constexpr _It
+      operator()(_It __x) const
+      {
+	++__x;
+	return __x;
+      }
 
-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
-    constexpr _It
-    next(_It __x, iter_difference_t<_It> __n, _Sent __bound)
-    {
-      ranges::advance(__x, __n, __bound);
-      return __x;
-    }
+    template<input_or_output_iterator _It>
+      constexpr _It
+      operator()(_It __x, iter_difference_t<_It> __n) const
+      {
+	ranges::advance(__x, __n);
+	return __x;
+      }
 
-  template<bidirectional_iterator _It>
-    constexpr _It
-    prev(_It __x)
-    {
-      --__x;
-      return __x;
-    }
+    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
+      constexpr _It
+      operator()(_It __x, _Sent __bound) const
+      {
+	ranges::advance(__x, __bound);
+	return __x;
+      }
 
-  template<bidirectional_iterator _It>
-    constexpr _It
-    prev(_It __x, iter_difference_t<_It> __n)
-    {
-      ranges::advance(__x, -__n);
-      return __x;
-    }
+    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
+      constexpr _It
+      operator()(_It __x, iter_difference_t<_It> __n, _Sent __bound) const
+      {
+	ranges::advance(__x, __n, __bound);
+	return __x;
+      }
+  };
 
-  template<bidirectional_iterator _It>
-    constexpr _It
-    prev(_It __x, iter_difference_t<_It> __n, _It __bound)
-    {
-      ranges::advance(__x, -__n, __bound);
-      return __x;
-    }
+  inline constexpr __next_fn next{};
+
+  struct __prev_fn
+  {
+    template<bidirectional_iterator _It>
+      constexpr _It
+      operator()(_It __x) const
+      {
+	--__x;
+	return __x;
+      }
+
+    template<bidirectional_iterator _It>
+      constexpr _It
+      operator()(_It __x, iter_difference_t<_It> __n) const
+      {
+	ranges::advance(__x, -__n);
+	return __x;
+      }
+
+    template<bidirectional_iterator _It>
+      constexpr _It
+      operator()(_It __x, iter_difference_t<_It> __n, _It __bound) const
+      {
+	ranges::advance(__x, -__n, __bound);
+	return __x;
+      }
+  };
+
+  inline constexpr __prev_fn prev{};
 
 } // namespace ranges
 #endif // library concepts
diff --git a/libstdc++-v3/include/bits/ranges_algo.h b/libstdc++-v3/include/bits/ranges_algo.h
index 095730974cd..2774afb2dd1 100644
--- a/libstdc++-v3/include/bits/ranges_algo.h
+++ b/libstdc++-v3/include/bits/ranges_algo.h
@@ -561,7 +561,7 @@ namespace ranges
 	if (__count <= 0)
 	  return {__first, __first};
 
-	auto __value_comp = [&] <typename _Rp> (_Rp&& __arg) {
+	auto __value_comp = [&] <typename _Rp> (_Rp&& __arg) -> bool {
 	    return std::__invoke(__pred, std::forward<_Rp>(__arg), __value);
 	};
 	if (__count == 1)
@@ -804,8 +804,8 @@ namespace ranges
 
 	for (auto __scan = __first1; __scan != __last1; ++__scan)
 	  {
-	    auto __proj_scan = std::__invoke(__proj1, *__scan);
-	    auto __comp_scan = [&] <typename _Tp> (_Tp&& __arg) {
+	    auto&& __proj_scan = std::__invoke(__proj1, *__scan);
+	    auto __comp_scan = [&] <typename _Tp> (_Tp&& __arg) -> bool {
 	      return std::__invoke(__pred, __proj_scan,
 				   std::forward<_Tp>(__arg));
 	    };
@@ -1255,7 +1255,7 @@ namespace ranges
       operator()(_Iter __first, _Sent __last,
 		 const _Tp& __value, _Proj __proj = {}) const
       {
-	auto __pred = [&] (auto&& __arg) {
+	auto __pred = [&] (auto&& __arg) -> bool {
 	  return std::forward<decltype(__arg)>(__arg) == __value;
 	};
 	return ranges::remove_if(__first, __last,
@@ -1395,6 +1395,13 @@ namespace ranges
 
   inline constexpr __unique_fn unique{};
 
+  namespace __detail
+  {
+    template<typename _Out, typename _Tp>
+      concept __can_reread_output = input_iterator<_Out>
+	&& same_as<_Tp, iter_value_t<_Out>>;
+  }
+
   template<typename _Iter, typename _Out>
     using unique_copy_result = in_out_result<_Iter, _Out>;
 
@@ -1406,8 +1413,7 @@ namespace ranges
 	       projected<_Iter, _Proj>> _Comp = ranges::equal_to>
       requires indirectly_copyable<_Iter, _Out>
 	&& (forward_iterator<_Iter>
-	    || (input_iterator<_Out>
-		&& same_as<iter_value_t<_Iter>, iter_value_t<_Out>>)
+	    || __detail::__can_reread_output<_Out, iter_value_t<_Iter>>
 	    || indirectly_copyable_storable<_Iter, _Out>)
       constexpr unique_copy_result<_Iter, _Out>
       operator()(_Iter __first, _Sent __last, _Out __result,
@@ -1431,8 +1437,7 @@ namespace ranges
 		}
 	    return {__next, std::move(++__result)};
 	  }
-	else if constexpr (input_iterator<_Out>
-			   && same_as<iter_value_t<_Iter>, iter_value_t<_Out>>)
+	else if constexpr (__detail::__can_reread_output<_Out, iter_value_t<_Iter>>)
 	  {
 	    *__result = *__first;
 	    while (++__first != __last)
@@ -1466,8 +1471,7 @@ namespace ranges
 	       projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
       requires indirectly_copyable<iterator_t<_Range>, _Out>
 	&& (forward_iterator<iterator_t<_Range>>
-	    || (input_iterator<_Out>
-		&& same_as<range_value_t<_Range>, iter_value_t<_Out>>)
+	    || __detail::__can_reread_output<_Out, range_value_t<_Range>>
 	    || indirectly_copyable_storable<iterator_t<_Range>, _Out>)
       constexpr unique_copy_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result,
@@ -1549,7 +1553,7 @@ namespace ranges
 	    *__result = *__tail;
 	    ++__result;
 	  }
-	return {__i, __result};
+	return {__i, std::move(__result)};
       }
 
     template<bidirectional_range _Range, weakly_incrementable _Out>
@@ -2534,11 +2538,11 @@ namespace ranges
 	else
 	  {
 	    if (__first == __last)
-	      return {std::move(__first), std::move(__first)};
+	      return {__first, __first};
 
 	    while (std::__invoke(__pred, std::__invoke(__proj, *__first)))
 	      if (++__first == __last)
-		return {std::move(__first), std::move(__first)};
+		return {__first, __first};
 
 	    auto __next = __first;
 	    while (++__next != __last)
@@ -2627,14 +2631,14 @@ namespace ranges
   struct __partition_copy_fn
   {
     template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out1, weakly_incrementable _O2,
+	     weakly_incrementable _Out1, weakly_incrementable _Out2,
 	     typename _Proj = identity,
 	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
       requires indirectly_copyable<_Iter, _Out1>
-	&& indirectly_copyable<_Iter, _O2>
-      constexpr partition_copy_result<_Iter, _Out1, _O2>
+	&& indirectly_copyable<_Iter, _Out2>
+      constexpr partition_copy_result<_Iter, _Out1, _Out2>
       operator()(_Iter __first, _Sent __last,
-		 _Out1 __out_true, _O2 __out_false,
+		 _Out1 __out_true, _Out2 __out_false,
 		 _Pred __pred, _Proj __proj = {}) const
       {
 	for (; __first != __last; ++__first)
@@ -2654,18 +2658,18 @@ namespace ranges
       }
 
     template<input_range _Range, weakly_incrementable _Out1,
-	     weakly_incrementable _O2,
+	     weakly_incrementable _Out2,
 	     typename _Proj = identity,
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires indirectly_copyable<iterator_t<_Range>, _Out1>
-	&& indirectly_copyable<iterator_t<_Range>, _O2>
-      constexpr partition_copy_result<borrowed_iterator_t<_Range>, _Out1, _O2>
-      operator()(_Range&& __r, _Out1 out_true, _O2 out_false,
+	&& indirectly_copyable<iterator_t<_Range>, _Out2>
+      constexpr partition_copy_result<borrowed_iterator_t<_Range>, _Out1, _Out2>
+      operator()(_Range&& __r, _Out1 __out_true, _Out2 __out_false,
 		 _Pred __pred, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(out_true), std::move(out_false),
+		       std::move(__out_true), std::move(__out_false),
 		       std::move(__pred), std::move(__proj));
       }
   };
@@ -3115,7 +3119,7 @@ namespace ranges
       operator()(const _Tp& __a, const _Tp& __b,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
-	if (std::__invoke(std::move(__comp),
+	if (std::__invoke(__comp,
 			  std::__invoke(__proj, __b),
 			  std::__invoke(__proj, __a)))
 	  return __b;
@@ -3169,7 +3173,7 @@ namespace ranges
       operator()(const _Tp& __a, const _Tp& __b,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
-	if (std::__invoke(std::move(__comp),
+	if (std::__invoke(__comp,
 			  std::__invoke(__proj, __a),
 			  std::__invoke(__proj, __b)))
 	  return __b;
@@ -3269,7 +3273,7 @@ namespace ranges
       operator()(const _Tp& __a, const _Tp& __b,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
-	if (std::__invoke(std::move(__comp),
+	if (std::__invoke(__comp,
 			  std::__invoke(__proj, __b),
 			  std::__invoke(__proj, __a)))
 	  return {__b, __a};
@@ -3280,26 +3284,59 @@ namespace ranges
     template<input_range _Range, typename _Proj = identity,
 	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      requires indirectly_copyable_storable<iterator_t<_Range>,
-      range_value_t<_Range>*>
+      requires indirectly_copyable_storable<iterator_t<_Range>, range_value_t<_Range>*>
       constexpr minmax_result<range_value_t<_Range>>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	auto __first = ranges::begin(__r);
 	auto __last = ranges::end(__r);
 	__glibcxx_assert(__first != __last);
+	auto __comp_proj = __detail::__make_comp_proj(__comp, __proj);
 	minmax_result<range_value_t<_Range>> __result = {*__first, *__first};
+	if (++__first == __last)
+	  return __result;
+	else
+	  {
+	    // At this point __result.min == __result.max, so a single
+	    // comparison with the next element suffices.
+	    auto&& __val = *__first;
+	    if (__comp_proj(__val, __result.min))
+	      __result.min = std::forward<decltype(__val)>(__val);
+	    else
+	      __result.max = std::forward<decltype(__val)>(__val);
+	  }
 	while (++__first != __last)
 	  {
-	    auto __tmp = *__first;
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, __tmp),
-			      std::__invoke(__proj, __result.min)))
-	      __result.min = std::move(__tmp);
-	    if (!(bool)std::__invoke(__comp,
-				     std::__invoke(__proj, __tmp),
-				     std::__invoke(__proj, __result.max)))
-	      __result.max = std::move(__tmp);
+	    // Now process two elements at a time so that we perform at most
+	    // 1 + 3*(N-2)/2 comparisons in total (each of the (N-2)/2
+	    // iterations of this loop performs three comparisons).
+	    range_value_t<_Range> __val1 = *__first;
+	    if (++__first == __last)
+	      {
+		// N is odd; in this final iteration, we perform at most two
+		// comparisons, for a total of 1 + 3*(N-3)/2 + 2 comparisons,
+		// which is not more than 3*N/2, as required.
+		if (__comp_proj(__val1, __result.min))
+		  __result.min = std::move(__val1);
+		else if (!__comp_proj(__val1, __result.max))
+		  __result.max = std::move(__val1);
+		break;
+	      }
+	    auto&& __val2 = *__first;
+	    if (!__comp_proj(__val2, __val1))
+	      {
+		if (__comp_proj(__val1, __result.min))
+		  __result.min = std::move(__val1);
+		if (!__comp_proj(__val2, __result.max))
+		  __result.max = std::forward<decltype(__val2)>(__val2);
+	      }
+	    else
+	      {
+		if (__comp_proj(__val2, __result.min))
+		  __result.min = std::forward<decltype(__val2)>(__val2);
+		if (!__comp_proj(__val1, __result.max))
+		  __result.max = std::move(__val1);
+	      }
 	  }
 	return __result;
       }
@@ -3405,21 +3442,50 @@ namespace ranges
       operator()(_Iter __first, _Sent __last,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
-	if (__first == __last)
-	  return {__first, __first};
-
+	auto __comp_proj = __detail::__make_comp_proj(__comp, __proj);
 	minmax_element_result<_Iter> __result = {__first, __first};
-	auto __i = __first;
-	while (++__i != __last)
+	if (__first == __last || ++__first == __last)
+	  return __result;
+	else
 	  {
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, *__i),
-			      std::__invoke(__proj, *__result.min)))
-	      __result.min = __i;
-	    if (!(bool)std::__invoke(__comp,
-				     std::__invoke(__proj, *__i),
-				     std::__invoke(__proj, *__result.max)))
-	      __result.max = __i;
+	    // At this point __result.min == __result.max, so a single
+	    // comparison with the next element suffices.
+	    if (__comp_proj(*__first, *__result.min))
+	      __result.min = __first;
+	    else
+	      __result.max = __first;
+	  }
+	while (++__first != __last)
+	  {
+	    // Now process two elements at a time so that we perform at most
+	    // 1 + 3*(N-2)/2 comparisons in total (each of the (N-2)/2
+	    // iterations of this loop performs three comparisons).
+	    auto __prev = __first;
+	    if (++__first == __last)
+	      {
+		// N is odd; in this final iteration, we perform at most two
+		// comparisons, for a total of 1 + 3*(N-3)/2 + 2 comparisons,
+		// which is not more than 3*N/2, as required.
+		if (__comp_proj(*__prev, *__result.min))
+		  __result.min = __prev;
+		else if (!__comp_proj(*__prev, *__result.max))
+		  __result.max = __prev;
+		break;
+	      }
+	    if (!__comp_proj(*__first, *__prev))
+	      {
+		if (__comp_proj(*__prev, *__result.min))
+		  __result.min = __prev;
+		if (!__comp_proj(*__first, *__result.max))
+		  __result.max = __first;
+	      }
+	    else
+	      {
+		if (__comp_proj(*__first, *__result.min))
+		  __result.min = __first;
+		if (!__comp_proj(*__prev, *__result.max))
+		  __result.max = __prev;
+	      }
 	  }
 	return __result;
       }
@@ -3746,8 +3812,7 @@ namespace ranges
 		  // i.e. we are shifting out at least half of the range.  In
 		  // this case we can safely perform the shift with a single
 		  // move.
-		  std::move(std::move(__first), std::move(__dest_head),
-			    std::move(__result));
+		  std::move(std::move(__first), std::move(__dest_head), __result);
 		  return __result;
 		}
 	      ++__dest_head;
diff --git a/libstdc++-v3/include/bits/ranges_algobase.h b/libstdc++-v3/include/bits/ranges_algobase.h
index 2adff643ac2..2fb558918f8 100644
--- a/libstdc++-v3/include/bits/ranges_algobase.h
+++ b/libstdc++-v3/include/bits/ranges_algobase.h
@@ -245,7 +245,7 @@ namespace ranges
       else if constexpr (__is_normal_iterator<_Out>)
 	{
 	  auto [__in,__out]
-	    = ranges::__copy_or_move<_IsMove>(__first, __last, __result.base());
+	    = ranges::__copy_or_move<_IsMove>(std::move(__first), __last, __result.base());
 	  return {std::move(__in), decltype(__result){__out}};
 	}
       else if constexpr (sized_sentinel_for<_Sent, _Iter>)
@@ -526,17 +526,25 @@ namespace ranges
 	if (__n <= 0)
 	  return __first;
 
-	// TODO: Generalize this optimization to contiguous iterators.
-	if constexpr (is_pointer_v<_Out>
-		      // Note that __is_byte already implies !is_volatile.
-		      && __is_byte<remove_pointer_t<_Out>>::__value
-		      && integral<_Tp>)
-	  {
-	    __builtin_memset(__first, static_cast<unsigned char>(__value), __n);
-	    return __first + __n;
-	  }
-	else if constexpr (is_scalar_v<_Tp>)
+	if constexpr (is_scalar_v<_Tp>)
 	  {
+	    // TODO: Generalize this optimization to contiguous iterators.
+	    if constexpr (is_pointer_v<_Out>
+			  // Note that __is_byte already implies !is_volatile.
+			  && __is_byte<remove_pointer_t<_Out>>::__value
+			  && integral<_Tp>)
+	      {
+#ifdef __cpp_lib_is_constant_evaluated
+		if (!std::is_constant_evaluated())
+#endif
+		  {
+		    __builtin_memset(__first,
+				     static_cast<unsigned char>(__value),
+				     __n);
+		    return __first + __n;
+		  }
+	      }
+
 	    const auto __tmp = __value;
 	    for (; __n > 0; --__n, (void)++__first)
 	      *__first = __tmp;
diff --git a/libstdc++-v3/include/bits/ranges_uninitialized.h b/libstdc++-v3/include/bits/ranges_uninitialized.h
index 25e664de753..434df6da2b7 100644
--- a/libstdc++-v3/include/bits/ranges_uninitialized.h
+++ b/libstdc++-v3/include/bits/ranges_uninitialized.h
@@ -106,8 +106,8 @@ namespace ranges
 
       public:
 	explicit
-	_DestroyGuard(const _Iter* __iter)
-	  : _M_first(*__iter), _M_cur(__iter)
+	_DestroyGuard(const _Iter& __iter)
+	  : _M_first(__iter), _M_cur(std::__addressof(__iter))
 	{ }
 
 	void
@@ -127,7 +127,7 @@ namespace ranges
       struct _DestroyGuard<_Iter>
       {
 	explicit
-	_DestroyGuard(const _Iter*)
+	_DestroyGuard(const _Iter&)
 	{ }
 
 	void
@@ -149,7 +149,7 @@ namespace ranges
 	  return ranges::next(__first, __last);
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
+	    auto __guard = __detail::_DestroyGuard(__first);
 	    for (; __first != __last; ++__first)
 	      ::new (__detail::__voidify(*__first)) _ValueType;
 	    __guard.release();
@@ -181,7 +181,7 @@ namespace ranges
 	  return ranges::next(__first, __n);
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
+	    auto __guard = __detail::_DestroyGuard(__first);
 	    for (; __n > 0; ++__first, (void) --__n)
 	      ::new (__detail::__voidify(*__first)) _ValueType;
 	    __guard.release();
@@ -207,7 +207,7 @@ namespace ranges
 	  return ranges::fill(__first, __last, _ValueType());
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
+	    auto __guard = __detail::_DestroyGuard(__first);
 	    for (; __first != __last; ++__first)
 	      ::new (__detail::__voidify(*__first)) _ValueType();
 	    __guard.release();
@@ -240,7 +240,7 @@ namespace ranges
 	  return ranges::fill_n(__first, __n, _ValueType());
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
+	    auto __guard = __detail::_DestroyGuard(__first);
 	    for (; __n > 0; ++__first, (void) --__n)
 	      ::new (__detail::__voidify(*__first)) _ValueType();
 	    __guard.release();
@@ -279,7 +279,7 @@ namespace ranges
 	  }
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
+	    auto __guard = __detail::_DestroyGuard(__ofirst);
 	    for (; __ifirst != __ilast && __ofirst != __olast;
 		 ++__ofirst, (void)++__ifirst)
 	      ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);
@@ -326,7 +326,7 @@ namespace ranges
 	  }
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
+	    auto __guard = __detail::_DestroyGuard(__ofirst);
 	    for (; __n > 0 && __ofirst != __olast;
 		 ++__ofirst, (void)++__ifirst, (void)--__n)
 	      ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);
@@ -368,7 +368,7 @@ namespace ranges
 	  }
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
+	    auto __guard = __detail::_DestroyGuard(__ofirst);
 	    for (; __ifirst != __ilast && __ofirst != __olast;
 		 ++__ofirst, (void)++__ifirst)
 	      ::new (__detail::__voidify(*__ofirst))
@@ -419,7 +419,7 @@ namespace ranges
 	  }
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
+	    auto __guard = __detail::_DestroyGuard(__ofirst);
 	    for (; __n > 0 && __ofirst != __olast;
 		 ++__ofirst, (void)++__ifirst, (void)--__n)
 	      ::new (__detail::__voidify(*__ofirst))
@@ -446,7 +446,7 @@ namespace ranges
 	  return ranges::fill(__first, __last, __x);
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
+	    auto __guard = __detail::_DestroyGuard(__first);
 	    for (; __first != __last; ++__first)
 	      ::new (__detail::__voidify(*__first)) _ValueType(__x);
 	    __guard.release();
@@ -479,7 +479,7 @@ namespace ranges
 	  return ranges::fill_n(__first, __n, __x);
 	else
 	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
+	    auto __guard = __detail::_DestroyGuard(__first);
 	    for (; __n > 0; ++__first, (void)--__n)
 	      ::new (__detail::__voidify(*__first)) _ValueType(__x);
 	    __guard.release();
diff --git a/libstdc++-v3/include/bits/refwrap.h b/libstdc++-v3/include/bits/refwrap.h
index 717aa01629c..4b84ac7f039 100644
--- a/libstdc++-v3/include/bits/refwrap.h
+++ b/libstdc++-v3/include/bits/refwrap.h
@@ -391,7 +391,7 @@ _GLIBCXX_MEM_FN_TRAITS(&& noexcept, false_type, true_type)
     cref(reference_wrapper<_Tp> __t) noexcept
     { return { __t.get() }; }
 
-  // @}
+  /// @}
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 4032fd7559b..3fded333d47 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -35,7 +35,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   template<typename, typename>
     class basic_regex;
 
-  template<typename, typename>
+  template<typename _Bi_iter, typename _Alloc>
     class match_results;
 
 _GLIBCXX_END_NAMESPACE_CXX11
@@ -402,7 +402,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @name Constants
        * std [28.8.1](1)
        */
-      //@{
+      ///@{
       static constexpr flag_type icase = regex_constants::icase;
       static constexpr flag_type nosubs = regex_constants::nosubs;
       static constexpr flag_type optimize = regex_constants::optimize;
@@ -413,7 +413,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       static constexpr flag_type awk = regex_constants::awk;
       static constexpr flag_type grep = regex_constants::grep;
       static constexpr flag_type egrep = regex_constants::egrep;
-      //@}
+      ///@}
 
       // [7.8.2] construct/copy/destroy
       /**
@@ -915,9 +915,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *
        * @param __s Another matched sequence to compare to this one.
        *
-       * @retval <0 this matched sequence will collate before @p __s.
-       * @retval =0 this matched sequence is equivalent to @p __s.
-       * @retval <0 this matched sequence will collate after @p __s.
+       * @retval negative  This matched sequence will collate before `__s`.
+       * @retval zero      This matched sequence is equivalent to `__s`.
+       * @retval positive  This matched sequence will collate after `__s`.
        */
       int
       compare(const sub_match& __s) const
@@ -925,13 +925,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
       /**
        * @{
-       * @brief Compares this sub_match to a string.
+       * @brief Compares this `sub_match` to a string.
        *
-       * @param __s A string to compare to this sub_match.
+       * @param __s A string to compare to this `sub_match`.
        *
-       * @retval <0 this matched sequence will collate before @p __s.
-       * @retval =0 this matched sequence is equivalent to @p __s.
-       * @retval <0 this matched sequence will collate after @p __s.
+       * @retval negative  This matched sequence will collate before `__s`.
+       * @retval zero      This matched sequence is equivalent to `__s`.
+       * @retval positive  This matched sequence will collate after `__s`.
        */
       int
       compare(const string_type& __s) const
@@ -940,7 +940,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       int
       compare(const value_type* __s) const
       { return this->_M_str().compare(__s); }
-      // @}
+      /// @}
 
       /// @cond undocumented
       // Non-standard, used by comparison operators
@@ -1648,7 +1648,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	       const sub_match<_Bi_iter>& __m)
     { return __os << __m.str(); }
 
-  // @} relates sub_match
+  /// @} relates sub_match
 
   // [7.10] Class template match_results
 
@@ -1702,7 +1702,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       /**
        * @name 28.10 Public Types
        */
-      //@{
+      ///@{
       typedef sub_match<_Bi_iter>			   value_type;
       typedef const value_type&				   const_reference;
       typedef value_type&				   reference;
@@ -1713,13 +1713,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       typedef _Alloc					   allocator_type;
       typedef typename __iter_traits::value_type 	   char_type;
       typedef std::basic_string<char_type>		   string_type;
-      //@}
+      ///@}
 
     public:
       /**
        * @name 28.10.1 Construction, Copying, and Destruction
        */
-      //@{
+      ///@{
 
       /**
        * @brief Constructs a default %match_results container.
@@ -1763,7 +1763,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       ~match_results() = default;
 
-      //@}
+      ///@}
 
       // 28.10.2, state:
       /**
@@ -1776,7 +1776,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       /**
        * @name 28.10.2 Size
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the number of matches and submatches.
@@ -1802,14 +1802,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       _GLIBCXX_NODISCARD bool
       empty() const noexcept
-      { return size() == 0; }
+      { return _Base_type::size() <= 3; }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.4 Element Access
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the length of the indicated submatch.
@@ -1920,7 +1920,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       const_iterator
       end() const noexcept
-      { return _Base_type::end() - (empty() ? 0 : 3); }
+      { return _Base_type::end() - (_Base_type::empty() ? 0 : 3); }
 
       /**
        * @brief Gets an iterator to one-past-the-end of the collection.
@@ -1929,7 +1929,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       cend() const noexcept
       { return this->end(); }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.5 Formatting
@@ -1939,7 +1939,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * escape sequences accepted by these functions are determined by
        * their @p flags parameter as documented above.
        */
-       //@{
+       ///@{
 
       /**
        * @pre   ready() == true
@@ -1990,12 +1990,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	return __result;
       }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.6 Allocator
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets a copy of the allocator.
@@ -2004,12 +2004,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       get_allocator() const noexcept
       { return _Base_type::get_allocator(); }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.7 Swap
        */
-       //@{
+       ///@{
 
       /**
        * @brief Swaps the contents of two match_results.
@@ -2021,7 +2021,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	_Base_type::swap(__that);
 	swap(_M_begin, __that._M_begin);
       }
-      //@}
+      ///@}
 
     private:
       template<typename, typename, typename>
@@ -2078,7 +2078,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       _M_suffix()
       { return _Base_type::operator[](_Base_type::size() - 1); }
 
-      _Bi_iter _M_begin;
+      _Bi_iter _M_begin {};
       /// @endcond
     };
 
@@ -2148,7 +2148,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   /**
    * @name Matching, Searching, and Replacing
    */
-  //@{
+  ///@{
 
   /**
    * @brief Determines if there is a match between the regular expression @p e
@@ -2610,7 +2610,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
       return __result;
     }
 
-  //@}
+  ///@}
 
 _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
@@ -2973,7 +2973,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
 #endif
 
-  //@} // group regex
+  ///@} // group regex
 
 _GLIBCXX_END_NAMESPACE_CXX11
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/regex_automaton.h b/libstdc++-v3/include/bits/regex_automaton.h
index d1ef05d1477..b7165f19cec 100644
--- a/libstdc++-v3/include/bits/regex_automaton.h
+++ b/libstdc++-v3/include/bits/regex_automaton.h
@@ -392,7 +392,7 @@ namespace __detail
       _StateIdT _M_end;
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/regex_compiler.h b/libstdc++-v3/include/bits/regex_compiler.h
index e68c4184c5a..809ae419f5e 100644
--- a/libstdc++-v3/include/bits/regex_compiler.h
+++ b/libstdc++-v3/include/bits/regex_compiler.h
@@ -552,7 +552,7 @@ namespace __detail
 #endif
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_constants.h b/libstdc++-v3/include/bits/regex_constants.h
index 5f096ac6226..2926bec42ba 100644
--- a/libstdc++-v3/include/bits/regex_constants.h
+++ b/libstdc++-v3/include/bits/regex_constants.h
@@ -50,7 +50,7 @@ namespace regex_constants
   /**
    * @name 5.1 Regular Expression Syntax Options
    */
-  //@{
+  ///@{
   enum __syntax_option
   {
     _S_icase,
@@ -216,7 +216,7 @@ namespace regex_constants
   operator^=(syntax_option_type& __a, syntax_option_type __b)
   { return __a = __a ^ __b; }
 
-  //@}
+  ///@}
 
   /**
    * @name 5.2 Matching Rules
@@ -227,7 +227,7 @@ namespace regex_constants
    * below for any bitmask elements set.
    *
    */
-  //@{
+  ///@{
 
   enum __match_flag
   {
@@ -407,9 +407,9 @@ namespace regex_constants
   operator^=(match_flag_type& __a, match_flag_type __b)
   { return __a = __a ^ __b; }
 
-  //@}
+  ///@}
 } // namespace regex_constants
-/* @} */ // group regex
+/// @} group regex
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_error.h b/libstdc++-v3/include/bits/regex_error.h
index 09e9288788c..b150002ceff 100644
--- a/libstdc++-v3/include/bits/regex_error.h
+++ b/libstdc++-v3/include/bits/regex_error.h
@@ -44,7 +44,7 @@ namespace regex_constants
   /**
    * @name 5.3 Error Types
    */
-  //@{
+  ///@{
 
   enum error_type
     {
@@ -119,7 +119,7 @@ namespace regex_constants
    */
   constexpr error_type error_stack(_S_error_stack);
 
-  //@}
+  ///@}
 } // namespace regex_constants
 
   // [7.8] Class regex_error
@@ -161,7 +161,7 @@ namespace regex_constants
     friend void __throw_regex_error(regex_constants::error_type, const char*);
   };
 
-  //@} // group regex
+  ///@} // group regex
 
   void
   __throw_regex_error(regex_constants::error_type __ecode);
diff --git a/libstdc++-v3/include/bits/regex_executor.h b/libstdc++-v3/include/bits/regex_executor.h
index b66c1280454..599928d79a7 100644
--- a/libstdc++-v3/include/bits/regex_executor.h
+++ b/libstdc++-v3/include/bits/regex_executor.h
@@ -250,7 +250,7 @@ namespace __detail
       bool                                                  _M_has_sol;
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_scanner.h b/libstdc++-v3/include/bits/regex_scanner.h
index 0fc3ed41078..93ef4c66f38 100644
--- a/libstdc++-v3/include/bits/regex_scanner.h
+++ b/libstdc++-v3/include/bits/regex_scanner.h
@@ -264,7 +264,7 @@ namespace __detail
       void (_Scanner::* _M_eat_escape)();
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/shared_ptr.h b/libstdc++-v3/include/bits/shared_ptr.h
index 0c393e23132..af7a696adb0 100644
--- a/libstdc++-v3/include/bits/shared_ptr.h
+++ b/libstdc++-v3/include/bits/shared_ptr.h
@@ -661,7 +661,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif // C++20
 #endif // C++17
 
-  // @}
+  /// @}
 
   /**
    * @brief  A non-owning observer for a pointer owned by a shared_ptr
@@ -856,6 +856,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline shared_ptr<_Tp>
     allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 			     std::forward<_Args>(__args)...);
     }
@@ -888,8 +890,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
-  // @} relates shared_ptr
-  // @} group pointer_abstractions
+  /// @} relates shared_ptr
+  /// @} group pointer_abstractions
 
 #if __cplusplus >= 201703L
   namespace __detail::__variant
diff --git a/libstdc++-v3/include/bits/shared_ptr_atomic.h b/libstdc++-v3/include/bits/shared_ptr_atomic.h
index 13eb7f44a82..ce2e260702d 100644
--- a/libstdc++-v3/include/bits/shared_ptr_atomic.h
+++ b/libstdc++-v3/include/bits/shared_ptr_atomic.h
@@ -87,7 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     atomic_is_lock_free(const shared_ptr<_Tp>* __p)
     { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
 
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic load for shared_ptr objects.
@@ -123,7 +123,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline __shared_ptr<_Tp, _Lp>
     atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
     { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic store for shared_ptr objects.
@@ -162,7 +162,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline void
     atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
     { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic exchange for shared_ptr objects.
@@ -207,7 +207,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::atomic_exchange_explicit(__p, std::move(__r),
 					   memory_order_seq_cst);
     }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic compare-and-swap for shared_ptr objects.
@@ -325,10 +325,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::atomic_compare_exchange_weak_explicit(__p, __v,
 	  std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
     }
-  // @}
+  /// @}
 
-  // @} relates shared_ptr
-  // @} group pointer_abstractions
+  /// @} relates shared_ptr
+  /// @} group pointer_abstractions
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index ff578e66117..792d8344664 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -716,8 +716,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  using _Alloc_traits = allocator_traits<_Alloc>;
 	  _Alloc __a;
 	  _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
+	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+	  // 3548. shared_ptr construction from unique_ptr should move
+	  // (not copy) the deleter
 	  _Alloc_traits::construct(__a, __mem, __r.release(),
-				   __r.get_deleter());  // non-throwing
+				   std::forward<_Del>(__r.get_deleter()));
 	  _M_pi = __mem;
 	}
 
@@ -1104,9 +1107,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // Constraint for construction from unique_ptr:
       template<typename _Yp, typename _Del, typename _Res = void,
 	       typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
-	using _UniqCompatible = typename enable_if<__and_<
-	  __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>
-	  >::value, _Res>::type;
+	using _UniqCompatible = __enable_if_t<__and_<
+	  __sp_compatible_with<_Yp*, _Tp*>,
+	  is_convertible<_Ptr, element_type*>,
+	  is_move_constructible<_Del>
+	  >::value, _Res>;
 
       // Constraint for assignment from unique_ptr:
       template<typename _Yp, typename _Del>
@@ -1362,7 +1367,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	bool
 	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 	{ return _M_refcount._M_less(__rhs._M_refcount); }
-      // @}
+      /// @}
 
     protected:
       // This constructor is non-standard, it is used by allocate_shared.
@@ -1865,6 +1870,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline __shared_ptr<_Tp, _Lp>
     __allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 				    std::forward<_Args>(__args)...);
     }
diff --git a/libstdc++-v3/include/bits/slice_array.h b/libstdc++-v3/include/bits/slice_array.h
index de33342e252..d875fc225b3 100644
--- a/libstdc++-v3/include/bits/slice_array.h
+++ b/libstdc++-v3/include/bits/slice_array.h
@@ -276,7 +276,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/specfun.h b/libstdc++-v3/include/bits/specfun.h
index f85d15d4d46..60cba06d011 100644
--- a/libstdc++-v3/include/bits/specfun.h
+++ b/libstdc++-v3/include/bits/specfun.h
@@ -1196,7 +1196,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return __detail::__sph_neumann<__type>(__n, __x);
     }
 
-  // @} group mathsf
+  /// @} group mathsf
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
@@ -1380,7 +1380,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
     }
 
-  // @}
+  /// @}
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace __gnu_cxx
 #endif // __STRICT_ANSI__
diff --git a/libstdc++-v3/include/bits/std_function.h b/libstdc++-v3/include/bits/std_function.h
index e2bf9b91850..8c5aba56787 100644
--- a/libstdc++-v3/include/bits/std_function.h
+++ b/libstdc++-v3/include/bits/std_function.h
@@ -537,7 +537,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Functor>       _Functor* target() noexcept;
 
       template<typename _Functor> const _Functor* target() const noexcept;
-      // @}
+      /// @}
 #endif
 
     private:
diff --git a/libstdc++-v3/include/bits/std_mutex.h b/libstdc++-v3/include/bits/std_mutex.h
index 56c853a3fdc..2e92a1a40d3 100644
--- a/libstdc++-v3/include/bits/std_mutex.h
+++ b/libstdc++-v3/include/bits/std_mutex.h
@@ -171,7 +171,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       mutex_type&  _M_device;
     };
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 #endif // C++11
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 3959dd7899d..2d7f7e11b3f 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -1836,7 +1836,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       }
 
       // called by the second initialize_dispatch above
-      //@{
+      ///@{
       /**
        *  @brief Fills the deque with whatever is in [first,last).
        *  @param  __first  An input iterator.
@@ -1857,7 +1857,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	void
 	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
 			    std::forward_iterator_tag);
-      //@}
+      ///@}
 
       /**
        *  @brief Fills the %deque with copies of value.
@@ -1941,7 +1941,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  }
       }
 
-      //@{
+      ///@{
       /// Helper functions for push_* and pop_*.
 #if __cplusplus < 201103L
       void _M_push_back_aux(const value_type&);
@@ -1958,7 +1958,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       void _M_pop_back_aux();
 
       void _M_pop_front_aux();
-      //@}
+      ///@}
 
       // Internal insert functions follow.  The *_aux functions do the actual
       // insertion work when all shortcuts fail.
@@ -2081,7 +2081,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _M_shrink_to_fit();
 #endif
 
-      //@{
+      ///@{
       /// Memory-handling helpers for the previous internal insert functions.
       iterator
       _M_reserve_elements_at_front(size_type __n)
@@ -2108,10 +2108,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       void
       _M_new_elements_at_back(size_type __new_elements);
-      //@}
+      ///@}
 
 
-      //@{
+      ///@{
       /**
        *  @brief Memory-handling helpers for the major %map.
        *
@@ -2137,7 +2137,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       void
       _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
-      //@}
+      ///@}
 
 #if __cplusplus >= 201103L
       // Constant-time, nothrow move assignment when source object's memory
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index d950e896928..8857813e691 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -61,6 +61,7 @@
 #define _STL_ITERATOR_H 1
 
 #include <bits/cpp_type_traits.h>
+#include <bits/stl_iterator_base_types.h>
 #include <ext/type_traits.h>
 #include <bits/move.h>
 #include <bits/ptr_traits.h>
@@ -136,11 +137,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     public:
       typedef _Iterator					iterator_type;
-      typedef typename __traits_type::difference_type	difference_type;
       typedef typename __traits_type::pointer		pointer;
+#if __cplusplus <= 201703L
+      typedef typename __traits_type::difference_type	difference_type;
       typedef typename __traits_type::reference		reference;
-
-#if __cplusplus > 201703L && __cpp_lib_concepts
+#else
       using iterator_concept
 	= conditional_t<random_access_iterator<_Iterator>,
 			random_access_iterator_tag,
@@ -148,6 +149,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       using iterator_category
 	= __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
 				     random_access_iterator_tag>;
+      using value_type = iter_value_t<_Iterator>;
+      using difference_type = iter_difference_t<_Iterator>;
+      using reference = iter_reference_t<_Iterator>;
 #endif
 
       /**
@@ -369,7 +373,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
         { return __t.operator->(); }
     };
 
-  //@{
+  ///@{
   /**
    *  @param  __x  A %reverse_iterator.
    *  @param  __y  A %reverse_iterator.
@@ -503,7 +507,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		const reverse_iterator<_IteratorR>& __y)
     { return __y.base() <=> __x.base(); }
 #endif // C++20
-  //@}
+  ///@}
 
 #if __cplusplus < 201103L
   template<typename _Iterator>
@@ -932,7 +936,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return insert_iterator<_Container>(__x, __i); }
 #endif
 
-  // @} group iterators
+  /// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
@@ -1270,6 +1274,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 #endif // C++20
 
+  namespace __detail
+  {
+#if __cplusplus > 201703L && __cpp_lib_concepts
+    template<typename _Iterator>
+      struct __move_iter_cat
+      { };
+
+    template<typename _Iterator>
+      requires requires { typename iterator_traits<_Iterator>::iterator_category; }
+      struct __move_iter_cat<_Iterator>
+      {
+	using iterator_category
+	  = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category,
+			     random_access_iterator_tag>;
+      };
+#endif
+  }
+
   // 24.4.3  Move iterators
   /**
    *  Class template move_iterator is an iterator adapter with the same
@@ -1281,13 +1303,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    */
   template<typename _Iterator>
     class move_iterator
+#if __cplusplus > 201703L && __cpp_lib_concepts
+      : public __detail::__move_iter_cat<_Iterator>
+#endif
     {
       _Iterator _M_current;
 
       using __traits_type = iterator_traits<_Iterator>;
-#if __cplusplus > 201703L && __cpp_lib_concepts
-      using __base_cat = typename __traits_type::iterator_category;
-#else
+#if ! (__cplusplus > 201703L && __cpp_lib_concepts)
       using __base_ref = typename __traits_type::reference;
 #endif
 
@@ -1296,8 +1319,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus > 201703L && __cpp_lib_concepts
       using iterator_concept = input_iterator_tag;
-      using iterator_category
-	= __detail::__clamp_iter_cat<__base_cat, random_access_iterator_tag>;
+      // iterator_category defined in __move_iter_cat
       using value_type = iter_value_t<_Iterator>;
       using difference_type = iter_difference_t<_Iterator>;
       using pointer = _Iterator;
@@ -1341,11 +1363,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       base() const
       { return _M_current; }
 #else
-      constexpr iterator_type
-      base() const &
-#if __cpp_lib_concepts
-	requires copy_constructible<iterator_type>
-#endif
+      constexpr const iterator_type&
+      base() const & noexcept
       { return _M_current; }
 
       constexpr iterator_type
@@ -1612,6 +1631,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    || is_reference_v<iter_reference_t<_It>>
 	    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
 
+    template<typename _It>
+      concept __common_iter_use_postfix_proxy
+	= (!requires (_It& __i) { { *__i++ } -> __can_reference; })
+	  && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
+	  && move_constructible<iter_value_t<_It>>;
   } // namespace __detail
 
   /// An iterator/sentinel adaptor for representing a non-common range.
@@ -1634,11 +1658,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _S_noexcept()
       { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }
 
-    class _Proxy
+    class __arrow_proxy
     {
       iter_value_t<_It> _M_keep;
 
-      _Proxy(iter_reference_t<_It>&& __x)
+      __arrow_proxy(iter_reference_t<_It>&& __x)
       : _M_keep(std::move(__x)) { }
 
       friend class common_iterator;
@@ -1649,6 +1673,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return std::__addressof(_M_keep); }
     };
 
+    class __postfix_proxy
+    {
+      iter_value_t<_It> _M_keep;
+
+      __postfix_proxy(iter_reference_t<_It>&& __x)
+      : _M_keep(std::forward<iter_reference_t<_It>>(__x)) { }
+
+      friend class common_iterator;
+
+    public:
+      const iter_value_t<_It>&
+      operator*() const
+      { return _M_keep; }
+    };
+
   public:
     constexpr
     common_iterator()
@@ -1805,7 +1844,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return std::__addressof(__tmp);
 	}
       else
-	return _Proxy{*_M_it};
+	return __arrow_proxy{*_M_it};
     }
 
     common_iterator&
@@ -1826,8 +1865,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  ++*this;
 	  return __tmp;
 	}
-      else
+      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
 	return _M_it++;
+      else
+	{
+	  __postfix_proxy __p(**this);
+	  ++*this;
+	  return __p;
+	}
     }
 
     template<typename _It2, sentinel_for<_It> _Sent2>
@@ -1958,12 +2003,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  using type = decltype(std::declval<const _CIter&>().operator->());
 	};
 
+      static auto
+      _S_iter_cat()
+      {
+	using _Traits = iterator_traits<_It>;
+	if constexpr (requires { requires derived_from<typename _Traits::iterator_category,
+						       forward_iterator_tag>; })
+	  return forward_iterator_tag{};
+	else
+	  return input_iterator_tag{};
+      }
+
     public:
       using iterator_concept = conditional_t<forward_iterator<_It>,
 	    forward_iterator_tag, input_iterator_tag>;
-      using iterator_category = __detail::__clamp_iter_cat<
-	typename iterator_traits<_It>::iterator_category,
-	forward_iterator_tag, input_iterator_tag>;
+      using iterator_category = decltype(_S_iter_cat());
       using value_type = iter_value_t<_It>;
       using difference_type = iter_difference_t<_It>;
       using pointer = typename __ptr<_It>::type;
@@ -1972,12 +2026,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   // [iterators.counted] Counted iterators
 
+  namespace __detail
+  {
+    template<typename _It>
+      struct __counted_iter_value_type
+      { };
+
+    template<indirectly_readable _It>
+      struct __counted_iter_value_type<_It>
+      { using value_type = iter_value_t<_It>; };
+
+    template<typename _It>
+      struct __counted_iter_concept
+      { };
+
+    template<typename _It>
+      requires requires { typename _It::iterator_concept; }
+      struct __counted_iter_concept<_It>
+      { using iterator_concept = typename _It::iterator_concept; };
+
+    template<typename _It>
+      struct __counted_iter_cat
+      { };
+
+    template<typename _It>
+      requires requires { typename _It::iterator_category; }
+      struct __counted_iter_cat<_It>
+      { using iterator_category = typename _It::iterator_category; };
+  }
+
   /// An iterator adaptor that keeps track of the distance to the end.
   template<input_or_output_iterator _It>
     class counted_iterator
+      : public __detail::__counted_iter_value_type<_It>,
+	public __detail::__counted_iter_concept<_It>,
+	public __detail::__counted_iter_cat<_It>
     {
     public:
       using iterator_type = _It;
+      // value_type defined in __counted_iter_value_type
+      using difference_type = iter_difference_t<_It>;
+      // iterator_concept defined in __counted_iter_concept
+      // iterator_category defined in __counted_iter_cat
 
       constexpr counted_iterator() = default;
 
@@ -2003,10 +2093,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return *this;
 	}
 
-      constexpr _It
-      base() const &
-      noexcept(is_nothrow_copy_constructible_v<_It>)
-      requires copy_constructible<_It>
+      constexpr const _It&
+      base() const & noexcept
       { return _M_current; }
 
       constexpr _It
@@ -2028,6 +2116,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       requires __detail::__dereferenceable<const _It>
       { return *_M_current; }
 
+      constexpr auto
+      operator->() const noexcept
+      requires contiguous_iterator<_It>
+      { return std::to_address(_M_current); }
+
       constexpr counted_iterator&
       operator++()
       {
@@ -2170,20 +2263,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       iter_difference_t<_It> _M_length = 0;
     };
 
-  template<typename _It>
-    struct incrementable_traits<counted_iterator<_It>>
-    {
-      using difference_type = iter_difference_t<_It>;
-    };
-
   template<input_iterator _It>
+    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
     struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
     {
-      using pointer = void;
+      using pointer = conditional_t<contiguous_iterator<_It>,
+				    add_pointer_t<iter_reference_t<_It>>,
+				    void>;
     };
 #endif // C++20
 
-  // @} group iterators
+  /// @} group iterators
 
   template<typename _Iterator>
     auto
diff --git a/libstdc++-v3/include/bits/stl_iterator_base_types.h b/libstdc++-v3/include/bits/stl_iterator_base_types.h
index aa02af59dc6..09279976bd6 100644
--- a/libstdc++-v3/include/bits/stl_iterator_base_types.h
+++ b/libstdc++-v3/include/bits/stl_iterator_base_types.h
@@ -79,7 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  @defgroup iterators Iterators
    *  Abstractions for uniform iterating through various underlying types.
   */
-  //@{ 
+  ///@{
 
   /**
    *  @defgroup iterator_tags Iterator Tags
@@ -88,7 +88,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  are.  Different underlying algorithms can then be used based on the
    *  different operations supported by different iterator types.
   */
-  //@{ 
+  ///@{
   ///  Marking input iterators.
   struct input_iterator_tag { };
 
@@ -110,7 +110,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// Contiguous iterators point to objects stored contiguously in memory.
   struct contiguous_iterator_tag : public random_access_iterator_tag { };
 #endif
-  //@}
+  ///@}
 
   /**
    *  @brief  Common %iterator class.
@@ -238,7 +238,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __iterator_category(const _Iter&)
     { return typename iterator_traits<_Iter>::iterator_category(); }
 
-  //@}
+  ///@}
 
 #if __cplusplus >= 201103L
   template<typename _Iter>
diff --git a/libstdc++-v3/include/bits/stl_map.h b/libstdc++-v3/include/bits/stl_map.h
index 2772d11462e..0bf9333fe62 100644
--- a/libstdc++-v3/include/bits/stl_map.h
+++ b/libstdc++-v3/include/bits/stl_map.h
@@ -816,7 +816,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	insert(_Pair&& __x)
 	{ return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
 #endif
-      // @}
+      /// @}
 
 #if __cplusplus >= 201103L
       /**
@@ -878,7 +878,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 					     std::forward<_Pair>(__x));
 	}
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief Template function that attempts to insert a range of elements.
@@ -1036,7 +1036,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_t.erase(__position); }
-      // @}
+      /// @}
 #else
       /**
        *  @brief Erases an element from a %map.
@@ -1152,7 +1152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // [23.3.1.3] map operations
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %map.
        *  @param  __x  Key of (key, value) %pair to be located.
@@ -1175,9 +1175,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %map.
        *  @param  __x  Key of (key, value) %pair to be located.
@@ -1200,9 +1200,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Finds the number of elements with given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1221,10 +1221,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1239,10 +1239,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1265,9 +1265,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1290,9 +1290,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1310,9 +1310,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1330,9 +1330,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1359,9 +1359,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1392,7 +1392,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	      _M_t._M_equal_range_tr(__x));
 	}
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _T1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_multimap.h b/libstdc++-v3/include/bits/stl_multimap.h
index 65f4d0117a4..38164810523 100644
--- a/libstdc++-v3/include/bits/stl_multimap.h
+++ b/libstdc++-v3/include/bits/stl_multimap.h
@@ -551,7 +551,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	insert(_Pair&& __x)
 	{ return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief Inserts a std::pair into the %multimap.
@@ -597,7 +597,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 					    std::forward<_Pair>(__x));
 	}
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief A template function that attempts to insert a range
@@ -707,7 +707,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_t.erase(__position); }
-      // @}
+      /// @}
 #else
       /**
        *  @brief Erases an element from a %multimap.
@@ -827,7 +827,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // multimap operations
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %multimap.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -849,9 +849,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %multimap.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -873,9 +873,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the number of elements with given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -891,10 +891,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -909,10 +909,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -935,9 +935,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -960,9 +960,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -980,9 +980,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1000,9 +1000,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1027,9 +1027,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1058,7 +1058,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	      _M_t._M_equal_range_tr(__x));
 	}
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _T1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_multiset.h b/libstdc++-v3/include/bits/stl_multiset.h
index bf6ae7de095..a0e635e00dc 100644
--- a/libstdc++-v3/include/bits/stl_multiset.h
+++ b/libstdc++-v3/include/bits/stl_multiset.h
@@ -720,7 +720,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // multiset operations:
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the number of elements with given key.
        *  @param  __x  Key of elements to be located.
@@ -736,10 +736,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of elements to be located.
@@ -754,12 +754,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 214.  set::find() missing const overload
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %set.
        *  @param  __x  Element to be located.
@@ -792,9 +792,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
 	{ return const_iterator{_M_t._M_find_tr(__x)}; }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -827,9 +827,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -857,9 +857,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -896,7 +896,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_numeric.h b/libstdc++-v3/include/bits/stl_numeric.h
index f95c86a0d48..06cb1ce5259 100644
--- a/libstdc++-v3/include/bits/stl_numeric.h
+++ b/libstdc++-v3/include/bits/stl_numeric.h
@@ -403,7 +403,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       return ++__result;
     }
 
-  // @} group numeric_ops
+  /// @} group numeric_ops
 
 #undef _GLIBCXX_MOVE_IF_20
 
diff --git a/libstdc++-v3/include/bits/stl_pair.h b/libstdc++-v3/include/bits/stl_pair.h
index 491c599076e..053c4236ace 100644
--- a/libstdc++-v3/include/bits/stl_pair.h
+++ b/libstdc++-v3/include/bits/stl_pair.h
@@ -542,7 +542,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
 #endif // __cplusplus >= 201103L
 
-  // @} relates pair
+  /// @} relates pair
 
   /**
    *  @brief A convenience wrapper for creating a pair from two objects.
diff --git a/libstdc++-v3/include/bits/stl_set.h b/libstdc++-v3/include/bits/stl_set.h
index da426650815..246c47a110a 100644
--- a/libstdc++-v3/include/bits/stl_set.h
+++ b/libstdc++-v3/include/bits/stl_set.h
@@ -115,14 +115,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef _Key     key_type;
       typedef _Key     value_type;
       typedef _Compare key_compare;
       typedef _Compare value_compare;
       typedef _Alloc   allocator_type;
-      //@}
+      ///@}
 
     private:
       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
@@ -135,7 +135,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
 
     public:
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Alloc_traits::pointer		 pointer;
       typedef typename _Alloc_traits::const_pointer	 const_pointer;
@@ -150,7 +150,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
       typedef typename _Rep_type::size_type		 size_type;
       typedef typename _Rep_type::difference_type	 difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Rep_type::node_type;
@@ -735,7 +735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // set operations:
 
-      //@{
+      ///@{
       /**
        *  @brief  Finds the number of elements.
        *  @param  __x  Element to located.
@@ -755,10 +755,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of elements to be located.
@@ -773,12 +773,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 214.  set::find() missing const overload
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %set.
        *  @param  __x  Element to be located.
@@ -811,9 +811,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
 	{ return const_iterator{_M_t._M_find_tr(__x)}; }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -846,9 +846,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -876,9 +876,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -915,7 +915,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_tree.h b/libstdc++-v3/include/bits/stl_tree.h
index 5be15afa257..21b72cebf2e 100644
--- a/libstdc++-v3/include/bits/stl_tree.h
+++ b/libstdc++-v3/include/bits/stl_tree.h
@@ -698,7 +698,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  : _Node_allocator(__a), _Base_key_compare(__comp)
 	  { }
 #else
-	  _Rb_tree_impl(_Rb_tree_impl&&) = default;
+	  _Rb_tree_impl(_Rb_tree_impl&&)
+	    noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
+	  = default;
 
 	  explicit
 	  _Rb_tree_impl(_Node_allocator&& __a)
diff --git a/libstdc++-v3/include/bits/stl_uninitialized.h b/libstdc++-v3/include/bits/stl_uninitialized.h
index 3109a89462d..5f75f69d3a2 100644
--- a/libstdc++-v3/include/bits/stl_uninitialized.h
+++ b/libstdc++-v3/include/bits/stl_uninitialized.h
@@ -1033,7 +1033,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// @endcond
 #endif
 
-  // @} group memory
+  /// @} group memory
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/stream_iterator.h b/libstdc++-v3/include/bits/stream_iterator.h
index bd5ba2a80c0..f53cadf5c24 100644
--- a/libstdc++-v3/include/bits/stream_iterator.h
+++ b/libstdc++-v3/include/bits/stream_iterator.h
@@ -177,7 +177,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : public iterator<output_iterator_tag, void, void, void, void>
     {
     public:
-      //@{
+      ///@{
       /// Public typedef
 #if __cplusplus > 201703L
       using difference_type = ptrdiff_t;
@@ -185,7 +185,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef basic_ostream<_CharT, _Traits> ostream_type;
-      //@}
+      ///@}
 
     private:
       ostream_type*	_M_stream;
@@ -249,7 +249,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return *this; }
     };
 
-  // @} group iterators
+  /// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/streambuf_iterator.h b/libstdc++-v3/include/bits/streambuf_iterator.h
index d3f1610fc8d..d77ecc5f9cb 100644
--- a/libstdc++-v3/include/bits/streambuf_iterator.h
+++ b/libstdc++-v3/include/bits/streambuf_iterator.h
@@ -53,7 +53,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
 #if __cplusplus < 201103L
       typedef _CharT& reference; // Changed to _CharT by LWG 445
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename _Traits::int_type		int_type;
       typedef basic_streambuf<_CharT, _Traits>		streambuf_type;
       typedef basic_istream<_CharT, _Traits>		istream_type;
-      //@}
+      ///@}
 
       template<typename _CharT2>
 	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
@@ -241,7 +241,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
 #if __cplusplus > 201703L
       using difference_type = ptrdiff_t;
@@ -250,7 +250,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef _Traits			       traits_type;
       typedef basic_streambuf<_CharT, _Traits> streambuf_type;
       typedef basic_ostream<_CharT, _Traits>   ostream_type;
-      //@}
+      ///@}
 
       template<typename _CharT2>
 	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
@@ -499,7 +499,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __i._M_c = __eof;
     }
 
-// @} group iterators
+/// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/unique_ptr.h b/libstdc++-v3/include/bits/unique_ptr.h
index d0e4cefadd7..05fe652cf36 100644
--- a/libstdc++-v3/include/bits/unique_ptr.h
+++ b/libstdc++-v3/include/bits/unique_ptr.h
@@ -906,7 +906,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return compare_three_way()(__x.get(), static_cast<pointer>(nullptr));
     }
 #endif
-  // @} relates unique_ptr
+  /// @} relates unique_ptr
 
   /// @cond undocumented
   template<typename _Up, typename _Ptr = typename _Up::pointer,
@@ -971,7 +971,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _Tp, typename... _Args>
     inline typename _MakeUniq<_Tp>::__invalid_type
     make_unique(_Args&&...) = delete;
-  // @} relates unique_ptr
+  /// @} relates unique_ptr
 #endif // C++14
 
 #if __cplusplus > 201703L && __cpp_concepts
@@ -989,7 +989,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 #endif // C++20
 
-  // @} group pointer_abstractions
+  /// @} group pointer_abstractions
 
 #if __cplusplus >= 201703L
   namespace __detail::__variant
diff --git a/libstdc++-v3/include/bits/unordered_map.h b/libstdc++-v3/include/bits/unordered_map.h
index 0071d62e462..d75e89240c4 100644
--- a/libstdc++-v3/include/bits/unordered_map.h
+++ b/libstdc++-v3/include/bits/unordered_map.h
@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
@@ -114,9 +114,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -128,7 +128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -209,6 +209,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_map(unordered_map&& __umap,
 		    const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__umap._M_h), __a)) )
       : _M_h(std::move(__umap._M_h), __a)
       { }
 
@@ -324,7 +325,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin() noexcept
       { return _M_h.begin(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_map.
@@ -336,7 +337,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cbegin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read/write iterator that points one past the last element in
@@ -346,7 +347,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end() noexcept
       { return _M_h.end(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_map.
@@ -358,7 +359,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cend() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       // modifiers.
 
@@ -557,7 +558,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert a std::pair into the %unordered_map.
 
@@ -590,9 +591,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 		      pair<iterator, bool>>
 	insert(_Pair&& __x)
         { return _M_h.emplace(std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert a std::pair into the %unordered_map.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -628,7 +629,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
 	{ return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -773,7 +774,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_map.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -795,7 +796,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -903,7 +904,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_map.
        *  @param  __x  Key to be located.
@@ -922,7 +923,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -948,7 +949,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -964,9 +965,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Subscript ( @c [] ) access to %unordered_map data.
        *  @param  __k  The key for which data should be retrieved.
@@ -986,9 +987,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       mapped_type&
       operator[](key_type&& __k)
       { return _M_h[std::move(__k)]; }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Access to %unordered_map data.
        *  @param  __k  The key for which data should be retrieved.
@@ -1003,7 +1004,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const mapped_type&
       at(const key_type& __k) const
       { return _M_h.at(__k); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1045,7 +1046,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin(size_type __n)
       { return _M_h.begin(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1059,7 +1060,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns a read/write iterator pointing to one past the last
@@ -1071,7 +1072,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end(size_type __n)
       { return _M_h.end(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1085,7 +1086,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
@@ -1253,7 +1254,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
@@ -1261,9 +1262,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -1275,7 +1276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -1355,6 +1356,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_multimap(unordered_multimap&& __ummap,
 			 const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__ummap._M_h), __a)) )
       : _M_h(std::move(__ummap._M_h), __a)
       { }
 
@@ -1470,7 +1472,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin() noexcept
       { return _M_h.begin(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_multimap.
@@ -1482,7 +1484,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cbegin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read/write iterator that points one past the last element in
@@ -1492,7 +1494,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end() noexcept
       { return _M_h.end(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_multimap.
@@ -1504,7 +1506,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cend() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       // modifiers.
 
@@ -1555,7 +1557,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts a std::pair into the %unordered_multimap.
        *  @param __x Pair to be inserted (see std::make_pair for easy
@@ -1577,9 +1579,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(_Pair&& __x)
         { return _M_h.emplace(std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts a std::pair into the %unordered_multimap.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -1613,7 +1615,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
         { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -1666,7 +1668,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_multimap.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -1688,7 +1690,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -1798,7 +1800,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_multimap.
        *  @param  __x  Key to be located.
@@ -1817,7 +1819,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -1839,7 +1841,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -1853,7 +1855,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1895,7 +1897,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin(size_type __n)
       { return _M_h.begin(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1909,7 +1911,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns a read/write iterator pointing to one past the last
@@ -1921,7 +1923,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end(size_type __n)
       { return _M_h.end(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1935,7 +1937,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
diff --git a/libstdc++-v3/include/bits/unordered_set.h b/libstdc++-v3/include/bits/unordered_set.h
index c9c9e9f38b7..c942978557d 100644
--- a/libstdc++-v3/include/bits/unordered_set.h
+++ b/libstdc++-v3/include/bits/unordered_set.h
@@ -101,16 +101,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -122,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -203,6 +203,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_set(unordered_set&& __uset,
 		    const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__uset._M_h), __a)) )
       : _M_h(std::move(__uset._M_h), __a)
       { }
 
@@ -310,7 +311,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // iterators.
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_set.
@@ -322,9 +323,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       begin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_set.
@@ -336,7 +337,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       end() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read-only (constant) iterator that points to the first
@@ -402,7 +403,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert an element into the %unordered_set.
        *  @param  __x  Element to be inserted.
@@ -423,9 +424,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<iterator, bool>
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert an element into the %unordered_set.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -452,7 +453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -504,7 +505,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node(std::move(__nh)).position; }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_set.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -526,7 +527,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -633,7 +634,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_set.
        *  @param  __x  Element to be located.
@@ -652,7 +653,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -678,7 +679,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -694,7 +695,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -726,7 +727,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bucket(const key_type& __key) const
       { return _M_h.bucket(__key); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -744,9 +745,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -764,7 +765,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
@@ -916,16 +917,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -937,7 +938,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -1044,6 +1045,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_multiset(unordered_multiset&& __umset,
 			 const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__umset._M_h), __a)) )
       : _M_h(std::move(__umset._M_h), __a)
       { }
 
@@ -1124,7 +1126,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // iterators.
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_multiset.
@@ -1136,9 +1138,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       begin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_multiset.
@@ -1150,7 +1152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       end() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read-only (constant) iterator that points to the first
@@ -1204,7 +1206,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts an element into the %unordered_multiset.
        *  @param  __x  Element to be inserted.
@@ -1219,9 +1221,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts an element into the %unordered_multiset.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -1245,7 +1247,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that inserts a range of elements.
@@ -1296,7 +1298,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_multiset.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -1319,7 +1321,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
 
       /**
@@ -1432,7 +1434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_multiset.
        *  @param  __x  Element to be located.
@@ -1451,7 +1453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -1473,7 +1475,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -1487,7 +1489,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1519,7 +1521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bucket(const key_type& __key) const
       { return _M_h.bucket(__key); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1537,9 +1539,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1557,7 +1559,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
diff --git a/libstdc++-v3/include/c_global/cmath b/libstdc++-v3/include/c_global/cmath
index b99aaf8df40..d27980ae916 100644
--- a/libstdc++-v3/include/c_global/cmath
+++ b/libstdc++-v3/include/c_global/cmath
@@ -1844,7 +1844,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif // _GLIBCXX_USE_C99_MATH_TR1
 #endif // C++11
 
-#if __cplusplus > 201402L
+#if __cplusplus >= 201703L
 
   // [c.math.hypot3], three-dimensional hypotenuse
 #define __cpp_lib_hypot 201603
@@ -1877,10 +1877,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { return std::__hypot3<long double>(__x, __y, __z); }
 
   template<typename _Tp, typename _Up, typename _Vp>
-    typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
+    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
     hypot(_Tp __x, _Up __y, _Vp __z)
     {
-      using __type = typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type;
+      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
       return std::__hypot3<__type>(__x, __y, __z);
     }
 #endif // C++17
@@ -1918,6 +1918,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   constexpr long double
   lerp(long double __a, long double __b, long double __t) noexcept
   { return std::__lerp(__a, __b, __t); }
+
+  template<typename _Tp, typename _Up, typename _Vp>
+    constexpr __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
+    lerp(_Tp __x, _Up __y, _Vp __z) noexcept
+    {
+      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
+      return std::__lerp<__type>(__x, __y, __z);
+    }
 #endif // C++20
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/debug/helper_functions.h b/libstdc++-v3/include/debug/helper_functions.h
index 62d5309257f..9e2d206f06c 100644
--- a/libstdc++-v3/include/debug/helper_functions.h
+++ b/libstdc++-v3/include/debug/helper_functions.h
@@ -64,7 +64,7 @@ namespace __gnu_debug
     {
     private:
       typedef
-      typename std::iterator_traits<_Iterator>::difference_type _ItDiffType;
+	typename std::iterator_traits<_Iterator>::difference_type _ItDiffType;
 
       template<typename _DiffType,
 	       typename = typename std::__is_void<_DiffType>::__type>
@@ -287,6 +287,18 @@ namespace __gnu_debug
     __can_advance(const _Safe_iterator<_Iterator, _Sequence, _Category>&,
 		  _Size);
 
+  template<typename _InputIterator, typename _Diff>
+    _GLIBCXX_CONSTEXPR
+    inline bool
+    __can_advance(_InputIterator, const std::pair<_Diff, _Distance_precision>&, int)
+    { return true; }
+
+  template<typename _Iterator, typename _Sequence, typename _Category,
+	   typename _Diff>
+    bool
+    __can_advance(const _Safe_iterator<_Iterator, _Sequence, _Category>&,
+		  const std::pair<_Diff, _Distance_precision>&, int);
+
   /** Helper function to extract base iterator of random access safe iterator
    *  in order to reduce performance impact of debug mode.  Limited to random
    *  access iterator because it is the only category for which it is possible
diff --git a/libstdc++-v3/include/debug/macros.h b/libstdc++-v3/include/debug/macros.h
index 73fb50d0cbd..1f45f8e0adc 100644
--- a/libstdc++-v3/include/debug/macros.h
+++ b/libstdc++-v3/include/debug/macros.h
@@ -104,6 +104,12 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Size),	\
 		      ._M_iterator(_First, #_First)			\
 		      ._M_integer(_Size, #_Size))
 
+#define __glibcxx_check_can_increment_dist(_First,_Dist,_Way)		\
+  _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Dist, _Way), \
+		      _M_message(__gnu_debug::__msg_iter_subscript_oob)	\
+		      ._M_iterator(_First, #_First)			\
+		      ._M_integer(_Way * _Dist.first, #_Dist))
+
 #define __glibcxx_check_can_increment_range(_First1,_Last1,_First2)	\
   do									\
   {									\
@@ -115,7 +121,7 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Size),	\
 			._M_iterator(_Last1, #_Last1),			\
 			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
     _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
-			__gnu_debug::__can_advance(_First2, __dist.first),\
+			__gnu_debug::__can_advance(_First2, __dist, 1), \
 			_M_message(__gnu_debug::__msg_iter_subscript_oob)\
 			._M_iterator(_First2, #_First2)			\
 			._M_integer(__dist.first),			\
@@ -133,7 +139,7 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Size),	\
 			._M_iterator(_Last1, #_Last1),			\
 			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
     _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
-			__gnu_debug::__can_advance(_First2, -__dist.first),\
+			__gnu_debug::__can_advance(_First2, __dist, -1), \
 			_M_message(__gnu_debug::__msg_iter_subscript_oob)\
 			._M_iterator(_First2, #_First2)			\
 			._M_integer(-__dist.first),			\
diff --git a/libstdc++-v3/include/debug/safe_iterator.h b/libstdc++-v3/include/debug/safe_iterator.h
index 687b844fd75..2f51618dd88 100644
--- a/libstdc++-v3/include/debug/safe_iterator.h
+++ b/libstdc++-v3/include/debug/safe_iterator.h
@@ -405,6 +405,12 @@ namespace __gnu_debug
       bool
       _M_can_advance(difference_type __n, bool __strict = false) const;
 
+      // Can we advance the iterator using @p __dist in @p __way direction.
+      template<typename _Diff>
+	bool
+	_M_can_advance(const std::pair<_Diff, _Distance_precision>& __dist,
+		       int __way) const;
+
       // Is the iterator range [*this, __rhs) valid?
       bool
       _M_valid_range(const _Safe_iterator& __rhs,
@@ -956,6 +962,14 @@ namespace __gnu_debug
 		  _Size __n)
     { return __it._M_can_advance(__n); }
 
+  template<typename _Iterator, typename _Sequence, typename _Category,
+	   typename _Diff>
+    inline bool
+    __can_advance(const _Safe_iterator<_Iterator, _Sequence, _Category>& __it,
+		  const std::pair<_Diff, _Distance_precision>& __dist,
+		  int __way)
+    { return __it._M_can_advance(__dist, __way); }
+
   template<typename _Iterator, typename _Sequence>
     _Iterator
     __base(const _Safe_iterator<_Iterator, _Sequence,
diff --git a/libstdc++-v3/include/debug/safe_iterator.tcc b/libstdc++-v3/include/debug/safe_iterator.tcc
index 312a88911ee..79a8ee28d97 100644
--- a/libstdc++-v3/include/debug/safe_iterator.tcc
+++ b/libstdc++-v3/include/debug/safe_iterator.tcc
@@ -92,24 +92,32 @@ namespace __gnu_debug
       if (__n == 0)
 	return true;
 
+      std::pair<difference_type, _Distance_precision> __dist = __n < 0
+	? _M_get_distance_from_begin()
+	: _M_get_distance_to_end();
+
       if (__n < 0)
-	{
-	  std::pair<difference_type, _Distance_precision> __dist =
-	    _M_get_distance_from_begin();
-	  return __dist.second == __dp_exact
-	    ? __dist.first >= -__n
-	    : !__strict && __dist.first > 0;
-	}
-      else
-	{
-	  std::pair<difference_type, _Distance_precision> __dist =
-	    _M_get_distance_to_end();
-	  return __dist.second == __dp_exact
-	    ? __dist.first >= __n
-	    : !__strict && __dist.first > 0;
-	}
+	__n = -__n;
+
+      return __dist.second > __dp_sign
+	? __dist.first >= __n
+	: !__strict && __dist.first > 0;
     }
 
+  template<typename _Iterator, typename _Sequence, typename _Category>
+    template<typename _Diff>
+      bool
+      _Safe_iterator<_Iterator, _Sequence, _Category>::
+      _M_can_advance(const std::pair<_Diff, _Distance_precision>& __dist,
+		     int __way) const
+      {
+	return __dist.second == __dp_exact
+	  ? _M_can_advance(__way * __dist.first)
+	  : _M_can_advance(__way * (__dist.first == 0
+				    ? 0
+				    : __dist.first < 0 ? -1 : 1));
+      }
+
   template<typename _Iterator, typename _Sequence, typename _Category>
     typename _Distance_traits<_Iterator>::__type
     _Safe_iterator<_Iterator, _Sequence, _Category>::
@@ -191,19 +199,12 @@ namespace __gnu_debug
 
       /* Determine iterators order */
       __dist = _M_get_distance_to(__rhs);
-      switch (__dist.second)
+      if (__dist.second != __dp_equality)
 	{
-	case __dp_equality:
-	  if (__dist.first == 0)
-	    return true;
-	  break;
-
-	case __dp_sign:
-	case __dp_exact:
 	  // If range is not empty first iterator must be dereferenceable.
-	  if (__dist.first > 0)
-	    return !__check_dereferenceable || _M_dereferenceable();
-	  return __dist.first == 0;
+	  return __dist.first == 0
+	    || (__dist.first > 0
+		&& (!__check_dereferenceable || _M_dereferenceable()));
 	}
 
       // Assume that this is a valid range; we can't check anything else.
@@ -224,9 +225,8 @@ namespace __gnu_debug
       __dist = std::make_pair(__rhs.base() - this->base(), __dp_exact);
 
       // If range is not empty first iterator must be dereferenceable.
-      if (__dist.first > 0)
-	return this->_M_dereferenceable();
-      return __dist.first == 0;
+      return __dist.first == 0
+	|| (__dist.first > 0 && this->_M_dereferenceable());
     }
 } // namespace __gnu_debug
 
@@ -244,7 +244,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_Ite>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, __dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	return std::__copy_move_a<_IsMove>(__first.base(), __last.base(),
@@ -261,7 +261,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, __dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_sign
 	  && __result._M_can_advance(__dist.first, true))
@@ -283,7 +283,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_IIte>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, __dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	{
@@ -311,7 +311,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_Ite>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, -__dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, -1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	return std::__copy_move_backward_a<_IsMove>(
@@ -328,7 +328,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, -__dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, -1);
 
       if (__dist.second > ::__gnu_debug::__dp_sign
 	  && __result._M_can_advance(-__dist.first, true))
@@ -351,7 +351,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_IIte>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, -__dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, -1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	{
@@ -416,7 +416,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;
       __glibcxx_check_valid_range2(__first1, __last1, __dist);
-      __glibcxx_check_can_increment(__first2, __dist.first);
+      __glibcxx_check_can_increment_dist(__first2, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	return std::__equal_aux(__first1.base(), __last1.base(), __first2);
@@ -431,7 +431,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;
       __glibcxx_check_valid_range2(__first1, __last1, __dist);
-      __glibcxx_check_can_increment(__first2, __dist.first);
+      __glibcxx_check_can_increment_dist(__first2, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_sign
 	  && __first2._M_can_advance(__dist.first, true))
@@ -450,7 +450,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;
       __glibcxx_check_valid_range2(__first1, __last1, __dist);
-      __glibcxx_check_can_increment(__first2, __dist.first);
+      __glibcxx_check_can_increment_dist(__first2, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	{
diff --git a/libstdc++-v3/include/debug/stl_iterator.h b/libstdc++-v3/include/debug/stl_iterator.h
index 6044f3588d9..02adb6e3c06 100644
--- a/libstdc++-v3/include/debug/stl_iterator.h
+++ b/libstdc++-v3/include/debug/stl_iterator.h
@@ -52,6 +52,13 @@ namespace __gnu_debug
     __can_advance(const std::reverse_iterator<_Iterator>& __it, _Size __n)
     { return __can_advance(__it.base(), -__n); }
 
+  template<typename _Iterator, typename _Diff>
+    inline bool
+    __can_advance(const std::reverse_iterator<_Iterator>& __it,
+		  const std::pair<_Diff, _Distance_precision>& __dist,
+		  int __way)
+    { return __can_advance(__it.base(), __dist, -__way); }
+
   template<typename _Iterator, typename _Sequence>
     inline std::reverse_iterator<_Iterator>
     __base(const std::reverse_iterator<_Safe_iterator<
@@ -101,6 +108,13 @@ namespace __gnu_debug
     __can_advance(const std::move_iterator<_Iterator>& __it, _Size __n)
     { return __can_advance(__it.base(), __n); }
 
+  template<typename _Iterator, typename _Diff>
+    inline bool
+    __can_advance(const std::move_iterator<_Iterator>& __it,
+		  const std::pair<_Diff, _Distance_precision>& __dist,
+		  int __way)
+    { return __can_advance(__it.base(), __dist, __way); }
+
   template<typename _Iterator>
     inline auto
     __unsafe(const std::move_iterator<_Iterator>& __it)
diff --git a/libstdc++-v3/include/debug/unordered_map b/libstdc++-v3/include/debug/unordered_map
index 17fbba3aade..54a8cba1c7b 100644
--- a/libstdc++-v3/include/debug/unordered_map
+++ b/libstdc++-v3/include/debug/unordered_map
@@ -136,6 +136,7 @@ namespace __debug
 
       unordered_map(unordered_map&& __umap,
 		    const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )
       : _Safe(std::move(__umap._M_safe()), __a),
 	_Base(std::move(__umap._M_base()), __a) { }
 
@@ -160,7 +161,7 @@ namespace __debug
 	unordered_map(_InputIterator __first, _InputIterator __last,
 		      size_type __n,
 		      const allocator_type& __a)
-	  : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
@@ -168,20 +169,20 @@ namespace __debug
 		      size_type __n,
 		      const hasher& __hf,
 		      const allocator_type& __a)
-	  : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_map(initializer_list<value_type> __l,
 		    size_type __n,
 		    const allocator_type& __a)
-	: unordered_map(__l, __n, hasher(), key_equal(), __a)
+      : unordered_map(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_map(initializer_list<value_type> __l,
 		    size_type __n,
 		    const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_map(__l, __n, __hf, key_equal(), __a)
+      : unordered_map(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_map() = default;
@@ -831,6 +832,7 @@ namespace __debug
 
       unordered_multimap(unordered_multimap&& __umap,
 			 const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )
       : _Safe(std::move(__umap._M_safe()), __a),
 	_Base(std::move(__umap._M_base()), __a) { }
 
@@ -854,26 +856,26 @@ namespace __debug
 	unordered_multimap(_InputIterator __first, _InputIterator __last,
 			   size_type __n,
 			   const allocator_type& __a)
-	  : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_multimap(_InputIterator __first, _InputIterator __last,
 			   size_type __n, const hasher& __hf,
 			   const allocator_type& __a)
-	  : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_multimap(initializer_list<value_type> __l,
 			 size_type __n,
 			 const allocator_type& __a)
-	: unordered_multimap(__l, __n, hasher(), key_equal(), __a)
+      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_multimap(initializer_list<value_type> __l,
 			 size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multimap(__l, __n, __hf, key_equal(), __a)
+      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_multimap() = default;
diff --git a/libstdc++-v3/include/debug/unordered_set b/libstdc++-v3/include/debug/unordered_set
index 4d30852186c..609cf42a076 100644
--- a/libstdc++-v3/include/debug/unordered_set
+++ b/libstdc++-v3/include/debug/unordered_set
@@ -133,6 +133,7 @@ namespace __debug
 
       unordered_set(unordered_set&& __uset,
 		    const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )
       : _Safe(std::move(__uset._M_safe()), __a),
 	_Base(std::move(__uset._M_base()), __a) { }
 
@@ -144,38 +145,38 @@ namespace __debug
       : _Base(__l, __n, __hf, __eql, __a) { }
 
       unordered_set(size_type __n, const allocator_type& __a)
-	: unordered_set(__n, hasher(), key_equal(), __a)
+      : unordered_set(__n, hasher(), key_equal(), __a)
       { }
 
       unordered_set(size_type __n, const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_set(__n, __hf, key_equal(), __a)
+      : unordered_set(__n, __hf, key_equal(), __a)
       { }
 
       template<typename _InputIterator>
 	unordered_set(_InputIterator __first, _InputIterator __last,
 		      size_type __n,
 		      const allocator_type& __a)
-	  : unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_set(_InputIterator __first, _InputIterator __last,
 		      size_type __n, const hasher& __hf,
 		      const allocator_type& __a)
-	  : unordered_set(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_set(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_set(initializer_list<value_type> __l,
 		    size_type __n,
 		    const allocator_type& __a)
-	: unordered_set(__l, __n, hasher(), key_equal(), __a)
+      : unordered_set(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_set(initializer_list<value_type> __l,
 		    size_type __n, const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_set(__l, __n, __hf, key_equal(), __a)
+      : unordered_set(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_set() = default;
@@ -701,6 +702,7 @@ namespace __debug
 
       unordered_multiset(unordered_multiset&& __uset,
 			 const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )
       : _Safe(std::move(__uset._M_safe()), __a),
 	_Base(std::move(__uset._M_base()), __a) { }
 
@@ -712,38 +714,38 @@ namespace __debug
       : _Base(__l, __n, __hf, __eql, __a) { }
 
       unordered_multiset(size_type __n, const allocator_type& __a)
-	: unordered_multiset(__n, hasher(), key_equal(), __a)
+      : unordered_multiset(__n, hasher(), key_equal(), __a)
       { }
 
       unordered_multiset(size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multiset(__n, __hf, key_equal(), __a)
+      : unordered_multiset(__n, __hf, key_equal(), __a)
       { }
 
       template<typename _InputIterator>
 	unordered_multiset(_InputIterator __first, _InputIterator __last,
 			   size_type __n,
 			   const allocator_type& __a)
-	  : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_multiset(_InputIterator __first, _InputIterator __last,
 			   size_type __n, const hasher& __hf,
 			   const allocator_type& __a)
-	  : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_multiset(initializer_list<value_type> __l,
 			 size_type __n,
 			 const allocator_type& __a)
-	: unordered_multiset(__l, __n, hasher(), key_equal(), __a)
+      : unordered_multiset(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_multiset(initializer_list<value_type> __l,
 			 size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multiset(__l, __n, __hf, key_equal(), __a)
+      : unordered_multiset(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_multiset() = default;
diff --git a/libstdc++-v3/include/decimal/decimal b/libstdc++-v3/include/decimal/decimal
index 8863d7e2a13..0e7e274716a 100644
--- a/libstdc++-v3/include/decimal/decimal
+++ b/libstdc++-v3/include/decimal/decimal
@@ -484,7 +484,7 @@ namespace decimal
 
 #define _GLIBCXX_USE_DECIMAL_ 1
 } // namespace decimal
-  // @} group decimal
+  /// @} group decimal
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/experimental/any b/libstdc++-v3/include/experimental/any
index 43455de479f..9b68f12c471 100644
--- a/libstdc++-v3/include/experimental/any
+++ b/libstdc++-v3/include/experimental/any
@@ -412,7 +412,7 @@ inline namespace fundamentals_v1
 	return std::move(*__p);
       __throw_bad_any_cast();
     }
-  // @}
+  /// @}
 
   /// @cond undocumented
   template<typename _Tp>
@@ -479,7 +479,7 @@ inline namespace fundamentals_v1
 	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
-  // @}
+  /// @}
 
   template<typename _Tp>
     void
@@ -555,7 +555,7 @@ inline namespace fundamentals_v1
       _S_manage(_Op, const any*, _Arg*) { }
     };
 
-  // @} group any
+  /// @} group any
 } // namespace fundamentals_v1
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/array b/libstdc++-v3/include/experimental/array
index 427bf8567cf..d3ee87101eb 100644
--- a/libstdc++-v3/include/experimental/array
+++ b/libstdc++-v3/include/experimental/array
@@ -104,7 +104,7 @@ template <typename _Tp, size_t _Nm>
     return experimental::__to_array(__a, make_index_sequence<_Nm>{});
   }
 
-  // @} group make_array
+  /// @} group make_array
 } // namespace fundamentals_v2
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/bits/fs_dir.h b/libstdc++-v3/include/experimental/bits/fs_dir.h
index ae67ae95015..dcffd65bb5e 100644
--- a/libstdc++-v3/include/experimental/bits/fs_dir.h
+++ b/libstdc++-v3/include/experimental/bits/fs_dir.h
@@ -351,7 +351,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
 _GLIBCXX_END_NAMESPACE_CXX11
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_fwd.h b/libstdc++-v3/include/experimental/bits/fs_fwd.h
index 535a800584f..4c80401ac14 100644
--- a/libstdc++-v3/include/experimental/bits/fs_fwd.h
+++ b/libstdc++-v3/include/experimental/bits/fs_fwd.h
@@ -279,7 +279,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   bool is_regular_file(file_status) noexcept;
   bool is_symlink(file_status) noexcept;
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_ops.h b/libstdc++-v3/include/experimental/bits/fs_ops.h
index 61611ba53eb..5b0aad4e3ae 100644
--- a/libstdc++-v3/include/experimental/bits/fs_ops.h
+++ b/libstdc++-v3/include/experimental/bits/fs_ops.h
@@ -288,7 +288,7 @@ inline namespace v1
   path temp_directory_path();
   path temp_directory_path(error_code& __ec);
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 69b823a3466..0a8f4eee0a1 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -124,7 +124,7 @@ namespace __detail
 
   template<typename _Source>
     struct __constructible_from<_Source, void>
-    : decltype(__is_path_src(std::declval<_Source>(), 0))
+    : decltype(__is_path_src(std::declval<const _Source&>(), 0))
     { };
 
   template<typename _Tp1, typename _Tp2 = void,
@@ -1268,7 +1268,7 @@ namespace __detail
     return _M_at_end == __rhs._M_at_end;
   }
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 _GLIBCXX_END_NAMESPACE_CXX11
 } // namespace v1
 } // namespace filesystem
diff --git a/libstdc++-v3/include/experimental/buffer b/libstdc++-v3/include/experimental/buffer
index 0b04b71286c..d319785fb25 100644
--- a/libstdc++-v3/include/experimental/buffer
+++ b/libstdc++-v3/include/experimental/buffer
@@ -172,7 +172,7 @@ inline namespace v1
     buffer_sequence_end(const _Cont& __c) -> decltype(__c.end())
     { return __c.end(); }
 
-  // @}
+  /// @}
 
 
   /** @brief buffer type traits
@@ -250,7 +250,7 @@ inline namespace v1
   template<typename _Tp>
     constexpr bool is_dynamic_buffer_v = is_dynamic_buffer<_Tp>::value;
 
-  // @}
+  /// @}
 
   /// buffer size
   template<typename _ConstBufferSequence>
@@ -727,7 +727,7 @@ inline namespace v1
       return net::read(__stream, __b, __completion_condition, __ec);
     }
 
-  // @}
+  /// @}
 
   /** @brief asynchronous read operations
    * @{
@@ -775,7 +775,7 @@ inline namespace v1
 			     std::forward<_CompletionToken>(__token));
     }
 
-  // @}
+  /// @}
 
 #if 0
   /** @brief synchronous write operations:
@@ -811,7 +811,7 @@ inline namespace v1
     size_t write(_SyncWriteStream& __stream, _DynamicBuffer&& __b,
                  _CompletionCondition __completion_condition, error_code& __ec);
 
-  // @}
+  /// @}
 
   /** @brief asynchronous write operations
    * @{
@@ -839,7 +839,7 @@ inline namespace v1
                        _CompletionCondition __completion_condition,
                        _CompletionToken&& __token);
 
-  // @}
+  /// @}
 
   /** @brief synchronous delimited read operations
    * @{
@@ -856,7 +856,7 @@ inline namespace v1
     size_t read_until(_SyncReadStream& __s, _DynamicBuffer&& __b,
                       string_view __delim, error_code& __ec);
 
-  // @}
+  /// @}
 
   /** @brief asynchronous delimited read operations
    * @{
@@ -871,7 +871,7 @@ inline namespace v1
                           _DynamicBuffer&& __b, string_view __delim,
                           _CompletionToken&& __token);
 
-  // @}
+  /// @}
 
 #endif
   /// @}
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index add9b09192d..de9da930274 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -101,10 +101,10 @@ namespace ip
     return __c;
   }
 
-  error_code make_error_code(resolver_errc __e) noexcept
+  inline error_code make_error_code(resolver_errc __e) noexcept
   { return error_code(static_cast<int>(__e), resolver_category()); }
 
-  error_condition make_error_condition(resolver_errc __e) noexcept
+  inline error_condition make_error_condition(resolver_errc __e) noexcept
   { return error_condition(static_cast<int>(__e), resolver_category()); }
 
   /// @}
@@ -126,7 +126,7 @@ namespace ip
   struct v4_mapped_t {};
   constexpr v4_mapped_t v4_mapped;
 
-  // @}
+  /// @}
 
   /// An IPv4 address.
   class address_v4
@@ -541,7 +541,7 @@ namespace ip
   operator>=(const address_v4& __a, const address_v4& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address_v6 comparisons
    * @{
@@ -585,7 +585,7 @@ namespace ip
   operator>=(const address_v6& __a, const address_v6& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address comparisons
    * @{
@@ -623,7 +623,7 @@ namespace ip
   operator>=(const address& __a, const address& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address_v4 creation
    * @{
@@ -695,7 +695,7 @@ namespace ip
   make_address_v4(string_view __str)
   { return make_address_v4(__str, __throw_on_error{"make_address_v4"}); }
 
-  // @}
+  /// @}
 
   /** ip::address_v6 creation
    * @{
@@ -867,7 +867,7 @@ namespace ip
   make_address_v6(string_view __str)
   { return make_address_v6(__str, __throw_on_error{"make_address_v6"}); }
 
-  // @}
+  /// @}
 
   /** ip::address creation
    * @{
@@ -912,7 +912,7 @@ namespace ip
   make_address(string_view __str)
   { return make_address(__str, __throw_on_error{"make_address"}); }
 
-  // @}
+  /// @}
 
   /// ip::address I/O
   template<typename _CharT, typename _Traits>
@@ -1093,7 +1093,7 @@ namespace ip
 
   typedef basic_address_range<address_v4> address_v4_range;
 
-  // @}
+  /// @}
 
   /** An IPv6 address range.
    * @{
@@ -1134,7 +1134,7 @@ namespace ip
 
   typedef basic_address_range<address_v6> address_v6_range;
 
-  // @}
+  /// @}
 
   bool
   operator==(const network_v4& __a, const network_v4& __b) noexcept;
@@ -1307,7 +1307,7 @@ namespace ip
   operator!=(const network_v4& __a, const network_v4& __b) noexcept
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** ip::network_v6 comparisons
    * @{
@@ -1324,7 +1324,7 @@ namespace ip
   operator!=(const network_v6& __a, const network_v6& __b) noexcept
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** ip::network_v4 creation
    * @{
@@ -1334,7 +1334,7 @@ namespace ip
   make_network_v4(const address_v4& __a, int __prefix_len)
   { return network_v4{__a, __prefix_len}; }
 
-  network_v4
+  inline network_v4
   make_network_v4(const address_v4& __a, const address_v4& __mask)
   { return network_v4{ __a, __mask }; }
 
@@ -1356,7 +1356,7 @@ namespace ip
   make_network_v4(string_view __str)
   { return make_network_v4(__str, __throw_on_error{"make_network_v4"}); }
 
-  // @}
+  /// @}
 
   /** ip::network_v6 creation
    * @{
@@ -1384,7 +1384,7 @@ namespace ip
   make_network_v6(string_view __str)
   { return make_network_v6(__str, __throw_on_error{"make_network_v6"}); }
 
-  // @}
+  /// @}
 
   /// ip::network_v4 I/O
   template<typename _CharT, typename _Traits>
@@ -1566,7 +1566,7 @@ namespace ip
 	       const basic_endpoint<_InternetProtocol>& __b)
     { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /// basic_endpoint I/O
   template<typename _CharT, typename _Traits, typename _InternetProtocol>
@@ -1640,7 +1640,7 @@ namespace ip
 	       const basic_resolver_entry<_InternetProtocol>& __b)
     { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** Base class defining flags for name/address resolution.
    * @{
@@ -1706,7 +1706,7 @@ namespace ip
 
   // TODO define resolver_base::flags static constants for C++14 mode
 
-  // @}
+  /// @}
 
   /** Container for results of name/address resolution.
    * @{
@@ -1788,7 +1788,7 @@ namespace ip
 	       const basic_resolver_results<_InternetProtocol>& __b)
     { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// Perform name/address resolution.
   template<typename _InternetProtocol>
@@ -2071,7 +2071,7 @@ namespace ip
   host_name()
   { return host_name(std::allocator<char>{}, __throw_on_error{"host_name"}); }
 
-  // @}
+  /// @}
 
   /// The TCP byte-stream protocol.
   class tcp
@@ -2126,7 +2126,7 @@ namespace ip
   operator!=(const tcp& __a, const tcp& __b)
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// The UDP datagram protocol.
   class udp
@@ -2157,7 +2157,7 @@ namespace ip
    * @{
    */
 
-  bool
+  inline bool
   operator==(const udp& __a, const udp& __b)
   { return __a.family() == __b.family(); }
 
@@ -2165,7 +2165,7 @@ namespace ip
   operator!=(const udp& __a, const udp& __b)
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// Restrict a socket created for an IPv6 protocol to IPv6 only.
   struct v6_only : __sockopt_crtp<v6_only, bool>
@@ -2395,7 +2395,7 @@ namespace ip
 
   } // namespace multicast
 
-  // @}
+  /// @}
 
 } // namespace ip
 } // namespace v1
diff --git a/libstdc++-v3/include/experimental/optional b/libstdc++-v3/include/experimental/optional
index 370e95ae83e..33c509678c1 100644
--- a/libstdc++-v3/include/experimental/optional
+++ b/libstdc++-v3/include/experimental/optional
@@ -910,8 +910,8 @@ inline namespace fundamentals_v1
     make_optional(_Tp&& __t)
     { return optional<decay_t<_Tp>> { std::forward<_Tp>(__t) }; }
 
-  // @} relates experimental::optional
-  // @} group optional
+  /// @} relates experimental::optional
+  /// @} group optional
 } // namespace fundamentals_v1
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/propagate_const b/libstdc++-v3/include/experimental/propagate_const
index b1b70cab879..d7034d6f724 100644
--- a/libstdc++-v3/include/experimental/propagate_const
+++ b/libstdc++-v3/include/experimental/propagate_const
@@ -422,7 +422,7 @@ inline namespace fundamentals_v2
       return __pt._M_t;
     }
 
-  // @} group propagate_const
+  /// @} group propagate_const
 } // namespace fundamentals_v2
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/socket b/libstdc++-v3/include/experimental/socket
index 4c47348373b..725fee4e71a 100644
--- a/libstdc++-v3/include/experimental/socket
+++ b/libstdc++-v3/include/experimental/socket
@@ -2285,7 +2285,7 @@ inline namespace v1
       protocol_type _M_protocol;
     };
 
-  // @}
+  /// @}
 
   /** @brief Socket streams
    * @{
@@ -2456,7 +2456,7 @@ inline namespace v1
       __streambuf_type _M_sb;
     };
 
-  // @}
+  /// @}
 
   /** @brief synchronous connect operations
    * @{
@@ -2577,7 +2577,7 @@ inline namespace v1
 			  __ec);
     }
 
-  // @}
+  /// @}
 
   /** @brief asynchronous connect operations
    * @{
@@ -2627,11 +2627,11 @@ inline namespace v1
 				forward<_CompletionToken>(__token));
     }
 
-  // @}
+  /// @}
 
 #endif  // _GLIBCXX_HAVE_UNISTD_H
 
-  // @}
+  /// @}
 
 } // namespace v1
 } // namespace net
diff --git a/libstdc++-v3/include/ext/bitmap_allocator.h b/libstdc++-v3/include/ext/bitmap_allocator.h
index edddf32fb97..7e34f97cdb7 100644
--- a/libstdc++-v3/include/ext/bitmap_allocator.h
+++ b/libstdc++-v3/include/ext/bitmap_allocator.h
@@ -31,7 +31,7 @@
 
 #include <utility> // For std::pair.
 #include <bits/functexcept.h> // For __throw_bad_alloc().
-#include <functional> // For greater_equal, and less_equal.
+#include <bits/stl_function.h> // For greater_equal, and less_equal.
 #include <new> // For operator new.
 #include <debug/debug.h> // _GLIBCXX_DEBUG_ASSERT
 #include <ext/concurrence.h>
diff --git a/libstdc++-v3/include/ext/extptr_allocator.h b/libstdc++-v3/include/ext/extptr_allocator.h
index 850ca286ef6..6b6bd61b08c 100644
--- a/libstdc++-v3/include/ext/extptr_allocator.h
+++ b/libstdc++-v3/include/ext/extptr_allocator.h
@@ -176,6 +176,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef _Pointer_adapter<_Relative_pointer_impl<const void> >
                                                               const_pointer;
 
+      _ExtPtr_allocator() { }
+
+      template<typename _Up>
+	_ExtPtr_allocator(const _ExtPtr_allocator<_Up>&) { }
+
       template<typename _Up>
         struct rebind
         { typedef _ExtPtr_allocator<_Up> other; };
diff --git a/libstdc++-v3/include/ext/malloc_allocator.h b/libstdc++-v3/include/ext/malloc_allocator.h
index 366c766f25b..8de833f3641 100644
--- a/libstdc++-v3/include/ext/malloc_allocator.h
+++ b/libstdc++-v3/include/ext/malloc_allocator.h
@@ -99,9 +99,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       // NB: __n is permitted to be 0.  The C++ standard says nothing
       // about what the return value is when __n == 0.
-      _Tp*
+      _GLIBCXX_NODISCARD _Tp*
       allocate(size_type __n, const void* = 0)
       {
+#if __cplusplus >= 201103L
+	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
+	 // 3308. std::allocator<void>().allocate(n)
+	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
+#endif
+
 	if (__n > this->_M_max_size())
 	  std::__throw_bad_alloc();
 
diff --git a/libstdc++-v3/include/ext/new_allocator.h b/libstdc++-v3/include/ext/new_allocator.h
index 131718b8b2f..5375be3bbb9 100644
--- a/libstdc++-v3/include/ext/new_allocator.h
+++ b/libstdc++-v3/include/ext/new_allocator.h
@@ -42,7 +42,7 @@ namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   /**
-   *  @brief  An allocator that uses global new, as per [20.4].
+   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].
    *  @ingroup allocators
    *
    *  This is precisely the allocator defined in the C++ Standard.
@@ -102,6 +102,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _GLIBCXX_NODISCARD _Tp*
       allocate(size_type __n, const void* = static_cast<const void*>(0))
       {
+#if __cplusplus >= 201103L
+	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
+	 // 3308. std::allocator<void>().allocate(n)
+	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
+#endif
+
 	if (__n > this->_M_max_size())
 	  std::__throw_bad_alloc();
 
diff --git a/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp b/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
index f497cfec53d..38286b8ac47 100644
--- a/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
@@ -516,7 +516,7 @@ namespace __gnu_pbds
     swap(gp_hash_table& other)
     { base_type::swap(other); }
   };
-  //@} hash-based
+  ///@} hash-based
 #undef PB_DS_GP_HASH_BASE
 
 
@@ -780,7 +780,7 @@ namespace __gnu_pbds
     swap(trie& other)
     { base_type::swap(other); }
   };
-  //@} branch-based
+  ///@} branch-based
 #undef PB_DS_TRIE_BASE
 #undef PB_DS_TRIE_NODE_AND_IT_TRAITS
 
@@ -852,10 +852,10 @@ namespace __gnu_pbds
     swap(list_update& other)
     { base_type::swap(other); }
   };
-  //@} list-based
+  ///@} list-based
 #undef PB_DS_LU_BASE
 
-  // @} group containers-pbds
+  /// @} group containers-pbds
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/cc_hash_table_map_/cc_ht_map_.hpp b/libstdc++-v3/include/ext/pb_ds/detail/cc_hash_table_map_/cc_ht_map_.hpp
index a46b23f4699..3787526a3a7 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/cc_hash_table_map_/cc_ht_map_.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/cc_hash_table_map_/cc_ht_map_.hpp
@@ -524,13 +524,16 @@ namespace __gnu_pbds
 
 	resize_base::notify_find_search_end();
 
-#ifdef _GLIBCXX_DEBUG
 	if (p_e == 0)
-	  PB_DS_CHECK_KEY_DOES_NOT_EXIST(r_key)
+	  {
+	    PB_DS_CHECK_KEY_DOES_NOT_EXIST(r_key)
+	    return 0;
+	  }
 	else
-	  PB_DS_CHECK_KEY_EXISTS(r_key)
-#endif
-	return &p_e->m_value;
+	  {
+	    PB_DS_CHECK_KEY_EXISTS(r_key)
+	    return &p_e->m_value;
+	  }
       }
 
       inline pointer
@@ -550,13 +553,16 @@ namespace __gnu_pbds
 
 	resize_base::notify_find_search_end();
 
-#ifdef _GLIBCXX_DEBUG
 	if (p_e == 0)
-	  PB_DS_CHECK_KEY_DOES_NOT_EXIST(r_key)
+	  {
+	    PB_DS_CHECK_KEY_DOES_NOT_EXIST(r_key)
+	    return 0;
+	  }
 	else
-	  PB_DS_CHECK_KEY_EXISTS(r_key)
-#endif
-	return &p_e->m_value;
+	  {
+	    PB_DS_CHECK_KEY_EXISTS(r_key)
+	    return &p_e->m_value;
+	  }
       }
 
       inline bool
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp b/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
index 1dc3f86c08b..9fec9a078cb 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
@@ -63,6 +63,12 @@ namespace __gnu_pbds
 {
   namespace detail
   {
+    /**
+     *  @ingroup pbds
+     *
+     *  @{
+     */
+
     /// Specialization for pairing_heap.
     template<typename _VTp, typename Cmp_Fn, typename _Alloc>
       struct container_base_dispatch<_VTp, Cmp_Fn, _Alloc, pairing_heap_tag,
@@ -107,7 +113,7 @@ namespace __gnu_pbds
 	/// Dispatched type.
 	typedef thin_heap<_VTp, Cmp_Fn, _Alloc> 		type;
       };
-    //@} group pbds
+    ///@} group pbds
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp b/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
index f77a6226768..8bed5906e78 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
@@ -96,7 +96,7 @@ namespace __gnu_pbds
     public:
       typedef typename tree_metadata_helper<__node_u, null_update>::type type;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp b/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
index f446af4effc..e24fc4d1f51 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
@@ -96,7 +96,7 @@ namespace __gnu_pbds
     public:
       typedef typename trie_metadata_helper<__node_u, null_update>::type type;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp b/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
index 4e91ed142e9..c2138ea09da 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
@@ -191,7 +191,7 @@ namespace __gnu_pbds
 	store_extra			       	m_store_extra_indicator;
 	no_throw_indicator 		 	m_no_throw_copies_indicator;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/exception.hpp b/libstdc++-v3/include/ext/pb_ds/exception.hpp
index b8013928eb3..95c5771bf95 100644
--- a/libstdc++-v3/include/ext/pb_ds/exception.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/exception.hpp
@@ -87,7 +87,7 @@ namespace __gnu_pbds
   inline void
   __throw_resize_error()
   { _GLIBCXX_THROW_OR_ABORT(resize_error()); }
-  //@}
+  ///@}
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp b/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
index d2010fc28cc..6dca5e1a6f6 100644
--- a/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
@@ -51,6 +51,7 @@ namespace __gnu_pbds
   /**
    *  @defgroup heap-based Heap-Based
    *  @ingroup containers-pbds
+   *
    *  @{
    */
 
@@ -151,6 +152,6 @@ namespace __gnu_pbds
     swap(priority_queue& other)
     { base_type::swap(other); }
   };
+ ///@} heap-based
 } // namespace __gnu_pbds
- //@} heap-based
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp b/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
index 46dc11447ae..8d2b61e19cd 100644
--- a/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
@@ -113,7 +113,7 @@ namespace __gnu_pbds
    */
   struct range_invalidation_guarantee : public point_invalidation_guarantee
   { };
-  //@}
+  ///@}
 
 
   /**
@@ -184,8 +184,8 @@ namespace __gnu_pbds
 
   /// Thin heap.
   struct thin_heap_tag : public priority_queue_tag { };
-  //@}
-  //@}
+  ///@}
+  ///@}
 
 
   /**
@@ -438,7 +438,7 @@ namespace __gnu_pbds
 	reverse_iteration = base_type::reverse_iteration
       };
   };
-  //@}
+  ///@}
 
 
   namespace detail
@@ -448,7 +448,7 @@ namespace __gnu_pbds
 	     typename Policy_Tl = null_type>
       struct container_base_dispatch;
   } // namespace detail
-  //@}
+  ///@}
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/random b/libstdc++-v3/include/ext/random
index 25d725015ec..bbd8c61e5d4 100644
--- a/libstdc++-v3/include/ext/random
+++ b/libstdc++-v3/include/ext/random
@@ -1043,7 +1043,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_ndy(result_type(0), __p.sigma())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1295,7 +1295,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_gd(__p.mu(), __p.omega() / __p.mu())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1540,7 +1540,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_ud()
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1801,7 +1801,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_gd2(__p.nu(), __p.mu() / __p.nu())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -2040,7 +2040,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      +1.5707963267948966192313216916397514L)
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -3303,7 +3303,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       : _M_param(__p)
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -3709,7 +3709,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       : _M_param(__p), _M_uosd()
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
diff --git a/libstdc++-v3/include/ext/type_traits.h b/libstdc++-v3/include/ext/type_traits.h
index cf773cf2d59..a6f5db23682 100644
--- a/libstdc++-v3/include/ext/type_traits.h
+++ b/libstdc++-v3/include/ext/type_traits.h
@@ -163,7 +163,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { return true; }
 #endif
 
-  // For complex and cmath
+  // For arithmetic promotions in <complex> and <cmath>
+
   template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
     struct __promote
     { typedef double __type; };
@@ -187,6 +188,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     struct __promote<float>
     { typedef float __type; };
 
+#if __cpp_fold_expressions
+  template<typename... _Tp>
+    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));
+#endif
+
   template<typename _Tp, typename _Up,
            typename _Tp2 = typename __promote<_Tp>::__type,
            typename _Up2 = typename __promote<_Up>::__type>
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
index e13292296d3..1428858d600 100644
--- a/libstdc++-v3/include/std/any
+++ b/libstdc++-v3/include/std/any
@@ -205,7 +205,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     /// the contained object.
     template <typename _Tp, typename _Up, typename... _Args,
 	      typename _VTp = decay_t<_Tp>, typename _Mgr = _Manager<_VTp>,
-	      __any_constructible_t<_VTp, initializer_list<_Up>,
+	      __any_constructible_t<_VTp, initializer_list<_Up>&,
 				    _Args&&...> = false>
       explicit
       any(in_place_type_t<_Tp>, initializer_list<_Up> __il, _Args&&... __args)
@@ -271,7 +271,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     /// Emplace with an object created from @p __il and @p __args as
     /// the contained object.
     template <typename _Tp, typename _Up, typename... _Args>
-      __emplace_t<decay_t<_Tp>, initializer_list<_Up>, _Args&&...>
+      __emplace_t<decay_t<_Tp>, initializer_list<_Up>&, _Args&&...>
       emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
 	using _VTp = decay_t<_Tp>;
@@ -411,16 +411,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// Exchange the states of two @c any objects.
   inline void swap(any& __x, any& __y) noexcept { __x.swap(__y); }
 
-  /// Create an any holding a @c _Tp constructed from @c __args.
+  /// Create an `any` holding a `_Tp` constructed from `__args...`.
   template <typename _Tp, typename... _Args>
-    any make_any(_Args&&... __args)
+    inline
+    enable_if_t<is_constructible_v<any, in_place_type_t<_Tp>, _Args...>, any>
+    make_any(_Args&&... __args)
     {
       return any(in_place_type<_Tp>, std::forward<_Args>(__args)...);
     }
 
-  /// Create an any holding a @c _Tp constructed from @c __il and @c __args.
+  /// Create an `any` holding a `_Tp` constructed from `__il` and `__args...`.
   template <typename _Tp, typename _Up, typename... _Args>
-    any make_any(initializer_list<_Up> __il, _Args&&... __args)
+    inline
+    enable_if_t<is_constructible_v<any, in_place_type_t<_Tp>,
+				   initializer_list<_Up>&, _Args...>, any>
+    make_any(initializer_list<_Up> __il, _Args&&... __args)
     {
       return any(in_place_type<_Tp>, __il, std::forward<_Args>(__args)...);
     }
@@ -488,7 +493,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return static_cast<_ValueType>(std::move(*__p));
       __throw_bad_any_cast();
     }
-  // @}
+  /// @}
 
   /// @cond undocumented
   template<typename _Tp>
@@ -547,7 +552,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
-  // @}
+  /// @}
 
   template<typename _Tp>
     void
diff --git a/libstdc++-v3/include/std/atomic b/libstdc++-v3/include/std/atomic
index 2161cbed0d2..d511dfe7b60 100644
--- a/libstdc++-v3/include/std/atomic
+++ b/libstdc++-v3/include/std/atomic
@@ -1549,7 +1549,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #endif // C++2a
 
-  // @} group atomics
+  /// @} group atomics
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/bit b/libstdc++-v3/include/std/bit
index f22ee528555..2b24f0d450b 100644
--- a/libstdc++-v3/include/std/bit
+++ b/libstdc++-v3/include/std/bit
@@ -34,7 +34,23 @@
 #if __cplusplus >= 201402L
 
 #include <type_traits>
-#include <ext/numeric_traits.h>
+
+#if _GLIBCXX_HOSTED
+# include <ext/numeric_traits.h>
+#else
+# include <limits>
+/// @cond undocumented
+namespace __gnu_cxx
+{
+  template<typename _Tp>
+    struct __int_traits
+    {
+      static constexpr int __digits = std::numeric_limits<_Tp>::digits;
+      static constexpr _Tp __max = std::numeric_limits<_Tp>::max();
+    };
+}
+/// @endcond
+#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
diff --git a/libstdc++-v3/include/std/bitset b/libstdc++-v3/include/std/bitset
index 5364e59f466..681f2116d67 100644
--- a/libstdc++-v3/include/std/bitset
+++ b/libstdc++-v3/include/std/bitset
@@ -961,7 +961,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 #endif
 
       // 23.3.5.2 bitset operations:
-      //@{
+      ///@{
       /**
        *  Operations on bitsets.
        *  @param  __rhs  A same-sized bitset.
@@ -988,9 +988,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	this->_M_do_xor(__rhs);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Operations on bitsets.
        *  @param  __position  The number of places to shift.
@@ -1022,9 +1022,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  this->_M_do_reset();
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  These versions of single-bit set, reset, flip, and test are
        *  extensions from the SGI version.  They do no range checking.
@@ -1065,7 +1065,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _Unchecked_test(size_t __pos) const _GLIBCXX_NOEXCEPT
       { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
 		!= static_cast<_WordT>(0)); }
-      //@}
+      ///@}
 
       // Set, reset, and flip.
       /**
@@ -1144,7 +1144,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator~() const _GLIBCXX_NOEXCEPT
       { return bitset<_Nb>(*this).flip(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Array-indexing support.
        *  @param  __position  Index into the %bitset.
@@ -1166,7 +1166,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _GLIBCXX_CONSTEXPR bool
       operator[](size_t __position) const
       { return _Unchecked_test(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Returns a numerical interpretation of the %bitset.
@@ -1300,7 +1300,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       size() const _GLIBCXX_NOEXCEPT
       { return _Nb; }
 
-      //@{
+      ///@{
       /// These comparisons for equality/inequality are, well, @e bitwise.
       bool
       operator==(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
@@ -1311,7 +1311,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator!=(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
       { return !this->_M_is_equal(__rhs); }
 #endif
-      //@}
+      ///@}
 
       /**
        *  @brief Tests the value of a bit.
@@ -1352,7 +1352,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       none() const _GLIBCXX_NOEXCEPT
       { return !this->_M_is_any(); }
 
-      //@{
+      ///@{
       /// Self-explanatory.
       bitset<_Nb>
       operator<<(size_t __position) const _GLIBCXX_NOEXCEPT
@@ -1361,7 +1361,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bitset<_Nb>
       operator>>(size_t __position) const _GLIBCXX_NOEXCEPT
       { return bitset<_Nb>(*this) >>= __position; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the index of the first "on" bit.
@@ -1421,7 +1421,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       }
 
   // 23.3.5.3 bitset operations:
-  //@{
+  ///@{
   /**
    *  @brief  Global bitwise operations on bitsets.
    *  @param  __x  A bitset.
@@ -1456,9 +1456,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       __result ^= __y;
       return __result;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief Global I/O operators for bitsets.
    *
@@ -1548,7 +1548,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
       return __os << __tmp;
     }
-  //@}
+  ///@}
 
 _GLIBCXX_END_NAMESPACE_CONTAINER
 } // namespace std
diff --git a/libstdc++-v3/include/std/charconv b/libstdc++-v3/include/std/charconv
index cc7dd0e3758..daad423570a 100644
--- a/libstdc++-v3/include/std/charconv
+++ b/libstdc++-v3/include/std/charconv
@@ -335,12 +335,10 @@ namespace __detail
 	  *__first = '0';
 	  return { __first + 1, errc{} };
 	}
-
-      if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)
+      else if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)
 	if (__value < 0)
 	  {
-	    if (__builtin_expect(__first != __last, 1))
-	      *__first++ = '-';
+	    *__first++ = '-';
 	    __unsigned_val = _Up(~__value) + _Up(1);
 	  }
 
diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index 1eab4b74cb7..62a200c73b0 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -165,7 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     struct common_type<chrono::time_point<_Clock, _Duration>>
     { using type = chrono::time_point<_Clock, _Duration>; };
 
-  // @} group chrono
+  /// @} group chrono
 
   namespace chrono
   {
@@ -1007,7 +1007,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		 const time_point<_Clock, _Dur2>& __rhs)
       { return !(__lhs < __rhs); }
 
-    // @}
+    /// @}
 
     // Clocks.
 
@@ -1127,7 +1127,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     using local_days = local_time<days>;
 #endif // C++20
 
-    // @}
+    /// @}
   } // namespace chrono
 
 #if __cplusplus > 201103L
diff --git a/libstdc++-v3/include/std/complex b/libstdc++-v3/include/std/complex
index f2917b8c368..ebd1e5a0d39 100644
--- a/libstdc++-v3/include/std/complex
+++ b/libstdc++-v3/include/std/complex
@@ -324,7 +324,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
   // Operators:
-  //@{
+  ///@{
   ///  Return new complex value @a x plus @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -352,9 +352,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r += __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x minus @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -382,9 +382,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r += __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x times @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -412,9 +412,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r *= __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x divided by @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -442,7 +442,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r /= __y;
       return __r;
     }
-  //@}
+  ///@}
 
   ///  Return @a x.
   template<typename _Tp>
@@ -456,7 +456,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator-(const complex<_Tp>& __x)
     { return complex<_Tp>(-__x.real(), -__x.imag()); }
 
-  //@{
+  ///@{
   ///  Return true if @a x is equal to @a y.
   template<typename _Tp>
     inline _GLIBCXX_CONSTEXPR bool
@@ -473,9 +473,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline _GLIBCXX_CONSTEXPR bool
     operator==(const _Tp& __x, const complex<_Tp>& __y)
     { return __x == __y.real() && _Tp() == __y.imag(); }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return false if @a x is equal to @a y.
   template<typename _Tp>
     inline _GLIBCXX_CONSTEXPR bool
@@ -492,7 +492,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator!=(const _Tp& __x, const complex<_Tp>& __y)
     { return __x != __y.real() || _Tp() != __y.imag(); }
 #endif
-  //@}
+  ///@}
 
   ///  Extraction operator for complex values.
   template<typename _Tp, typename _CharT, class _Traits>
@@ -1548,7 +1548,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
 #endif
 
-  // @} group complex_numbers
+  /// @} group complex_numbers
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/concepts b/libstdc++-v3/include/std/concepts
index e710a5e6ecd..5d173e5ebed 100644
--- a/libstdc++-v3/include/std/concepts
+++ b/libstdc++-v3/include/std/concepts
@@ -70,9 +70,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// [concept.convertible], concept convertible_to
   template<typename _From, typename _To>
     concept convertible_to = is_convertible_v<_From, _To>
-      && requires(add_rvalue_reference_t<_From> (&__f)()) {
-	  static_cast<_To>(__f());
-      };
+      && requires { static_cast<_To>(std::declval<_From>()); };
 
   /// [concept.commonref], concept common_reference_with
   template<typename _Tp, typename _Up>
diff --git a/libstdc++-v3/include/std/condition_variable b/libstdc++-v3/include/std/condition_variable
index a08cfc62705..82a3afec563 100644
--- a/libstdc++-v3/include/std/condition_variable
+++ b/libstdc++-v3/include/std/condition_variable
@@ -453,7 +453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   } // end inline namespace
 
-  // @} group condition_variables
+  /// @} group condition_variables
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/fstream b/libstdc++-v3/include/std/fstream
index efc99d1e5a5..0f02938cb1d 100644
--- a/libstdc++-v3/include/std/fstream
+++ b/libstdc++-v3/include/std/fstream
@@ -155,7 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool                      _M_reading;
       bool                      _M_writing;
 
-      //@{
+      ///@{
       /**
        *  Necessary bits for putback buffer management.
        *
@@ -165,7 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       char_type*		_M_pback_cur_save;
       char_type*		_M_pback_end_save;
       bool			_M_pback_init;
-      //@}
+      ///@}
 
       // Cached codecvt facet.
       const __codecvt_type* 	_M_codecvt;
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 09f4af6fe7c..a036dc15682 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -533,26 +533,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
         };
 
       template<typename _Res, typename _Arg>
+	__attribute__((__always_inline__))
         static _Setter<_Res, _Arg&&>
-        __setter(promise<_Res>* __prom, _Arg&& __arg)
+        __setter(promise<_Res>* __prom, _Arg&& __arg) noexcept
         {
-	  _S_check(__prom->_M_future);
           return _Setter<_Res, _Arg&&>{ __prom, std::__addressof(__arg) };
         }
 
       template<typename _Res>
+	__attribute__((__always_inline__))
         static _Setter<_Res, __exception_ptr_tag>
-        __setter(exception_ptr& __ex, promise<_Res>* __prom)
+        __setter(exception_ptr& __ex, promise<_Res>* __prom) noexcept
         {
-	  _S_check(__prom->_M_future);
           return _Setter<_Res, __exception_ptr_tag>{ __prom, &__ex };
         }
 
       template<typename _Res>
+	__attribute__((__always_inline__))
 	static _Setter<_Res, void>
-	__setter(promise<_Res>* __prom)
+	__setter(promise<_Res>* __prom) noexcept
 	{
-	  _S_check(__prom->_M_future);
 	  return _Setter<_Res, void>{ __prom };
 	}
 
@@ -1118,36 +1118,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // Setting the result
       void
       set_value(const _Res& __r)
-      { _M_future->_M_set_result(_State::__setter(this, __r)); }
+      { _M_state()._M_set_result(_State::__setter(this, __r)); }
 
       void
       set_value(_Res&& __r)
-      { _M_future->_M_set_result(_State::__setter(this, std::move(__r))); }
+      { _M_state()._M_set_result(_State::__setter(this, std::move(__r))); }
 
       void
       set_exception(exception_ptr __p)
-      { _M_future->_M_set_result(_State::__setter(__p, this)); }
+      { _M_state()._M_set_result(_State::__setter(__p, this)); }
 
       void
       set_value_at_thread_exit(const _Res& __r)
       {
-	_M_future->_M_set_delayed_result(_State::__setter(this, __r),
+	_M_state()._M_set_delayed_result(_State::__setter(this, __r),
 					 _M_future);
       }
 
       void
       set_value_at_thread_exit(_Res&& __r)
       {
-	_M_future->_M_set_delayed_result(
+	_M_state()._M_set_delayed_result(
 	    _State::__setter(this, std::move(__r)), _M_future);
       }
 
       void
       set_exception_at_thread_exit(exception_ptr __p)
       {
-	_M_future->_M_set_delayed_result(_State::__setter(__p, this),
+	_M_state()._M_set_delayed_result(_State::__setter(__p, this),
 					 _M_future);
       }
+
+    private:
+      _State&
+      _M_state()
+      {
+	__future_base::_State_base::_S_check(_M_future);
+	return *_M_future;
+      }
     };
 
   template<typename _Res>
@@ -1229,25 +1237,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // Setting the result
       void
       set_value(_Res& __r)
-      { _M_future->_M_set_result(_State::__setter(this, __r)); }
+      { _M_state()._M_set_result(_State::__setter(this, __r)); }
 
       void
       set_exception(exception_ptr __p)
-      { _M_future->_M_set_result(_State::__setter(__p, this)); }
+      { _M_state()._M_set_result(_State::__setter(__p, this)); }
 
       void
       set_value_at_thread_exit(_Res& __r)
       {
-	_M_future->_M_set_delayed_result(_State::__setter(this, __r),
+	_M_state()._M_set_delayed_result(_State::__setter(this, __r),
 					 _M_future);
       }
 
       void
       set_exception_at_thread_exit(exception_ptr __p)
       {
-	_M_future->_M_set_delayed_result(_State::__setter(__p, this),
+	_M_state()._M_set_delayed_result(_State::__setter(__p, this),
 					 _M_future);
       }
+
+    private:
+      _State&
+      _M_state()
+      {
+	__future_base::_State_base::_S_check(_M_future);
+	return *_M_future;
+      }
     };
 
   /// Explicit specialization for promise<void>
@@ -1321,22 +1337,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // Setting the result
       void
       set_value()
-      { _M_future->_M_set_result(_State::__setter(this)); }
+      { _M_state()._M_set_result(_State::__setter(this)); }
 
       void
       set_exception(exception_ptr __p)
-      { _M_future->_M_set_result(_State::__setter(__p, this)); }
+      { _M_state()._M_set_result(_State::__setter(__p, this)); }
 
       void
       set_value_at_thread_exit()
-      { _M_future->_M_set_delayed_result(_State::__setter(this), _M_future); }
+      { _M_state()._M_set_delayed_result(_State::__setter(this), _M_future); }
 
       void
       set_exception_at_thread_exit(exception_ptr __p)
       {
-	_M_future->_M_set_delayed_result(_State::__setter(__p, this),
+	_M_state()._M_set_delayed_result(_State::__setter(__p, this),
 					 _M_future);
       }
+
+    private:
+      _State&
+      _M_state()
+      {
+	__future_base::_State_base::_S_check(_M_future);
+	return *_M_future;
+      }
     };
 
   template<typename _Ptr_type, typename _Fn, typename _Res>
@@ -1767,7 +1791,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif // _GLIBCXX_ASYNC_ABI_COMPAT
 #endif // _GLIBCXX_HAS_GTHREADS
 
-  // @} group futures
+  /// @} group futures
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/iostream b/libstdc++-v3/include/std/iostream
index f988342b90a..970c0e4fecc 100644
--- a/libstdc++-v3/include/std/iostream
+++ b/libstdc++-v3/include/std/iostream
@@ -56,7 +56,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  startup and termination. For more information, see the section of the
    *  manual linked to above.
   */
-  //@{
+  ///@{
   extern istream cin;		/// Linked to standard input
   extern ostream cout;		/// Linked to standard output
   extern ostream cerr;		/// Linked to standard error (unbuffered)
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   extern wostream wcerr;	/// Linked to standard error (unbuffered)
   extern wostream wclog;	/// Linked to standard error (buffered)
 #endif
-  //@}
+  ///@}
 
   // For construction of filebuffers for cout, cin, cerr, clog et. al.
   static ios_base::Init __ioinit;
diff --git a/libstdc++-v3/include/std/istream b/libstdc++-v3/include/std/istream
index 407c1ccda49..5454f87a38e 100644
--- a/libstdc++-v3/include/std/istream
+++ b/libstdc++-v3/include/std/istream
@@ -107,7 +107,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       class sentry;
       friend class sentry;
 
-      //@{
+      ///@{
       /**
        *  @brief  Interface for manipulators.
        *
@@ -133,9 +133,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	__pf(*this);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Extractors
        *
@@ -155,7 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  be rethrown if badbit is set in the exceptions mask.
       */
 
-      //@{
+      ///@{
       /**
        *  @brief  Integer arithmetic extractors
        *  @param  __n A variable of builtin integral type.
@@ -199,9 +199,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       operator>>(unsigned long long& __n)
       { return _M_extract(__n); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Floating point arithmetic extractors
        *  @param  __f A variable of builtin floating point type.
@@ -221,7 +221,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __istream_type&
       operator>>(long double& __f)
       { return _M_extract(__f); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Basic arithmetic extractors
@@ -257,7 +257,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __istream_type&
       operator>>(__streambuf_type* __sb);
-      //@}
+      ///@}
 
       // [27.6.1.3] unformatted input
       /**
@@ -269,7 +269,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       gcount() const
       { return _M_gcount; }
 
-      //@{
+      ///@{
       /**
        *  @name Unformatted Input Functions
        *
@@ -600,7 +600,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __istream_type&
       seekg(off_type, ios_base::seekdir);
-      //@}
+      ///@}
 
     protected:
       basic_istream()
@@ -735,7 +735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_ok; }
     };
 
-  //@{
+  ///@{
   /**
    *  @brief  Character extractors
    *  @param  __in  An input stream.
@@ -760,9 +760,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<char, _Traits>&
     operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
     { return (__in >> reinterpret_cast<char&>(__c)); }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief  Character string extractors
    *  @param  __in  An input stream.
@@ -807,7 +807,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<char, _Traits>&
     operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
     { return (__in >> reinterpret_cast<char*>(__s)); }
-  //@}
+  ///@}
 
   /**
    *  @brief  Template class basic_iostream
diff --git a/libstdc++-v3/include/std/memory b/libstdc++-v3/include/std/memory
index 3b3fec0d95c..eea472e8600 100644
--- a/libstdc++-v3/include/std/memory
+++ b/libstdc++-v3/include/std/memory
@@ -177,7 +177,7 @@ undeclare_no_pointers(char*, size_t) { }
 /// The type of pointer safety supported by the implementation.
 inline pointer_safety
 get_pointer_safety() noexcept { return pointer_safety::relaxed; }
-// @}
+/// @}
 
 #if __cplusplus > 201703L
 #define __cpp_lib_assume_aligned 201811L
diff --git a/libstdc++-v3/include/std/mutex b/libstdc++-v3/include/std/mutex
index 3c619f87040..dc846f015aa 100644
--- a/libstdc++-v3/include/std/mutex
+++ b/libstdc++-v3/include/std/mutex
@@ -738,7 +738,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 #endif // _GLIBCXX_HAS_GTHREADS
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index bd70a52019b..03cf719c676 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -259,9 +259,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     reduce(_InputIterator __first, _InputIterator __last, _Tp __init,
 	   _BinaryOperation __binary_op)
     {
-      using value_type = typename iterator_traits<_InputIterator>::value_type;
+      using __ref = typename iterator_traits<_InputIterator>::reference;
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, __ref>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, _Tp&>);
       static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, _Tp&>);
-      static_assert(is_convertible_v<value_type, _Tp>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, __ref>);
       if constexpr (__is_random_access_iter<_InputIterator>::value)
 	{
 	  while ((__last - __first) >= 4)
@@ -693,7 +695,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return __result;
     }
 
-  // @} group numeric_ops
+  /// @} group numeric_ops
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/std/optional b/libstdc++-v3/include/std/optional
index d473b5369be..4975bc6f922 100644
--- a/libstdc++-v3/include/std/optional
+++ b/libstdc++-v3/include/std/optional
@@ -798,7 +798,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Up>
 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 			    is_constructible<_Tp, const _Up&>,
-			    is_assignable<_Tp&, _Up>,
+			    is_assignable<_Tp&, const _Up&>,
 			    __not_<__converts_from_optional<_Tp, _Up>>,
 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 		    optional&>
@@ -1210,7 +1210,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !__rhs || __lhs >= *__rhs; }
 
 #ifdef __cpp_lib_three_way_comparison
+  template<typename _Tp>
+    inline constexpr bool __is_optional_v = false;
+  template<typename _Tp>
+    inline constexpr bool __is_optional_v<optional<_Tp>> = true;
+
   template<typename _Tp, typename _Up>
+    requires (!__is_optional_v<_Up>)
+      && three_way_comparable_with<_Tp, _Up>
     constexpr compare_three_way_result_t<_Tp, _Up>
     operator<=>(const optional<_Tp>& __x, const _Up& __v)
     { return bool(__x) ? *__x <=> __v : strong_ordering::less; }
diff --git a/libstdc++-v3/include/std/ostream b/libstdc++-v3/include/std/ostream
index 9a80adf3a5a..97ff1cee4e6 100644
--- a/libstdc++-v3/include/std/ostream
+++ b/libstdc++-v3/include/std/ostream
@@ -96,7 +96,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       class sentry;
       friend class sentry;
 
-      //@{
+      ///@{
       /**
        *  @brief  Interface for manipulators.
        *
@@ -132,9 +132,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	__pf(*this);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Inserters
        *
@@ -153,7 +153,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  be rethrown.
       */
 
-      //@{
+      ///@{
       /**
        *  @brief Integer arithmetic inserters
        *  @param  __n A variable of builtin integral type.
@@ -205,9 +205,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       operator<<(unsigned long long __n)
       { return _M_insert(__n); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Floating point arithmetic inserters
        *  @param  __f A variable of builtin floating point type.
@@ -231,7 +231,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __ostream_type&
       operator<<(long double __f)
       { return _M_insert(__f); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Pointer arithmetic inserters
@@ -274,9 +274,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __ostream_type&
       operator<<(__streambuf_type* __sb);
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Unformatted Output Functions
        *
@@ -339,7 +339,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __ostream_type&
       write(const char_type* __s, streamsize __n);
-      //@}
+      ///@}
 
       /**
        *  @brief  Synchronizing the stream buffer.
@@ -485,7 +485,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_ok; }
     };
 
-  //@{
+  ///@{
   /**
    *  @brief  Character inserters
    *  @param  __out  An output stream.
@@ -568,9 +568,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;
 #endif // _GLIBCXX_USE_WCHAR_T
 #endif // C++20
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief  String inserters
    *  @param  __out  An output stream.
@@ -664,7 +664,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
 #endif // _GLIBCXX_USE_WCHAR_T
 #endif // C++20
-  //@}
+  ///@}
 
   // Standard basic_ostream manipulators
 
diff --git a/libstdc++-v3/include/std/ranges b/libstdc++-v3/include/std/ranges
index 8e00222c2e8..cec775db3b1 100644
--- a/libstdc++-v3/include/std/ranges
+++ b/libstdc++-v3/include/std/ranges
@@ -222,11 +222,6 @@ namespace ranges
 	&& __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>>
 	&& convertible_to<_Vp, tuple_element_t<1, _Tp>>;
 
-    template<typename _Tp>
-      concept __iterator_sentinel_pair
-	= !range<_Tp> && __pair_like<_Tp>
-	&& sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;
-
   } // namespace __detail
 
   enum class subrange_kind : bool { unsized, sized };
@@ -387,16 +382,6 @@ namespace ranges
 	     __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
       -> subrange<_It, _Sent, subrange_kind::sized>;
 
-  template<__detail::__iterator_sentinel_pair _Pr>
-    subrange(_Pr)
-      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;
-
-  template<__detail::__iterator_sentinel_pair _Pr>
-    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<
-						     tuple_element_t<0, _Pr>>>)
-      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,
-		  subrange_kind::sized>;
-
   template<borrowed_range _Rng>
     subrange(_Rng&&)
       -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
@@ -625,6 +610,13 @@ namespace ranges
 	  { __j - __j } -> convertible_to<__iota_diff_t<_It>>;
 	};
 
+    template<typename _Winc>
+      struct __iota_view_iter_cat
+      { };
+
+    template<incrementable _Winc>
+      struct __iota_view_iter_cat<_Winc>
+      { using iterator_category = input_iterator_tag; };
   } // namespace __detail
 
   template<weakly_incrementable _Winc,
@@ -636,11 +628,11 @@ namespace ranges
     private:
       struct _Sentinel;
 
-      struct _Iterator
+      struct _Iterator : __detail::__iota_view_iter_cat<_Winc>
       {
       private:
 	static auto
-	_S_iter_cat()
+	_S_iter_concept()
 	{
 	  using namespace __detail;
 	  if constexpr (__advanceable<_Winc>)
@@ -654,7 +646,8 @@ namespace ranges
 	}
 
       public:
-	using iterator_category = decltype(_S_iter_cat());
+	using iterator_concept = decltype(_S_iter_concept());
+	// iterator_category defined in __iota_view_iter_cat
 	using value_type = _Winc;
 	using difference_type = __detail::__iota_diff_t<_Winc>;
 
@@ -823,6 +816,10 @@ namespace ranges
 	_M_equal(const _Iterator& __x) const
 	{ return __x._M_value == _M_bound; }
 
+	constexpr auto
+	_M_distance_from(const _Iterator& __x) const
+	{ return _M_bound - __x._M_value; }
+
 	_Bound _M_bound = _Bound();
 
       public:
@@ -839,12 +836,12 @@ namespace ranges
 	friend constexpr iter_difference_t<_Winc>
 	operator-(const _Iterator& __x, const _Sentinel& __y)
 	  requires sized_sentinel_for<_Bound, _Winc>
-	{ return __x._M_value - __y._M_bound; }
+	{ return -__y._M_distance_from(__x); }
 
 	friend constexpr iter_difference_t<_Winc>
 	operator-(const _Sentinel& __x, const _Iterator& __y)
 	  requires sized_sentinel_for<_Bound, _Winc>
-	{ return -(__y - __x); }
+	{ return __x._M_distance_from(__y); }
       };
 
       _Winc _M_value = _Winc();
@@ -954,7 +951,8 @@ namespace views
 	= requires(basic_istream<_CharT, _Traits>& is, _Val& t) { is >> t; };
   } // namespace __detail
 
-  template<movable _Val, typename _CharT, typename _Traits>
+  template<movable _Val, typename _CharT,
+	   typename _Traits = char_traits<_CharT>>
     requires default_initializable<_Val>
       && __detail::__stream_extractable<_Val, _CharT, _Traits>
     class basic_istream_view
@@ -973,7 +971,7 @@ namespace views
       {
 	if (_M_stream != nullptr)
 	  *_M_stream >> _M_object;
-	return _Iterator{*this};
+	return _Iterator{this};
       }
 
       constexpr default_sentinel_t
@@ -994,8 +992,8 @@ namespace views
 	_Iterator() = default;
 
 	constexpr explicit
-	_Iterator(basic_istream_view& __parent) noexcept
-	  : _M_parent(std::__addressof(__parent))
+	_Iterator(basic_istream_view* __parent) noexcept
+	  : _M_parent(__parent)
 	{ }
 
 	_Iterator(const _Iterator&) = delete;
@@ -1292,65 +1290,50 @@ namespace views
 
   } // namespace views
 
-  // XXX: the following algos are copied from ranges_algo.h to avoid a circular
-  // dependency with that header.
+  // The following simple algos are transcribed from ranges_algo.h to avoid
+  // having to include that entire header.
   namespace __detail
   {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
+    template<typename _Iter, typename _Sent, typename _Tp>
       constexpr _Iter
-      find_if(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
+      find(_Iter __first, _Sent __last, const _Tp& __value)
       {
 	while (__first != __last
-	    && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
+	       && !(bool)(*__first == __value))
 	  ++__first;
 	return __first;
       }
 
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
+    template<typename _Iter, typename _Sent, typename _Pred>
       constexpr _Iter
-      find_if_not(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
+      find_if(_Iter __first, _Sent __last, _Pred __pred)
       {
 	while (__first != __last
-	    && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
+	       && !(bool)std::__invoke(__pred, *__first))
 	  ++__first;
 	return __first;
       }
 
-    template<typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr const _Tp&
-      min(const _Tp& __a, const _Tp& __b, _Comp __comp = {}, _Proj __proj = {})
+    template<typename _Iter, typename _Sent, typename _Pred>
+      constexpr _Iter
+      find_if_not(_Iter __first, _Sent __last, _Pred __pred)
       {
-	if (std::__invoke(std::move(__comp),
-			  std::__invoke(__proj, __b),
-			  std::__invoke(__proj, __a)))
-	  return __b;
-	else
-	  return __a;
+	while (__first != __last
+	       && (bool)std::__invoke(__pred, *__first))
+	  ++__first;
+	return __first;
       }
 
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
+    template<typename _Iter1, typename _Sent1, typename _Iter2, typename _Sent2>
       constexpr pair<_Iter1, _Iter2>
-      mismatch(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
-	       _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})
+      mismatch(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2)
       {
 	while (__first1 != __last1 && __first2 != __last2
-	       && (bool)std::__invoke(__pred,
-				      std::__invoke(__proj1, *__first1),
-				      std::__invoke(__proj2, *__first2)))
-	{
-	  ++__first1;
-	  ++__first2;
-	}
+	       && (bool)ranges::equal_to{}(*__first1, *__first2))
+	  {
+	    ++__first1;
+	    ++__first2;
+	  }
 	return { std::move(__first1), std::move(__first2) };
       }
   } // namespace __detail
@@ -1429,7 +1412,32 @@ namespace views
 	  _M_offset = __it - ranges::begin(__r);
 	}
       };
+  } // namespace __detail
 
+  namespace __detail
+  {
+    template<typename _Base>
+      struct __filter_view_iter_cat
+      { };
+
+    template<forward_range _Base>
+      struct __filter_view_iter_cat<_Base>
+      {
+      private:
+	static auto
+	_S_iter_cat()
+	{
+	  using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;
+	  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)
+	    return bidirectional_iterator_tag{};
+	  else if constexpr (derived_from<_Cat, forward_iterator_tag>)
+	    return forward_iterator_tag{};
+	  else
+	    return _Cat{};
+	}
+      public:
+	using iterator_category = decltype(_S_iter_cat());
+      };
   } // namespace __detail
 
   template<input_range _Vp,
@@ -1440,7 +1448,7 @@ namespace views
     private:
       struct _Sentinel;
 
-      struct _Iterator
+      struct _Iterator : __detail::__filter_view_iter_cat<_Vp>
       {
       private:
 	static constexpr auto
@@ -1454,18 +1462,6 @@ namespace views
 	    return input_iterator_tag{};
 	}
 
-	static constexpr auto
-	_S_iter_cat()
-	{
-	  using _Cat = typename iterator_traits<_Vp_iter>::iterator_category;
-	  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)
-	    return bidirectional_iterator_tag{};
-	  else if constexpr (derived_from<_Cat, forward_iterator_tag>)
-	    return forward_iterator_tag{};
-	  else
-	    return _Cat{};
-	}
-
 	friend filter_view;
 
 	using _Vp_iter = iterator_t<_Vp>;
@@ -1475,21 +1471,20 @@ namespace views
 
       public:
 	using iterator_concept = decltype(_S_iter_concept());
-	using iterator_category = decltype(_S_iter_cat());
+	// iterator_category defined in __filter_view_iter_cat
 	using value_type = range_value_t<_Vp>;
 	using difference_type = range_difference_t<_Vp>;
 
 	_Iterator() = default;
 
 	constexpr
-	_Iterator(filter_view& __parent, _Vp_iter __current)
+	_Iterator(filter_view* __parent, _Vp_iter __current)
 	  : _M_current(std::move(__current)),
-	    _M_parent(std::__addressof(__parent))
+	    _M_parent(__parent)
 	{ }
 
-	constexpr _Vp_iter
-	base() const &
-	  requires copyable<_Vp_iter>
+	constexpr const _Vp_iter&
+	base() const & noexcept
 	{ return _M_current; }
 
 	constexpr _Vp_iter
@@ -1574,8 +1569,8 @@ namespace views
 	_Sentinel() = default;
 
 	constexpr explicit
-	_Sentinel(filter_view& __parent)
-	  : _M_end(ranges::end(__parent._M_base))
+	_Sentinel(filter_view* __parent)
+	  : _M_end(ranges::end(__parent->_M_base))
 	{ }
 
 	constexpr sentinel_t<_Vp>
@@ -1615,23 +1610,23 @@ namespace views
       begin()
       {
 	if (_M_cached_begin._M_has_value())
-	  return {*this, _M_cached_begin._M_get(_M_base)};
+	  return {this, _M_cached_begin._M_get(_M_base)};
 
 	__glibcxx_assert(_M_pred.has_value());
 	auto __it = __detail::find_if(ranges::begin(_M_base),
 				      ranges::end(_M_base),
 				      std::ref(*_M_pred));
 	_M_cached_begin._M_set(_M_base, __it);
-	return {*this, std::move(__it)};
+	return {this, std::move(__it)};
       }
 
       constexpr auto
       end()
       {
 	if constexpr (common_range<_Vp>)
-	  return _Iterator{*this, ranges::end(_M_base)};
+	  return _Iterator{this, ranges::end(_M_base)};
 	else
-	  return _Sentinel{*this};
+	  return _Sentinel{this};
       }
     };
 
@@ -1656,36 +1651,26 @@ namespace views
     {
     private:
       template<bool _Const>
-	struct _Sentinel;
+	using _Base = __detail::__maybe_const_t<_Const, _Vp>;
 
       template<bool _Const>
-	struct _Iterator
+	struct __iter_cat
+	{ };
+
+      template<bool _Const>
+	requires forward_range<_Base<_Const>>
+	struct __iter_cat<_Const>
 	{
 	private:
-	  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
-
-	  static constexpr auto
-	  _S_iter_concept()
-	  {
-	    if constexpr (random_access_range<_Vp>)
-	      return random_access_iterator_tag{};
-	    else if constexpr (bidirectional_range<_Vp>)
-	      return bidirectional_iterator_tag{};
-	    else if constexpr (forward_range<_Vp>)
-	      return forward_iterator_tag{};
-	    else
-	      return input_iterator_tag{};
-	  }
-
-	  static constexpr auto
+	  static auto
 	  _S_iter_cat()
 	  {
+	    using _Base = transform_view::_Base<_Const>;
 	    using _Res = invoke_result_t<_Fp&, range_reference_t<_Base>>;
 	    if constexpr (is_lvalue_reference_v<_Res>)
 	      {
 		using _Cat
-		  = typename iterator_traits<_Base_iter>::iterator_category;
+		  = typename iterator_traits<iterator_t<_Base>>::iterator_category;
 		if constexpr (derived_from<_Cat, contiguous_iterator_tag>)
 		  return random_access_iterator_tag{};
 		else
@@ -1694,6 +1679,32 @@ namespace views
 	    else
 	      return input_iterator_tag{};
 	  }
+	public:
+	  using iterator_category = decltype(_S_iter_cat());
+	};
+
+      template<bool _Const>
+	struct _Sentinel;
+
+      template<bool _Const>
+	struct _Iterator : __iter_cat<_Const>
+	{
+	private:
+	  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;
+	  using _Base = transform_view::_Base<_Const>;
+
+	  static auto
+	  _S_iter_concept()
+	  {
+	    if constexpr (random_access_range<_Base>)
+	      return random_access_iterator_tag{};
+	    else if constexpr (bidirectional_range<_Base>)
+	      return bidirectional_iterator_tag{};
+	    else if constexpr (forward_range<_Base>)
+	      return forward_iterator_tag{};
+	    else
+	      return input_iterator_tag{};
+	  }
 
 	  using _Base_iter = iterator_t<_Base>;
 
@@ -1702,7 +1713,7 @@ namespace views
 
 	public:
 	  using iterator_concept = decltype(_S_iter_concept());
-	  using iterator_category = decltype(_S_iter_cat());
+	  // iterator_category defined in __transform_view_iter_cat
 	  using value_type
 	    = remove_cvref_t<invoke_result_t<_Fp&, range_reference_t<_Base>>>;
 	  using difference_type = range_difference_t<_Base>;
@@ -1710,9 +1721,9 @@ namespace views
 	  _Iterator() = default;
 
 	  constexpr
-	  _Iterator(_Parent& __parent, _Base_iter __current)
+	  _Iterator(_Parent* __parent, _Base_iter __current)
 	    : _M_current(std::move(__current)),
-	      _M_parent(std::__addressof(__parent))
+	      _M_parent(__parent)
 	  { }
 
 	  constexpr
@@ -1722,9 +1733,8 @@ namespace views
 	    : _M_current(std::move(__i._M_current)), _M_parent(__i._M_parent)
 	  { }
 
-	  constexpr _Base_iter
-	  base() const &
-	    requires copyable<_Base_iter>
+	  constexpr const _Base_iter&
+	  base() const & noexcept
 	  { return _M_current; }
 
 	  constexpr _Base_iter
@@ -1825,17 +1835,17 @@ namespace views
 	  friend constexpr _Iterator
 	  operator+(_Iterator __i, difference_type __n)
 	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current + __n}; }
+	  { return {__i._M_parent, __i._M_current + __n}; }
 
 	  friend constexpr _Iterator
 	  operator+(difference_type __n, _Iterator __i)
 	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current + __n}; }
+	  { return {__i._M_parent, __i._M_current + __n}; }
 
 	  friend constexpr _Iterator
 	  operator-(_Iterator __i, difference_type __n)
 	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current - __n}; }
+	  { return {__i._M_parent, __i._M_current - __n}; }
 
 	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
 	  // 3483. transform_view::iterator's difference is overconstrained
@@ -1853,12 +1863,6 @@ namespace views
 	      return *__i;
 	  }
 
-	  friend constexpr void
-	  iter_swap(const _Iterator& __x, const _Iterator& __y)
-	    noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
-	    requires indirectly_swappable<_Base_iter>
-	  { return ranges::iter_swap(__x._M_current, __y._M_current); }
-
 	  friend _Iterator<!_Const>;
 	  template<bool> friend struct _Sentinel;
 	};
@@ -1868,7 +1872,7 @@ namespace views
 	{
 	private:
 	  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+	  using _Base = transform_view::_Base<_Const>;
 
 	  template<bool _Const2>
 	    constexpr auto
@@ -1946,13 +1950,13 @@ namespace views
 
       constexpr _Iterator<false>
       begin()
-      { return _Iterator<false>{*this, ranges::begin(_M_base)}; }
+      { return _Iterator<false>{this, ranges::begin(_M_base)}; }
 
       constexpr _Iterator<true>
       begin() const
 	requires range<const _Vp>
 	  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>
-      { return _Iterator<true>{*this, ranges::begin(_M_base)}; }
+      { return _Iterator<true>{this, ranges::begin(_M_base)}; }
 
       constexpr _Sentinel<false>
       end()
@@ -1960,7 +1964,7 @@ namespace views
 
       constexpr _Iterator<false>
       end() requires common_range<_Vp>
-      { return _Iterator<false>{*this, ranges::end(_M_base)}; }
+      { return _Iterator<false>{this, ranges::end(_M_base)}; }
 
       constexpr _Sentinel<true>
       end() const
@@ -1972,7 +1976,7 @@ namespace views
       end() const
 	requires common_range<const _Vp>
 	  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>
-      { return _Iterator<true>{*this, ranges::end(_M_base)}; }
+      { return _Iterator<true>{this, ranges::end(_M_base)}; }
 
       constexpr auto
       size() requires sized_range<_Vp>
@@ -2127,14 +2131,14 @@ namespace views
       size() requires sized_range<_Vp>
       {
 	auto __n = ranges::size(_M_base);
-	return __detail::min(__n, static_cast<decltype(__n)>(_M_count));
+	return std::min(__n, static_cast<decltype(__n)>(_M_count));
       }
 
       constexpr auto
       size() const requires sized_range<const _Vp>
       {
 	auto __n = ranges::size(_M_base);
-	return __detail::min(__n, static_cast<decltype(__n)>(_M_count));
+	return std::min(__n, static_cast<decltype(__n)>(_M_count));
       }
     };
 
@@ -2399,6 +2403,7 @@ namespace views
 	if (_M_cached_begin._M_has_value())
 	  return _M_cached_begin._M_get(_M_base);
 
+	__glibcxx_assert(_M_pred.has_value());
 	auto __it = __detail::find_if_not(ranges::begin(_M_base),
 					  ranges::end(_M_base),
 					  std::cref(*_M_pred));
@@ -2438,18 +2443,62 @@ namespace views
     private:
       using _InnerRange = range_reference_t<_Vp>;
 
+      template<bool _Const>
+	using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+
+      template<bool _Const>
+	using _Outer_iter = iterator_t<_Base<_Const>>;
+
+      template<bool _Const>
+	using _Inner_iter = iterator_t<range_reference_t<_Base<_Const>>>;
+
+      template<bool _Const>
+	static constexpr bool _S_ref_is_glvalue
+	  = is_reference_v<range_reference_t<_Base<_Const>>>;
+
+      template<bool _Const>
+	struct __iter_cat
+	{ };
+
+      template<bool _Const>
+	requires _S_ref_is_glvalue<_Const>
+	  && forward_range<_Base<_Const>>
+	  && forward_range<range_reference_t<_Base<_Const>>>
+	struct __iter_cat<_Const>
+	{
+	private:
+	  static constexpr auto
+	  _S_iter_cat()
+	  {
+	    using _Outer_iter = join_view::_Outer_iter<_Const>;
+	    using _Inner_iter = join_view::_Inner_iter<_Const>;
+	    using _OuterCat = typename iterator_traits<_Outer_iter>::iterator_category;
+	    using _InnerCat = typename iterator_traits<_Inner_iter>::iterator_category;
+	    if constexpr (derived_from<_OuterCat, bidirectional_iterator_tag>
+			  && derived_from<_InnerCat, bidirectional_iterator_tag>)
+	      return bidirectional_iterator_tag{};
+	    else if constexpr (derived_from<_OuterCat, forward_iterator_tag>
+			       && derived_from<_InnerCat, forward_iterator_tag>)
+	      return forward_iterator_tag{};
+	    else
+	      return input_iterator_tag{};
+	  }
+	public:
+	  using iterator_category = decltype(_S_iter_cat());
+	};
+
       template<bool _Const>
 	struct _Sentinel;
 
       template<bool _Const>
-	struct _Iterator
+	struct _Iterator : __iter_cat<_Const>
 	{
 	private:
 	  using _Parent = __detail::__maybe_const_t<_Const, join_view>;
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+	  using _Base = join_view::_Base<_Const>;
 
 	  static constexpr bool _S_ref_is_glvalue
-	    = is_reference_v<range_reference_t<_Base>>;
+	    = join_view::_S_ref_is_glvalue<_Const>;
 
 	  constexpr void
 	  _M_satisfy()
@@ -2489,30 +2538,8 @@ namespace views
 	      return input_iterator_tag{};
 	  }
 
-	  static constexpr auto
-	  _S_iter_cat()
-	  {
-	    using _OuterCat
-	      = typename iterator_traits<_Outer_iter>::iterator_category;
-	    using _InnerCat
-	      = typename iterator_traits<_Inner_iter>::iterator_category;
-	    if constexpr (_S_ref_is_glvalue
-			  && derived_from<_OuterCat, bidirectional_iterator_tag>
-			  && derived_from<_InnerCat, bidirectional_iterator_tag>)
-	      return bidirectional_iterator_tag{};
-	    else if constexpr (_S_ref_is_glvalue
-			       && derived_from<_OuterCat, forward_iterator_tag>
-			       && derived_from<_InnerCat, forward_iterator_tag>)
-	      return forward_iterator_tag{};
-	    else if constexpr (derived_from<_OuterCat, input_iterator_tag>
-			       && derived_from<_InnerCat, input_iterator_tag>)
-	      return input_iterator_tag{};
-	    else
-	      return output_iterator_tag{};
-	  }
-
-	  using _Outer_iter = iterator_t<_Base>;
-	  using _Inner_iter = iterator_t<range_reference_t<_Base>>;
+	  using _Outer_iter = join_view::_Outer_iter<_Const>;
+	  using _Inner_iter = join_view::_Inner_iter<_Const>;
 
 	  _Outer_iter _M_outer = _Outer_iter();
 	  _Inner_iter _M_inner = _Inner_iter();
@@ -2520,7 +2547,7 @@ namespace views
 
 	public:
 	  using iterator_concept = decltype(_S_iter_concept());
-	  using iterator_category = decltype(_S_iter_cat());
+	  // iterator_category defined in __join_view_iter_cat
 	  using value_type = range_value_t<range_reference_t<_Base>>;
 	  using difference_type
 	    = common_type_t<range_difference_t<_Base>,
@@ -2529,9 +2556,9 @@ namespace views
 	  _Iterator() = default;
 
 	  constexpr
-	  _Iterator(_Parent& __parent, _Outer_iter __outer)
+	  _Iterator(_Parent* __parent, _Outer_iter __outer)
 	    : _M_outer(std::move(__outer)),
-	      _M_parent(std::__addressof(__parent))
+	      _M_parent(__parent)
 	  { _M_satisfy(); }
 
 	  constexpr
@@ -2539,7 +2566,7 @@ namespace views
 	    requires _Const
 	      && convertible_to<iterator_t<_Vp>, _Outer_iter>
 	      && convertible_to<iterator_t<_InnerRange>, _Inner_iter>
-	    : _M_outer(std::move(__i._M_outer)), _M_inner(__i._M_inner),
+	    : _M_outer(std::move(__i._M_outer)), _M_inner(std::move(__i._M_inner)),
 	      _M_parent(__i._M_parent)
 	  { }
 
@@ -2558,7 +2585,7 @@ namespace views
 	  constexpr _Iterator&
 	  operator++()
 	  {
-	    auto&& __inner_range = [this] () -> decltype(auto) {
+	    auto&& __inner_range = [this] () -> auto&& {
 	      if constexpr (_S_ref_is_glvalue)
 		return *_M_outer;
 	      else
@@ -2629,6 +2656,7 @@ namespace views
 	  friend constexpr void
 	  iter_swap(const _Iterator& __x, const _Iterator& __y)
 	    noexcept(noexcept(ranges::iter_swap(__x._M_inner, __y._M_inner)))
+	    requires indirectly_swappable<_Inner_iter>
 	  { return ranges::iter_swap(__x._M_inner, __y._M_inner); }
 
 	  friend _Iterator<!_Const>;
@@ -2640,7 +2668,7 @@ namespace views
 	{
 	private:
 	  using _Parent = __detail::__maybe_const_t<_Const, join_view>;
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+	  using _Base = join_view::_Base<_Const>;
 
 	  template<bool _Const2>
 	    constexpr bool
@@ -2653,8 +2681,8 @@ namespace views
 	  _Sentinel() = default;
 
 	  constexpr explicit
-	  _Sentinel(_Parent& __parent)
-	    : _M_end(ranges::end(__parent._M_base))
+	  _Sentinel(_Parent* __parent)
+	    : _M_end(ranges::end(__parent->_M_base))
 	  { }
 
 	  constexpr
@@ -2702,7 +2730,7 @@ namespace views
 	constexpr bool __use_const
 	  = (__detail::__simple_view<_Vp>
 	     && is_reference_v<range_reference_t<_Vp>>);
-	return _Iterator<__use_const>{*this, ranges::begin(_M_base)};
+	return _Iterator<__use_const>{this, ranges::begin(_M_base)};
       }
 
       constexpr auto
@@ -2710,7 +2738,7 @@ namespace views
 	requires input_range<const _Vp>
 	  && is_reference_v<range_reference_t<const _Vp>>
       {
-	return _Iterator<true>{*this, ranges::begin(_M_base)};
+	return _Iterator<true>{this, ranges::begin(_M_base)};
       }
 
       constexpr auto
@@ -2719,10 +2747,10 @@ namespace views
 	if constexpr (forward_range<_Vp> && is_reference_v<_InnerRange>
 		      && forward_range<_InnerRange>
 		      && common_range<_Vp> && common_range<_InnerRange>)
-	  return _Iterator<__detail::__simple_view<_Vp>>{*this,
+	  return _Iterator<__detail::__simple_view<_Vp>>{this,
 							 ranges::end(_M_base)};
 	else
-	  return _Sentinel<__detail::__simple_view<_Vp>>{*this};
+	  return _Sentinel<__detail::__simple_view<_Vp>>{this};
       }
 
       constexpr auto
@@ -2735,9 +2763,9 @@ namespace views
 		      && forward_range<range_reference_t<const _Vp>>
 		      && common_range<const _Vp>
 		      && common_range<range_reference_t<const _Vp>>)
-	  return _Iterator<true>{*this, ranges::end(_M_base)};
+	  return _Iterator<true>{this, ranges::end(_M_base)};
 	else
-	  return _Sentinel<true>{*this};
+	  return _Sentinel<true>{this};
       }
     };
 
@@ -2765,6 +2793,35 @@ namespace views
 	&& requires
 	   { typename __require_constant<remove_reference_t<_Range>::size()>; }
 	&& (remove_reference_t<_Range>::size() <= 1);
+
+    template<typename _Base>
+      struct __split_view_outer_iter_cat
+      { };
+
+    template<forward_range _Base>
+      struct __split_view_outer_iter_cat<_Base>
+      { using iterator_category = input_iterator_tag; };
+
+    template<typename _Base>
+      struct __split_view_inner_iter_cat
+      { };
+
+    template<forward_range _Base>
+      struct __split_view_inner_iter_cat<_Base>
+      {
+      private:
+	static constexpr auto
+	_S_iter_cat()
+	{
+	  using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;
+	  if constexpr (derived_from<_Cat, forward_iterator_tag>)
+	    return forward_iterator_tag{};
+	  else
+	    return _Cat{};
+	}
+      public:
+	using iterator_category = decltype(_S_iter_cat());
+      };
   }
 
   template<input_range _Vp, forward_range _Pattern>
@@ -2775,15 +2832,19 @@ namespace views
     class split_view : public view_interface<split_view<_Vp, _Pattern>>
     {
     private:
+      template<bool _Const>
+	using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+
       template<bool _Const>
 	struct _InnerIter;
 
       template<bool _Const>
 	struct _OuterIter
+	  : __detail::__split_view_outer_iter_cat<_Base<_Const>>
 	{
 	private:
 	  using _Parent = __detail::__maybe_const_t<_Const, split_view>;
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+	  using _Base = split_view::_Base<_Const>;
 
 	  constexpr bool
 	  __at_end() const
@@ -2822,7 +2883,7 @@ namespace views
 	  using iterator_concept = conditional_t<forward_range<_Base>,
 						 forward_iterator_tag,
 						 input_iterator_tag>;
-	  using iterator_category = input_iterator_tag;
+	  // iterator_category defined in __split_view_outer_iter_cat
 	  using difference_type = range_difference_t<_Base>;
 
 	  struct value_type : view_interface<value_type>
@@ -2840,14 +2901,8 @@ namespace views
 
 	    constexpr _InnerIter<_Const>
 	    begin() const
-	      requires copyable<_OuterIter>
 	    { return _InnerIter<_Const>{_M_i}; }
 
-	    constexpr _InnerIter<_Const>
-	    begin()
-	      requires (!copyable<_OuterIter>)
-	    { return _InnerIter<_Const>{std::move(_M_i)}; }
-
 	    constexpr default_sentinel_t
 	    end() const
 	    { return default_sentinel; }
@@ -2856,14 +2911,14 @@ namespace views
 	  _OuterIter() = default;
 
 	  constexpr explicit
-	  _OuterIter(_Parent& __parent) requires (!forward_range<_Base>)
-	    : _M_parent(std::__addressof(__parent))
+	  _OuterIter(_Parent* __parent) requires (!forward_range<_Base>)
+	    : _M_parent(__parent)
 	  { }
 
 	  constexpr
-	  _OuterIter(_Parent& __parent, iterator_t<_Base> __current)
+	  _OuterIter(_Parent* __parent, iterator_t<_Base> __current)
 	    requires forward_range<_Base>
-	    : _M_parent(std::__addressof(__parent)),
+	    : _M_parent(__parent),
 	      _M_current(std::move(__current))
 	  { }
 
@@ -2881,21 +2936,31 @@ namespace views
 	  constexpr _OuterIter&
 	  operator++()
 	  {
+	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
+	    // 3505. split_view::outer-iterator::operator++ misspecified
 	    const auto __end = ranges::end(_M_parent->_M_base);
 	    if (__current() == __end)
 	      return *this;
 	    const auto [__pbegin, __pend] = subrange{_M_parent->_M_pattern};
 	    if (__pbegin == __pend)
 	      ++__current();
+	    else if constexpr (__detail::__tiny_range<_Pattern>)
+	      {
+		__current() = __detail::find(std::move(__current()), __end,
+					     *__pbegin);
+		if (__current() != __end)
+		  ++__current();
+	      }
 	    else
 	      do
 		{
 		  auto [__b, __p]
-		    = __detail::mismatch(std::move(__current()), __end,
-					 __pbegin, __pend);
-		  __current() = std::move(__b);
+		    = __detail::mismatch(__current(), __end, __pbegin, __pend);
 		  if (__p == __pend)
-		    break;
+		    {
+		      __current() = __b;
+		      break;
+		    }
 		} while (++__current() != __end);
 	    return *this;
 	  }
@@ -2928,9 +2993,10 @@ namespace views
 
       template<bool _Const>
 	struct _InnerIter
+	  : __detail::__split_view_inner_iter_cat<_Base<_Const>>
 	{
 	private:
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+	  using _Base = split_view::_Base<_Const>;
 
 	  constexpr bool
 	  __at_end() const
@@ -2964,17 +3030,6 @@ namespace views
 	      }
 	  }
 
-	  static constexpr auto
-	  _S_iter_cat()
-	  {
-	    using _Cat
-              = typename iterator_traits<iterator_t<_Base>>::iterator_category;
-	    if constexpr (derived_from<_Cat, forward_iterator_tag>)
-	      return forward_iterator_tag{};
-	    else
-	      return _Cat{};
-	  }
-
 	  constexpr auto&
 	  _M_i_current() noexcept
 	  { return _M_i.__current(); }
@@ -2989,7 +3044,7 @@ namespace views
 	public:
 	  using iterator_concept
 	    = typename _OuterIter<_Const>::iterator_concept;
-	  using iterator_category = decltype(_S_iter_cat());
+	  // iterator_category defined in __split_view_inner_iter_cat
 	  using value_type = range_value_t<_Base>;
 	  using difference_type = range_difference_t<_Base>;
 
@@ -3000,6 +3055,14 @@ namespace views
 	    : _M_i(std::move(__i))
 	  { }
 
+	  constexpr const iterator_t<_Base>&
+	  base() const& noexcept
+	  { return _M_i_current(); }
+
+	  constexpr iterator_t<_Base>
+	  base() &&
+	  { return std::move(_M_i_current()); }
+
 	  constexpr decltype(auto)
 	  operator*() const
 	  { return *_M_i_current(); }
@@ -3018,7 +3081,7 @@ namespace views
 	  constexpr decltype(auto)
 	  operator++(int)
 	  {
-	    if constexpr (forward_range<_Vp>)
+	    if constexpr (forward_range<_Base>)
 	      {
 		auto __tmp = *this;
 		++*this;
@@ -3089,25 +3152,25 @@ namespace views
       {
 	if constexpr (forward_range<_Vp>)
 	  return _OuterIter<__detail::__simple_view<_Vp>>{
-	      *this, ranges::begin(_M_base)};
+	      this, ranges::begin(_M_base)};
 	else
 	  {
 	    _M_current = ranges::begin(_M_base);
-	    return _OuterIter<false>{*this};
+	    return _OuterIter<false>{this};
 	  }
       }
 
       constexpr auto
       begin() const requires forward_range<_Vp> && forward_range<const _Vp>
       {
-	return _OuterIter<true>{*this, ranges::begin(_M_base)};
+	return _OuterIter<true>{this, ranges::begin(_M_base)};
       }
 
       constexpr auto
       end() requires forward_range<_Vp> && common_range<_Vp>
       {
 	return _OuterIter<__detail::__simple_view<_Vp>>{
-	    *this, ranges::end(_M_base)};
+	    this, ranges::end(_M_base)};
       }
 
       constexpr auto
@@ -3116,7 +3179,7 @@ namespace views
 	if constexpr (forward_range<_Vp>
 		      && forward_range<const _Vp>
 		      && common_range<const _Vp>)
-	  return _OuterIter<true>{*this, ranges::end(_M_base)};
+	  return _OuterIter<true>{this, ranges::end(_M_base)};
 	else
 	  return default_sentinel;
       }
@@ -3388,6 +3451,10 @@ namespace views
 	{ std::get<_Nm>(__t) }
 	  -> convertible_to<const tuple_element_t<_Nm, _Tp>&>;
       };
+
+    template<typename _Tp, size_t _Nm>
+      concept __returnable_element
+	= is_reference_v<_Tp> || move_constructible<tuple_element_t<_Nm, _Tp>>;
   }
 
   template<input_range _Vp, size_t _Nm>
@@ -3395,6 +3462,7 @@ namespace views
       && __detail::__has_tuple_element<range_value_t<_Vp>, _Nm>
       && __detail::__has_tuple_element<remove_reference_t<range_reference_t<_Vp>>,
 				       _Nm>
+      && __detail::__returnable_element<range_reference_t<_Vp>, _Nm>
     class elements_view : public view_interface<elements_view<_Vp, _Nm>>
     {
     public:
@@ -3446,21 +3514,75 @@ namespace views
       { return ranges::size(_M_base); }
 
     private:
+      template<bool _Const>
+	using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+
+      template<bool _Const>
+	struct __iter_cat
+	{ };
+
+      template<bool _Const>
+	requires forward_range<_Base<_Const>>
+	struct __iter_cat<_Const>
+	{
+	private:
+	  static auto _S_iter_cat()
+	  {
+	    using _Base = elements_view::_Base<_Const>;
+	    using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;
+	    using _Res = decltype((std::get<_Nm>(*std::declval<iterator_t<_Base>>())));
+	    if constexpr (!is_lvalue_reference_v<_Res>)
+	      return input_iterator_tag{};
+	    else if constexpr (derived_from<_Cat, random_access_iterator_tag>)
+	      return random_access_iterator_tag{};
+	    else
+	      return _Cat{};
+	  }
+	public:
+	  using iterator_category = decltype(_S_iter_cat());
+	};
+
       template<bool _Const>
 	struct _Sentinel;
 
       template<bool _Const>
-	struct _Iterator
+	struct _Iterator : __iter_cat<_Const>
 	{
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+	private:
+	  using _Base = elements_view::_Base<_Const>;
 
 	  iterator_t<_Base> _M_current = iterator_t<_Base>();
 
+	  static constexpr decltype(auto)
+	  _S_get_element(const iterator_t<_Base>& __i)
+	  {
+	    if constexpr (is_reference_v<range_reference_t<_Base>>)
+	      return std::get<_Nm>(*__i);
+	    else
+	      {
+		using _Et = remove_cv_t<tuple_element_t<_Nm, range_reference_t<_Base>>>;
+		return static_cast<_Et>(std::get<_Nm>(*__i));
+	      }
+	  }
+
+	  static auto
+	  _S_iter_concept()
+	  {
+	    if constexpr (random_access_range<_Base>)
+	      return random_access_iterator_tag{};
+	    else if constexpr (bidirectional_range<_Base>)
+	      return bidirectional_iterator_tag{};
+	    else if constexpr (forward_range<_Base>)
+	      return forward_iterator_tag{};
+	    else
+	      return input_iterator_tag{};
+	  }
+
 	  friend _Iterator<!_Const>;
 
 	public:
-	  using iterator_category
-	    = typename iterator_traits<iterator_t<_Base>>::iterator_category;
+	  using iterator_concept = decltype(_S_iter_concept());
+	  // iterator_category defined in elements_view::__iter_cat
 	  using value_type
 	    = remove_cvref_t<tuple_element_t<_Nm, range_value_t<_Base>>>;
 	  using difference_type = range_difference_t<_Base>;
@@ -3478,9 +3600,8 @@ namespace views
 	    : _M_current(std::move(i._M_current))
 	  { }
 
-	  constexpr iterator_t<_Base>
-	  base() const&
-	    requires copyable<iterator_t<_Base>>
+	  constexpr const iterator_t<_Base>&
+	  base() const& noexcept
 	  { return _M_current; }
 
 	  constexpr iterator_t<_Base>
@@ -3488,8 +3609,8 @@ namespace views
 	  { return std::move(_M_current); }
 
 	  constexpr decltype(auto)
-	    operator*() const
-	  { return std::get<_Nm>(*_M_current); }
+	  operator*() const
+	  { return _S_get_element(_M_current); }
 
 	  constexpr _Iterator&
 	  operator++()
@@ -3499,7 +3620,7 @@ namespace views
 	  }
 
 	  constexpr void
-	  operator++(int) requires (!forward_range<_Base>)
+	  operator++(int)
 	  { ++_M_current; }
 
 	  constexpr _Iterator
@@ -3544,7 +3665,7 @@ namespace views
 	  constexpr decltype(auto)
 	  operator[](difference_type __n) const
 	    requires random_access_range<_Base>
-	  { return std::get<_Nm>(*(_M_current + __n)); }
+	  { return _S_get_element(_M_current + __n); }
 
 	  friend constexpr bool
 	  operator==(const _Iterator& __x, const _Iterator& __y)
@@ -3601,18 +3722,24 @@ namespace views
 	    requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>
 	  { return __x._M_current - __y._M_current; }
 
-	  friend _Sentinel<_Const>;
+	  template <bool> friend struct _Sentinel;
 	};
 
       template<bool _Const>
 	struct _Sentinel
 	{
 	private:
-	  constexpr bool
-	  _M_equal(const _Iterator<_Const>& __x) const
-	  { return __x._M_current == _M_end; }
+	  template<bool _Const2>
+	    constexpr bool
+	    _M_equal(const _Iterator<_Const2>& __x) const
+	    { return __x._M_current == _M_end; }
 
-	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
+	  template<bool _Const2>
+	    constexpr auto
+	    _M_distance_from(const _Iterator<_Const2>& __i) const
+	    { return _M_end - __i._M_current; }
+
+	  using _Base = elements_view::_Base<_Const>;
 	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();
 
 	public:
@@ -3646,14 +3773,14 @@ namespace views
 	    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
 	    friend constexpr range_difference_t<_Base2>
 	    operator-(const _Iterator<_Const2>& __x, const _Sentinel& __y)
-	    { return __x._M_current - __y._M_end; }
+	    { return -__y._M_distance_from(__x); }
 
 	  template<bool _Const2,
 		   typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>
 	    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
-	    friend constexpr range_difference_t<_Base>
+	    friend constexpr range_difference_t<_Base2>
 	    operator-(const _Sentinel& __x, const _Iterator<_Const2>& __y)
-	    { return __x._M_end - __y._M_current; }
+	    { return __x._M_distance_from(__y); }
 
 	  friend _Sentinel<!_Const>;
 	};
diff --git a/libstdc++-v3/include/std/ratio b/libstdc++-v3/include/std/ratio
index 83c8c792793..293ed9a8e7c 100644
--- a/libstdc++-v3/include/std/ratio
+++ b/libstdc++-v3/include/std/ratio
@@ -567,7 +567,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   typedef ratio<         1000000000000000, 1> peta;
   typedef ratio<      1000000000000000000, 1> exa;
 
-  // @} group ratio
+  /// @} group ratio
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/shared_mutex b/libstdc++-v3/include/std/shared_mutex
index 414dce3a1b7..edfd4e4e523 100644
--- a/libstdc++-v3/include/std/shared_mutex
+++ b/libstdc++-v3/include/std/shared_mutex
@@ -846,7 +846,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     swap(shared_lock<_Mutex>& __x, shared_lock<_Mutex>& __y) noexcept
     { __x.swap(__y); }
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/span b/libstdc++-v3/include/std/span
index 1cdc0589ddb..4173446d141 100644
--- a/libstdc++-v3/include/std/span
+++ b/libstdc++-v3/include/std/span
@@ -412,7 +412,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     span(_Iter, _End)
       -> span<remove_reference_t<iter_reference_t<_Iter>>>;
 
-  template<typename _Range>
+  template<ranges::contiguous_range _Range>
     span(_Range &&)
       -> span<remove_reference_t<ranges::range_reference_t<_Range&>>>;
 
@@ -430,6 +430,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
   template<typename _Type, size_t _Extent>
+    requires (!is_const_v<_Type>)
     inline
     span<byte, _Extent == dynamic_extent
        ? dynamic_extent : _Extent * sizeof(_Type)>
diff --git a/libstdc++-v3/include/std/stdexcept b/libstdc++-v3/include/std/stdexcept
index 49161d5d0d2..43b84cda398 100644
--- a/libstdc++-v3/include/std/stdexcept
+++ b/libstdc++-v3/include/std/stdexcept
@@ -299,7 +299,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     virtual ~underflow_error() _GLIBCXX_NOTHROW;
   };
 
-  // @} group exceptions
+  /// @} group exceptions
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/streambuf b/libstdc++-v3/include/std/streambuf
index 7cb4fabbb89..5c6267e8e7e 100644
--- a/libstdc++-v3/include/std/streambuf
+++ b/libstdc++-v3/include/std/streambuf
@@ -122,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class basic_streambuf
     {
     public:
-      //@{
+      ///@{
       /**
        *  These are standard types.  They permit a standardized way of
        *  referring to names of (or names dependent on) the template
@@ -133,12 +133,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename traits_type::int_type 		int_type;
       typedef typename traits_type::pos_type 		pos_type;
       typedef typename traits_type::off_type 		off_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /// This is a non-standard type.
       typedef basic_streambuf<char_type, traits_type>  	__streambuf_type;
-      //@}
+      ///@}
 
       friend class basic_ios<char_type, traits_type>;
       friend class basic_istream<char_type, traits_type>;
@@ -234,7 +234,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_buf_locale; }
 
       // [27.5.2.2.2] buffer management and positioning
-      //@{
+      ///@{
       /**
        *  @brief  Entry points for derived buffer functions.
        *
@@ -276,7 +276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       int
       pubsync() { return this->sync(); }
-      //@}
+      ///@}
 
       // [27.5.2.2.3] get area
       /**
@@ -474,7 +474,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { }
 
       // [27.5.2.3.1] get area access
-      //@{
+      ///@{
       /**
        *  @brief  Access to the get area.
        *
@@ -493,7 +493,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       char_type*
       egptr() const { return _M_in_end; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Moving the read position.
@@ -521,7 +521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
 
       // [27.5.2.3.2] put area access
-      //@{
+      ///@{
       /**
        *  @brief  Access to the put area.
        *
@@ -540,7 +540,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       char_type*
       epptr() const { return _M_out_end; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Moving the write position.
diff --git a/libstdc++-v3/include/std/string_view b/libstdc++-v3/include/std/string_view
index f05ff32d9e5..7e8ccbdd9e4 100644
--- a/libstdc++-v3/include/std/string_view
+++ b/libstdc++-v3/include/std/string_view
@@ -22,7 +22,7 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
-/** @file string_view
+/** @file include/string_view
  *  This is a Standard C++ Library header.
  */
 
@@ -338,8 +338,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       constexpr bool
       ends_with(basic_string_view __x) const noexcept
       {
-	return this->size() >= __x.size()
-	    && this->compare(this->size() - __x.size(), npos, __x) == 0;
+	const auto __len = this->size();
+	const auto __xlen = __x.size();
+	return __len >= __xlen
+	  && traits_type::compare(end() - __xlen, __x.data(), __xlen) == 0;
       }
 
       constexpr bool
diff --git a/libstdc++-v3/include/std/system_error b/libstdc++-v3/include/std/system_error
index f92b4345895..d376610e761 100644
--- a/libstdc++-v3/include/std/system_error
+++ b/libstdc++-v3/include/std/system_error
@@ -262,7 +262,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
     { return (__os << __e.category().name() << ':' << __e.value()); }
 
-  // @}
+  /// @}
 
   error_condition make_error_condition(errc) noexcept;
 
diff --git a/libstdc++-v3/include/std/thread b/libstdc++-v3/include/std/thread
index b1ed458ba21..f25e74a685e 100644
--- a/libstdc++-v3/include/std/thread
+++ b/libstdc++-v3/include/std/thread
@@ -428,7 +428,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
   }
 
-  // @} group threads
+  /// @} group threads
 
 #ifdef __cpp_lib_jthread
 
diff --git a/libstdc++-v3/include/std/tuple b/libstdc++-v3/include/std/tuple
index 99121532101..fac6d4d656b 100644
--- a/libstdc++-v3/include/std/tuple
+++ b/libstdc++-v3/include/std/tuple
@@ -90,26 +90,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
         constexpr _Head_base(_UHead&& __h)
 	: _Head(std::forward<_UHead>(__h)) { }
 
+      _GLIBCXX20_CONSTEXPR
       _Head_base(allocator_arg_t, __uses_alloc0)
       : _Head() { }
 
       template<typename _Alloc>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 	: _Head(allocator_arg, *__a._M_a) { }
 
       template<typename _Alloc>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 	: _Head(*__a._M_a) { }
 
       template<typename _UHead>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(__uses_alloc0, _UHead&& __uhead)
 	: _Head(std::forward<_UHead>(__uhead)) { }
 
       template<typename _Alloc, typename _UHead>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 	: _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }
 
       template<typename _Alloc, typename _UHead>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 	: _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }
 
@@ -141,10 +147,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       : _M_head_impl() { }
 
       template<typename _Alloc>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 	: _M_head_impl(allocator_arg, *__a._M_a) { }
 
       template<typename _Alloc>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 	: _M_head_impl(*__a._M_a) { }
 
@@ -154,11 +162,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	: _M_head_impl(std::forward<_UHead>(__uhead)) { }
 
       template<typename _Alloc, typename _UHead>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 	: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 	{ }
 
       template<typename _Alloc, typename _UHead>
+	_GLIBCXX20_CONSTEXPR
 	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
 
@@ -255,6 +265,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
           _Base(__tag, __use_alloc<_Head>(__a)) { }
 
       template<typename _Alloc>
+	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
 		    const _Head& __head, const _Tail&... __tail)
 	: _Inherited(__tag, __a, __tail...),
@@ -389,6 +400,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	: _Base(__tag, __use_alloc<_Head>(__a)) { }
 
       template<typename _Alloc>
+	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
 		    const _Head& __head)
 	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }
@@ -872,6 +884,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class tuple<>
     {
     public:
+      _GLIBCXX20_CONSTEXPR
       void swap(tuple&) noexcept { /* no-op */ }
       // We need the default since we're going to define no-op
       // allocator constructors.
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
index c62dc72d3d7..cc34f82a31d 100644
--- a/libstdc++-v3/include/std/type_traits
+++ b/libstdc++-v3/include/std/type_traits
@@ -3307,11 +3307,17 @@ template <typename _From, typename _To>
   template<typename _Ap, typename _Bp>
     using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;
 
+  // COND-RES(COPYCV(X, Y) &, COPYCV(Y, X) &)
+  template<typename _Xp, typename _Yp>
+    using __condres_cvref
+      = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>;
+
   // If A and B are both lvalue reference types, ...
   template<typename _Xp, typename _Yp>
-    struct __common_ref_impl<_Xp&, _Yp&,
-      __void_t<__cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>>>
-    { using type = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>; };
+    struct __common_ref_impl<_Xp&, _Yp&, __void_t<__condres_cvref<_Xp, _Yp>>>
+    : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>,
+		__condres_cvref<_Xp, _Yp>>
+    { };
 
   // let C be remove_reference_t<COMMON-REF(X&, Y&)>&&
   template<typename _Xp, typename _Yp>
diff --git a/libstdc++-v3/include/std/valarray b/libstdc++-v3/include/std/valarray
index be2e70dc06a..e1b5d5f4f02 100644
--- a/libstdc++-v3/include/std/valarray
+++ b/libstdc++-v3/include/std/valarray
@@ -595,7 +595,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return _M_data[__i];
     }
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
@@ -1211,8 +1211,8 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline _Tp*
-    begin(valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]); }
+    begin(valarray<_Tp>& __va) noexcept
+    { return __va.size() ? std::__addressof(__va[0]) : nullptr; }
 
   /**
    *  @brief  Return an iterator pointing to the first element of
@@ -1221,8 +1221,8 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline const _Tp*
-    begin(const valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]); }
+    begin(const valarray<_Tp>& __va) noexcept
+    { return __va.size() ? std::__addressof(__va[0]) : nullptr; }
 
   /**
    *  @brief  Return an iterator pointing to one past the last element of
@@ -1231,8 +1231,13 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline _Tp*
-    end(valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]) + __va.size(); }
+    end(valarray<_Tp>& __va) noexcept
+    {
+      if (auto __n = __va.size())
+	return std::__addressof(__va[0]) + __n;
+      else
+	return nullptr;
+    }
 
   /**
    *  @brief  Return an iterator pointing to one past the last element of
@@ -1241,11 +1246,16 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline const _Tp*
-    end(const valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]) + __va.size(); }
+    end(const valarray<_Tp>& __va) noexcept
+    {
+      if (auto __n = __va.size())
+	return std::__addressof(__va[0]) + __n;
+      else
+	return nullptr;
+    }
 #endif // C++11
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index fa0284d9738..660b7fbc31c 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -23,7 +23,7 @@
 // <http://www.gnu.org/licenses/>.
 
 /** @file variant
- *  This is the <variant> C++ Library header.
+ *  This is the `<variant>` C++ Library header.
  */
 
 #ifndef _GLIBCXX_VARIANT
@@ -1053,6 +1053,14 @@ namespace __variant
 			      std::index_sequence<__indices...>>
     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
 
+  template<size_t _Np, typename _Variant>
+    using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
+
+  // Return type of std::visit.
+  template<typename _Visitor, typename... _Variants>
+    using __visit_result_t
+      = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
+
 } // namespace __variant
 } // namespace __detail
 
@@ -1238,7 +1246,8 @@ namespace __variant
 #endif
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto) visit(_Visitor&&, _Variants&&...);
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
+    visit(_Visitor&&, _Variants&&...);
 
   template<typename... _Types>
     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
@@ -1704,14 +1713,14 @@ namespace __variant
     }
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto)
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
     visit(_Visitor&& __visitor, _Variants&&... __variants)
     {
       if ((__variants.valueless_by_exception() || ...))
 	__throw_bad_variant_access("std::visit: variant is valueless");
 
-      using _Result_type = std::invoke_result_t<_Visitor,
-	decltype(std::get<0>(std::declval<_Variants>()))...>;
+      using _Result_type
+	= __detail::__variant::__visit_result_t<_Visitor, _Variants...>;
 
       using _Tag = __detail::__variant::__deduce_visit_result<_Result_type>;
 
diff --git a/libstdc++-v3/include/std/version b/libstdc++-v3/include/std/version
index 1cb2e4edb75..569375c8de4 100644
--- a/libstdc++-v3/include/std/version
+++ b/libstdc++-v3/include/std/version
@@ -131,6 +131,7 @@
 #define __cpp_lib_clamp 201603
 #if __cplusplus == 201703L // N.B. updated value in C++20
 # define __cpp_lib_constexpr_char_traits 201611L
+# define __cpp_lib_constexpr_string 201611L
 #endif
 #define __cpp_lib_enable_shared_from_this 201603
 #define __cpp_lib_execution 201902L // FIXME: should be 201603L
@@ -200,13 +201,18 @@
 // FIXME: #define __cpp_lib_execution 201902L
 #define __cpp_lib_integer_comparison_functions 202002L
 #define __cpp_lib_constexpr_algorithms 201806L
-#define __cpp_lib_constexpr_char_traits 201811L
+#ifdef __cpp_lib_is_constant_evaluated
+# define __cpp_lib_constexpr_char_traits 201811L
+#endif
 #define __cpp_lib_constexpr_complex 201711L
 #define __cpp_lib_constexpr_dynamic_alloc 201907L
 #define __cpp_lib_constexpr_functional 201907L
 #define __cpp_lib_constexpr_iterator 201811L
 #define __cpp_lib_constexpr_memory 201811L
 #define __cpp_lib_constexpr_numeric 201911L
+#ifdef __cpp_lib_is_constant_evaluated
+# define __cpp_lib_constexpr_string 201811L
+#endif
 #define __cpp_lib_constexpr_string_view 201811L
 #define __cpp_lib_constexpr_tuple 201811L
 #define __cpp_lib_constexpr_utility 201811L
diff --git a/libstdc++-v3/include/tr1/cmath b/libstdc++-v3/include/tr1/cmath
index 0ad4121e895..c4a3ad4bb35 100644
--- a/libstdc++-v3/include/tr1/cmath
+++ b/libstdc++-v3/include/tr1/cmath
@@ -1057,7 +1057,7 @@ namespace tr1
 
 #endif // __cplusplus < 201103L
 
-  // @}
+  /// @}
 
 #endif /* _GLIBCXX_USE_C99_MATH_TR1 */
 
@@ -1618,7 +1618,7 @@ namespace tr1
       return __detail::__sph_neumann<__type>(__n, __x);
     }
 
-  // @} tr1_math_spec_func
+  /// @} tr1_math_spec_func
 
 } // namespace tr1
 
@@ -1698,7 +1698,7 @@ namespace tr1
       return __detail::__hyperg<__type>(__a, __b, __c, __x);
     }
 
-  // @} tr1_math_spec_func
+  /// @} tr1_math_spec_func
 
 } // namespace tr1
 
diff --git a/libstdc++-v3/include/tr1/complex b/libstdc++-v3/include/tr1/complex
index 3c9e6e27b30..9a4ee8cf128 100644
--- a/libstdc++-v3/include/tr1/complex
+++ b/libstdc++-v3/include/tr1/complex
@@ -411,7 +411,7 @@ namespace tr1
     pow(const std::complex<_Tp>& __x, const std::complex<_Tp>& __y)
     { return std::pow(__x, __y); }
 
-// @} group complex_numbers
+/// @} group complex_numbers
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr1/random.h b/libstdc++-v3/include/tr1/random.h
index 3f777cb0321..20ea2edbbe9 100644
--- a/libstdc++-v3/include/tr1/random.h
+++ b/libstdc++-v3/include/tr1/random.h
@@ -1543,7 +1543,7 @@ namespace tr1
 #endif
   };
 
-  /* @} */ // group tr1_random_generators
+  /// @} group tr1_random_generators
 
   /**
    * @addtogroup tr1_random_distributions Random Number Distributions
@@ -2046,7 +2046,7 @@ namespace tr1
       bool      _M_easy;
     };
 
-  /* @} */ // group tr1_random_distributions_discrete
+  /// @} group tr1_random_distributions_discrete
 
   /**
    * @addtogroup tr1_random_distributions_continuous Continuous Distributions
@@ -2403,9 +2403,9 @@ namespace tr1
       result_type _M_l_d;
     };
 
-  /* @} */ // group tr1_random_distributions_continuous
-  /* @} */ // group tr1_random_distributions
-  /* @} */ // group tr1_random
+  /// @} group tr1_random_distributions_continuous
+  /// @} group tr1_random_distributions
+  /// @} group tr1_random
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr1/regex b/libstdc++-v3/include/tr1/regex
index 1efbcf86789..7d7ed6131a9 100644
--- a/libstdc++-v3/include/tr1/regex
+++ b/libstdc++-v3/include/tr1/regex
@@ -53,7 +53,7 @@ namespace tr1
  * @defgroup tr1_regex Regular Expressions
  * A facility for performing regular expression pattern matching.
  */
- //@{
+ ///@{
 
 /** @namespace std::regex_constants
  *  @brief ISO C++ 0x entities sub namespace for regex.
@@ -63,7 +63,7 @@ namespace regex_constants
   /**
    * @name 5.1 Regular Expression Syntax Options
    */
-  //@{
+  ///@{
   enum __syntax_option
     {
       _S_icase,
@@ -174,7 +174,7 @@ namespace regex_constants
    */
   static const syntax_option_type egrep      = 1 << _S_egrep;
 
-  //@}
+  ///@}
 
   /**
    * @name 5.2 Matching Rules
@@ -185,7 +185,7 @@ namespace regex_constants
    * below for any bitmask elements set.
    *
    */
-  //@{
+  ///@{
 
   enum __match_flag
     {
@@ -315,12 +315,12 @@ namespace regex_constants
    */
   static const match_flag_type format_first_only = 1 << _S_first_only;
 
-  //@}
+  ///@}
 
   /**
    * @name 5.3 Error Types
    */
-  //@{
+  ///@{
  
   enum error_type
     {
@@ -396,7 +396,7 @@ namespace regex_constants
    */
   static const error_type error_stack(_S_error_stack);
 
-  //@}
+  ///@}
 }
 
   // [7.8] Class regex_error
@@ -735,7 +735,7 @@ namespace regex_constants
        * @name Constants
        * tr1 [7.8.1] std [28.8.1]
        */
-      //@{
+      ///@{
       static const regex_constants::syntax_option_type icase
         = regex_constants::icase;
       static const regex_constants::syntax_option_type nosubs
@@ -756,7 +756,7 @@ namespace regex_constants
         = regex_constants::grep;
       static const regex_constants::syntax_option_type egrep
         = regex_constants::egrep;
-      //@}
+      ///@}
 
       // [7.8.2] construct/copy/destroy
       /**
@@ -1787,7 +1787,7 @@ namespace regex_constants
       /**
        * @name 10.? Public Types
        */
-      //@{
+      ///@{
       typedef sub_match<_Bi_iter>                             value_type;
       typedef typename _Base_type::const_reference            const_reference;
       typedef const_reference                                 reference;
@@ -1799,13 +1799,13 @@ namespace regex_constants
       typedef _Allocator                                      allocator_type;
       typedef typename iterator_traits<_Bi_iter>::value_type  char_type;
       typedef basic_string<char_type>                         string_type;
-      //@}
+      ///@}
   
     public:
       /**
        * @name 10.1 Construction, Copying, and Destruction
        */
-      //@{
+      ///@{
 
       /**
        * @brief Constructs a default %match_results container.
@@ -1841,12 +1841,12 @@ namespace regex_constants
       ~match_results()
       { }
       
-      //@}
+      ///@}
 
       /**
        * @name 10.2 Size
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the number of matches and submatches.
@@ -1874,12 +1874,12 @@ namespace regex_constants
       empty() const
       { return size() == 0; }
       
-      //@}
+      ///@}
 
       /**
        * @name 10.3 Element Access
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the length of the indicated submatch.
@@ -1988,7 +1988,7 @@ namespace regex_constants
       { return _Base_type::end(); }
 #endif
 
-      //@}
+      ///@}
 
       /**
        * @name 10.4 Formatting
@@ -1998,7 +1998,7 @@ namespace regex_constants
        * and escape sequences accepted by these functions are
        * determined by their @p flags parameter as documented above.
        */
-       //@{
+       ///@{
 
       /**
        * @todo Implement this function.
@@ -2017,12 +2017,12 @@ namespace regex_constants
 	     regex_constants::match_flag_type __flags
 	     = regex_constants::format_default) const;
 
-      //@} 
+      ///@}
 
       /**
        * @name 10.5 Allocator
        */
-      //@{ 
+      ///@{
 
       /**
        * @brief Gets a copy of the allocator.
@@ -2031,12 +2031,12 @@ namespace regex_constants
       //get_allocator() const;
       using _Base_type::get_allocator;
       
-      //@} 
+      ///@}
 
       /**
        * @name 10.6 Swap
        */
-       //@{ 
+       ///@{
 
       /**
        * @brief Swaps the contents of two match_results.
@@ -2049,7 +2049,7 @@ namespace regex_constants
 	std::swap(_M_prefix,  __that._M_prefix);
 	std::swap(_M_suffix,  __that._M_suffix);
       }
-      //@} 
+      ///@}
       
     private:
       bool       _M_matched;
@@ -2105,7 +2105,7 @@ namespace regex_constants
   /**
    * @name Matching, Searching, and Replacing
    */
-  //@{
+  ///@{
 
   /**
    * @brief Determines if there is a match between the regular expression @p e
@@ -2432,7 +2432,7 @@ namespace regex_constants
       return __result;
     }
 
-  //@}
+  ///@}
 
   // tr1 [7.12.1] std [28.12] Class template regex_iterator
   /**
@@ -2718,7 +2718,7 @@ namespace regex_constants
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
 #endif
   
-  //@}
+  ///@}
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset b/libstdc++-v3/include/tr2/dynamic_bitset
index 1591bc5a494..634679dfc45 100644
--- a/libstdc++-v3/include/tr2/dynamic_bitset
+++ b/libstdc++-v3/include/tr2/dynamic_bitset
@@ -748,7 +748,7 @@ namespace tr2
 	}
 
       // 23.3.5.2 dynamic_bitset operations:
-      //@{
+      ///@{
       /**
        *  @brief  Operations on dynamic_bitsets.
        *  @param  __rhs  A same-sized dynamic_bitset.
@@ -789,9 +789,9 @@ namespace tr2
 	this->_M_do_dif(__rhs);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Operations on dynamic_bitsets.
        *  @param  __pos The number of places to shift.
@@ -823,7 +823,7 @@ namespace tr2
 	  this->_M_do_reset();
 	return *this;
       }
-      //@}
+      ///@}
 
       // Set, reset, and flip.
       /**
@@ -905,7 +905,7 @@ namespace tr2
       operator~() const
       { return dynamic_bitset<_WordT, _Alloc>(*this).flip(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Array-indexing support.
        *  @param  __pos  Index into the %dynamic_bitset.
@@ -921,7 +921,7 @@ namespace tr2
       const_reference
       operator[](size_type __pos) const
       { return _M_unchecked_test(__pos); }
-      //@}
+      ///@}
 
       /**
        *  @brief Returns a numerical interpretation of the %dynamic_bitset.
@@ -1052,7 +1052,7 @@ namespace tr2
       none() const
       { return !this->_M_is_any(); }
 
-      //@{
+      ///@{
       /// Self-explanatory.
       dynamic_bitset
       operator<<(size_type __pos) const
@@ -1061,7 +1061,7 @@ namespace tr2
       dynamic_bitset
       operator>>(size_type __pos) const
       { return dynamic_bitset(*this) >>= __pos; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the index of the first "on" bit.
@@ -1115,7 +1115,7 @@ namespace tr2
       }
 
 
-  //@{
+  ///@{
   /// These comparisons for equality/inequality are, well, @e bitwise.
 
   template<typename _WordT, typename _Alloc>
@@ -1141,10 +1141,10 @@ namespace tr2
     operator>=(const dynamic_bitset<_WordT, _Alloc>& __lhs,
 	       const dynamic_bitset<_WordT, _Alloc>& __rhs)
     { return !(__lhs < __rhs); }
-  //@}
+  ///@}
 
   // 23.3.5.3 bitset operations:
-  //@{
+  ///@{
   /**
    *  @brief  Global bitwise operations on bitsets.
    *  @param  __x  A bitset.
@@ -1192,7 +1192,7 @@ namespace tr2
       __result -= __y;
       return __result;
     }
-  //@}
+  ///@}
 
   /// Stream output operator for dynamic_bitset.
   template <typename _CharT, typename _Traits,
diff --git a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
index 35ad3ae7799..b6b2516b284 100644
--- a/libstdc++-v3/libsupc++/Makefile.am
+++ b/libstdc++-v3/libsupc++/Makefile.am
@@ -48,6 +48,7 @@ sources = \
 	array_type_info.cc \
 	atexit_arm.cc \
 	atexit_thread.cc \
+	atomicity.cc \
 	bad_alloc.cc \
 	bad_array_length.cc \
 	bad_array_new.cc \
@@ -127,6 +128,9 @@ cp-demangle.lo: cp-demangle.c
 cp-demangle.o: cp-demangle.c
 	$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
 
+atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
+atomicity.cc: ${atomicity_file}
+	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 # Use special rules for the C++17 sources so that the proper flags are passed.
 new_opa.lo: new_opa.cc
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index a0a500eabe5..f4f4f3c2862 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -153,13 +153,13 @@ am__installdirs = "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(bitsdir)" \
 LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
 libsupc___la_LIBADD =
 am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \
-	bad_alloc.lo bad_array_length.lo bad_array_new.lo bad_cast.lo \
-	bad_typeid.lo class_type_info.lo del_op.lo del_ops.lo \
-	del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo dyncast.lo \
-	eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \
-	eh_exception.lo eh_globals.lo eh_personality.lo eh_ptr.lo \
-	eh_term_handler.lo eh_terminate.lo eh_tm.lo eh_throw.lo \
-	eh_type.lo eh_unex_handler.lo enum_type_info.lo \
+	atomicity.lo bad_alloc.lo bad_array_length.lo bad_array_new.lo \
+	bad_cast.lo bad_typeid.lo class_type_info.lo del_op.lo \
+	del_ops.lo del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo \
+	dyncast.lo eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo \
+	eh_catch.lo eh_exception.lo eh_globals.lo eh_personality.lo \
+	eh_ptr.lo eh_term_handler.lo eh_terminate.lo eh_tm.lo \
+	eh_throw.lo eh_type.lo eh_unex_handler.lo enum_type_info.lo \
 	function_type_info.lo fundamental_type_info.lo guard.lo \
 	guard_error.lo hash_bytes.lo nested_exception.lo \
 	new_handler.lo new_op.lo new_opnt.lo new_opv.lo new_opvnt.lo \
@@ -498,6 +498,7 @@ sources = \
 	array_type_info.cc \
 	atexit_arm.cc \
 	atexit_thread.cc \
+	atomicity.cc \
 	bad_alloc.cc \
 	bad_array_length.cc \
 	bad_array_new.cc \
@@ -564,6 +565,7 @@ sources = \
 
 libsupc___la_SOURCES = $(sources) $(c_sources) $(vtv_sources)
 libsupc__convenience_la_SOURCES = $(sources) $(c_sources) $(vtv_sources)
+atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
 
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
@@ -955,6 +957,8 @@ cp-demangle.lo: cp-demangle.c
 	$(LTCOMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
 cp-demangle.o: cp-demangle.c
 	$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
+atomicity.cc: ${atomicity_file}
+	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 # Use special rules for the C++17 sources so that the proper flags are passed.
 new_opa.lo: new_opa.cc
diff --git a/libstdc++-v3/libsupc++/atomic_lockfree_defines.h b/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
index f0b57aeee55..eec5872fc2e 100644
--- a/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
+++ b/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
@@ -61,6 +61,6 @@
 #define ATOMIC_POINTER_LOCK_FREE	__GCC_ATOMIC_POINTER_LOCK_FREE
 #endif
 
-// @} group atomics
+/// @} group atomics
 
 #endif
diff --git a/libstdc++-v3/libsupc++/compare b/libstdc++-v3/libsupc++/compare
index bd9c3b2352b..3a1d85a4c96 100644
--- a/libstdc++-v3/libsupc++/compare
+++ b/libstdc++-v3/libsupc++/compare
@@ -600,6 +600,9 @@ namespace std
 	  // FIXME: || floating_point<remove_reference_t<_Tp>>
 	  || __cmp3way<strong_ordering, _Tp, _Up>;
 
+    template<typename _Tp, typename _Up>
+      concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;
+
     class _Strong_order
     {
       template<typename _Tp, typename _Up>
@@ -620,14 +623,12 @@ namespace std
       friend class _Strong_fallback;
 
     public:
-      template<typename _Tp, typename _Up>
+      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 	requires __strongly_ordered<_Tp, _Up>
 	constexpr strong_ordering
 	operator()(_Tp&& __e, _Up&& __f) const
 	noexcept(_S_noexcept<_Tp, _Up>())
 	{
-	  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
-
 	  /* FIXME:
 	  if constexpr (floating_point<decay_t<_Tp>>)
 	    return __cmp_cust::__fp_strong_order(__e, __f);
@@ -669,14 +670,12 @@ namespace std
       friend class _Weak_fallback;
 
     public:
-      template<typename _Tp, typename _Up>
+      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 	requires __weakly_ordered<_Tp, _Up>
 	constexpr weak_ordering
 	operator()(_Tp&& __e, _Up&& __f) const
 	noexcept(_S_noexcept<_Tp, _Up>())
 	{
-	  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
-
 	  if constexpr (floating_point<decay_t<_Tp>>)
 	    return __cmp_cust::__fp_weak_ordering(__e, __f);
 	  else if constexpr (__adl_weak<_Tp, _Up>)
@@ -716,14 +715,12 @@ namespace std
       friend class _Partial_fallback;
 
     public:
-      template<typename _Tp, typename _Up>
+      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 	requires __partially_ordered<_Tp, _Up>
 	constexpr partial_ordering
 	operator()(_Tp&& __e, _Up&& __f) const
 	noexcept(_S_noexcept<_Tp, _Up>())
 	{
-	  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
-
 	  if constexpr (__adl_partial<_Tp, _Up>)
 	    return partial_ordering(partial_order(static_cast<_Tp&&>(__e),
 						  static_cast<_Up&&>(__f)));
@@ -759,18 +756,16 @@ namespace std
 	}
 
     public:
-      template<typename _Tp, typename _Up>
+      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 	requires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
-	constexpr decltype(auto)
+	constexpr strong_ordering
 	operator()(_Tp&& __e, _Up&& __f) const
 	noexcept(_S_noexcept<_Tp, _Up>())
 	{
-	  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
-
 	  if constexpr (__strongly_ordered<_Tp, _Up>)
 	    return _Strong_order{}(static_cast<_Tp&&>(__e),
 				   static_cast<_Up&&>(__f));
-	  else if constexpr (__op_eq_lt<_Tp, _Up>)
+	  else // __op_eq_lt<_Tp, _Up>
 	    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
 	      ? strong_ordering::equal
 	      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
@@ -793,18 +788,16 @@ namespace std
 	}
 
     public:
-      template<typename _Tp, typename _Up>
+      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 	requires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
-	constexpr decltype(auto)
+	constexpr weak_ordering
 	operator()(_Tp&& __e, _Up&& __f) const
 	noexcept(_S_noexcept<_Tp, _Up>())
 	{
-	  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
-
 	  if constexpr (__weakly_ordered<_Tp, _Up>)
 	    return _Weak_order{}(static_cast<_Tp&&>(__e),
 				 static_cast<_Up&&>(__f));
-	  else if constexpr (__op_eq_lt<_Tp, _Up>)
+	  else // __op_eq_lt<_Tp, _Up>
 	    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
 	      ? weak_ordering::equivalent
 	      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
@@ -813,6 +806,16 @@ namespace std
 	}
     };
 
+    // _GLIBCXX_RESOLVE_LIB_DEFECTS
+    // 3465. compare_partial_order_fallback requires F < E
+    template<typename _Tp, typename _Up>
+      concept __op_eq_lt_lt = __op_eq_lt<_Tp, _Up>
+	&& requires(_Tp&& __t, _Up&& __u)
+	{
+	  { static_cast<_Up&&>(__u) < static_cast<_Tp&&>(__t) }
+	    -> convertible_to<bool>;
+	};
+
     class _Partial_fallback
     {
       template<typename _Tp, typename _Up>
@@ -827,18 +830,16 @@ namespace std
 	}
 
     public:
-      template<typename _Tp, typename _Up>
-	requires __partially_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
-	constexpr decltype(auto)
+      template<typename _Tp, __decayed_same_as<_Tp> _Up>
+	requires __partially_ordered<_Tp, _Up> || __op_eq_lt_lt<_Tp, _Up>
+	constexpr partial_ordering
 	operator()(_Tp&& __e, _Up&& __f) const
 	noexcept(_S_noexcept<_Tp, _Up>())
 	{
-	  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
-
 	  if constexpr (__partially_ordered<_Tp, _Up>)
 	    return _Partial_order{}(static_cast<_Tp&&>(__e),
 				    static_cast<_Up&&>(__f));
-	  else if constexpr (__op_eq_lt<_Tp, _Up>)
+	  else // __op_eq_lt_lt<_Tp, _Up>
 	    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
 	      ? partial_ordering::equivalent
 	      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
diff --git a/libstdc++-v3/libsupc++/exception b/libstdc++-v3/libsupc++/exception
index 863eb91e7f0..992e6f8f256 100644
--- a/libstdc++-v3/libsupc++/exception
+++ b/libstdc++-v3/libsupc++/exception
@@ -111,7 +111,7 @@ namespace std
   int uncaught_exceptions() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));
 #endif
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 namespace __gnu_cxx
diff --git a/libstdc++-v3/libsupc++/exception.h b/libstdc++-v3/libsupc++/exception.h
index 47c6eeaee23..8ade3ea9cc3 100644
--- a/libstdc++-v3/libsupc++/exception.h
+++ b/libstdc++-v3/libsupc++/exception.h
@@ -45,7 +45,7 @@ namespace std
    * @defgroup exceptions Exceptions
    * @ingroup diagnostics
    *
-   * Classes and functions for reporting errors via exception classes.
+   * Classes and functions for reporting errors via exceptions.
    * @{
    */
 
@@ -75,6 +75,8 @@ namespace std
     what() const _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_NOTHROW;
   };
 
+  /// @}
+
 } // namespace std
 
 }
diff --git a/libstdc++-v3/libsupc++/exception_ptr.h b/libstdc++-v3/libsupc++/exception_ptr.h
index fb38a3d203f..f1592c84afe 100644
--- a/libstdc++-v3/libsupc++/exception_ptr.h
+++ b/libstdc++-v3/libsupc++/exception_ptr.h
@@ -214,7 +214,7 @@ namespace std
 #endif
     }
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 } // extern "C++"
diff --git a/libstdc++-v3/libsupc++/nested_exception.h b/libstdc++-v3/libsupc++/nested_exception.h
index 1a9c603ae49..04302521e2e 100644
--- a/libstdc++-v3/libsupc++/nested_exception.h
+++ b/libstdc++-v3/libsupc++/nested_exception.h
@@ -159,7 +159,7 @@ namespace std
     rethrow_if_nested(const _Ex& __ex)
     { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 } // extern "C++"
diff --git a/libstdc++-v3/libsupc++/new_opa.cc b/libstdc++-v3/libsupc++/new_opa.cc
index b935936e19a..732fe827cda 100644
--- a/libstdc++-v3/libsupc++/new_opa.cc
+++ b/libstdc++-v3/libsupc++/new_opa.cc
@@ -26,7 +26,6 @@
 #include <bits/c++config.h>
 #include <stdlib.h>
 #include <stdint.h>
-#include <bits/exception_defines.h>
 #include <bit>
 #include "new"
 
@@ -44,6 +43,7 @@ using std::new_handler;
 using std::bad_alloc;
 
 #if ! _GLIBCXX_HOSTED
+using std::size_t;
 extern "C"
 {
 # if _GLIBCXX_HAVE_ALIGNED_ALLOC
diff --git a/libstdc++-v3/python/Makefile.am b/libstdc++-v3/python/Makefile.am
index 5249137ce4b..d56f072b3b6 100644
--- a/libstdc++-v3/python/Makefile.am
+++ b/libstdc++-v3/python/Makefile.am
@@ -29,6 +29,12 @@ else
 pythondir = $(datadir)/gcc-$(gcc_version)/python
 endif
 
+if GLIBCXX_BUILD_DEBUG
+debug_gdb_py = YES
+else
+debug_gdb_py =
+endif
+
 all-local: gdb.py
 
 nobase_python_DATA = \
@@ -44,21 +50,17 @@ gdb.py: hook.in Makefile
 install-data-local: gdb.py
 	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
 ## We want to install gdb.py as SOMETHING-gdb.py.  SOMETHING is the
-## full name of the final library.  We want to ignore symlinks, the
-## .la file, and any previous -gdb.py file.  This is inherently
-## fragile, but there does not seem to be a better option, because
-## libtool hides the real names from us.
-	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++.*; do \
-	    case $$file in \
-	      *-gdb.py) ;; \
-	      *.la) ;; \
-	      *) if test -h $$file; then \
-	           continue; \
-	         fi; \
-	         libname=$$file;; \
-	    esac; \
-	  done; \
-	cd $$here; \
+## full name of the final library.  We use the libtool .la file to get
+## the correct name.
+	@libname=`sed -ne "/^library_names=/{s/.*='//;s/'$$//;s/ .*//;p;}" \
+	          $(DESTDIR)$(toolexeclibdir)/libstdc++.la`; \
+	if [ -z "$$libname" ]; then \
+	  libname=`sed -ne "/^old_library=/{s/.*='//;s/'$$//;s/ .*//;p;}" \
+		  $(DESTDIR)$(toolexeclibdir)/libstdc++.la`; \
+	fi; \
 	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
-	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py ; \
+	if [ -n "$(debug_gdb_py)" ]; then \
+	  sed "/^libdir = /s;'$$;/debug';" gdb.py > debug-gdb.py ; \
+	  $(INSTALL_DATA) debug-gdb.py $(DESTDIR)$(toolexeclibdir)/debug/$$libname-gdb.py ; \
+	fi
diff --git a/libstdc++-v3/python/Makefile.in b/libstdc++-v3/python/Makefile.in
index 1817b3340aa..0955a44478a 100644
--- a/libstdc++-v3/python/Makefile.in
+++ b/libstdc++-v3/python/Makefile.in
@@ -398,6 +398,8 @@ WARN_CXXFLAGS = \
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
 @ENABLE_PYTHONDIR_FALSE@pythondir = $(datadir)/gcc-$(gcc_version)/python
 @ENABLE_PYTHONDIR_TRUE@pythondir = $(prefix)/$(python_mod_dir)
+@GLIBCXX_BUILD_DEBUG_FALSE@debug_gdb_py = 
+@GLIBCXX_BUILD_DEBUG_TRUE@debug_gdb_py = YES
 nobase_python_DATA = \
     libstdcxx/v6/printers.py \
     libstdcxx/v6/xmethods.py \
@@ -602,20 +604,18 @@ gdb.py: hook.in Makefile
 
 install-data-local: gdb.py
 	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
-	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++.*; do \
-	    case $$file in \
-	      *-gdb.py) ;; \
-	      *.la) ;; \
-	      *) if test -h $$file; then \
-	           continue; \
-	         fi; \
-	         libname=$$file;; \
-	    esac; \
-	  done; \
-	cd $$here; \
+	@libname=`sed -ne "/^library_names=/{s/.*='//;s/'$$//;s/ .*//;p;}" \
+	          $(DESTDIR)$(toolexeclibdir)/libstdc++.la`; \
+	if [ -z "$$libname" ]; then \
+	  libname=`sed -ne "/^old_library=/{s/.*='//;s/'$$//;s/ .*//;p;}" \
+		  $(DESTDIR)$(toolexeclibdir)/libstdc++.la`; \
+	fi; \
 	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
-	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py ; \
+	if [ -n "$(debug_gdb_py)" ]; then \
+	  sed "/^libdir = /s;'$$;/debug';" gdb.py > debug-gdb.py ; \
+	  $(INSTALL_DATA) debug-gdb.py $(DESTDIR)$(toolexeclibdir)/debug/$$libname-gdb.py ; \
+	fi
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index 27e0740af7e..74c629a710c 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -18,7 +18,7 @@
 import gdb
 import itertools
 import re
-import sys
+import sys, os, errno
 
 ### Python 2 + Python 3 compatibility code
 
@@ -85,8 +85,8 @@ except ImportError:
 def find_type(orig, name):
     typ = orig.strip_typedefs()
     while True:
-        # Strip cv-qualifiers.  PR 67440.
-        search = '%s::%s' % (typ.unqualified(), name)
+        # Use Type.tag to ignore cv-qualifiers.  PR 67440.
+        search = '%s::%s' % (typ.tag, name)
         try:
             return gdb.lookup_type(search)
         except RuntimeError:
@@ -240,32 +240,63 @@ class SharedPointerPrinter:
                 state = 'use count %d, weak count %d' % (usecount, weakcount - 1)
         return '%s<%s> (%s)' % (self.typename, str(self.val.type.template_argument(0)), state)
 
+def _tuple_impl_get(val):
+    "Return the tuple element stored in a _Tuple_impl<N, T> base class."
+    bases = val.type.fields()
+    if not bases[-1].is_base_class:
+        raise ValueError("Unsupported implementation for std::tuple: %s" % str(val.type))
+    # Get the _Head_base<N, T> base class:
+    head_base = val.cast(bases[-1].type)
+    fields = head_base.type.fields()
+    if len(fields) == 0:
+        raise ValueError("Unsupported implementation for std::tuple: %s" % str(val.type))
+    if fields[0].name == '_M_head_impl':
+        # The tuple element is the _Head_base::_M_head_impl data member.
+        return head_base['_M_head_impl']
+    elif fields[0].is_base_class:
+        # The tuple element is an empty base class of _Head_base.
+        # Cast to that empty base class.
+        return head_base.cast(fields[0].type)
+    else:
+        raise ValueError("Unsupported implementation for std::tuple: %s" % str(val.type))
+
+def tuple_get(n, val):
+    "Return the result of std::get<n>(val) on a std::tuple"
+    tuple_size = len(get_template_arg_list(val.type))
+    if n > tuple_size:
+        raise ValueError("Out of range index for std::get<N> on std::tuple")
+    # Get the first _Tuple_impl<0, T...> base class:
+    node = val.cast(val.type.fields()[0].type)
+    while n > 0:
+        # Descend through the base classes until the Nth one.
+        node = node.cast(node.type.fields()[0].type)
+        n -= 1
+    return _tuple_impl_get(node)
+
+def unique_ptr_get(val):
+    "Return the result of val.get() on a std::unique_ptr"
+    # std::unique_ptr<T, D> contains a std::tuple<D::pointer, D>,
+    # either as a direct data member _M_t (the old implementation)
+    # or within a data member of type __uniq_ptr_data.
+    impl_type = val.type.fields()[0].type.strip_typedefs()
+    # Check for new implementations first:
+    if is_specialization_of(impl_type, '__uniq_ptr_data') \
+        or is_specialization_of(impl_type, '__uniq_ptr_impl'):
+        tuple_member = val['_M_t']['_M_t']
+    elif is_specialization_of(impl_type, 'tuple'):
+        tuple_member = val['_M_t']
+    else:
+        raise ValueError("Unsupported implementation for unique_ptr: %s" % str(impl_type))
+    return tuple_get(0, tuple_member)
+
 class UniquePointerPrinter:
     "Print a unique_ptr"
 
     def __init__ (self, typename, val):
         self.val = val
-        impl_type = val.type.fields()[0].type.strip_typedefs()
-        # Check for new implementations first:
-        if is_specialization_of(impl_type, '__uniq_ptr_data') \
-            or is_specialization_of(impl_type, '__uniq_ptr_impl'):
-            tuple_member = val['_M_t']['_M_t']
-        elif is_specialization_of(impl_type, 'tuple'):
-            tuple_member = val['_M_t']
-        else:
-            raise ValueError("Unsupported implementation for unique_ptr: %s" % str(impl_type))
-        tuple_impl_type = tuple_member.type.fields()[0].type # _Tuple_impl
-        tuple_head_type = tuple_impl_type.fields()[1].type   # _Head_base
-        head_field = tuple_head_type.fields()[0]
-        if head_field.name == '_M_head_impl':
-            self.pointer = tuple_member['_M_head_impl']
-        elif head_field.is_base_class:
-            self.pointer = tuple_member.cast(head_field.type)
-        else:
-            raise ValueError("Unsupported implementation for tuple in unique_ptr: %s" % str(impl_type))
 
     def children (self):
-        return SmartPtrIterator(self.pointer)
+        return SmartPtrIterator(unique_ptr_get(self.val))
 
     def to_string (self):
         return ('std::unique_ptr<%s>' % (str(self.val.type.template_argument(0))))
@@ -1351,7 +1382,7 @@ class StdPathPrinter:
     def __init__ (self, typename, val):
         self.val = val
         self.typename = typename
-        impl = self.val['_M_cmpts']['_M_impl']['_M_t']['_M_t']['_M_head_impl']
+        impl = unique_ptr_get(self.val['_M_cmpts']['_M_impl'])
         self.type = impl.cast(gdb.lookup_type('uintptr_t')) & 3
         if self.type == 0:
             self.impl = impl
@@ -1465,6 +1496,45 @@ class StdCmpCatPrinter:
             name = names[int(self.val)]
         return 'std::{}::{}'.format(self.typename, name)
 
+class StdErrorCodePrinter:
+    "Print a std::error_code or std::error_condition"
+
+    _errno_categories = None # List of categories that use errno values
+
+    def __init__ (self, typename, val):
+        self.val = val
+        self.typename = strip_versioned_namespace(typename)
+        # Do this only once ...
+        if StdErrorCodePrinter._errno_categories is None:
+            StdErrorCodePrinter._errno_categories = ['generic']
+            try:
+                import posix
+                StdErrorCodePrinter._errno_categories.append('system')
+            except ImportError:
+                pass
+
+    @staticmethod
+    def _category_name(cat):
+        "Call the virtual function that overrides std::error_category::name()"
+        gdb.set_convenience_variable('__cat', cat)
+        return gdb.parse_and_eval('$__cat->name()').string()
+
+    def to_string (self):
+        value = self.val['_M_value']
+        category = self._category_name(self.val['_M_cat'])
+        strval = str(value)
+        if value == 0:
+            default_cats = {'error_code':'system', 'error_condition':'generic'}
+            unqualified = self.typename.split('::')[-1]
+            if category == default_cats[unqualified]:
+                return self.typename + ' = { }' # default-constructed value
+        if value > 0 and category in StdErrorCodePrinter._errno_categories:
+            try:
+                strval = errno.errorcode[int(value)]
+            except:
+                pass
+        return '%s = {"%s": %s}' % (self.typename, category, strval)
+
 # A "regular expression" printer which conforms to the
 # "SubPrettyPrinter" protocol from gdb.printing.
 class RxPrinter(object):
@@ -1867,6 +1937,8 @@ def build_libstdcxx_dictionary ():
     libstdcxx_printer.add_version('std::__cxx11::', 'basic_string', StdStringPrinter)
     libstdcxx_printer.add_container('std::', 'bitset', StdBitsetPrinter)
     libstdcxx_printer.add_container('std::', 'deque', StdDequePrinter)
+    libstdcxx_printer.add_version('std::', 'error_code', StdErrorCodePrinter)
+    libstdcxx_printer.add_version('std::', 'error_condition', StdErrorCodePrinter)
     libstdcxx_printer.add_container('std::', 'list', StdListPrinter)
     libstdcxx_printer.add_container('std::__cxx11::', 'list', StdListPrinter)
     libstdcxx_printer.add_container('std::', 'map', StdMapPrinter)
diff --git a/libstdc++-v3/python/libstdcxx/v6/xmethods.py b/libstdc++-v3/python/libstdcxx/v6/xmethods.py
index e77f8504cc3..2617c189e40 100644
--- a/libstdc++-v3/python/libstdcxx/v6/xmethods.py
+++ b/libstdc++-v3/python/libstdcxx/v6/xmethods.py
@@ -597,7 +597,7 @@ class UniquePtrGetWorker(gdb.xmethod.XMethodWorker):
         tuple_head_type = tuple_impl_type.fields()[1].type   # _Head_base
         head_field = tuple_head_type.fields()[0]
         if head_field.name == '_M_head_impl':
-            return tuple_member['_M_head_impl']
+            return tuple_member.cast(tuple_head_type)['_M_head_impl']
         elif head_field.is_base_class:
             return tuple_member.cast(head_field.type)
         else:
diff --git a/libstdc++-v3/src/c++11/system_error.cc b/libstdc++-v3/src/c++11/system_error.cc
index 1f06e67feea..2c8fd4bf161 100644
--- a/libstdc++-v3/src/c++11/system_error.cc
+++ b/libstdc++-v3/src/c++11/system_error.cc
@@ -70,6 +70,8 @@ namespace
     virtual std::error_condition
     default_error_condition(int ev) const noexcept
     {
+      // Use generic category for all known POSIX errno values (including zero)
+      // and system category otherwise.
       switch (ev)
       {
       // List of errno macros from [cerrno.syn].
@@ -310,6 +312,7 @@ namespace
 #ifdef EXDEV
       case EXDEV:
 #endif
+      case 0:
         return std::error_condition(ev, std::generic_category());
 
       /* Additional system-dependent mappings from non-standard error codes
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index 81c84dfb557..008195c2d31 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -65,19 +65,12 @@ namespace posix = std::filesystem::__gnu_posix;
 fs::path
 fs::absolute(const path& p)
 {
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
   error_code ec;
   path ret = absolute(p, ec);
   if (ec)
     _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot make absolute path", p,
 					     ec));
   return ret;
-#else
-  if (p.empty())
-    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot make absolute path", p,
-	  make_error_code(std::errc::invalid_argument)));
-  return current_path() / p;
-#endif
 }
 
 fs::path
@@ -496,7 +489,7 @@ fs::create_directories(const path& p, error_code& ec)
       return false;
     }
 
-  file_status st = symlink_status(p, ec);
+  file_status st = status(p, ec);
   if (is_directory(st))
     return false;
   else if (ec && !status_known(st))
@@ -577,8 +570,7 @@ namespace
   {
     bool created = false;
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
-    posix::mode_t mode
-      = static_cast<std::underlying_type_t<fs::perms>>(perm);
+    posix::mode_t mode = static_cast<std::underlying_type_t<fs::perms>>(perm);
     if (posix::mkdir(p.c_str(), mode))
       {
 	const int err = errno;
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index edfb91fc6c5..812f39fe253 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -1907,10 +1907,9 @@ path::_M_split_cmpts()
 	  _M_cmpts.type(_Type::_Multi);
 	  _M_cmpts.reserve(_M_cmpts.size() + buf.size());
 	  auto output = _M_cmpts._M_impl->end();
-	  for (auto& c : buf)
+	  for (const auto& c : buf)
 	    {
-	      auto pos = c.str.data() - _M_pathname.data();
-	      ::new(output++) _Cmpt(c.str, c.type, pos);
+	      ::new(output++) _Cmpt(c.str, c.type, parser.offset(c));
 	      ++_M_cmpts._M_impl->_M_size;
 	    }
 	  next = buf.begin();
@@ -1930,9 +1929,8 @@ path::_M_split_cmpts()
       auto output = _M_cmpts._M_impl->end();
       for (int i = 0; i < n; ++i)
 	{
-	  auto c = buf[i];
-	  auto pos = c.str.data() - _M_pathname.data();
-	  ::new(output++) _Cmpt(c.str, c.type, pos);
+	  const auto& c = buf[i];
+	  ::new(output++) _Cmpt(c.str, c.type, parser.offset(c));
 	  ++_M_cmpts._M_impl->_M_size;
 	}
     }
diff --git a/libstdc++-v3/src/c++98/Makefile.am b/libstdc++-v3/src/c++98/Makefile.am
index 61916f86dec..51920591135 100644
--- a/libstdc++-v3/src/c++98/Makefile.am
+++ b/libstdc++-v3/src/c++98/Makefile.am
@@ -39,7 +39,6 @@ endif
 # particular host.
 host_sources = \
 	$(cow_string_host_sources) \
-	atomicity.cc \
 	codecvt_members.cc \
 	collate_members.cc \
 	messages_members.cc \
@@ -65,10 +64,6 @@ numeric_members.cc: ${glibcxx_srcdir}/$(CNUMERIC_CC)
 time_members.cc: ${glibcxx_srcdir}/$(CTIME_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CTIME_CC) . || true
 
-atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
-atomicity.cc: ${atomicity_file}
-	$(LN_S) ${atomicity_file} ./atomicity.cc || true
-
 if ENABLE_DUAL_ABI
 collate_members_cow.cc: ${glibcxx_srcdir}/$(CCOLLATE_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CCOLLATE_CC) ./$@ || true
diff --git a/libstdc++-v3/src/c++98/Makefile.in b/libstdc++-v3/src/c++98/Makefile.in
index 6895780a5f7..68e3a95f9a0 100644
--- a/libstdc++-v3/src/c++98/Makefile.in
+++ b/libstdc++-v3/src/c++98/Makefile.in
@@ -127,9 +127,9 @@ libc__98convenience_la_LIBADD =
 @ENABLE_DUAL_ABI_TRUE@	messages_members_cow.lo \
 @ENABLE_DUAL_ABI_TRUE@	monetary_members_cow.lo \
 @ENABLE_DUAL_ABI_TRUE@	numeric_members_cow.lo
-am__objects_3 = $(am__objects_2) atomicity.lo codecvt_members.lo \
-	collate_members.lo messages_members.lo monetary_members.lo \
-	numeric_members.lo time_members.lo
+am__objects_3 = $(am__objects_2) codecvt_members.lo collate_members.lo \
+	messages_members.lo monetary_members.lo numeric_members.lo \
+	time_members.lo
 @ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = allocator-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	concept-inst.lo ext-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	misc-inst.lo
@@ -443,7 +443,6 @@ headers =
 # particular host.
 host_sources = \
 	$(cow_string_host_sources) \
-	atomicity.cc \
 	codecvt_members.cc \
 	collate_members.cc \
 	messages_members.cc \
@@ -451,7 +450,6 @@ host_sources = \
 	numeric_members.cc \
 	time_members.cc
 
-atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
 
 # Source files linked in via configuration/make substitution for a
 # particular host, but with ad hoc naming rules.
@@ -842,8 +840,6 @@ numeric_members.cc: ${glibcxx_srcdir}/$(CNUMERIC_CC)
 
 time_members.cc: ${glibcxx_srcdir}/$(CTIME_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CTIME_CC) . || true
-atomicity.cc: ${atomicity_file}
-	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 @ENABLE_DUAL_ABI_TRUE@collate_members_cow.cc: ${glibcxx_srcdir}/$(CCOLLATE_CC)
 @ENABLE_DUAL_ABI_TRUE@	$(LN_S) ${glibcxx_srcdir}/$(CCOLLATE_CC) ./$@ || true
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 7cc82a50e01..32a17a6d818 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -426,7 +426,7 @@ fs::create_directories(const path& p, error_code& ec) noexcept
       return false;
     }
 
-  file_status st = symlink_status(p, ec);
+  file_status st = status(p, ec);
   if (is_directory(st))
     return false;
   else if (ec && !status_known(st))
diff --git a/libstdc++-v3/testsuite/18_support/comparisons/algorithms/fallback.cc b/libstdc++-v3/testsuite/18_support/comparisons/algorithms/fallback.cc
new file mode 100644
index 00000000000..05e1bf7775e
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/comparisons/algorithms/fallback.cc
@@ -0,0 +1,42 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+#include <compare>
+
+using std::strong_ordering;
+using std::partial_ordering;
+
+namespace adl
+{
+  struct S { };
+  void strong_ordering(const S&, const S&);
+  bool operator==(const S&, S&) { return true; }
+  bool operator<(const S&, S&) { return true; }
+}
+
+template<typename T, typename U>
+  concept has_strong_order_fallback = requires (T& t, U& u) {
+    std::compare_strong_order_fallback(t, u);
+  };
+
+template<typename T, typename U>
+  concept has_weak_order_fallback = requires (T& t, U& u) {
+    std::compare_weak_order_fallback(t, u);
+  };
+
+template<typename T, typename U>
+  concept has_partial_order_fallback = requires (T& t, U& u) {
+    std::compare_partial_order_fallback(t, u);
+  };
+
+using adl::S;
+
+static_assert( has_strong_order_fallback<S, S> );
+static_assert( has_strong_order_fallback<const S, S> );
+static_assert( ! has_strong_order_fallback<const S, const S> );
+static_assert( has_weak_order_fallback<S, S> );
+static_assert( has_weak_order_fallback<const S, S> );
+static_assert( ! has_weak_order_fallback<const S, const S> );
+static_assert( has_partial_order_fallback<S, S> );
+static_assert( ! has_partial_order_fallback<const S, S> ); // LWG 3465
+static_assert( ! has_partial_order_fallback<const S, const S> );
diff --git a/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc b/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc
new file mode 100644
index 00000000000..61572668385
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc
@@ -0,0 +1,17 @@
+// { dg-options "-nodefaultlibs -lsupc++ -lgcc_s -lc" { target sparc*-*-linux-gnu } }
+// { dg-do link { target c++11 } }
+
+#include <exception>
+
+void
+test01()
+{
+  // PR libstdc++/96657 undefined references in libsupc++
+  std::make_exception_ptr(1);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc b/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc
new file mode 100644
index 00000000000..069b5e284e1
--- /dev/null
+++ b/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc
@@ -0,0 +1,18 @@
+// { dg-do run { target c++11 } }
+#include <system_error>
+#include <testsuite_hooks.h>
+
+void test01()
+{
+  // PR libstdc++/102425
+  VERIFY( std::error_code() == std::error_condition() );
+
+  auto zero = std::system_category().default_error_condition(0);
+  // This is the condition that the equality above relies on:
+  VERIFY( zero.category() == std::generic_category() );
+}
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/20_util/allocator/void.cc b/libstdc++-v3/testsuite/20_util/allocator/void.cc
index 86dde5416ea..309f3b5f850 100644
--- a/libstdc++-v3/testsuite/20_util/allocator/void.cc
+++ b/libstdc++-v3/testsuite/20_util/allocator/void.cc
@@ -33,6 +33,18 @@ test01()
   std::allocator_traits<alloc_type>::destroy(a, &i);
 }
 
+static_assert( std::allocator<void>::propagate_on_container_move_assignment(),
+	       "POCMA trait should always be present" );
+static_assert( std::allocator<void>::is_always_equal(),
+	       "is_always_equal trait should always be present" );
+
+static_assert(
+    std::is_same<std::allocator<void>::size_type, std::size_t>(),
+    "size_type is size_t" );
+static_assert(
+    std::is_same<std::allocator<void>::difference_type, std::ptrdiff_t>(),
+    "size_type is size_t" );
+
 // These properties are formally unspecified, but have always been true for
 // the libstdc++ definition of allocator<void>.
 static_assert(
@@ -51,9 +63,29 @@ static_assert(
 #if __cplusplus > 201703L
 // C++20 removes the allocator<void> explicit specialization, so it can now be
 // constructed using the converting constructor from other specializations.
-static_assert( std::is_constructible_v<std::allocator<void>,
-				       std::allocator<int>> );
-#endif
+static_assert( std::is_nothrow_constructible_v<std::allocator<void>,
+					       std::allocator<int>> );
+
+template<typename T>
+concept has_pointer = requires { typename T::pointer; };
+template<typename T>
+concept has_const_pointer = requires { typename T::const_pointer; };
+template<typename T>
+concept has_size_type = requires { typename T::size_type; };
+template<typename T>
+concept has_difference_type = requires { typename T::difference_type; };
+
+// These were removed for C++20
+static_assert( ! has_pointer<std::allocator<void>> );
+static_assert( ! has_const_pointer<std::allocator<void>> );
+
+#else
+static_assert(
+    std::is_same<std::allocator<void>::pointer, void*>(),
+    "pointer is void*" );
+static_assert( std::is_same<std::allocator<void>::const_pointer, const void*>(),
+    "const_pointer is const void*" );
+#endif // C++20
 
 int
 main()
diff --git a/libstdc++-v3/testsuite/20_util/any/102894.cc b/libstdc++-v3/testsuite/20_util/any/102894.cc
new file mode 100644
index 00000000000..66ea9a03fea
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/102894.cc
@@ -0,0 +1,20 @@
+// { dg-do compile { target c++17 } }
+#include <any>
+
+template<typename T, typename = void>
+struct can_make_any
+: std::false_type
+{ };
+
+template<typename T>
+struct can_make_any<T, std::void_t<decltype(std::make_any<T>())>>
+: std::true_type
+{ };
+
+struct move_only
+{
+  move_only() = default;
+  move_only(move_only&&) = default;
+};
+
+static_assert( ! can_make_any<move_only>::value ); // PR libstdc++/102894
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/101034.cc b/libstdc++-v3/testsuite/20_util/any/cons/101034.cc
new file mode 100644
index 00000000000..55f550a839e
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/101034.cc
@@ -0,0 +1,11 @@
+// { dg-do compile { target c++17 } }
+// PR libstdc++/101034 - wrong constraint in std::any's constructor
+
+#include <any>
+
+struct S {
+  S(std::initializer_list<int>&, int) {}
+};
+
+std::any a(std::in_place_type<S>, {0}, 0);
+S& s = a.emplace<S>({0}, 0);
diff --git a/libstdc++-v3/testsuite/20_util/common_reference/100894.cc b/libstdc++-v3/testsuite/20_util/common_reference/100894.cc
new file mode 100644
index 00000000000..5e144768002
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/common_reference/100894.cc
@@ -0,0 +1,9 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+// PR libstdc++/100894 - common_reference implementation seems to be wrong
+
+#include <type_traits>
+
+struct A {};
+struct B { B(A); };
+static_assert( std::is_same_v<std::common_reference_t<A&, B&&>, B> );
diff --git a/libstdc++-v3/testsuite/20_util/forward/c_neg.cc b/libstdc++-v3/testsuite/20_util/forward/c_neg.cc
index 8b6736d42f0..5e318ed67f4 100644
--- a/libstdc++-v3/testsuite/20_util/forward/c_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/forward/c_neg.cc
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-error "static assertion failed" "" { target *-*-* } 89 }
+// { dg-error "convert an rvalue to an lvalue" "" { target *-*-* } 0 }
 
 #include <list>
 
diff --git a/libstdc++-v3/testsuite/20_util/forward/f_neg.cc b/libstdc++-v3/testsuite/20_util/forward/f_neg.cc
index 4b697f1cd5d..c6cf880bd15 100644
--- a/libstdc++-v3/testsuite/20_util/forward/f_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/forward/f_neg.cc
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-error "static assertion failed" "" { target *-*-* } 89 }
+// { dg-error "convert an rvalue to an lvalue" "" { target *-*-* } 0 }
 
 #include <utility>
 
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/3.cc b/libstdc++-v3/testsuite/20_util/from_chars/3.cc
index 9d4a77f5c31..d1f93bba2cb 100644
--- a/libstdc++-v3/testsuite/20_util/from_chars/3.cc
+++ b/libstdc++-v3/testsuite/20_util/from_chars/3.cc
@@ -29,7 +29,7 @@ long long
 read(const char* first, const char* last, int base)
 {
   long long val = 0;
-  long long place = 1;
+  unsigned long long place = 1;
   while (last > first)
   {
     val += (*--last - '0') * place;
diff --git a/libstdc++-v3/testsuite/20_util/headers/memory/synopsis.cc b/libstdc++-v3/testsuite/20_util/headers/memory/synopsis.cc
index 187de621257..dd4324a3915 100644
--- a/libstdc++-v3/testsuite/20_util/headers/memory/synopsis.cc
+++ b/libstdc++-v3/testsuite/20_util/headers/memory/synopsis.cc
@@ -20,6 +20,12 @@
 
 #include <memory>
 
+#if __cplusplus >= 201103L
+# define NOTHROW noexcept
+#else
+# define NOTHROW
+#endif
+
 namespace std {
   //  lib.default.allocator, the default allocator:
   template <class T> class allocator;
@@ -40,7 +46,7 @@ namespace std {
 
   //  lib.temporary.buffer, temporary buffers:
   template <class T>
-  pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n);
+  pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) NOTHROW;
   template <class T>
   void return_temporary_buffer(T* p);
 
diff --git a/libstdc++-v3/testsuite/20_util/integer_comparisons/greater.cc b/libstdc++-v3/testsuite/20_util/integer_comparisons/greater.cc
new file mode 100644
index 00000000000..e564d8d03f2
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/integer_comparisons/greater.cc
@@ -0,0 +1,61 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do run { target c++20 } }
+
+#include <utility>
+#include <limits>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  VERIFY( !std::cmp_greater(s, u) );
+  VERIFY( std::cmp_greater(u, s) );
+  u = (unsigned) std::numeric_limits<int>::max() + 1U;
+  VERIFY( !std::cmp_greater(s, u) );
+  VERIFY( std::cmp_greater(u, s) );
+}
+
+constexpr bool
+test02()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  if (std::cmp_greater(s, u))
+    throw 1;
+  if (!std::cmp_greater(u, s))
+    throw 2;
+  return true;
+}
+
+void
+test03()
+{
+  short ss = -1;
+  int s = -1;
+  VERIFY( !std::cmp_greater(s, ss) );
+  VERIFY( !std::cmp_greater(ss, s) );
+
+  unsigned int u = (unsigned int) -1;
+  VERIFY( !std::cmp_greater(s, u) );
+  VERIFY( std::cmp_greater(u, s) );
+  VERIFY( !std::cmp_greater(ss, u) );
+  VERIFY( std::cmp_greater(u, ss) );
+
+  unsigned long long ul = (unsigned long long) -1;
+  VERIFY( !std::cmp_greater(s, ul) );
+  VERIFY( std::cmp_greater(ul, s) );
+  VERIFY( !std::cmp_greater(ss, ul) );
+  VERIFY( std::cmp_greater(ul, ss) );
+  VERIFY( !std::cmp_greater(u, ul) );
+  VERIFY( std::cmp_greater(ul, u) );
+}
+
+int
+main()
+{
+  test01();
+  static_assert( test02() );
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc b/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc
new file mode 100644
index 00000000000..ae565250d68
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc
@@ -0,0 +1,17 @@
+// { dg-do compile { target c++17 } }
+
+#include <optional>
+
+struct U {};
+
+struct T {
+  explicit T(const U&);
+  T& operator=(const U&);
+  T& operator=(U&&) = delete;
+};
+
+int main() {
+  std::optional<U> opt1;
+  std::optional<T> opt2;
+  opt2 = opt1; // PR libstdc++/100982
+}
diff --git a/libstdc++-v3/testsuite/20_util/optional/relops/three_way.cc b/libstdc++-v3/testsuite/20_util/optional/relops/three_way.cc
index d7bd16bf32a..416e6a9b891 100644
--- a/libstdc++-v3/testsuite/20_util/optional/relops/three_way.cc
+++ b/libstdc++-v3/testsuite/20_util/optional/relops/three_way.cc
@@ -15,8 +15,8 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
 
 #include <optional>
 
@@ -74,3 +74,21 @@ test02()
   static_assert( nullopt <= O{} );
   static_assert( nullopt <= O{1} );
 }
+
+template<typename T>
+  concept has_spaceship = requires (const T& t) { t <=> t; };
+
+void
+test03()
+{
+  struct E
+  {
+    auto operator<=>(const E&) const { return std::strong_ordering::equal; }
+  };
+  static_assert( !std::three_way_comparable<E> ); // not equality comparable
+  using O = std::optional<E>;
+  static_assert( !std::three_way_comparable<O> );
+  static_assert( ! has_spaceship<O> ); // PR libstdc++/98842
+  struct U : O { };
+  static_assert( ! has_spaceship<U> );
+}
diff --git a/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc b/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc
index 6f3cd0a2521..975862b3365 100644
--- a/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc
@@ -47,6 +47,7 @@ test01()
   auto p = sa.allocate(1);
   sa.construct(p);  // this is required to be ill-formed
   // { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
+  // { dg-error "too many initializers for 'X'" "" { target c++2a } 0 }
 }
 
 // Needed because of PR c++/92193
diff --git a/libstdc++-v3/testsuite/20_util/shared_ptr/cons/lwg3548.cc b/libstdc++-v3/testsuite/20_util/shared_ptr/cons/lwg3548.cc
new file mode 100644
index 00000000000..d6ec7b1d057
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/shared_ptr/cons/lwg3548.cc
@@ -0,0 +1,16 @@
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+
+// LWG 3548
+// shared_ptr construction from unique_ptr should move (not copy) the deleter
+
+struct D
+{
+  D() { }
+  D(D&&) { }
+  void operator()(int* p) const { delete p; }
+};
+
+std::unique_ptr<int, D> u;
+std::shared_ptr<int> s1(std::move(u));
diff --git a/libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc b/libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc
index 3205cc37f1f..506e1823c8f 100644
--- a/libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc
+++ b/libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc
@@ -58,10 +58,25 @@ test02()
   VERIFY( D::count == 0 ); // LWG 2415
 }
 
+void
+test03()
+{
+  struct D
+  {
+    D() = default;
+    D(const D&) = delete; // not copyable or movable
+    void operator()(int* p) const { delete p; }
+  };
+
+  using namespace std;
+  static_assert( ! is_constructible<shared_ptr<int>, unique_ptr<int, D>>(),
+		 "Constraints: is_move_constructible_v<D> is true" );
+}
+
 int
 main()
 {
   test01();
   test02();
-  return 0;
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
new file mode 100644
index 00000000000..e070fb9d420
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
@@ -0,0 +1,9 @@
+// FIXME: This should use { target { c++11 && { ! c++20 } } }
+// { dg-do compile { target { c++11 } } }
+
+#include <memory>
+
+auto p = std::make_shared<int[]>(2); // { dg-error "here" }
+auto q = std::make_shared<int[2]>(1, 2); // { dg-error "here" }
+
+// { dg-prune-output "static assertion failed" }
diff --git a/libstdc++-v3/testsuite/20_util/tuple/comparison_operators/overloaded.cc b/libstdc++-v3/testsuite/20_util/tuple/comparison_operators/overloaded.cc
index 9d6b0189525..b64d8818365 100644
--- a/libstdc++-v3/testsuite/20_util/tuple/comparison_operators/overloaded.cc
+++ b/libstdc++-v3/testsuite/20_util/tuple/comparison_operators/overloaded.cc
@@ -48,4 +48,9 @@ TwistedLogic operator<(const Compares&, const Compares&) { return {false}; }
 
 auto a = std::make_tuple(nullptr, Compares{}, 2, 'U');
 auto b = a == a;
-auto c = a < a;
+
+#if ! __cpp_lib_three_way_comparison
+// Not valid in C++20, because TwistedLogic doesn't model boolean-testable.
+auto c = std::make_tuple("", Compares{}, 2, 'U');
+auto d = c < c;
+#endif
diff --git a/libstdc++-v3/testsuite/20_util/tuple/cons/102270.cc b/libstdc++-v3/testsuite/20_util/tuple/cons/102270.cc
new file mode 100644
index 00000000000..5500cacab6d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/tuple/cons/102270.cc
@@ -0,0 +1,64 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+#include <tuple>
+
+// PR libstdc++/102270 - std::tuple<>::swap missing constexpr specifier
+
+constexpr bool swap_empty_tuple()
+{
+  std::tuple<> t, u;
+  t.swap(u);
+  return true;
+}
+static_assert( swap_empty_tuple() );
+
+#include <testsuite_allocator.h>
+
+constexpr bool construct_using_allocator()
+{
+  using Alloc = __gnu_test::SimpleAllocator<int>;
+
+  Alloc a;
+  const int i = 0;
+
+  struct X0a {
+    using allocator_type = Alloc;
+    /* not constexpr */ X0a() { }
+    constexpr X0a(allocator_type) { }
+  };
+  std::tuple<X0a> t0a(std::allocator_arg, a);
+  std::tuple<X0a, X0a> t00a(std::allocator_arg, a);
+
+  struct X0b {
+    using allocator_type = Alloc;
+    /* not constexpr */ X0b() { }
+    constexpr X0b(std::allocator_arg_t, allocator_type) { }
+  };
+  std::tuple<X0b> t0b(std::allocator_arg, a);
+  std::tuple<X0b, X0b> t00b(std::allocator_arg, a);
+
+  struct X1a {
+    using allocator_type = Alloc;
+    /* not constexpr */ X1a(int) { }
+    constexpr X1a(int, allocator_type) { }
+  };
+  std::tuple<X1a> t1a(std::allocator_arg, a, 1);
+  std::tuple<X1a, X1a> t11a(std::allocator_arg, a, 1, i);
+
+  struct X1b {
+    using allocator_type = Alloc;
+    /* not constexpr */ X1b(int) { }
+    constexpr X1b(std::allocator_arg_t, allocator_type, int) { }
+  };
+  std::tuple<X1b> t1b(std::allocator_arg, a, 1);
+  std::tuple<X1b, X1b> t11b(std::allocator_arg, a, 1, i);
+
+  std::tuple<X1a, X1a, X1b, X1b> t1a1b(std::allocator_arg, a, 1, i, 1, i);
+
+  const int c = 0;
+  std::tuple<int, int> tii(std::allocator_arg, a, c, c);
+
+  return true;
+}
+static_assert( construct_using_allocator() );
diff --git a/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc b/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc
index 423ecc4d90e..6626e5a9713 100644
--- a/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc
@@ -45,5 +45,6 @@ test01()
   alloc_type a;
   std::tuple<X> t(std::allocator_arg, a); // this is required to be ill-formed
   // { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
-  // { dg-error "no matching function for call" "" { target c++2a } 0 }
+  // { dg-error "too many initializers for 'X'" "" { target c++2a } 0 }
+  // { dg-prune-output "in 'constexpr' expansion" }
 }
diff --git a/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc b/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
index c3ff05aa72a..966e579cc99 100644
--- a/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
@@ -45,3 +45,4 @@ void test01()
 }
 // { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
 // { dg-error "no matching function for call" "" { target c++2a } 0 }
+// { dg-prune-output "in 'constexpr' expansion" }
diff --git a/libstdc++-v3/testsuite/20_util/variant/100384.cc b/libstdc++-v3/testsuite/20_util/variant/100384.cc
new file mode 100644
index 00000000000..4866aa017ff
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/variant/100384.cc
@@ -0,0 +1,9 @@
+// { dg-do compile { target c++17 } }
+
+#include <variant>
+
+int visit(int*, std::true_type) { return 0; }
+
+const std::true_type dat;
+
+int i = visit(nullptr, dat);
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/requirements/trivially_copyable.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/requirements/trivially_copyable.cc
new file mode 100644
index 00000000000..bf04587b413
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/requirements/trivially_copyable.cc
@@ -0,0 +1,12 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf
+
+#include <string_view>
+
+static_assert( std::is_trivially_copyable_v<std::string_view> );
+static_assert( std::is_trivially_copyable_v<std::wstring_view> );
+
+struct traits : std::char_traits<char> { };
+static_assert( std::is_trivially_copyable_v<std::basic_string_view<char, traits>> );
diff --git a/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++17.cc b/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++17.cc
index 55dcba48db6..ebde98be20e 100644
--- a/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++17.cc
@@ -73,12 +73,17 @@ template<typename CT>
     return true;
   }
 
+#ifndef __cpp_lib_constexpr_string
+# error Feature-test macro for constexpr char_traits is missing
+#elif __cpp_lib_constexpr_string < (__cplusplus == 201703 ? 201611 : 201811)
+# error Feature-test macro for constexpr char_traits has the wrong value
+#endif
+
+// We also provide this non-standard macro for P0426R1 (and P1032R1 in C++20).
 #ifndef __cpp_lib_constexpr_char_traits
 # error Feature-test macro for constexpr char_traits is missing
-#elif __cpp_lib_constexpr_char_traits < 201611
+#elif __cpp_lib_constexpr_char_traits != (__cplusplus == 201703 ? 201611 : 201811)
 # error Feature-test macro for constexpr char_traits has the wrong value
-#elif __cpp_lib_constexpr_char_traits > 201611 && __cplusplus == 201703
-# error Feature-test macro for constexpr char_traits has wrong value for C++17
 #endif
 
 static_assert( test_assign<std::char_traits<char>>() );
diff --git a/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++20.cc b/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++20.cc
index 63c7c9cbb57..878a08e8328 100644
--- a/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++20.cc
+++ b/libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions_c++20.cc
@@ -1,5 +1,5 @@
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
 
 // Copyright (C) 2017-2020 Free Software Foundation, Inc.
 //
@@ -25,11 +25,35 @@ template<typename CT>
   test_move()
   {
     using char_type = typename CT::char_type;
+
+    // Overlapping strings
     char_type s1[3] = {1, 2, 3};
     CT::move(s1+1, s1, 2);
-    return s1[0]==char_type{1} && s1[1]==char_type{1} && s1[2]==char_type{2};
+    if (s1[0] != char_type{1} || s1[1] != char_type{1} || s1[2] != char_type{2})
+      throw 1;
+    CT::move(s1, s1+1, 2);
+    if (s1[0] != char_type{1} || s1[1] != char_type{2} || s1[2] != char_type{2})
+      throw 2;
+
+    // Disjoint strings
+    char_type why_is_six_scared_of_seven[] = {4, 5, 6};
+    char_type because789[] = {7, 8, 9};
+    CT::move(why_is_six_scared_of_seven, because789, 3);
+    if (why_is_six_scared_of_seven[0] != char_type{7}
+	|| why_is_six_scared_of_seven[1] != char_type{8}
+	|| why_is_six_scared_of_seven[2] != char_type{9})
+      throw 3;
+
+    return true;
   }
 
+#ifndef __cpp_lib_constexpr_string
+# error Feature-test macro for constexpr char_traits is missing
+#elif __cpp_lib_constexpr_string < 201811
+# error Feature-test macro for constexpr char_traits has the wrong value
+#endif
+
+// We also provide this non-standard macro for P0426R1 and P1032R1.
 #ifndef __cpp_lib_constexpr_char_traits
 # error Feature-test macro for constexpr char_traits is missing
 #elif __cpp_lib_constexpr_char_traits != 201811
diff --git a/libstdc++-v3/testsuite/21_strings/char_traits/requirements/version.cc b/libstdc++-v3/testsuite/21_strings/char_traits/requirements/version.cc
new file mode 100644
index 00000000000..6f571f48010
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/char_traits/requirements/version.cc
@@ -0,0 +1,16 @@
+// { dg-do compile { target c++17 } }
+
+#include <version>
+
+#ifndef __cpp_lib_constexpr_string
+# error Feature-test macro for constexpr char_traits is missing in <version>
+#elif __cpp_lib_constexpr_string < (__cplusplus == 201703 ? 201611 : 201811)
+# error Feature-test macro for constexpr char_traits has the wrong value in <version>
+#endif
+
+// We also provide this non-standard macro for P0426R1 and P1032R1.
+#ifndef __cpp_lib_constexpr_char_traits
+# error Feature-test macro for constexpr char_traits is missing in <version>
+#elif __cpp_lib_constexpr_char_traits != (__cplusplus == 201703 ? 201611 : 201811)
+# error Feature-test macro for constexpr char_traits has the wrong value in <version>
+#endif
diff --git a/libstdc++-v3/testsuite/23_containers/array/comparison_operators/96851.cc b/libstdc++-v3/testsuite/23_containers/array/comparison_operators/96851.cc
index b2a464b8f68..96d6e94d5ae 100644
--- a/libstdc++-v3/testsuite/23_containers/array/comparison_operators/96851.cc
+++ b/libstdc++-v3/testsuite/23_containers/array/comparison_operators/96851.cc
@@ -17,6 +17,7 @@
 
 // { dg-options "-std=gnu++2a" }
 // { dg-do run { target c++2a } }
+// { dg-require-normal-mode "" }
 
 #include <array>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
index 119b199ddff..25d1c9b5aca 100644
--- a/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mtype,
 	       mtype&&, const typename mtype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::map<int, int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<std::pair<const int, int>>> amtype;
+
+static_assert( std::is_nothrow_move_constructible<amtype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::map<int, int, not_noexcept_less> emtype;
 
+static_assert( !std::is_nothrow_move_constructible<emtype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emtype, emtype&&,
 	       const typename emtype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
index 44c3015a282..af545ae297c 100644
--- a/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mmtype,
 	       mmtype&&, const typename mmtype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::multimap<int, int, std::less<int>,
+		      not_noexcept_move_constructor_alloc<std::pair<const int, int>>> ammtype;
+
+static_assert( std::is_nothrow_move_constructible<ammtype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::multimap<int, int, not_noexcept_less> emmtype;
 
+static_assert( !std::is_nothrow_move_constructible<emmtype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emmtype, emmtype&&,
 	       const typename emmtype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
index 225b2206ad4..ed4d9128606 100644
--- a/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mstype,
 	       mstype&&, const typename mstype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::multiset<int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<int>> amstype;
+
+static_assert( std::is_nothrow_move_constructible<amstype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::multiset<int, not_noexcept_less> emstype;
 
+static_assert( !std::is_nothrow_move_constructible<emstype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emstype, emstype&&,
 	       const typename emstype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
index acd84a8fcd0..dc96236a668 100644
--- a/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<stype,
 	       stype&&, const typename stype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::set<int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<int>> astype;
+
+static_assert( std::is_nothrow_move_constructible<astype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::set<int, not_noexcept_less> estype;
 
+static_assert( !std::is_nothrow_move_constructible<estype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<estype, estype&&,
 	       const typename estype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/span/101411.cc b/libstdc++-v3/testsuite/23_containers/span/101411.cc
new file mode 100644
index 00000000000..deae73689da
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/span/101411.cc
@@ -0,0 +1,15 @@
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { xfail c++2a } }
+#include <span>
+
+// PR libstdc++/101411
+
+void f(std::span<const int> s)
+{
+  std::as_writable_bytes(s); // { dg-error "unsatisfied constraints" }
+}
+
+void f1(std::span<const int, 1> s)
+{
+  std::as_writable_bytes(s); // { dg-error "unsatisfied constraints" }
+}
diff --git a/libstdc++-v3/testsuite/23_containers/span/trivially_copyable.cc b/libstdc++-v3/testsuite/23_containers/span/trivially_copyable.cc
new file mode 100644
index 00000000000..e3748293555
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/span/trivially_copyable.cc
@@ -0,0 +1,13 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf
+
+#include <span>
+
+static_assert( std::is_trivially_copyable_v<std::span<int>> );
+static_assert( std::is_trivially_copyable_v<std::span<int, 42>> );
+
+struct NonTrivial { NonTrivial(); NonTrivial(const NonTrivial&); };
+static_assert( std::is_trivially_copyable_v<std::span<NonTrivial>> );
+static_assert( std::is_trivially_copyable_v<std::span<NonTrivial, 99>> );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc
new file mode 100644
index 00000000000..3da42453152
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-options "-O0" }
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+#include <ext/aligned_buffer.h>
+
+using T = int;
+
+using __gnu_test::default_init_allocator;
+
+void test01()
+{
+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;
+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type;
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+void test02()
+{
+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;
+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type();
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/cons/default.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/default.cc
new file mode 100644
index 00000000000..7a785e980b1
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/default.cc
@@ -0,0 +1,51 @@
+// { dg-do compile { target c++11 } }
+#include <unordered_map>
+
+static_assert( std::is_default_constructible<std::unordered_map<int, int>>{}, "" );
+
+template<typename T>
+  struct NoDefaultConsAlloc
+  {
+    using value_type = T;
+
+    NoDefaultConsAlloc(int) noexcept { }
+
+    template<typename U>
+      NoDefaultConsAlloc(const NoDefaultConsAlloc<U>&) { }
+
+    T *allocate(std::size_t n)
+    { return std::allocator<T>().allocate(n); }
+
+    void deallocate(T *p, std::size_t n)
+    { std::allocator<T>().deallocate(p, n); }
+
+    bool operator==(const NoDefaultConsAlloc&) const { return true; }
+    bool operator!=(const NoDefaultConsAlloc&) const { return false; }
+  };
+
+using Map = std::unordered_map<int, int, std::hash<int>, std::equal_to<int>,
+			       NoDefaultConsAlloc<std::pair<const int, int>>>;
+static_assert( ! std::is_default_constructible<Map>{}, "PR libstdc++/100863" );
+
+struct Hash : std::hash<int> { Hash(int) { } };
+using Map2 = std::unordered_map<int, int, Hash>;
+static_assert( ! std::is_default_constructible<Map2>{}, "PR libstdc++/100863" );
+
+struct Equal : std::equal_to<int> { Equal(int) { } };
+using Map3 = std::unordered_map<int, int, std::hash<int>, Equal>;
+static_assert( ! std::is_default_constructible<Map3>{}, "PR libstdc++/100863" );
+
+// PR libstdc++/101583
+// verify non-default ctors can still be used
+using Map4 = std::unordered_map<int, int, Hash, Equal,
+			        NoDefaultConsAlloc<std::pair<const int, int>>>;
+Hash h(1);
+Equal eq(1);
+Map4::allocator_type a(1);
+Map4 m{1, h, eq, a};
+Map4 m2{m.begin(), m.end(), m.size(), h, eq, a};
+Map4 m3{{{1,1}, {2,2}, {3,3}}, 3, h, eq, a};
+Map4 m4{m};
+Map4 m5{m, a};
+Map4 m6{std::move(m)};
+Map4 m7{std::move(m6), a};
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..f859ec939d0
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_map>
+
+using type1 = std::unordered_map<int, int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_map<int, int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_map<int, int, std::hash<int>,
+				  not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_map<int, int, std::hash<int>, std::equal_to<int>,
+			not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..b6b5b473553
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+
+using type1 = std::unordered_map<int, int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_map<int, int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_map<int, int, std::hash<int>,
+				  not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc
new file mode 100644
index 00000000000..0a5ef1113d9
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc
@@ -0,0 +1,81 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <utility>
+#include <unordered_map>
+#include <vector>
+
+#include <testsuite_hooks.h>
+#include <testsuite_counter_type.h>
+#include <testsuite_allocator.h>
+
+void test01()
+{
+  using namespace std;
+  using __gnu_test::counter_type;
+
+  std::vector<pair<int, counter_type>> insts { { 0, 0 }, { 1, 1 }, { 2, 2 } };
+  typedef unordered_map<int, counter_type> Map;
+  Map m;
+
+  counter_type::reset();
+
+  m.insert(make_move_iterator(insts.begin()), make_move_iterator(insts.end()));
+
+  VERIFY( m.size() == 3 );
+  VERIFY( counter_type::default_count == 0 );
+  VERIFY( counter_type::copy_count == 0 );
+  VERIFY( counter_type::move_count == 3 );
+}
+
+void test02()
+{
+  using namespace std;
+  using __gnu_test::counter_type;
+  using __gnu_test::propagating_allocator;
+
+  typedef propagating_allocator<pair<const int, counter_type>, false> Alloc;
+  typedef unordered_map<int, counter_type,
+			hash<int>, equal_to<int>,
+			Alloc> Map;
+
+  Alloc a1(1);
+  Map m1(3, a1);
+  m1 = { { 0, 0 }, { 1, 1 }, { 2, 2 } };
+  Alloc a2(2);
+  Map m2(3, a2);
+  m2 = { { 3, 0 }, { 4, 1 }, { 5, 2 } };
+
+  counter_type::reset();
+
+  m2 = move(m1);
+
+  VERIFY( m1.empty() );
+  VERIFY( m2.size() == 3 );
+  VERIFY( counter_type::default_count == 0 );
+  VERIFY( counter_type::copy_count == 0 );
+  VERIFY( counter_type::move_count == 3 );
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..98e2b017ca9
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_map>
+
+using type1 = std::unordered_multimap<int, int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multimap<int, int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multimap<int, int, std::hash<int>,
+				       not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>,
+				       not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..e51ad5065a8
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+
+using type1 = std::unordered_multimap<int, int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multimap<int, int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multimap<int, int, std::hash<int>,
+				       not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..8511cb95421
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+using type1 = std::unordered_multiset<int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multiset<int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multiset<int, std::hash<int>,
+				      not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_multiset<int, std::hash<int>, std::equal_to<int>,
+				      not_noexcept_dflt_cons_alloc<int>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..1ccb8b0cf41
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_set>
+
+using type1 = std::unordered_multiset<int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multiset<int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multiset<int, std::hash<int>,
+				      not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc
new file mode 100644
index 00000000000..1f2f3516859
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-options "-O0" }
+
+#include <unordered_set>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+#include <ext/aligned_buffer.h>
+
+using T = int;
+
+using __gnu_test::default_init_allocator;
+
+void test01()
+{
+  typedef default_init_allocator<T> alloc_type;
+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type;
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+void test02()
+{
+  typedef default_init_allocator<T> alloc_type;
+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type();
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc
new file mode 100644
index 00000000000..b209f7627f5
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc
@@ -0,0 +1,47 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+#include <testsuite_allocator.h>
+
+template<typename Alloc, typename T = typename Alloc::value_type>
+  using Set = std::unordered_set<T, std::hash<T>, std::equal_to<T>, Alloc>;
+
+// PR libstdc++/99985 - invalid constexpr function in C++11 mode
+
+void
+test01()
+{
+  using A = std::allocator<int>;
+  A a;
+  Set<A> s;
+  static_assert( noexcept( Set<A>(std::move(s)) ), "non-throwing" );
+  static_assert( noexcept( Set<A>(std::move(s), a) ), "non-throwing" );
+}
+
+void
+test02()
+{
+  using A = __gnu_test::uneq_allocator<long>;
+  A a;
+  Set<A> s;
+  static_assert( noexcept( Set<A>(std::move(s)) ), "non-throwing" );
+  static_assert( ! noexcept( Set<A>(std::move(s), a) ), "throwing" );
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/default.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/default.cc
new file mode 100644
index 00000000000..fb87c96ce9d
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/default.cc
@@ -0,0 +1,50 @@
+// { dg-do compile { target c++11 } }
+#include <unordered_set>
+
+static_assert( std::is_default_constructible<std::unordered_set<int>>{}, "" );
+
+template<typename T>
+  struct NoDefaultConsAlloc
+  {
+    using value_type = T;
+
+    NoDefaultConsAlloc(int) noexcept { }
+
+    template<typename U>
+      NoDefaultConsAlloc(const NoDefaultConsAlloc<U>&) { }
+
+    T *allocate(std::size_t n)
+    { return std::allocator<T>().allocate(n); }
+
+    void deallocate(T *p, std::size_t n)
+    { std::allocator<T>().deallocate(p, n); }
+
+    bool operator==(const NoDefaultConsAlloc&) const { return true; }
+    bool operator!=(const NoDefaultConsAlloc&) const { return false; }
+  };
+
+using Set = std::unordered_set<int, std::hash<int>, std::equal_to<int>,
+			       NoDefaultConsAlloc<int>>;
+static_assert( ! std::is_default_constructible<Set>{}, "PR libstdc++/100863" );
+
+struct Hash : std::hash<int> { Hash(int) { } };
+using Set2 = std::unordered_set<int, Hash>;
+static_assert( ! std::is_default_constructible<Set2>{}, "PR libstdc++/100863" );
+
+struct Equal : std::equal_to<int> { Equal(int) { } };
+using Set3 = std::unordered_set<int, std::hash<int>, Equal>;
+static_assert( ! std::is_default_constructible<Set3>{}, "PR libstdc++/100863" );
+
+// PR libstdc++/101583
+// verify non-default ctors can still be used
+using Set4 = std::unordered_set<int, Hash, Equal, NoDefaultConsAlloc<int>>;
+Hash h(1);
+Equal eq(1);
+Set4::allocator_type a(1);
+Set4 s{1, h, eq, a};
+Set4 s2{s.begin(), s.end(), s.size(), h, eq, a};
+Set4 s3{{1, 2, 3}, 3, h, eq, a};
+Set4 s4{s};
+Set4 s5{s, a};
+Set4 s6{std::move(s)};
+Set4 s7{std::move(s6), a};
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..44db4aec6cf
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+using type1 = std::unordered_set<int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_set<int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_set<int, std::hash<int>,
+				  not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_set<int, std::hash<int>, std::equal_to<int>,
+				 not_noexcept_dflt_cons_alloc<int>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..65df57613ae
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_set>
+
+using type1 = std::unordered_set<int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_set<int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_set<int, std::hash<int>,
+				  not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc b/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc
index b503b0cdc1e..3c9c3927153 100644
--- a/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc
+++ b/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc
@@ -141,3 +141,29 @@ struct J
 // iterator_traits<J> matches constrained specialization in the library,
 // so use its value_type.
 static_assert( check_alias<J, int> );
+
+struct I2
+{
+  using element_type = int;
+};
+// iterator_traits<I2> is not specialized, and no standard specialization
+// matches, so use indirectly_readable_traits.
+static_assert( check_alias<I2, std::indirectly_readable_traits<I2>::value_type> );
+
+// LWG 3446
+struct I3
+{
+  using value_type = long;
+  using element_type = const long;
+};
+// iterator_traits<I3> is not specialized, and no standard specialization
+// matches, so use indirectly_readable_traits.
+static_assert( check_alias<I3, std::indirectly_readable_traits<I3>::value_type> );
+
+// Correction to LWG 3446
+struct I4
+{
+  using value_type = int;
+  using element_type = long;
+};
+static_assert( ! has_alias<I4> );
diff --git a/libstdc++-v3/testsuite/24_iterators/headers/iterator/synopsis_c++20.cc b/libstdc++-v3/testsuite/24_iterators/headers/iterator/synopsis_c++20.cc
index fbe116be2fd..8962e869123 100644
--- a/libstdc++-v3/testsuite/24_iterators/headers/iterator/synopsis_c++20.cc
+++ b/libstdc++-v3/testsuite/24_iterators/headers/iterator/synopsis_c++20.cc
@@ -31,26 +31,11 @@ namespace std
 
   namespace ranges
   {
-    template<input_or_output_iterator I, sentinel_for<I> S>
-      constexpr iter_difference_t<I> distance(I first, S last);
-    template<range R>
-      constexpr range_difference_t<R> distance(R&& r);
-
-    template<input_or_output_iterator I>
-      constexpr I next(I x);
-    template<input_or_output_iterator I>
-      constexpr I next(I x, iter_difference_t<I> n);
-    template<input_or_output_iterator I, sentinel_for<I> S>
-      constexpr I next(I x, S bound);
-    template<input_or_output_iterator I, sentinel_for<I> S>
-      constexpr I next(I x, iter_difference_t<I> n, S bound);
-
-    template<bidirectional_iterator I>
-      constexpr I prev(I x);
-    template<bidirectional_iterator I>
-      constexpr I prev(I x, iter_difference_t<I> n);
-    template<bidirectional_iterator I>
-      constexpr I prev(I x, iter_difference_t<I> n, I bound);
+    // These are function objects of unspecified type.
+    auto& _distance = distance;
+    auto& _advance = advance;
+    auto& _next = next;
+    auto& _prev = prev;
   }
 
   template<semiregular S> class move_sentinel;
@@ -73,6 +58,7 @@ namespace std
     struct incrementable_traits<counted_iterator<I>>;
 
   template<input_iterator I>
+    requires same_as<__detail::__iter_traits<I>, iterator_traits<I>>
     struct iterator_traits<counted_iterator<I>>;
 
   struct unreachable_sentinel_t;
diff --git a/libstdc++-v3/testsuite/24_iterators/move_iterator/lwg3391.cc b/libstdc++-v3/testsuite/24_iterators/move_iterator/lwg3391.cc
new file mode 100644
index 00000000000..18e015777cd
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/move_iterator/lwg3391.cc
@@ -0,0 +1,37 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+// Verify LWG 3391 changes.
+
+#include <iterator>
+#include <ranges>
+
+#include <testsuite_iterators.h>
+
+using __gnu_test::test_range;
+using __gnu_test::input_iterator_wrapper_nocopy;
+
+void
+test01()
+{
+  extern test_range<int, input_iterator_wrapper_nocopy> rx;
+  auto v = rx | std::views::take(5);
+  std::ranges::begin(v) != std::ranges::end(v);
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/move_iterator/move_only.cc b/libstdc++-v3/testsuite/24_iterators/move_iterator/move_only.cc
index eaf307ddf60..7f4dda11e11 100644
--- a/libstdc++-v3/testsuite/24_iterators/move_iterator/move_only.cc
+++ b/libstdc++-v3/testsuite/24_iterators/move_iterator/move_only.cc
@@ -43,7 +43,13 @@ template<> struct std::iterator_traits<move_only_iterator>
 static_assert(std::input_iterator<move_only_iterator>);
 
 template<typename T>
-  concept has_member_base = requires (T t) { std::forward<T>(t).base(); };
+  concept has_member_base = requires (T t) {
+    // LWG 3391 made the const& overload of move_iterator::base()
+    // unconstrained and return a const reference.  So rather than checking
+    // whether base() is valid (which is now trivially true in an unevaluated
+    // context), the below now checks whether decay-copying base() is valid.
+    [](auto){}(std::forward<T>(t).base());
+  };
 
 using move_only_move_iterator = std::move_iterator<move_only_iterator>;
 
diff --git a/libstdc++-v3/testsuite/24_iterators/range_operations/100768.cc b/libstdc++-v3/testsuite/24_iterators/range_operations/100768.cc
new file mode 100644
index 00000000000..bbcfcece5ff
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/range_operations/100768.cc
@@ -0,0 +1,128 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// PR libstdc++/100768 - Range iterator operations should be function objects
+
+#include <iterator>
+#include <ranges>
+
+namespace ns1
+{
+  struct R { };
+  void check_adl(R) { }
+}
+
+namespace ns2
+{
+  using ns1::R;
+
+  struct A { };
+
+  template<typename I>
+    R advance(I, ...) { return R{}; }
+
+  template<typename I>
+    R distance(I, ...) { return R{}; }
+
+  template<typename I>
+    R next(I, ...) { return R{}; }
+
+  template<typename I>
+    R prev(I, ...) { return R{}; }
+}
+
+template<typename T, typename U> struct associated { };
+
+void
+test02()
+{
+  // This type has both ns2 and std::ranges as associated namespaces.
+  using X = associated<ns2::A, std::ranges::dangling>;
+
+  X range[1];
+  X* iter = range;
+  X* const sentinel = iter + 1;
+
+  // [range.iter.op.general] p2 says: "The function templates defined in
+  // [range.iter.ops] are not found by argument-dependent name lookup."
+  //
+  // If we do not meet that requirement then the following will find those
+  // function templates (because std::ranges is an associated namespace),
+  // and the calls to check_adl will be ill-formed.
+  check_adl( advance(iter, 1) );
+  check_adl( advance(iter, 1, sentinel) );
+  check_adl( distance(iter, sentinel) );
+  check_adl( distance(range) );
+  check_adl( next(iter) );
+  check_adl( next(iter, 1) );
+  check_adl( next(iter, sentinel) );
+  check_adl( next(iter, 1, sentinel) );
+  check_adl( prev(iter) );
+  check_adl( prev(iter, 1) );
+  check_adl( prev(iter, 1, sentinel) );
+}
+
+namespace ns3
+{
+  struct A { };
+
+  void advance(A*, int) = delete;
+  void advance(A*, int, A*) = delete;
+
+  void distance(A*, A*) = delete;
+  void distance(A(&)[1]) = delete;
+
+  void next(A*) = delete;
+  void next(A*, int) = delete;
+  void next(A*, A*) = delete;
+  void next(A*, int, A*) = delete;
+
+  void prev(A*) = delete;
+  void prev(A*, int) = delete;
+  void prev(A*, int, A*) = delete;
+}
+
+void
+test01()
+{
+  ns3::A range[1];
+  ns3::A* iter = range;
+  ns3::A* const sentinel = iter + 1;
+
+  // [range.iter.op.general] p2 also says: "When found by unqualified name
+  // lookup for the postfix-expression in a function call, they inhibit
+  // argument-dependent name lookup."
+  //
+  // If we do not meet that requirement then the following will find the
+  // deleted overloads in namespace ns3 (because it is an associated namespace
+  // and those functions are exact matches for the arguments).
+  using namespace std::ranges;
+  advance(iter, 1);
+  advance(iter, 3, sentinel);
+  distance(iter, sentinel);
+  distance(range);
+  next(iter);
+  next(iter, -1);
+  next(iter, sentinel);
+  next(iter, 5, sentinel);
+  prev(iter);
+  prev(iter, 0);
+  prev(iter, 0, sentinel);
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/range_operations/advance.cc b/libstdc++-v3/testsuite/24_iterators/range_operations/advance.cc
index 429d48f41de..a6121af8e97 100644
--- a/libstdc++-v3/testsuite/24_iterators/range_operations/advance.cc
+++ b/libstdc++-v3/testsuite/24_iterators/range_operations/advance.cc
@@ -49,10 +49,12 @@ test01()
   std::ranges::advance(iter, r.begin());
   VERIFY( iter == r.begin() );
 
-  std::ranges::advance(iter, 99, r.end());
+  auto diff = std::ranges::advance(iter, 99, r.end());
   VERIFY( iter == r.end() );
-  std::ranges::advance(iter, -222, r.begin());
+  VERIFY( diff == 97 );
+  diff = std::ranges::advance(iter, -222, r.begin());
   VERIFY( iter == r.begin() );
+  VERIFY( diff == -220 );
 }
 
 void
@@ -77,10 +79,12 @@ test02()
   std::ranges::advance(iter, r.begin());
   VERIFY( iter == r.begin() );
 
-  std::ranges::advance(iter, 99, r.end());
+  auto diff = std::ranges::advance(iter, 99, r.end());
   VERIFY( iter == r.end() );
-  std::ranges::advance(iter, -222, r.begin());
+  VERIFY( diff == 97 );
+  diff = std::ranges::advance(iter, -222, r.begin());
   VERIFY( iter == r.begin() );
+  VERIFY( diff == -220 );
 }
 
 void
@@ -108,15 +112,19 @@ test03()
   std::ranges::advance(iter, r.end());
   VERIFY( iter == r.end() );
 
-  std::ranges::advance(iter, 99, r.end());
+  auto diff = std::ranges::advance(iter, 99, r.end());
   VERIFY( iter == r.end() );
-  std::ranges::advance(iter, 99, r.end());
+  VERIFY( diff == 99 ); // PR libstdc++/100833
+  diff = std::ranges::advance(iter, 99, r.end());
   VERIFY( iter == r.end() );
+  VERIFY( diff == 99 );
   iter = r.begin();
-  std::ranges::advance(iter, 99, r.end());
+  diff = std::ranges::advance(iter, 99, r.end());
   VERIFY( iter == r.end() );
-  std::ranges::advance(iter, 99, r.end());
+  VERIFY( diff == 97 );
+  diff = std::ranges::advance(iter, 99, r.end());
   VERIFY( iter == r.end() );
+  VERIFY( diff == 99 );
 }
 
 void
@@ -145,17 +153,21 @@ test04()
   std::ranges::advance(iter, r2.end());
   VERIFY( iter == r2.end() );
 
-  std::ranges::advance(iter, 99, r2.end());
+  auto diff = std::ranges::advance(iter, 99, r2.end());
   VERIFY( iter == r2.end() );
-  std::ranges::advance(iter, 99, r2.end());
+  VERIFY( diff == 99 );
+  diff = std::ranges::advance(iter, 99, r2.end());
   VERIFY( iter == r2.end() );
+  VERIFY( diff == 99 );
 
   test_range<int, input_iterator_wrapper> r3(a);
   iter = r3.begin();
-  std::ranges::advance(iter, 99, r3.end());
+  diff = std::ranges::advance(iter, 99, r3.end());
   VERIFY( iter == r3.end() );
-  std::ranges::advance(iter, 99, r3.end());
+  VERIFY( diff == 97 );
+  diff = std::ranges::advance(iter, 99, r3.end());
   VERIFY( iter == r3.end() );
+  VERIFY( diff == 99 );
 }
 
 void
@@ -180,17 +192,21 @@ test05()
   std::ranges::advance(iter, r2.end());
   VERIFY( iter == r2.end() );
 
-  std::ranges::advance(iter, 99, r2.end());
+  auto diff = std::ranges::advance(iter, 99, r2.end());
   VERIFY( iter == r2.end() );
-  std::ranges::advance(iter, 99, r2.end());
+  VERIFY( diff == 99 );
+  diff = std::ranges::advance(iter, 99, r2.end());
   VERIFY( iter == r2.end() );
+  VERIFY( diff == 99 );
 
   test_range<int, output_iterator_wrapper> r3(a);
   iter = r3.begin();
-  std::ranges::advance(iter, 99, r3.end());
+  diff = std::ranges::advance(iter, 99, r3.end());
   VERIFY( iter == r3.end() );
-  std::ranges::advance(iter, 99, r3.end());
+  VERIFY( diff == 97 );
+  diff = std::ranges::advance(iter, 99, r3.end());
   VERIFY( iter == r3.end() );
+  VERIFY( diff == 99 );
 }
 
 int
diff --git a/libstdc++-v3/testsuite/24_iterators/reverse_iterator/100639.cc b/libstdc++-v3/testsuite/24_iterators/reverse_iterator/100639.cc
new file mode 100644
index 00000000000..358d91dfef1
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/reverse_iterator/100639.cc
@@ -0,0 +1,37 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=c++2a" }
+// { dg-do compile { target c++2a } }
+
+// PR libstdc++/100639
+
+#include <iterator>
+#include <ranges>
+
+void
+test01()
+{
+  using iter = std::ranges::iterator_t<std::ranges::iota_view<long long>>;
+  using riter = std::reverse_iterator<iter>;
+  static_assert(std::same_as<std::iter_reference_t<iter>,
+			     std::iter_reference_t<riter>>);
+  static_assert(std::same_as<std::iter_value_t<iter>,
+			     std::iter_value_t<riter>>);
+  static_assert(std::same_as<std::iter_difference_t<iter>,
+			     std::iter_difference_t<riter>>);
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/reverse_iterator/2.cc b/libstdc++-v3/testsuite/24_iterators/reverse_iterator/2.cc
index 29c4a5aae25..54e9f79bdd2 100644
--- a/libstdc++-v3/testsuite/24_iterators/reverse_iterator/2.cc
+++ b/libstdc++-v3/testsuite/24_iterators/reverse_iterator/2.cc
@@ -27,7 +27,7 @@ void test02()
   iterator_type it01;
   iterator_type it02;
 
-  // Sanity check non-member operators and functions can be instantiated. 
+  // Sanity check non-member operators and functions can be instantiated.
   it01 == it02;
   it01 != it02;
   it01 < it02;
@@ -35,11 +35,11 @@ void test02()
   it01 > it02;
   it01 >= it02;
   it01 - it02;
-  5 + it02;
+  0 + it02;
 }
 
-int main() 
-{ 
+int main()
+{
   test02();
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc b/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc
index aafe845db3a..b7b3569ff83 100644
--- a/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc
@@ -26,6 +26,7 @@
 using __gnu_test::test_container;
 using __gnu_test::test_range;
 using __gnu_test::input_iterator_wrapper;
+using __gnu_test::input_iterator_wrapper_nocopy;
 using __gnu_test::output_iterator_wrapper;
 using __gnu_test::forward_iterator_wrapper;
 
@@ -214,6 +215,17 @@ test05()
   return ok;
 }
 
+void
+test06()
+{
+  // PR libstdc++/101599
+  int x[] = {1,2,3};
+  test_range<int, input_iterator_wrapper_nocopy> rx(x);
+  std::vector<int> v(4, 0);
+  ranges::copy(rx, v.begin());
+  VERIFY( ranges::equal(v, (int[]){1,2,3,0}) );
+}
+
 int
 main()
 {
@@ -222,4 +234,5 @@ main()
   static_assert(test03());
   test04();
   static_assert(test05());
+  test06();
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/copy/debug/99402.cc b/libstdc++-v3/testsuite/25_algorithms/copy/debug/99402.cc
new file mode 100644
index 00000000000..9a9c97af605
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/copy/debug/99402.cc
@@ -0,0 +1,36 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-D_GLIBCXX_DEBUG" }
+// { dg-do run }
+
+#include <algorithm>
+#include <set>
+#include <vector>
+
+// PR libstdc++/99402
+
+using namespace std;
+
+int main()
+{
+    int two[] = { 0, 1 };
+    // any container with non-random access iterators:
+    const set<int> source(two, two + 2);
+    vector<int> dest(1);
+    copy(source.begin(), ++source.begin(), dest.begin());
+}
diff --git a/libstdc++-v3/testsuite/25_algorithms/copy_backward/move_iterators/69478.cc b/libstdc++-v3/testsuite/25_algorithms/copy_backward/move_iterators/69478.cc
index 1d779df10d6..2ed14fe110a 100644
--- a/libstdc++-v3/testsuite/25_algorithms/copy_backward/move_iterators/69478.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/copy_backward/move_iterators/69478.cc
@@ -35,6 +35,6 @@ test01()
   static_assert(std::is_trivial<trivial_rvalstruct>::value, "");
 
   trivial_rvalstruct a[1], b[1];
-  copy_backward(std::make_move_iterator(a), std::make_move_iterator(a+1), b);
+  copy_backward(std::make_move_iterator(a), std::make_move_iterator(a+1), b+1);
 }
 // { dg-prune-output "use of deleted" }
diff --git a/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc b/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc
index e9ce8e8fb0a..09d3bd37630 100644
--- a/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc
@@ -73,11 +73,12 @@ test01()
     }
 }
 
+template<typename T>
 constexpr bool
 test02()
 {
   bool ok = true;
-  int x[6] = { 1, 2, 3, 4, 5, 6 };
+  T x[6] = { 1, 2, 3, 4, 5, 6 };
   const int y[6] = { 1, 2, 3, 4, 5, 6 };
   const int z[6] = { 17, 17, 17, 4, 5, 6 };
 
@@ -94,5 +95,6 @@ int
 main()
 {
   test01();
-  static_assert(test02());
+  static_assert(test02<int>());
+  static_assert(test02<unsigned char>()); // PR libstdc++/101608
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc b/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc
index f2c28412515..e7ce1f3e184 100644
--- a/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc
@@ -20,6 +20,7 @@
 // 25.2.12 [alg.is_permutation] Is permutation
 
 #include <algorithm>
+#include <iterator>
 #include <functional>
 #include <testsuite_hooks.h>
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc b/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc
index aa9364ab04c..af14152d345 100644
--- a/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc
@@ -19,6 +19,8 @@
 // { dg-do run { target c++2a } }
 
 #include <algorithm>
+#include <string>
+#include <vector>
 #include <testsuite_hooks.h>
 #include <testsuite_iterators.h>
 
@@ -89,10 +91,50 @@ test03()
 	  == res_t(1,4) );
 }
 
+void
+test04()
+{
+  // Verify we perform at most 3*N/2 applications of the comparison predicate.
+  static int counter;
+  struct counted_less
+  { bool operator()(int a, int b) { ++counter; return a < b; } };
+
+  ranges::minmax({1,2}, counted_less{});
+  VERIFY( counter == 1 );
+
+  counter = 0;
+  ranges::minmax({1,2,3}, counted_less{});
+  VERIFY( counter == 3 );
+
+  counter = 0;
+  ranges::minmax({1,2,3,4,5,6,7,8,9,10}, counted_less{});
+  VERIFY( counter <= 15 );
+
+  counter = 0;
+  ranges::minmax({10,9,8,7,6,5,4,3,2,1}, counted_less{});
+  VERIFY( counter <= 15 );
+}
+
+void
+test05()
+{
+  // PR libstdc++/100387
+  using namespace std::literals::string_literals;
+  auto comp = [](const auto& a, const auto& b) {
+    return a.size() == b.size() ? a.front() < b.front() : a.size() > b.size();
+  };
+  auto result = ranges::minmax({"b"s, "a"s}, comp);
+  VERIFY( result.min == "a"s && result.max == "b"s );
+  result = ranges::minmax({"c"s, "b"s, "a"s}, comp);
+  VERIFY( result.min == "a"s && result.max == "c"s );
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc b/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc
index 40019c43326..ece1f93d04e 100644
--- a/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc
@@ -61,8 +61,35 @@ test01()
   static_assert(ranges::minmax_element(y, y+3, {}, &X::i).max->j == 3);
 }
 
+void
+test02()
+{
+  // Verify we perform at most 3*N/2 applications of the comparison predicate.
+  static int counter;
+  struct counted_less
+  { bool operator()(int a, int b) { ++counter; return a < b; } };
+
+  int x[] = {1,2,3,4,5,6,7,8,9,10};
+  ranges::minmax_element(x, x+2, counted_less{});
+  VERIFY( counter == 1 );
+
+  counter = 0;
+  ranges::minmax_element(x, x+3, counted_less{});
+  VERIFY( counter == 3 );
+
+  counter = 0;
+  ranges::minmax_element(x, counted_less{});
+  VERIFY( counter <= 15 );
+
+  ranges::reverse(x);
+  counter = 0;
+  ranges::minmax_element(x, counted_less{});
+  VERIFY( counter <= 15 );
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc b/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc
index f15de548709..14eeb1483ac 100644
--- a/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc
@@ -26,6 +26,7 @@
 using __gnu_test::test_container;
 using __gnu_test::test_range;
 using __gnu_test::input_iterator_wrapper;
+using __gnu_test::input_iterator_wrapper_nocopy;
 using __gnu_test::output_iterator_wrapper;
 using __gnu_test::forward_iterator_wrapper;
 
@@ -193,6 +194,17 @@ test04()
   VERIFY( ranges::count(y, 0, &X::moved) == 6 );
 }
 
+void
+test05()
+{
+  // PR libstdc++/101599
+  int x[] = {1,2,3};
+  test_range<int, input_iterator_wrapper_nocopy> rx(x);
+  std::vector<int> v(4, 0);
+  ranges::move(rx, v.begin());
+  VERIFY( ranges::equal(v, (int[]){1,2,3,0}) );
+}
+
 int
 main()
 {
@@ -200,4 +212,5 @@ main()
   test02();
   static_assert(test03());
   test04();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/move_backward/69478.cc b/libstdc++-v3/testsuite/25_algorithms/move_backward/69478.cc
index c9690288fee..ef28722a3ce 100644
--- a/libstdc++-v3/testsuite/25_algorithms/move_backward/69478.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/move_backward/69478.cc
@@ -35,6 +35,6 @@ test01()
   static_assert(std::is_trivial<trivial_rvalstruct>::value, "");
 
   trivial_rvalstruct a[1], b[1];
-  std::move_backward(a, a + 1, b);
+  std::move_backward(a, a + 1, b + 1);
 }
 // { dg-prune-output "use of deleted" }
diff --git a/libstdc++-v3/testsuite/25_algorithms/move_backward/93872.cc b/libstdc++-v3/testsuite/25_algorithms/move_backward/93872.cc
index 69774fa86c6..e16de82ce31 100644
--- a/libstdc++-v3/testsuite/25_algorithms/move_backward/93872.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/move_backward/93872.cc
@@ -35,5 +35,5 @@ void
 test01()
 {
   X a[2], b[2];
-  std::move_backward(std::begin(a), std::end(a), std::begin(b));
+  std::move_backward(std::begin(a), std::end(a), std::end(b));
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc b/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc
index 08daa104173..30098d129fa 100644
--- a/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc
@@ -1,7 +1,7 @@
 // -*- C++ -*-
 // { dg-options "-std=gnu++17 -ltbb" }
 // { dg-do run { target c++17 } }
-// { dg-timeout-factor 3 }
+// { dg-timeout-factor 4 }
 // { dg-require-effective-target tbb-backend }
 
 //===-- find_end.pass.cpp -------------------------------------------------===//
@@ -78,8 +78,8 @@ test(const std::size_t bits)
 
     const std::size_t max_n1 = 1000;
     const std::size_t max_n2 = (max_n1 * 10) / 8;
-    Sequence<T> in(max_n1, [max_n1, bits](std::size_t k) { return T(2 * HashBits(max_n1, bits - 1) ^ 1); });
-    Sequence<T> sub(max_n2, [max_n1, bits](std::size_t k) { return T(2 * HashBits(max_n1, bits - 1)); });
+    Sequence<T> in(max_n1, [max_n1, bits](std::size_t) { return T(2 * HashBits(max_n1, bits - 1) ^ 1); });
+    Sequence<T> sub(max_n2, [max_n1, bits](std::size_t) { return T(2 * HashBits(max_n1, bits - 1)); });
     for (std::size_t n1 = 0; n1 <= max_n1; n1 = n1 <= 16 ? n1 + 1 : size_t(3.1415 * n1))
     {
         std::size_t sub_n[] = {0, 1, 3, n1, (n1 * 10) / 8};
@@ -89,7 +89,7 @@ test(const std::size_t bits)
             for (auto r : res)
             {
                 std::size_t i = r, isub = 0;
-                for (; i < n1 & isub < n2; ++i, ++isub)
+                for (; i < n1 && isub < n2; ++i, ++isub)
                     in[i] = sub[isub];
                 invoke_on_all_policies(test_one_policy(), in.begin(), in.begin() + n1, sub.begin(), sub.begin() + n2,
                                        std::equal_to<T>());
diff --git a/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc b/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc
index 0720c377011..5ecf2ce3616 100644
--- a/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc
@@ -79,7 +79,7 @@ test()
             {
                 Sequence<T> in(n1, [n1](std::size_t k) { return T(0); });
                 std::size_t i = r, isub = 0;
-                for (; i < n1 & isub < n2; ++i, ++isub)
+                for (; i < n1 && isub < n2; ++i, ++isub)
                     in[i] = value;
 
                 invoke_on_all_policies(test_one_policy(), in.begin(), in.begin() + n1, n2, value, std::equal_to<T>());
diff --git a/libstdc++-v3/testsuite/26_numerics/lerp.cc b/libstdc++-v3/testsuite/26_numerics/lerp/1.cc
similarity index 100%
rename from libstdc++-v3/testsuite/26_numerics/lerp.cc
rename to libstdc++-v3/testsuite/26_numerics/lerp/1.cc
diff --git a/libstdc++-v3/testsuite/26_numerics/lerp/constexpr.cc b/libstdc++-v3/testsuite/26_numerics/lerp/constexpr.cc
new file mode 100644
index 00000000000..f1ab42b5a42
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/lerp/constexpr.cc
@@ -0,0 +1,21 @@
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <cmath>
+
+// Fails template argument deduction unless both arguments are the same type.
+template<typename T>
+constexpr bool
+eq(T result, T expected) { return result == expected; }
+
+static_assert( eq( std::lerp(-10.0, 10.0, 0.25), -5.0 ) );
+static_assert( eq( std::lerp(2.0f, 2.0f, 200.0f), 2.0f ) );
+static_assert( eq( std::lerp(2.0L, 4.0L, 200.0L), 402.0L ) );
+// at least one type is long double, so result is long double
+static_assert( eq( std::lerp(2.0L, 4.0f, -20.0), -38.0L ) );
+// at least one type is double, so result is double:
+static_assert( eq( std::lerp(-8.0f, 10.0, 0.5f), 1.0 ) );
+// int promotes to double, so result is double
+static_assert( eq( std::lerp(0, 1, 0), 0.0 ) );
+// int promotes to double, so result is double
+static_assert( eq( std::lerp(2.0f, -10.0f, 1), -10.0 ) );
diff --git a/libstdc++-v3/testsuite/26_numerics/lerp/version.cc b/libstdc++-v3/testsuite/26_numerics/lerp/version.cc
new file mode 100644
index 00000000000..3ccb032bc67
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/lerp/version.cc
@@ -0,0 +1,10 @@
+// { dg-options "-std=gnu++2a" }
+// { dg-do preprocess { target c++2a } }
+
+#include <version>
+
+#ifndef __cpp_lib_interpolate
+# error "Feature-test macro for midpoint and lerp missing in <version>"
+#elif __cpp_lib_interpolate != 201902L
+# error "Feature-test macro for midpoint and lerp has wrong value in <version>"
+#endif
diff --git a/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc b/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
index 9cffc3d06f9..1291967b0d1 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
@@ -12,4 +12,4 @@ auto x = std::generate_canonical<std::size_t,
 
 // { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 167 }
 
-// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 3284 }
+// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 3288 }
diff --git a/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/default.cc b/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/default.cc
index 73a4390da26..3c4e38a7408 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/default.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/default.cc
@@ -25,6 +25,9 @@
 #include <random>
 #include <testsuite_hooks.h>
 
+static_assert( std::is_nothrow_default_constructible<std::seed_seq>::value,
+	       "LWG 3422" );
+
 void
 test01()
 {
@@ -34,7 +37,6 @@ test01()
   seq.generate(foo.begin(), foo.end());
 
   VERIFY( seq.size() == 0 );
-  //VERIFY();
 }
 
 int
diff --git a/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/initlist.cc b/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/initlist.cc
index 1e2a88d32ff..396141e9c4e 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/initlist.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/seed_seq/cons/initlist.cc
@@ -36,6 +36,13 @@ test01()
   VERIFY( seq.size() == 10 );
 }
 
+void
+lwg3422()
+{
+  int i[32] = { };
+  std::seed_seq ss{i, i+32}; // LWG 3422
+}
+
 int main()
 {
   test01();
diff --git a/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
new file mode 100644
index 00000000000..cf4644f53c9
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
@@ -0,0 +1,16 @@
+// { dg-do compile { target c++17 } }
+// PR libstdc++/95833 - Incorrect static_assert in std::reduce overload
+
+#include <numeric>
+
+struct A { };
+struct B { };
+
+struct binop
+{
+  template<typename T, typename U>
+    A operator()(T&&, U&&) const { return A{}; }
+};
+
+B b;
+A a = std::reduce(&b, &b + 1, A{}, binop{});
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc b/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc
new file mode 100644
index 00000000000..d2e346760dd
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc
@@ -0,0 +1,15 @@
+// { dg-options "-D_GLIBCXX_DEBUG" }
+// { dg-do compile { target c++11 } }
+
+#include <valarray>
+
+int main()
+{
+  // PR libstdc++/103022
+  std::valarray<double> va;
+  (void) std::begin(va);
+  (void) std::end(va);
+  const auto& cva = va;
+  (void) std::begin(cva);
+  (void) std::end(cva);
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.C b/libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.cc
similarity index 100%
rename from libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.C
rename to libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.cc
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc b/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
index 709755dc678..2928fee0a21 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
@@ -1,4 +1,4 @@
-// { dg-do compile { target c++11 } }
+// { dg-do run { target c++11 } }
 
 // Copyright (C) 2010-2020 Free Software Foundation, Inc.
 //
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 26.6.10 valarray range access: [valarray.range]
+// C++11 26.6.10 valarray range access: [valarray.range]
 
 #include <valarray>
 
@@ -25,9 +25,46 @@ void
 test01()
 {
   std::valarray<double> va{1.0, 2.0, 3.0};
-  std::begin(va);
-  std::end(va);
+  (void) std::begin(va);
+  (void) std::end(va);
   const auto& cva = va;
-  std::begin(cva);
-  std::end(cva);
+  (void) std::begin(cva);
+  (void) std::end(cva);
+
+  using Iter = decltype(std::begin(va));
+  using IterTraits = std::iterator_traits<Iter>;
+  static_assert( std::is_same<Iter, decltype(std::end(va))>::value, "" );
+  static_assert( std::is_same<IterTraits::iterator_category,
+			      std::random_access_iterator_tag>::value, "" );
+  static_assert( std::is_same<IterTraits::value_type, double>::value, "" );
+  static_assert( std::is_same<IterTraits::reference, double&>::value, "" );
+  using CIter = decltype(std::begin(cva));
+  using CIterTraits = std::iterator_traits<CIter>;
+  static_assert( std::is_same<CIter, decltype(std::end(cva))>::value, "" );
+  static_assert( std::is_same<CIterTraits::iterator_category,
+			      std::random_access_iterator_tag>::value, "" );
+  static_assert( std::is_same<CIterTraits::value_type, double>::value, "" );
+  static_assert( std::is_same<CIterTraits::reference, const double&>::value, "" );
+#if __cplusplus >= 202002L
+  static_assert( std::contiguous_iterator<Iter> );
+  static_assert( std::contiguous_iterator<CIter> );
+#endif
+}
+
+// PR libstdc++/103022
+void
+test02()
+{
+  std::valarray<double> va;
+  (void) std::begin(va);
+  (void) std::end(va);
+  const auto& cva = va;
+  (void) std::begin(cva);
+  (void) std::end(cva);
+}
+
+int main()
+{
+  test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc b/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
index e4395a57e74..48f8019161b 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
@@ -1,4 +1,4 @@
-// { dg-do compile { target c++14 } }
+// { dg-do run { target c++14 } }
 
 // Copyright (C) 2015-2020 Free Software Foundation, Inc.
 //
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 26.6.10 valarray range access: [valarray.range]
+// C++11 26.6.10 valarray range access: [valarray.range]
 
 #include <iterator>
 #include <valarray>
@@ -33,3 +33,21 @@ test01()
   std::cbegin(cva);
   std::cend(cva);
 }
+
+// PR libstdc++/103022
+void
+test02()
+{
+  std::valarray<double> va;
+  (void) std::cbegin(va);
+  (void) std::cend(va);
+  const auto& cva = va;
+  (void) std::cbegin(cva);
+  (void) std::cend(cva);
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/close/81256.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/close/wchar_t/81256.cc
similarity index 100%
rename from libstdc++-v3/testsuite/27_io/basic_filebuf/close/81256.cc
rename to libstdc++-v3/testsuite/27_io/basic_filebuf/close/wchar_t/81256.cc
diff --git a/libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.C b/libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.cc
similarity index 100%
rename from libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.C
rename to libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.cc
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/directory_iterator.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/directory_iterator.cc
index 10d36dfe42b..2f6c3a04acd 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/directory_iterator.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/directory_iterator.cc
@@ -57,24 +57,26 @@ test01()
   ++iter;
   VERIFY( iter == end(iter) );
 
-#if !(defined(__MINGW32__) || defined(__MINGW64__))
-  // Test inaccessible directory.
-  ec = bad_ec;
-  permissions(p, fs::perms::none, ec);
-  VERIFY( !ec );
-  iter = fs::directory_iterator(p, ec);
-  VERIFY( ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible directory, skipping permission denied.
-  const auto opts = fs::directory_options::skip_permission_denied;
-  ec = bad_ec;
-  iter = fs::directory_iterator(p, opts, ec);
-  VERIFY( !ec );
-  VERIFY( iter == end(iter) );
-#endif
+  if (__gnu_test::permissions_are_testable())
+  {
+    // Test inaccessible directory.
+    ec = bad_ec;
+    permissions(p, fs::perms::none, ec);
+    VERIFY( !ec );
+    iter = fs::directory_iterator(p, ec);
+    VERIFY( ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible directory, skipping permission denied.
+    const auto opts = fs::directory_options::skip_permission_denied;
+    ec = bad_ec;
+    iter = fs::directory_iterator(p, opts, ec);
+    VERIFY( !ec );
+    VERIFY( iter == end(iter) );
+
+    permissions(p, fs::perms::owner_all, ec);
+  }
 
-  permissions(p, fs::perms::owner_all, ec);
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc
index 86a03c3c787..283024fe287 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc
@@ -60,54 +60,55 @@ test01()
   ++iter;
   VERIFY( iter == end(iter) );
 
-#if ! (defined (__MINGW32__) || defined(__MINGW64__))
-  // Test inaccessible directory.
-  ec = bad_ec;
-  permissions(p, fs::perms::none, ec);
-  VERIFY( !ec );
-  iter = fs::recursive_directory_iterator(p, ec);
-  VERIFY( ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible directory, skipping permission denied.
-  const auto opts = fs::directory_options::skip_permission_denied;
-  iter = fs::recursive_directory_iterator(p, opts, ec);
-  VERIFY( !ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible sub-directory.
-  ec = bad_ec;
-  permissions(p, fs::perms::owner_all, ec);
-  VERIFY( !ec );
-  ec = bad_ec;
-  permissions(p/"d1/d2", fs::perms::none, ec);
-  VERIFY( !ec );
-  ec = bad_ec;
-  iter = fs::recursive_directory_iterator(p, ec);
-  VERIFY( !ec );
-  VERIFY( iter != end(iter) );
-  VERIFY( iter->path() == p/"d1" );
-  ++iter;              // should recurse into d1
-  VERIFY( iter != end(iter) );
-  VERIFY( iter->path() == p/"d1/d2" );
-  iter.increment(ec);  // should fail to recurse into p/d1/d2
-  VERIFY( ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible sub-directory, skipping permission denied.
-  ec = bad_ec;
-  iter = fs::recursive_directory_iterator(p, opts, ec);
-  VERIFY( !ec );
-  VERIFY( iter != end(iter) );
-  VERIFY( iter->path() == p/"d1" );
-  ++iter;              // should recurse into d1
-  VERIFY( iter != end(iter) );
-  VERIFY( iter->path() == p/"d1/d2" );
-  ec = bad_ec;
-  iter.increment(ec);  // should fail to recurse into p/d1/d2, so skip it
-  VERIFY( !ec );
-  VERIFY( iter == end(iter) );
-#endif
+  if (__gnu_test::permissions_are_testable())
+  {
+    // Test inaccessible directory.
+    ec = bad_ec;
+    permissions(p, fs::perms::none, ec);
+    VERIFY( !ec );
+    iter = fs::recursive_directory_iterator(p, ec);
+    VERIFY( ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible directory, skipping permission denied.
+    const auto opts = fs::directory_options::skip_permission_denied;
+    iter = fs::recursive_directory_iterator(p, opts, ec);
+    VERIFY( !ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible sub-directory.
+    ec = bad_ec;
+    permissions(p, fs::perms::owner_all, ec);
+    VERIFY( !ec );
+    ec = bad_ec;
+    permissions(p/"d1/d2", fs::perms::none, ec);
+    VERIFY( !ec );
+    ec = bad_ec;
+    iter = fs::recursive_directory_iterator(p, ec);
+    VERIFY( !ec );
+    VERIFY( iter != end(iter) );
+    VERIFY( iter->path() == p/"d1" );
+    ++iter;              // should recurse into d1
+    VERIFY( iter != end(iter) );
+    VERIFY( iter->path() == p/"d1/d2" );
+    iter.increment(ec);  // should fail to recurse into p/d1/d2
+    VERIFY( ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible sub-directory, skipping permission denied.
+    ec = bad_ec;
+    iter = fs::recursive_directory_iterator(p, opts, ec);
+    VERIFY( !ec );
+    VERIFY( iter != end(iter) );
+    VERIFY( iter->path() == p/"d1" );
+    ++iter;              // should recurse into d1
+    VERIFY( iter != end(iter) );
+    VERIFY( iter->path() == p/"d1/d2" );
+    ec = bad_ec;
+    iter.increment(ec);  // should fail to recurse into p/d1/d2, so skip it
+    VERIFY( !ec );
+    VERIFY( iter == end(iter) );
+  }
 
   permissions(p/"d1/d2", fs::perms::owner_all, ec);
   remove_all(p, ec);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
index aaa07042a19..ec58cdb0e7f 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
@@ -146,10 +146,33 @@ test03()
   remove_all(p);
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510
+  // create_directories reports an error if the path is a symlink to a dir
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  const auto p = __gnu_test::nonexistent_path() / "";
+  fs::create_directories(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  bool created = fs::create_directories(link, ec);
+  VERIFY( !created );
+  VERIFY( !ec );
+  created = fs::create_directories(link);
+  VERIFY( !created );
+  remove_all(p);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
index 02846040f5b..bf2e6132df1 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
@@ -55,6 +55,37 @@ test01()
   b = create_directory(p);
   VERIFY( !b );
 
+  auto f = p/"file";
+  std::ofstream{f} << "create file";
+  b = create_directory(f, ec);
+  VERIFY( ec == std::errc::file_exists );
+  VERIFY( !b );
+  try
+  {
+    create_directory(f);
+    VERIFY( false );
+  }
+  catch (const fs::filesystem_error& e)
+  {
+    VERIFY( e.code() == std::errc::file_exists );
+    VERIFY( e.path1() == f );
+  }
+
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510 create_directory on an existing symlink to a directory
+  fs::create_directory(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  ec = bad_ec;
+  b = fs::create_directory(link, ec);
+  VERIFY( !b );
+  VERIFY( !ec );
+  b = fs::create_directory(link);
+  VERIFY( !b );
+#endif
+
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc
index 8b8e1fb77ad..71da9675521 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc
@@ -80,10 +80,8 @@ test03()
 void
 test04()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // filesystem permissions not supported
-  return;
-#endif
+  if (!__gnu_test::permissions_are_testable())
+    return;
 
   using std::filesystem::perms;
   using std::filesystem::perm_options;
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc
index ad24fede03a..8615906384c 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc
@@ -28,10 +28,8 @@ namespace fs = std::filesystem;
 void
 test01()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // filesystem permissions not supported
-  return;
-#endif
+  if (!__gnu_test::permissions_are_testable())
+    return;
 
   auto p = __gnu_test::nonexistent_path();
   create_directory(p);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove.cc
index b5315b43f71..1a19ab66c1e 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove.cc
@@ -77,19 +77,18 @@ test01()
   VERIFY( !n );
   VERIFY( exists(dir/"a/b") );
 
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // No permissions support
-#else
-  permissions(dir, fs::perms::none, ec);
-  if (!ec)
+  if (__gnu_test::permissions_are_testable())
   {
-    ec.clear();
-    n = remove(dir/"a/b", ec);
-    VERIFY( ec );
-    VERIFY( !n );
-    permissions(dir, fs::perms::owner_all, ec);
+    permissions(dir, fs::perms::none, ec);
+    if (!ec)
+    {
+      ec.clear();
+      n = remove(dir/"a/b", ec);
+      VERIFY( ec );
+      VERIFY( !n );
+      permissions(dir, fs::perms::owner_all, ec);
+    }
   }
-#endif
 
   ec = bad_ec;
   n = remove(dir/"a/b", ec);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
index 7e018b51af2..24d69b30fdd 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
@@ -143,9 +143,9 @@ test03()
 void
 test04()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // no permissions
-#else
+  if (!__gnu_test::permissions_are_testable())
+    return;
+
   // PR libstdc++/93201
   std::error_code ec;
   std::uintmax_t n;
@@ -171,7 +171,8 @@ test04()
   }
 
   fs::permissions(dir, fs::perms::owner_write, fs::perm_options::add);
-#endif
+  fs::remove_all(dir, ec);
+  f.path.clear();
 }
 
 int
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc
index 2f65d3dca5f..cc15ff47868 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc
@@ -56,10 +56,8 @@ test02()
 void
 test03()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // No permissions support
-  return;
-#endif
+  if (!__gnu_test::permissions_are_testable())
+    return;
 
   fs::path dir = __gnu_test::nonexistent_path();
   fs::create_directory(dir);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc
index 4184dda0272..a297fc05359 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc
@@ -69,6 +69,9 @@ test02()
 void
 test03()
 {
+  if (!__gnu_test::permissions_are_testable())
+    return;
+
   fs::path dir = __gnu_test::nonexistent_path();
   fs::create_directory(dir);
   __gnu_test::scoped_file d(dir, __gnu_test::scoped_file::adopt_file);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
index 72a2db5cf9b..8c51ef836ca 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
@@ -95,10 +95,8 @@ test02()
 void
 test03()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // No permissions support
-  return;
-#endif
+  if (!__gnu_test::permissions_are_testable())
+    return;
 
   clean_env();
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..eb8473e600e
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <filesystem>
+
+void f(bool) { }
+void f(const std::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc
index cf3724025f7..16175c4072a 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc
@@ -18,7 +18,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 8.4.9 path decomposition [path.decompose]
+// C++17 30.10.8.4.9 path decomposition [fs.path.decompose]
 
 #include <filesystem>
 #include <testsuite_hooks.h>
@@ -64,9 +64,32 @@ test02()
   }
 }
 
+void
+test03()
+{
+  const std::string narrow = "there/are/no/wrong/turns/only/unexpected/paths";
+  const path::string_type s(narrow.begin(), narrow.end());
+  const auto s1 = s.substr(0, s.length() - 6);    // remove "/paths"
+  const auto s2 = s1.substr(0, s1.length() - 16); // remove "/only/..."
+
+  // PR libstdc++/99805
+  path p = path::string_type(s);
+  auto pp = p.parent_path();
+  VERIFY( pp.native() == s1 );
+  pp = pp.parent_path().parent_path();
+  VERIFY( pp.native() == s2 );
+
+  path from_lval(s);
+  pp = from_lval.parent_path();
+  VERIFY( pp.native() == s1 );
+  pp = pp.parent_path().parent_path();
+  VERIFY( pp.native() == s2 );
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/27_io/types/1.cc b/libstdc++-v3/testsuite/27_io/types/1.cc
index a565c205b35..b2838e429c9 100644
--- a/libstdc++-v3/testsuite/27_io/types/1.cc
+++ b/libstdc++-v3/testsuite/27_io/types/1.cc
@@ -27,14 +27,14 @@
 // Annex D, deprecated.
 void test01()
 {
-  typedef std::ios_base::streampos streampos_type; // { dg-warning "is deprecated: use 'std::streampos' instead" }
-  typedef std::ios_base::streamoff streamoff_type; // { dg-warning "is deprecated: use 'std::streamoff' instead" }
+  typedef std::ios_base::streampos streampos_type; // { dg-warning "is deprecated: use 'std::streampos' instead" "" { target c++11 } }
+  typedef std::ios_base::streamoff streamoff_type; // { dg-warning "is deprecated: use 'std::streamoff' instead" "" { target c++11 } }
 }
 
 // Annex D, deprecated.
 void test02()
 {
-  typedef std::ios_base::io_state iostate_type; // { dg-warning "is deprecated: use 'std::iostate' instead" }
-  typedef std::ios_base::open_mode openmode_type; // { dg-warning "is deprecated: use 'std::openmode' instead" }
-  typedef std::ios_base::seek_dir seekdir_type; // { dg-warning "is deprecated: use 'std::seekdir' instead" }
+  typedef std::ios_base::io_state iostate_type; // { dg-warning "is deprecated: use 'std::iostate' instead" "" { target c++11 } }
+  typedef std::ios_base::open_mode openmode_type; // { dg-warning "is deprecated: use 'std::openmode' instead" "" { target c++11 } }
+  typedef std::ios_base::seek_dir seekdir_type; // { dg-warning "is deprecated: use 'std::seekdir' instead" "" { target c++11 } }
 }
diff --git a/libstdc++-v3/testsuite/28_regex/match_results/102667.cc b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
new file mode 100644
index 00000000000..9e38c9edaa4
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
@@ -0,0 +1,39 @@
+// { dg-do run { target c++11 } }
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::cmatch sm;
+  VERIFY( sm.empty() );
+  VERIFY( sm.size() == 0 );
+  VERIFY( sm.begin() == sm.end() );  // PR libstdc++/83600
+
+  bool matched = std::regex_match("a", sm, std::regex("b"));
+  VERIFY( ! matched );
+  VERIFY( sm.ready() );
+  VERIFY( sm.empty() );
+  VERIFY( sm.size() == 0 );
+  VERIFY( sm.begin() == sm.end() ); // PR libstdc++/102667
+
+  matched = std::regex_match("a", sm, std::regex("a"));
+  VERIFY( matched );
+  VERIFY( sm.ready() );
+  VERIFY( ! sm.empty() );
+  VERIFY( sm.size() == 1 );
+  VERIFY( (sm.end() - sm.begin()) == 1 );
+
+  matched = std::regex_search("abcd", sm, std::regex("(b)(c)"));
+  VERIFY( matched );
+  VERIFY( sm.ready() );
+  VERIFY( ! sm.empty() );
+  VERIFY( sm.size() == 3 );
+  VERIFY( (sm.end() - sm.begin()) == 3 );
+}
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc b/libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc
index 59eeae823ec..7db52a6336e 100644
--- a/libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc
+++ b/libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc
@@ -119,7 +119,6 @@ void test02()
 void test03()
 {
   std::promise<void> p1;
-  int i = 0;
   p1.set_value();
   try {
     p1.set_value_at_thread_exit();
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc
index 82f39aa347f..6044a11e436 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc
@@ -53,22 +53,24 @@ test01()
   ++iter;
   VERIFY( iter == end(iter) );
 
-#if !(defined(__MINGW32__) || defined(__MINGW64__))
-  // Test inaccessible directory.
-  permissions(p, fs::perms::none, ec);
-  VERIFY( !ec );
-  iter = fs::directory_iterator(p, ec);
-  VERIFY( ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible directory, skipping permission denied.
-  const auto opts = fs::directory_options::skip_permission_denied;
-  iter = fs::directory_iterator(p, opts, ec);
-  VERIFY( !ec );
-  VERIFY( iter == end(iter) );
-#endif
+  if (__gnu_test::permissions_are_testable())
+  {
+    // Test inaccessible directory.
+    permissions(p, fs::perms::none, ec);
+    VERIFY( !ec );
+    iter = fs::directory_iterator(p, ec);
+    VERIFY( ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible directory, skipping permission denied.
+    const auto opts = fs::directory_options::skip_permission_denied;
+    iter = fs::directory_iterator(p, opts, ec);
+    VERIFY( !ec );
+    VERIFY( iter == end(iter) );
+
+    permissions(p, fs::perms::owner_all, ec);
+  }
 
-  permissions(p, fs::perms::owner_all, ec);
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
index 1c073e125f9..e9569c2dd53 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
@@ -61,54 +61,58 @@ test01()
   ++iter;
   VERIFY( iter == end(iter) );
 
-  // Test inaccessible directory.
-  ec = bad_ec;
-  permissions(p, fs::perms::none, ec);
-  VERIFY( !ec );
-  iter = fs::recursive_directory_iterator(p, ec);
-  VERIFY( ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible directory, skipping permission denied.
-  const auto opts = fs::directory_options::skip_permission_denied;
-  ec = bad_ec;
-  iter = fs::recursive_directory_iterator(p, opts, ec);
-  VERIFY( !ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible sub-directory.
-  ec = bad_ec;
-  permissions(p, fs::perms::owner_all, ec);
-  VERIFY( !ec );
-  ec = bad_ec;
-  permissions(p/"d1/d2", fs::perms::none, ec);
-  VERIFY( !ec );
-  ec = bad_ec;
-  iter = fs::recursive_directory_iterator(p, ec);
-  VERIFY( !ec );
-  VERIFY( iter != end(iter) );
-  VERIFY( iter->path() == p/"d1" );
-  ++iter;              // should recurse into d1
-  VERIFY( iter != end(iter) );
-  VERIFY( iter->path() == p/"d1/d2" );
-  iter.increment(ec);  // should fail to recurse into p/d1/d2
-  VERIFY( ec );
-  VERIFY( iter == end(iter) );
-
-  // Test inaccessible sub-directory, skipping permission denied.
-  ec = bad_ec;
-  iter = fs::recursive_directory_iterator(p, opts, ec);
-  VERIFY( !ec );
-  VERIFY( iter != end(iter) );
-  VERIFY( iter->path() == p/"d1" );
-  ++iter;              // should recurse into d1
-  VERIFY( iter->path() == p/"d1/d2" );
-  ec = bad_ec;
-  iter.increment(ec);  // should fail to recurse into p/d1/d2, so skip it
-  VERIFY( !ec );
-  VERIFY( iter == end(iter) );
+  if (__gnu_test::permissions_are_testable())
+  {
+    // Test inaccessible directory.
+    ec = bad_ec;
+    permissions(p, fs::perms::none, ec);
+    VERIFY( !ec );
+    iter = fs::recursive_directory_iterator(p, ec);
+    VERIFY( ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible directory, skipping permission denied.
+    const auto opts = fs::directory_options::skip_permission_denied;
+    ec = bad_ec;
+    iter = fs::recursive_directory_iterator(p, opts, ec);
+    VERIFY( !ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible sub-directory.
+    ec = bad_ec;
+    permissions(p, fs::perms::owner_all, ec);
+    VERIFY( !ec );
+    ec = bad_ec;
+    permissions(p/"d1/d2", fs::perms::none, ec);
+    VERIFY( !ec );
+    ec = bad_ec;
+    iter = fs::recursive_directory_iterator(p, ec);
+    VERIFY( !ec );
+    VERIFY( iter != end(iter) );
+    VERIFY( iter->path() == p/"d1" );
+    ++iter;              // should recurse into d1
+    VERIFY( iter != end(iter) );
+    VERIFY( iter->path() == p/"d1/d2" );
+    iter.increment(ec);  // should fail to recurse into p/d1/d2
+    VERIFY( ec );
+    VERIFY( iter == end(iter) );
+
+    // Test inaccessible sub-directory, skipping permission denied.
+    ec = bad_ec;
+    iter = fs::recursive_directory_iterator(p, opts, ec);
+    VERIFY( !ec );
+    VERIFY( iter != end(iter) );
+    VERIFY( iter->path() == p/"d1" );
+    ++iter;              // should recurse into d1
+    VERIFY( iter->path() == p/"d1/d2" );
+    ec = bad_ec;
+    iter.increment(ec);  // should fail to recurse into p/d1/d2, so skip it
+    VERIFY( !ec );
+    VERIFY( iter == end(iter) );
+
+    permissions(p/"d1/d2", fs::perms::owner_all, ec);
+  }
 
-  permissions(p/"d1/d2", fs::perms::owner_all, ec);
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
index 064c30b5b21..b8e853fe2ee 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
@@ -129,10 +129,33 @@ test03()
   remove_all(p);
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510
+  // create_directories reports an error if the path is a symlink to a dir
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  const auto p = __gnu_test::nonexistent_path() / "";
+  fs::create_directories(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  bool created = fs::create_directories(link, ec);
+  VERIFY( !created );
+  VERIFY( !ec );
+  created = fs::create_directories(link);
+  VERIFY( !created );
+  remove_all(p);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
index a39a456133a..271c152e4b9 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
@@ -46,12 +46,44 @@ test01()
   VERIFY( exists(p) );
 
   // Test existing path (libstdc++/71036).
+  ec = make_error_code(std::errc::invalid_argument);
   b = create_directory(p, ec);
   VERIFY( !ec );
   VERIFY( !b );
   b = create_directory(p);
   VERIFY( !b );
 
+  auto f = p/"file";
+  std::ofstream{f} << "create file";
+  b = create_directory(f, ec);
+  VERIFY( ec == std::errc::file_exists );
+  VERIFY( !b );
+  try
+  {
+    create_directory(f);
+    VERIFY( false );
+  }
+  catch (const fs::filesystem_error& e)
+  {
+    VERIFY( e.code() == std::errc::file_exists );
+    VERIFY( e.path1() == f );
+  }
+
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510 create_directory on an existing symlink to a directory
+  fs::create_directory(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  ec = make_error_code(std::errc::invalid_argument);
+  b = fs::create_directory(link, ec);
+  VERIFY( !b );
+  VERIFY( !ec );
+  b = fs::create_directory(link);
+  VERIFY( !b );
+#endif
+
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
index 26cb6be8eec..1443ef1c871 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
@@ -74,10 +74,8 @@ test03()
 void
 test04()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // filesystem permissions not supported
-  return;
-#endif
+  if (!__gnu_test::permissions_are_testable())
+    return;
 
   using perms = std::experimental::filesystem::perms;
   path p = __gnu_test::nonexistent_path();
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc
index 6fd4f531ccd..ccb805beb0c 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc
@@ -28,10 +28,8 @@ namespace fs = std::experimental::filesystem;
 void
 test01()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // filesystem permissions not supported
-  return;
-#endif
+  if (!__gnu_test::permissions_are_testable())
+    return;
 
   auto p = __gnu_test::nonexistent_path();
   create_directory(p);
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove.cc
index 4bed583d15c..ff35d64f4b0 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove.cc
@@ -78,19 +78,18 @@ test01()
   VERIFY( !n );
   VERIFY( exists(dir/"a/b") );
 
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // No permissions support
-#else
-  permissions(dir, fs::perms::none, ec);
-  if (!ec)
+  if (__gnu_test::permissions_are_testable())
   {
-    ec.clear();
-    n = remove(dir/"a/b", ec);
-    VERIFY( ec );
-    VERIFY( !n );
-    permissions(dir, fs::perms::owner_all, ec);
+    permissions(dir, fs::perms::none, ec);
+    if (!ec)
+    {
+      ec.clear();
+      n = remove(dir/"a/b", ec);
+      VERIFY( ec );
+      VERIFY( !n );
+      permissions(dir, fs::perms::owner_all, ec);
+    }
   }
-#endif
 
   ec = bad_ec;
   n = remove(dir/"a/b", ec);
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
index 0e2aedae96d..1a3061c64f0 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
@@ -111,9 +111,9 @@ test02()
 void
 test04()
 {
-#if defined(__MINGW32__) || defined(__MINGW64__)
-  // no permissions
-#else
+  if (!__gnu_test::permissions_are_testable())
+    return;
+
   // PR libstdc++/93201
   std::error_code ec;
   std::uintmax_t n;
@@ -137,7 +137,8 @@ test04()
   }
 
   fs::permissions(dir, fs::perms::owner_write|fs::perms::add_perms);
-#endif
+  fs::remove_all(dir, ec);
+  f.path.clear();
 }
 
 int
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
index 3791a0108d7..dd90f717b05 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
@@ -95,6 +95,9 @@ test02()
 void
 test03()
 {
+  if (!__gnu_test::permissions_are_testable())
+    return;
+
   auto p = __gnu_test::nonexistent_path();
   create_directories(p/"tmp");
   permissions(p, fs::perms::none);
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..b2428ff74cf
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+
+void f(bool) { }
+void f(const std::experimental::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc b/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc
index b77d6a29e3d..5fffdd97691 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <sstream>
diff --git a/libstdc++-v3/testsuite/experimental/random/randint.cc b/libstdc++-v3/testsuite/experimental/random/randint.cc
index 94b4c416540..f51edef8ce0 100644
--- a/libstdc++-v3/testsuite/experimental/random/randint.cc
+++ b/libstdc++-v3/testsuite/experimental/random/randint.cc
@@ -34,7 +34,7 @@ test01()
   }
 
   std::experimental::reseed(99u);
-  const long n1[] = {
+  const int n1[] = {
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
@@ -42,7 +42,7 @@ test01()
     std::experimental::randint(0, 100)
   };
   std::experimental::reseed(99u);
-  const long n2[] = {
+  const int n2[] = {
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
@@ -52,13 +52,13 @@ test01()
   for (int i = 0; i < 5; ++i)
     VERIFY( n1[i] == n2[i] );
 
-  std::experimental::reseed();
-  const long n3[] = {
-    std::experimental::randint(0, 100),
-    std::experimental::randint(0, 100),
-    std::experimental::randint(0, 100)
-  };
-  VERIFY( !(n3[0] == n1[0] && n3[1] == n1[1] && n3[2] == n1[2]) );
+  do
+  {
+    std::experimental::reseed();
+  }
+  while (std::experimental::randint(0, 100) == n1[0]
+      && std::experimental::randint(0, 100) == n1[1]
+      && std::experimental::randint(0, 100) == n1[2]);
 }
 
 void
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index 3b8587cd01d..45dd2c8c02e 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -410,8 +410,7 @@ proc libstdc++-dg-test { prog do_what extra_tool_flags } {
     set select_compile "v3_target_compile"
     set options ""
     if { $extra_tool_flags != "" } {
-	verbose -log "extra_tool_flags are:"
-	verbose -log -- $extra_tool_flags
+	verbose -log "extra_tool_flags are: $extra_tool_flags"
 	if { [string first "-x c" $extra_tool_flags ] != -1 } {
 	    verbose -log "compiling and executing as C, not C++"
 	    set edit_tool_flags $extra_tool_flags
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
index 001b121dcec..b03f8479d35 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
@@ -151,10 +151,40 @@ main()
   std::unique_ptr<int, Deleter>& rempty_ptr = empty_ptr;
 // { dg-final { note-test rempty_ptr {std::unique_ptr<int> = {get() = {<No data fields>}}} } }
 
+  struct Deleter_pr103086
+  {
+    int deleter_member = -1;
+    void operator()(int*) const noexcept { }
+  };
+
+  std::unique_ptr<int, Deleter_pr103086> uniq_ptr;
+// { dg-final { note-test uniq_ptr {std::unique_ptr<int> = {get() = 0x0}} } }
+  std::unique_ptr<int, Deleter_pr103086>& runiq_ptr = uniq_ptr;
+// { dg-final { note-test runiq_ptr {std::unique_ptr<int> = {get() = 0x0}} } }
+
   ExTuple tpl(6,7);
 // { dg-final { note-test tpl {std::tuple containing = {[1] = 6, [2] = 7}} } }
   ExTuple &rtpl = tpl;
 // { dg-final { note-test rtpl {std::tuple containing = {[1] = 6, [2] = 7}} } }
+
+  std::error_code e0;
+  // { dg-final { note-test e0 {std::error_code = { }} } }
+  std::error_condition ec0;
+  // { dg-final { note-test ec0 {std::error_condition = { }} } }
+  std::error_code einval = std::make_error_code(std::errc::invalid_argument);
+  // { dg-final { note-test einval {std::error_code = {"generic": EINVAL}} } }
+  std::error_condition ecinval = std::make_error_condition(std::errc::invalid_argument);
+  // { dg-final { note-test ecinval {std::error_condition = {"generic": EINVAL}} } }
+
+  struct custom_cat : std::error_category {
+    const char* name() const noexcept { return "miaow"; }
+    std::string message(int) const { return ""; }
+  } cat;
+  std::error_code emiaow(42, cat);
+  // { dg-final { note-test emiaow {std::error_code = {"miaow": 42}} } }
+  std::error_condition ecmiaow(42, cat);
+  // { dg-final { note-test ecmiaow {std::error_condition = {"miaow": 42}} } }
+
   placeholder(""); // Mark SPOT
   use(efl);
   use(fl);
diff --git a/libstdc++-v3/testsuite/std/ranges/97600.cc b/libstdc++-v3/testsuite/std/ranges/97600.cc
new file mode 100644
index 00000000000..d992318259d
--- /dev/null
+++ b/libstdc++-v3/testsuite/std/ranges/97600.cc
@@ -0,0 +1,32 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+// PR libstdc++/97600
+
+#include <sstream>
+#include <ranges>
+
+void
+test01()
+{
+  std::ranges::basic_istream_view<int, char, std::char_traits<char>> v;
+  v.begin();
+  static_assert(std::ranges::range<decltype(v)>);
+}
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc
index 94dd7c94505..1ad05361d00 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc
@@ -76,6 +76,9 @@ struct X
 void
 test03()
 {
+  using ranges::next;
+  using ranges::begin;
+
   // LWG 3483
   std::pair<int, X> x[3];
   __gnu_test::test_forward_range<std::pair<int, X>> r(x);
@@ -89,10 +92,58 @@ test03()
   VERIFY( (next(b_const, 2) - b_const) == 2 );
 }
 
+void
+test05()
+{
+  // LWG 3502
+  std::vector<int> vec = {42};
+  auto r1 = vec
+    | views::transform([](auto c) { return std::make_tuple(c, c); })
+    | views::keys;
+  VERIFY( ranges::equal(r1, (int[]){42}) );
+
+  std::tuple<int, int> a[] = {{1,2},{3,4}};
+  auto r2 = a | views::keys;
+  VERIFY( r2[0] == 1 && r2[1] == 3 );
+}
+
+void
+test06()
+{
+  // PR libstdc++/100631
+  auto r = views::iota(0)
+    | views::filter([](int){ return true; })
+    | views::take(42)
+    | views::reverse
+    | views::transform([](int) { return std::make_pair(42, "hello"); })
+    | views::take(42)
+    | views::keys;
+  auto b = r.begin();
+  auto e = r.end();
+  VERIFY( e - b == 42 );
+  VERIFY( b - e == -42 );
+}
+
+void
+test07()
+{
+  // PR libstdc++/100631 comment #2
+  auto r = views::iota(0)
+    | views::transform([](int) { return std::make_pair(42, "hello"); })
+    | views::keys;
+  auto b = ranges::cbegin(r);
+  auto e = ranges::end(r);
+  b.base() == e.base();
+  b == e;
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test05();
+  test06();
+  test07();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
index 8bbea9a6b25..9c0231b704b 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
@@ -149,6 +149,16 @@ test08()
   VERIFY( i->a == 5 );
 }
 
+void
+test10()
+{
+  // PR libstdc++/100290
+  auto v = views::single(0)
+    | views::transform([](const auto& s) { return views::single(s); })
+    | views::join;
+  VERIFY( ranges::next(v.begin()) == v.end() );
+}
+
 int
 main()
 {
@@ -160,4 +170,5 @@ main()
   test06();
   test07();
   test08();
+  test10();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc
index 37d003d11f0..cacaa275335 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc
@@ -149,6 +149,15 @@ void test06()
   static_assert( std::ranges::range<const V> );
 }
 
+void
+test08()
+{
+  // PR libstdc++/100639
+  auto v = views::iota(1701ll, 3000ll) | views::reverse | views::take(5);
+  for (auto x : v)
+    ;
+}
+
 int
 main()
 {
@@ -158,4 +167,5 @@ main()
   test04();
   test05();
   test06();
+  test08();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc
index fe895827fc5..661b55dca2c 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc
@@ -152,6 +152,17 @@ test08()
   VERIFY( i == v.end() );
 }
 
+void
+test10()
+{
+  // LWG 3505
+  auto to_string = [] (auto r) {
+    return std::string(r.begin(), ranges::next(r.begin(), r.end()));
+  };
+  auto v = "xxyx"sv | views::split("xy"sv) | views::transform(to_string);
+  VERIFY( ranges::equal(v, (std::string_view[]){"x", "x"}) );
+}
+
 int
 main()
 {
@@ -163,4 +174,5 @@ main()
   test06();
   test07();
   test08();
+  test10();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc
index 41a7d3b3321..e834c24a723 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc
@@ -132,6 +132,9 @@ struct Y
 void
 test06()
 {
+  using ranges::next;
+  using ranges::begin;
+
   // LWG 3483
   Y y[3];
   __gnu_test::test_forward_range<Y> r(y);
diff --git a/libstdc++-v3/testsuite/std/ranges/iota/iota_view.cc b/libstdc++-v3/testsuite/std/ranges/iota/iota_view.cc
index 65d166fbd3b..76888ac7959 100644
--- a/libstdc++-v3/testsuite/std/ranges/iota/iota_view.cc
+++ b/libstdc++-v3/testsuite/std/ranges/iota/iota_view.cc
@@ -77,6 +77,16 @@ test04()
   VERIFY( it == v.end() );
 }
 
+void
+test05()
+{
+  // PR libstdc++/100690
+  int x[] = {42, 42, 42};
+  auto r = std::views::iota(std::ranges::begin(x), std::ranges::cbegin(x) + 3);
+  VERIFY( r.end() - r.begin() == 3 );
+  VERIFY( r.begin() - r.end() == -3 );
+}
+
 int
 main()
 {
@@ -84,4 +94,5 @@ main()
   test02();
   test03();
   test04();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/istream_view.cc b/libstdc++-v3/testsuite/std/ranges/istream_view.cc
index f74e05e347a..77df686aa4a 100644
--- a/libstdc++-v3/testsuite/std/ranges/istream_view.cc
+++ b/libstdc++-v3/testsuite/std/ranges/istream_view.cc
@@ -83,6 +83,15 @@ test04()
   static_assert(!std::forward_iterator<It>);
 }
 
+void
+test06()
+{
+  // Default template argument
+  using V = std::ranges::basic_istream_view<int, char>;
+  using W = std::ranges::basic_istream_view<int, char, std::char_traits<char>>;
+  static_assert( std::is_same_v<V, W> );
+}
+
 int
 main()
 {
@@ -90,4 +99,5 @@ main()
   test02();
   test03();
   test04();
+  test06();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/p2259.cc b/libstdc++-v3/testsuite/std/ranges/p2259.cc
new file mode 100644
index 00000000000..1b422e44f16
--- /dev/null
+++ b/libstdc++-v3/testsuite/std/ranges/p2259.cc
@@ -0,0 +1,91 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+// Verify P2259 changes.
+
+#include <ranges>
+#include <tuple>
+#include <vector>
+
+namespace ranges = std::ranges;
+namespace views = std::views;
+
+using std::__detail::__iter_without_category;
+
+template<typename _Range>
+concept only_cxx20_input_range = ranges::input_range<_Range>
+  && !ranges::forward_range<_Range>
+  && __iter_without_category<ranges::iterator_t<_Range>>;
+
+void
+test01()
+{
+  extern std::vector<int> vec;
+  only_cxx20_input_range auto v0
+    = vec
+    | views::transform([](int c) { return views::single(c); })
+    | views::join;
+
+  // Verify the changes to filter_view.
+  only_cxx20_input_range auto v1 = v0 | views::filter([](int c) { return c > 0; });
+
+  // Verify the changes to transform_view.
+  only_cxx20_input_range auto v2 = v0 | views::transform([](int& c) -> auto& { return c; });
+
+  // Verify the changes to split_view.
+  only_cxx20_input_range auto v3 = v0 | views::split(12);
+  static_assert(only_cxx20_input_range<decltype(*v3.begin())>);
+
+  // Verify the changes to join_view.
+  only_cxx20_input_range auto v4 = v0 | views::split(12) | views::join;
+
+  // Verify the changes to elements_view.
+  only_cxx20_input_range auto v5
+    = v0
+    | views::transform([](int c) { return std::make_tuple(c, c); })
+    | views::elements<0>;
+
+  // Verify the changes to common_iterator.
+  only_cxx20_input_range auto v6 = v0 | views::common;
+  *(v6.begin()++);
+
+  // Verify the changes to iota_view.
+  only_cxx20_input_range auto v8 = ranges::iota_view{v0.begin()};
+
+  // Verify the changes to move_iterator.
+  __iter_without_category auto i9 = std::make_move_iterator(v0.begin());
+
+  // Verify the changes to counted_iterator.
+  extern std::counted_iterator<int*> i10;
+  static_assert(std::contiguous_iterator<decltype(i10)>);
+  static_assert(std::same_as<std::iterator_traits<decltype(i10)>::iterator_category,
+			     std::random_access_iterator_tag>);
+  i10.operator->();
+  __iter_without_category auto i11 = std::counted_iterator{v0.begin(), 5};
+}
+
+void
+test02()
+{
+  // Verify LWG 3291 example.
+  auto v = views::iota(0);
+  auto i = std::counted_iterator{v.begin(), 5};
+  static_assert(std::random_access_iterator<decltype(i)>);
+}
diff --git a/libstdc++-v3/testsuite/std/ranges/range.cc b/libstdc++-v3/testsuite/std/ranges/range.cc
index cf349de8735..5548e93d6cd 100644
--- a/libstdc++-v3/testsuite/std/ranges/range.cc
+++ b/libstdc++-v3/testsuite/std/ranges/range.cc
@@ -75,9 +75,6 @@ static_assert( same_as<std::ranges::range_difference_t<C>,
 static_assert( same_as<std::ranges::range_difference_t<O>,
 		       std::ptrdiff_t> );
 
-static_assert( same_as<std::ranges::range_value_t<O>,
-		       char> );
-
 static_assert( same_as<std::ranges::range_reference_t<I>,
 		       char&> );
 static_assert( same_as<std::ranges::range_reference_t<O>,
diff --git a/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc b/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc
index 5c2f1de45ad..3d21774c966 100644
--- a/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc
+++ b/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc
@@ -29,3 +29,18 @@ struct Base {};
 struct Derived : Base {};
 subrange<Derived*> sd;
 subrange<Base*> sb = sd; // { dg-error "conversion" }
+
+void
+test_lwg3404()
+{
+  // LWG 3404. Finish removing subrange's conversions from pair-like
+  std::pair<char*, char*> p;
+  subrange sb1(p);			// { dg-error "no matching function" }
+  // { dg-error "class template argument deduction" "" { target *-*-* } 38 }
+  subrange sb2(p, p.second - p.first);	// { dg-error "no matching function" }
+  // { dg-error "class template argument deduction" "" { target *-*-* } 40 }
+
+  // { dg-prune-output "in requirements with" }
+  // { dg-prune-output "template constraint failure" }
+  // { dg-prune-output "unsatisfied constraints" }
+}
diff --git a/libstdc++-v3/testsuite/util/pstl/test_utils.h b/libstdc++-v3/testsuite/util/pstl/test_utils.h
index 6547d931c29..80a8f9c7b87 100644
--- a/libstdc++-v3/testsuite/util/pstl/test_utils.h
+++ b/libstdc++-v3/testsuite/util/pstl/test_utils.h
@@ -752,7 +752,7 @@ struct invoke_if_<std::false_type, std::false_type>
 {
     template <typename Op, typename... Rest>
     void
-    operator()(bool is_allow, Op op, Rest&&... rest)
+    operator()(bool, Op op, Rest&&... rest)
     {
         op(std::forward<Rest>(rest)...);
     }
@@ -787,14 +787,14 @@ struct non_const_wrapper_tagged : non_const_wrapper
 
     template <typename Policy, typename Iterator>
     typename std::enable_if<IsPositiveCondition != is_same_iterator_category<Iterator, IteratorTag>::value, void>::type
-    operator()(Policy&& exec, Iterator iter)
+    operator()(Policy&&, Iterator)
     {
     }
 
     template <typename Policy, typename InputIterator, typename OutputIterator>
     typename std::enable_if<IsPositiveCondition != is_same_iterator_category<OutputIterator, IteratorTag>::value,
                             void>::type
-    operator()(Policy&& exec, InputIterator input_iter, OutputIterator out_iter)
+    operator()(Policy&&, InputIterator, OutputIterator)
     {
     }
 };
@@ -999,7 +999,7 @@ struct iterator_invoker<std::forward_iterator_tag, /*isReverse=*/std::true_type>
 {
     template <typename... Rest>
     void
-    operator()(Rest&&... rest)
+    operator()(Rest&&...)
     {
     }
 };
@@ -1226,7 +1226,7 @@ test_algo_basic_double(F&& f)
 
 template <typename Policy, typename F>
 static void
-invoke_if(Policy&& p, F f)
+invoke_if(Policy&&, F f)
 {
 #if _PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN || _PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN
     __pstl::__internal::invoke_if_not(__pstl::__internal::allow_unsequenced<Policy>(), f);
diff --git a/libstdc++-v3/testsuite/util/testsuite_allocator.h b/libstdc++-v3/testsuite/util/testsuite_allocator.h
index e52ef788467..dacb4daf6b0 100644
--- a/libstdc++-v3/testsuite/util/testsuite_allocator.h
+++ b/libstdc++-v3/testsuite/util/testsuite_allocator.h
@@ -512,7 +512,7 @@ namespace __gnu_test
     {
       typedef Tp value_type;
 
-      SimpleAllocator() noexcept { }
+      constexpr SimpleAllocator() noexcept { }
 
       template <class T>
         SimpleAllocator(const SimpleAllocator<T>&) { }
diff --git a/libstdc++-v3/testsuite/util/testsuite_fs.h b/libstdc++-v3/testsuite/util/testsuite_fs.h
index df2344fae92..54fb42598f0 100644
--- a/libstdc++-v3/testsuite/util/testsuite_fs.h
+++ b/libstdc++-v3/testsuite/util/testsuite_fs.h
@@ -34,7 +34,7 @@ namespace test_fs = std::experimental::filesystem;
 #include <fstream>
 #include <string>
 #include <cstdio>
-#include <unistd.h> // unlink, close, getpid
+#include <unistd.h> // unlink, close, getpid, geteuid
 
 #if defined(_GNU_SOURCE) || _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L
 #include <stdlib.h> // mkstemp
@@ -160,5 +160,21 @@ namespace __gnu_test
     path_type path;
   };
 
+  inline bool
+  permissions_are_testable(bool print_msg = true)
+  {
+    bool testable = false;
+#if !(defined __MINGW32__ || defined __MINGW64__)
+    if (geteuid() != 0)
+      testable = true;
+    // XXX on Linux the CAP_DAC_OVERRIDE and CAP_DAC_READ_SEARCH capabilities
+    // can give normal users extra permissions for files and directories.
+    // We ignore that possibility here.
+#endif
+    if (print_msg && !testable)
+      std::puts("Skipping tests that depend on filesystem permissions");
+    return testable;
+  }
+
 } // namespace __gnu_test
 #endif
diff --git a/libstdc++-v3/testsuite/util/testsuite_iterators.h b/libstdc++-v3/testsuite/util/testsuite_iterators.h
index 60eba26eab4..241b8a9ec2c 100644
--- a/libstdc++-v3/testsuite/util/testsuite_iterators.h
+++ b/libstdc++-v3/testsuite/util/testsuite_iterators.h
@@ -122,7 +122,7 @@ namespace __gnu_test
    */
   template<class T>
   struct output_iterator_wrapper
-  : public std::iterator<std::output_iterator_tag, T, std::ptrdiff_t, T*, T&>
+  : public std::iterator<std::output_iterator_tag, void, std::ptrdiff_t, void, void>
   {
   protected:
     output_iterator_wrapper() : ptr(0), SharedInfo(0)
@@ -175,10 +175,14 @@ namespace __gnu_test
 #if __cplusplus >= 201103L
     template<typename U>
       void operator,(const U&) const = delete;
+
+    void operator&() const = delete;
 #else
   private:
     template<typename U>
       void operator,(const U&) const;
+
+    void operator&() const;
 #endif
   };
 
@@ -275,10 +279,14 @@ namespace __gnu_test
 #if __cplusplus >= 201103L
     template<typename U>
       void operator,(const U&) const = delete;
+
+    void operator&() const = delete;
 #else
   private:
     template<typename U>
       void operator,(const U&) const;
+
+    void operator&() const;
 #endif
   };
 
diff --git a/maintainer-scripts/ChangeLog b/maintainer-scripts/ChangeLog
index 2be23318cd4..982fdf70563 100644
--- a/maintainer-scripts/ChangeLog
+++ b/maintainer-scripts/ChangeLog
@@ -1,3 +1,11 @@
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* generate_libstdcxx_web_docs: Add --disable-multilib to
+	configure command.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/maintainer-scripts/generate_libstdcxx_web_docs b/maintainer-scripts/generate_libstdcxx_web_docs
index 74886356bc7..29572172761 100755
--- a/maintainer-scripts/generate_libstdcxx_web_docs
+++ b/maintainer-scripts/generate_libstdcxx_web_docs
@@ -43,7 +43,7 @@ do
   [ $dir == 'libstdc++-v3' ] || disabled_libs="$disabled_libs --disable-$dir"
 done
 set -x
-${SRCDIR}/configure --enable-languages=c,c++ --disable-gcc $disabled_libs --docdir=/docs
+${SRCDIR}/configure --enable-languages=c,c++ --disable-gcc --disable-multilib $disabled_libs --docdir=/docs
 eval `grep '^target=' config.log`
 make configure-target
 # If the following step fails with an error like
